var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = typeof require !== "undefined" ? require : (id) => { throw new Error(`require() not available for "${id}"`) };

// node_modules/@iggy.rs/sdk/dist/wire/client/client.utils.js
var transportString = (t) => {
  switch (t.toString()) {
    case "1":
      return "tcp";
    case "2":
      return "quic";
    default:
      return `unknown_transport_${t}`;
  }
}, deserializeClient = (r, pos = 0) => {
  const addressLength = r.readUInt32LE(pos + 9);
  return {
    bytesRead: 13 + addressLength + 4,
    data: {
      clientId: r.readUInt32LE(pos),
      userId: r.readUInt32LE(pos + 4),
      transport: transportString(r.readUInt8(pos + 8)),
      address: r.subarray(pos + 13, pos + 13 + addressLength).toString(),
      consumerGroupCount: r.readUInt32LE(pos + 13 + addressLength)
    }
  };
};

// node_modules/@iggy.rs/sdk/dist/wire/command.utils.js
function wrapCommand(cmd) {
  return (getClient) => async (arg) => cmd.deserialize(await (await getClient()).sendCommand(cmd.code, cmd.serialize(arg)));
}

// node_modules/@iggy.rs/sdk/dist/wire/client/get-client.command.js
var GET_CLIENT, getClient;
var init_get_client_command = __esm(() => {
  GET_CLIENT = {
    code: 21,
    serialize: ({ clientId }) => {
      const b = Buffer.alloc(4);
      b.writeUInt32LE(clientId);
      return b;
    },
    deserialize: (r) => deserializeClient(r.data).data
  };
  getClient = wrapCommand(GET_CLIENT);
});

// node_modules/@iggy.rs/sdk/dist/wire/client/get-clients.command.js
var GET_CLIENTS, getClients;
var init_get_clients_command = __esm(() => {
  GET_CLIENTS = {
    code: 22,
    serialize: () => Buffer.alloc(0),
    deserialize: (r) => {
      const payloadSize = r.data.length;
      const clients = [];
      let pos = 0;
      while (pos < payloadSize) {
        const { bytesRead, data } = deserializeClient(r.data, pos);
        clients.push(data);
        pos += bytesRead;
      }
      return clients;
    }
  };
  getClients = wrapCommand(GET_CLIENTS);
});

// node_modules/@iggy.rs/sdk/dist/wire/client/get-me.command.js
var GET_ME, getMe;
var init_get_me_command = __esm(() => {
  GET_ME = {
    code: 20,
    serialize: () => Buffer.alloc(0),
    deserialize: (r) => deserializeClient(r.data).data
  };
  getMe = wrapCommand(GET_ME);
});

// node_modules/@iggy.rs/sdk/dist/wire/client/index.js
var init_client = __esm(() => {
  init_get_client_command();
  init_get_clients_command();
  init_get_me_command();
});

// node_modules/@iggy.rs/sdk/dist/wire/identifier.utils.js
var NUMERIC = 1, STRING = 2, serializeIdentifier = (id) => {
  if (typeof id === "string") {
    return serializeStringId(id);
  }
  if (typeof id === "number") {
    return serializeNumericId(id);
  }
  throw new Error(`Unsuported id type (${id} - ${typeof id})`);
}, serializeStringId = (id) => {
  const b = Buffer.alloc(1 + 1);
  const bId = Buffer.from(id);
  if (bId.length < 1 || bId.length > 255)
    throw new Error("identifier/name should be between 1 and 255 bytes");
  b.writeUInt8(STRING);
  b.writeUInt8(bId.length, 1);
  return Buffer.concat([
    b,
    bId
  ]);
}, serializeNumericId = (id) => {
  const b = Buffer.alloc(1 + 1 + 4);
  b.writeUInt8(NUMERIC);
  b.writeUInt8(4, 1);
  b.writeUInt32LE(id, 2);
  return b;
};

// node_modules/@iggy.rs/sdk/dist/wire/consumer-group/group.utils.js
var serializeTargetGroup = (streamId, topicId, groupId) => {
  return Buffer.concat([
    serializeIdentifier(streamId),
    serializeIdentifier(topicId),
    serializeIdentifier(groupId)
  ]);
}, deserializeConsumerGroup = (r, pos = 0) => {
  const id = r.readUInt32LE(pos);
  const partitionsCount = r.readUInt32LE(pos + 4);
  const membersCount = r.readUInt32LE(pos + 8);
  const nameLength = r.readUInt8(pos + 12);
  const name = r.subarray(pos + 13, pos + 13 + nameLength).toString();
  return {
    bytesRead: 4 + 4 + 4 + 1 + nameLength,
    data: {
      id,
      name,
      partitionsCount,
      membersCount
    }
  };
}, deserializeConsumerGroups = (r, pos = 0) => {
  const end = r.length;
  const cgroups = [];
  while (pos < end) {
    const { bytesRead, data } = deserializeConsumerGroup(r, pos);
    cgroups.push(data);
    pos += bytesRead;
  }
  return cgroups;
};
var init_group_utils = () => {};

// node_modules/@iggy.rs/sdk/dist/wire/consumer-group/create-group.command.js
var CREATE_GROUP, createGroup;
var init_create_group_command = __esm(() => {
  init_group_utils();
  CREATE_GROUP = {
    code: 602,
    serialize: ({ streamId, topicId, groupId, name }) => {
      const bName = Buffer.from(name);
      if (bName.length < 1 || bName.length > 255)
        throw new Error("Consumer group name should be between 1 and 255 bytes");
      const b = Buffer.allocUnsafe(5);
      b.writeUInt32LE(groupId);
      b.writeUInt8(bName.length, 4);
      return Buffer.concat([
        serializeIdentifier(streamId),
        serializeIdentifier(topicId),
        b,
        bName
      ]);
    },
    deserialize: (r) => {
      return deserializeConsumerGroup(r.data).data;
    }
  };
  createGroup = wrapCommand(CREATE_GROUP);
});

// node_modules/@iggy.rs/sdk/dist/type.utils.js
function reverseRecord(input) {
  return Object.fromEntries(Object.entries(input).map(([key, value]) => [
    value,
    key
  ]));
}

// node_modules/@iggy.rs/sdk/dist/wire/command.code.js
var COMMAND_CODE, reverseCommandCodeMap, translateCommandCode = (code) => {
  return reverseCommandCodeMap[code.toString()] || `unknow_command_code_${code}`;
};
var init_command_code = __esm(() => {
  COMMAND_CODE = {
    Ping: "1",
    GetStats: "10",
    GetMe: "20",
    GetClient: "21",
    GetClients: "22",
    GetUser: "31",
    GetUsers: "32",
    CreateUser: "33",
    DeleteUser: "34",
    UpdateUser: "35",
    UpdatePermissions: "36",
    ChangePassword: "37",
    LoginUser: "38",
    LogoutUser: "39",
    GetAccessTokens: "41",
    CreateAccessToken: "42",
    DeleteAccessToken: "43",
    LoginWithAccessToken: "44",
    PollMessages: "100",
    SendMessages: "101",
    GetOffset: "120",
    StoreOffset: "121",
    GetStream: "200",
    GetStreams: "201",
    CreateStream: "202",
    DeleteStream: "203",
    UpdateStream: "204",
    PurgeStream: "205",
    GetTopic: "300",
    GetTopics: "301",
    CreateTopic: "302",
    DeleteTopic: "303",
    UpdateTopic: "304",
    PurgeTopic: "305",
    CreatePartitions: "402",
    DeletePartitions: "403",
    GetGroup: "600",
    GetGroups: "601",
    CreateGroup: "602",
    DeleteGroup: "603",
    JoinGroup: "604",
    LeaveGroup: "605"
  };
  reverseCommandCodeMap = reverseRecord(COMMAND_CODE);
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0;i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/@iggy.rs/sdk/dist/client/client.debug.js
var import_debug, debug;
var init_client_debug = __esm(() => {
  import_debug = __toESM(require_src(), 1);
  debug = import_debug.default("iggy:client");
});

// node_modules/@iggy.rs/sdk/dist/client/client.utils.js
var { Transform } = __require("node:stream");
var handleResponse = (r) => {
  const status = r.readUint32LE(0);
  const length = r.readUint32LE(4);
  debug("<== handleResponse", { status, length });
  return {
    status,
    length,
    data: r.subarray(8)
  };
}, handleResponseTransform = () => new Transform({
  transform(chunk, encoding, cb) {
    try {
      const r = handleResponse(chunk);
      debug("response::", r);
      return cb(null, r.data);
    } catch (err) {
      return cb(new Error("handleResponseTransform error", { cause: err }), null);
    }
  }
}), deserializeVoidResponse = (r) => r.status === 0 && r.data.length === 0, COMMAND_LENGTH = 4, serializeCommand = (command, payload) => {
  const payloadSize = payload.length + COMMAND_LENGTH;
  const head = Buffer.allocUnsafe(8);
  head.writeUint32LE(payloadSize, 0);
  head.writeUint32LE(command, 4);
  debug("==> CMD", command, translateCommandCode(command), head.subarray(4, 8).toString("hex"), "LENGTH", payloadSize, head.subarray(0, 4).toString("hex"));
  debug("message#HEAD", head.toString("hex"));
  debug("message#PAYLOAD", payload.toString("hex"));
  const pl = Buffer.concat([head, payload]);
  debug("FullMessage#Base64", pl.toString("base64"));
  return pl;
};
var init_client_utils = __esm(() => {
  init_command_code();
  init_client_debug();
});

// node_modules/@iggy.rs/sdk/dist/wire/consumer-group/delete-group.command.js
var DELETE_GROUP, deleteGroup;
var init_delete_group_command = __esm(() => {
  init_group_utils();
  init_client_utils();
  DELETE_GROUP = {
    code: 603,
    serialize: ({ streamId, topicId, groupId }) => {
      return serializeTargetGroup(streamId, topicId, groupId);
    },
    deserialize: deserializeVoidResponse
  };
  deleteGroup = wrapCommand(DELETE_GROUP);
});

// node_modules/@iggy.rs/sdk/dist/wire/consumer-group/get-group.command.js
var GET_GROUP, getGroup;
var init_get_group_command = __esm(() => {
  init_group_utils();
  GET_GROUP = {
    code: 600,
    serialize: ({ streamId, topicId, groupId }) => {
      return serializeTargetGroup(streamId, topicId, groupId);
    },
    deserialize: (r) => {
      return deserializeConsumerGroup(r.data).data;
    }
  };
  getGroup = wrapCommand(GET_GROUP);
});

// node_modules/@iggy.rs/sdk/dist/wire/consumer-group/get-groups.command.js
var GET_GROUPS, getGroups;
var init_get_groups_command = __esm(() => {
  init_group_utils();
  GET_GROUPS = {
    code: 601,
    serialize: ({ streamId, topicId }) => {
      return Buffer.concat([
        serializeIdentifier(streamId),
        serializeIdentifier(topicId)
      ]);
    },
    deserialize: (r) => {
      return deserializeConsumerGroups(r.data);
    }
  };
  getGroups = wrapCommand(GET_GROUPS);
});

// node_modules/@iggy.rs/sdk/dist/wire/consumer-group/join-group.command.js
var JOIN_GROUP, joinGroup;
var init_join_group_command = __esm(() => {
  init_group_utils();
  init_client_utils();
  JOIN_GROUP = {
    code: 604,
    serialize: ({ streamId, topicId, groupId }) => {
      return serializeTargetGroup(streamId, topicId, groupId);
    },
    deserialize: deserializeVoidResponse
  };
  joinGroup = wrapCommand(JOIN_GROUP);
});

// node_modules/@iggy.rs/sdk/dist/wire/consumer-group/leave-group.command.js
var LEAVE_GROUP, leaveGroup;
var init_leave_group_command = __esm(() => {
  init_group_utils();
  init_client_utils();
  LEAVE_GROUP = {
    code: 605,
    serialize: ({ streamId, topicId, groupId }) => {
      return serializeTargetGroup(streamId, topicId, groupId);
    },
    deserialize: deserializeVoidResponse
  };
  leaveGroup = wrapCommand(LEAVE_GROUP);
});

// node_modules/@iggy.rs/sdk/dist/wire/consumer-group/index.js
var init_consumer_group = __esm(() => {
  init_create_group_command();
  init_delete_group_command();
  init_get_group_command();
  init_get_groups_command();
  init_join_group_command();
  init_leave_group_command();
});

// node_modules/@iggy.rs/sdk/dist/wire/serialize.utils.js
var toDate = (n) => new Date(Number(n / BigInt(1000))), deserializeUUID = (p) => {
  const v = p.toString("hex");
  return `${v.slice(0, 8)}-` + `${v.slice(8, 12)}-${v.slice(12, 16)}-${v.slice(16, 20)}-` + `${v.slice(20, 32)}`;
};

// node_modules/@iggy.rs/sdk/dist/wire/number.utils.js
var boolToBuf = (v) => {
  const b = Buffer.allocUnsafe(1);
  b.writeUInt8(!v ? 0 : 1);
  return b;
}, int8ToBuf = (v) => {
  const b = Buffer.allocUnsafe(1);
  b.writeInt8(v);
  return b;
}, int16ToBuf = (v) => {
  const b = Buffer.allocUnsafe(2);
  b.writeInt16LE(v);
  return b;
}, int32ToBuf = (v) => {
  const b = Buffer.allocUnsafe(4);
  b.writeInt32LE(v);
  return b;
}, int64ToBuf = (v) => {
  const b = Buffer.allocUnsafe(8);
  b.writeBigInt64LE(v);
  return b;
}, uint8ToBuf = (v) => {
  const b = Buffer.allocUnsafe(1);
  b.writeUInt8(v);
  return b;
}, uint16ToBuf = (v) => {
  const b = Buffer.allocUnsafe(2);
  b.writeUInt16LE(v);
  return b;
}, uint32ToBuf = (v) => {
  const b = Buffer.allocUnsafe(4);
  b.writeUInt32LE(v);
  return b;
}, uint64ToBuf = (v) => {
  const b = Buffer.allocUnsafe(8);
  b.writeBigUInt64LE(v);
  return b;
}, floatToBuf = (v) => {
  const b = Buffer.allocUnsafe(4);
  b.writeFloatLE(v);
  return b;
}, doubleToBuf = (v) => {
  const b = Buffer.allocUnsafe(8);
  b.writeDoubleLE(v);
  return b;
};

// node_modules/@iggy.rs/sdk/dist/wire/offset/offset.utils.js
var ConsumerKind, serializeGetOffset = (streamId, topicId, consumer, partitionId) => {
  if (consumer.kind === ConsumerKind.Single && (!partitionId || partitionId < 1))
    throw new Error("getOffset error: partitionId must be > 0 for single consumer kind");
  const streamIdentifier = serializeIdentifier(streamId);
  const topicIdentifier = serializeIdentifier(topicId);
  const consumerIdentifier = serializeIdentifier(consumer.id);
  const b1 = uint8ToBuf(consumer.kind);
  const b2 = uint32ToBuf(partitionId || 0);
  return Buffer.concat([
    b1,
    consumerIdentifier,
    streamIdentifier,
    topicIdentifier,
    b2
  ]);
}, serializeStoreOffset = (streamId, topicId, consumer, partitionId, offset) => {
  const b = Buffer.allocUnsafe(8);
  b.writeBigUInt64LE(offset, 0);
  return Buffer.concat([
    serializeGetOffset(streamId, topicId, consumer, partitionId),
    b
  ]);
};
var init_offset_utils = __esm(() => {
  ConsumerKind = {
    Single: 1,
    Group: 2
  };
});

// node_modules/@iggy.rs/sdk/dist/wire/message/header.type.js
var HeaderKind, ReverseHeaderKind;
var init_header_type = __esm(() => {
  HeaderKind = {
    Raw: 1,
    String: 2,
    Bool: 3,
    Int8: 4,
    Int16: 5,
    Int32: 6,
    Int64: 7,
    Int128: 8,
    Uint8: 9,
    Uint16: 10,
    Uint32: 11,
    Uint64: 12,
    Uint128: 13,
    Float: 14,
    Double: 15
  };
  ReverseHeaderKind = reverseRecord(HeaderKind);
});

// node_modules/@iggy.rs/sdk/dist/wire/message/header.utils.js
var serializeHeaderValue = (header) => {
  const { kind, value } = header;
  switch (kind) {
    case HeaderKind.Raw:
      return value;
    case HeaderKind.String:
      return Buffer.from(value);
    case HeaderKind.Bool:
      return boolToBuf(value);
    case HeaderKind.Int8:
      return int8ToBuf(value);
    case HeaderKind.Int16:
      return int16ToBuf(value);
    case HeaderKind.Int32:
      return int32ToBuf(value);
    case HeaderKind.Int64:
      return int64ToBuf(value);
    case HeaderKind.Int128:
      return value;
    case HeaderKind.Uint8:
      return uint8ToBuf(value);
    case HeaderKind.Uint16:
      return uint16ToBuf(value);
    case HeaderKind.Uint32:
      return uint32ToBuf(value);
    case HeaderKind.Uint64:
      return uint64ToBuf(value);
    case HeaderKind.Uint128:
      return value;
    case HeaderKind.Float:
      return floatToBuf(value);
    case HeaderKind.Double:
      return doubleToBuf(value);
  }
}, serializeHeader = (key, v) => {
  const bKey = Buffer.from(key);
  const b1 = uint32ToBuf(bKey.length);
  const b2 = Buffer.alloc(5);
  b2.writeUInt8(v.kind);
  b2.writeUInt32LE(v.value.length, 1);
  return Buffer.concat([
    b1,
    bKey,
    b2,
    v.value
  ]);
}, EMPTY_HEADERS, createHeaderValue = (header) => ({
  kind: header.kind,
  value: serializeHeaderValue(header)
}), serializeHeaders = (headers) => {
  if (!headers)
    return EMPTY_HEADERS;
  return Buffer.concat(Object.keys(headers).map((c) => serializeHeader(c, createHeaderValue(headers[c]))));
}, mapHeaderKind = (k) => {
  if (!ReverseHeaderKind[k])
    throw new Error(`unknow header kind: ${k}`);
  return ReverseHeaderKind[k];
}, deserializeHeaderValue = (kind, value) => {
  switch (kind) {
    case HeaderKind.Int128:
    case HeaderKind.Uint128:
    case HeaderKind.Raw:
      return value;
    case HeaderKind.String:
      return value.toString();
    case HeaderKind.Int8:
      return value.readInt8();
    case HeaderKind.Int16:
      return value.readInt16LE();
    case HeaderKind.Int32:
      return value.readInt32LE();
    case HeaderKind.Int64:
      return value.readBigInt64LE();
    case HeaderKind.Uint8:
      return value.readUint8();
    case HeaderKind.Uint16:
      return value.readUint16LE();
    case HeaderKind.Uint32:
      return value.readUInt32LE();
    case HeaderKind.Uint64:
      return value.readBigUInt64LE();
    case HeaderKind.Bool:
      return value.readUInt8() === 1;
    case HeaderKind.Float:
      return value.readFloatLE();
    case HeaderKind.Double:
      return value.readDoubleLE();
    default:
      throw new Error(`deserializeHeaderValue: invalid HeaderKind ${kind}`);
  }
}, deserializeHeader = (p, pos = 0) => {
  const keyLength = p.readUInt32LE(pos);
  const key = p.subarray(pos + 4, pos + 4 + keyLength).toString();
  pos += keyLength + 4;
  const rawKind = p.readUInt8(pos);
  const valueLength = p.readUInt32LE(pos + 1);
  const value = deserializeHeaderValue(rawKind, p.subarray(pos + 5, pos + 5 + valueLength));
  return {
    bytesRead: 4 + 4 + 1 + keyLength + valueLength,
    data: {
      key,
      kind: rawKind,
      value
    }
  };
}, deserializeHeaders = (p, pos = 0) => {
  const headers = {};
  const len = p.length;
  while (pos < len) {
    const { bytesRead, data: { kind, key, value } } = deserializeHeader(p, pos);
    headers[key] = { kind, value };
    pos += bytesRead;
  }
  return headers;
}, Raw = (value) => ({
  kind: HeaderKind.Raw,
  value
}), String2 = (value) => ({
  kind: HeaderKind.String,
  value
}), Bool = (value) => ({
  kind: HeaderKind.Bool,
  value
}), Int8 = (value) => ({
  kind: HeaderKind.Int8,
  value
}), Int16 = (value) => ({
  kind: HeaderKind.Int16,
  value
}), Int32 = (value) => ({
  kind: HeaderKind.Int32,
  value
}), Int64 = (value) => ({
  kind: HeaderKind.Int64,
  value
}), Int128 = (value) => ({
  kind: HeaderKind.Int128,
  value
}), Uint8 = (value) => ({
  kind: HeaderKind.Uint8,
  value
}), Uint16 = (value) => ({
  kind: HeaderKind.Uint16,
  value
}), Uint32 = (value) => ({
  kind: HeaderKind.Uint32,
  value
}), Uint64 = (value) => ({
  kind: HeaderKind.Uint64,
  value
}), Uint128 = (value) => ({
  kind: HeaderKind.Uint128,
  value
}), Float = (value) => ({
  kind: HeaderKind.Float,
  value
}), Double = (value) => ({
  kind: HeaderKind.Double,
  value
}), getKind = (h) => mapHeaderKind(h.kind), getValue = (h) => h.value, HeaderValue;
var init_header_utils = __esm(() => {
  init_header_type();
  EMPTY_HEADERS = Buffer.alloc(0);
  HeaderValue = {
    Raw,
    String: String2,
    Bool,
    Int8,
    Int16,
    Int32,
    Int64,
    Int128,
    Uint8,
    Uint16,
    Uint32,
    Uint64,
    Uint128,
    Float,
    Double,
    getKind,
    getValue
  };
});

// node_modules/@iggy.rs/sdk/dist/wire/message/poll.utils.js
var PollingStrategyKind, Next, First, Last, Offset = (n) => ({
  kind: PollingStrategyKind.Offset,
  value: n
}), Timestamp = (n) => ({
  kind: PollingStrategyKind.Timestamp,
  value: n
}), PollingStrategy, serializePollMessages = (streamId, topicId, consumer, partitionId, pollingStrategy, count = 10, autocommit = false) => {
  const b = Buffer.allocUnsafe(14);
  b.writeUInt8(pollingStrategy.kind, 0);
  b.writeBigUInt64LE(pollingStrategy.value, 1);
  b.writeUInt32LE(count, 9);
  b.writeUInt8(autocommit ? 1 : 0, 13);
  return Buffer.concat([
    serializeGetOffset(streamId, topicId, consumer, partitionId),
    b
  ]);
}, MessageState, ReverseMessageState, mapMessageState = (k) => {
  if (!ReverseMessageState[k])
    throw new Error(`unknow message state: ${k}`);
  return ReverseMessageState[k];
}, deserializePollMessages = (r, pos = 0) => {
  const len = r.length;
  const partitionId = r.readUInt32LE(pos);
  const currentOffset = r.readBigUInt64LE(pos + 4);
  const messageCount = r.readUInt32LE(pos + 12);
  const messages = [];
  pos += 16;
  if (pos >= len) {
    return {
      partitionId,
      currentOffset,
      messageCount,
      messages
    };
  }
  while (pos < len) {
    const offset = r.readBigUInt64LE(pos);
    const state = mapMessageState(r.readUInt8(pos + 8));
    const timestamp = toDate(r.readBigUInt64LE(pos + 9));
    const id = deserializeUUID(r.subarray(pos + 17, pos + 17 + 16));
    const checksum = r.readUInt32LE(pos + 33);
    const headersLength = r.readUInt32LE(pos + 37);
    const headers = deserializeHeaders(r.subarray(pos + 41, pos + 41 + headersLength));
    pos += headersLength;
    const messageLength = r.readUInt32LE(pos + 41);
    const payload = r.subarray(pos + 45, pos + 45 + messageLength);
    pos += 45 + messageLength;
    messages.push({
      id,
      state,
      timestamp,
      offset,
      headers,
      payload,
      checksum
    });
  }
  return {
    partitionId,
    currentOffset,
    messageCount,
    messages
  };
};
var init_poll_utils = __esm(() => {
  init_offset_utils();
  init_header_utils();
  PollingStrategyKind = {
    Offset: 1,
    Timestamp: 2,
    First: 3,
    Last: 4,
    Next: 5
  };
  Next = {
    kind: PollingStrategyKind.Next,
    value: 0n
  };
  First = {
    kind: PollingStrategyKind.First,
    value: 0n
  };
  Last = {
    kind: PollingStrategyKind.Last,
    value: 0n
  };
  PollingStrategy = {
    Next,
    First,
    Last,
    Offset,
    Timestamp
  };
  MessageState = {
    Available: 1,
    Unavailable: 10,
    Poisoned: 20,
    MarkedForDeletion: 30
  };
  ReverseMessageState = reverseRecord(MessageState);
});

// node_modules/@iggy.rs/sdk/dist/wire/message/poll-messages.command.js
var POLL_MESSAGES, pollMessages;
var init_poll_messages_command = __esm(() => {
  init_poll_utils();
  POLL_MESSAGES = {
    code: 100,
    serialize: ({ streamId, topicId, consumer, partitionId, pollingStrategy, count, autocommit }) => {
      return serializePollMessages(streamId, topicId, consumer, partitionId, pollingStrategy, count, autocommit);
    },
    deserialize: (r) => {
      return deserializePollMessages(r.data);
    }
  };
  pollMessages = wrapCommand(POLL_MESSAGES);
});

// node_modules/@iggy.rs/sdk/dist/wire/message/partitioning.utils.js
var PartitionKind, Balanced, PartitionId = (id) => ({
  kind: PartitionKind.PartitionId,
  value: id
}), MessageKey = (key) => ({
  kind: PartitionKind.MessageKey,
  value: key
}), Partitioning, serializeMessageKey = (v) => {
  if (v instanceof Buffer)
    return v;
  if (typeof v === "string")
    return Buffer.from(v);
  if (typeof v === "number")
    return uint32ToBuf(v);
  if (typeof v === "bigint")
    return uint64ToBuf(v);
  throw new Error(`cannot serialize messageKey ${v}, ${typeof v}`);
}, serializePartitioningValue = (part) => {
  const { kind, value } = part;
  switch (kind) {
    case PartitionKind.Balanced:
      return Buffer.alloc(0);
    case PartitionKind.PartitionId:
      return uint32ToBuf(value);
    case PartitionKind.MessageKey:
      return serializeMessageKey(value);
  }
}, default_partionning, serializePartitioning = (p) => {
  const part = p || default_partionning;
  const b = Buffer.alloc(2);
  const bValue = serializePartitioningValue(part);
  b.writeUint8(part.kind);
  b.writeUint8(bValue.length, 1);
  return Buffer.concat([
    b,
    bValue
  ]);
};
var init_partitioning_utils = __esm(() => {
  PartitionKind = {
    Balanced: 1,
    PartitionId: 2,
    MessageKey: 3
  };
  Balanced = {
    kind: PartitionKind.Balanced,
    value: null
  };
  Partitioning = {
    Balanced,
    PartitionId,
    MessageKey
  };
  default_partionning = {
    kind: PartitionKind.Balanced,
    value: null
  };
});

// node_modules/uuidv7/dist/index.js
class UUID {
  constructor(bytes) {
    this.bytes = bytes;
  }
  static ofInner(bytes) {
    if (bytes.length !== 16) {
      throw new TypeError("not 128-bit length");
    } else {
      return new UUID(bytes);
    }
  }
  static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {
    if (!Number.isInteger(unixTsMs) || !Number.isInteger(randA) || !Number.isInteger(randBHi) || !Number.isInteger(randBLo) || unixTsMs < 0 || randA < 0 || randBHi < 0 || randBLo < 0 || unixTsMs > 281474976710655 || randA > 4095 || randBHi > 1073741823 || randBLo > 4294967295) {
      throw new RangeError("invalid field value");
    }
    const bytes = new Uint8Array(16);
    bytes[0] = unixTsMs / 2 ** 40;
    bytes[1] = unixTsMs / 2 ** 32;
    bytes[2] = unixTsMs / 2 ** 24;
    bytes[3] = unixTsMs / 2 ** 16;
    bytes[4] = unixTsMs / 2 ** 8;
    bytes[5] = unixTsMs;
    bytes[6] = 112 | randA >>> 8;
    bytes[7] = randA;
    bytes[8] = 128 | randBHi >>> 24;
    bytes[9] = randBHi >>> 16;
    bytes[10] = randBHi >>> 8;
    bytes[11] = randBHi;
    bytes[12] = randBLo >>> 24;
    bytes[13] = randBLo >>> 16;
    bytes[14] = randBLo >>> 8;
    bytes[15] = randBLo;
    return new UUID(bytes);
  }
  static parse(uuid) {
    var _a, _b, _c, _d;
    let hex = undefined;
    switch (uuid.length) {
      case 32:
        hex = (_a = /^[0-9a-f]{32}$/i.exec(uuid)) === null || _a === undefined ? undefined : _a[0];
        break;
      case 36:
        hex = (_b = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid)) === null || _b === undefined ? undefined : _b.slice(1, 6).join("");
        break;
      case 38:
        hex = (_c = /^\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\}$/i.exec(uuid)) === null || _c === undefined ? undefined : _c.slice(1, 6).join("");
        break;
      case 45:
        hex = (_d = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid)) === null || _d === undefined ? undefined : _d.slice(1, 6).join("");
        break;
      default:
        break;
    }
    if (hex) {
      const inner = new Uint8Array(16);
      for (let i = 0;i < 16; i += 4) {
        const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);
        inner[i + 0] = n >>> 24;
        inner[i + 1] = n >>> 16;
        inner[i + 2] = n >>> 8;
        inner[i + 3] = n;
      }
      return new UUID(inner);
    } else {
      throw new SyntaxError("could not parse UUID string");
    }
  }
  toString() {
    let text = "";
    for (let i = 0;i < this.bytes.length; i++) {
      text += DIGITS.charAt(this.bytes[i] >>> 4);
      text += DIGITS.charAt(this.bytes[i] & 15);
      if (i === 3 || i === 5 || i === 7 || i === 9) {
        text += "-";
      }
    }
    return text;
  }
  toHex() {
    let text = "";
    for (let i = 0;i < this.bytes.length; i++) {
      text += DIGITS.charAt(this.bytes[i] >>> 4);
      text += DIGITS.charAt(this.bytes[i] & 15);
    }
    return text;
  }
  toJSON() {
    return this.toString();
  }
  getVariant() {
    const n = this.bytes[8] >>> 4;
    if (n < 0) {
      throw new Error("unreachable");
    } else if (n <= 7) {
      return this.bytes.every((e) => e === 0) ? "NIL" : "VAR_0";
    } else if (n <= 11) {
      return "VAR_10";
    } else if (n <= 13) {
      return "VAR_110";
    } else if (n <= 15) {
      return this.bytes.every((e) => e === 255) ? "MAX" : "VAR_RESERVED";
    } else {
      throw new Error("unreachable");
    }
  }
  getVersion() {
    return this.getVariant() === "VAR_10" ? this.bytes[6] >>> 4 : undefined;
  }
  clone() {
    return new UUID(this.bytes.slice(0));
  }
  equals(other) {
    return this.compareTo(other) === 0;
  }
  compareTo(other) {
    for (let i = 0;i < 16; i++) {
      const diff = this.bytes[i] - other.bytes[i];
      if (diff !== 0) {
        return Math.sign(diff);
      }
    }
    return 0;
  }
}
var DIGITS = "0123456789abcdef";

// node_modules/@iggy.rs/sdk/dist/wire/uuid.utils.js
var parse = (uid) => UUID.parse(uid);
var init_uuid_utils = () => {};

// node_modules/@iggy.rs/sdk/dist/wire/message/message.utils.js
var import_debug2, debug2, isValidMessageId = (x) => x === undefined || x === 0 || x === 0n || typeof x === "string", serializeMessageId = (id) => {
  if (!isValidMessageId(id))
    throw new Error(`invalid message id: '${id}' (use uuid string or 0)`);
  if (id === undefined || id === 0 || id === 0n) {
    return Buffer.alloc(16, 0);
  }
  try {
    const uuid = parse(id);
    return Buffer.from(uuid.toHex(), "hex");
  } catch (err) {
    throw new Error(`invalid message id: '${id}' (use uuid string or 0)`, { cause: err });
  }
}, serializeMessage = (msg) => {
  const { id, headers, payload } = msg;
  const bId = serializeMessageId(id);
  const bHeaders = serializeHeaders(headers);
  const bHLen = uint32ToBuf(bHeaders.length);
  const bPayload = typeof payload === "string" ? Buffer.from(payload) : payload;
  const bPLen = uint32ToBuf(bPayload.length);
  const r = Buffer.concat([
    bId,
    bHLen,
    bHeaders,
    bPLen,
    bPayload
  ]);
  debug2("id", bId.length, bId.toString("hex"), "headers", bHeaders.length, bHeaders.toString("hex"), "binLength/PL", bPLen.length, bPLen.toString("hex"), "payload", bPayload.length, bPayload.toString("hex"), "full len", r.length);
  return r;
}, serializeMessages = (messages) => Buffer.concat(messages.map((c) => serializeMessage(c))), serializeSendMessages = (streamId, topicId, messages, partitioning) => {
  const streamIdentifier = serializeIdentifier(streamId);
  const topicIdentifier = serializeIdentifier(topicId);
  const bPartitioning = serializePartitioning(partitioning);
  const bMessages = serializeMessages(messages);
  return Buffer.concat([
    streamIdentifier,
    topicIdentifier,
    bPartitioning,
    bMessages
  ]);
};
var init_message_utils = __esm(() => {
  init_header_utils();
  init_partitioning_utils();
  init_uuid_utils();
  import_debug2 = __toESM(require_src(), 1);
  debug2 = import_debug2.default("iggy:client");
});

// node_modules/@iggy.rs/sdk/dist/wire/message/send-messages.command.js
var SEND_MESSAGES, sendMessages;
var init_send_messages_command = __esm(() => {
  init_message_utils();
  init_client_utils();
  SEND_MESSAGES = {
    code: 101,
    serialize: ({ streamId, topicId, messages, partition }) => {
      return serializeSendMessages(streamId, topicId, messages, partition);
    },
    deserialize: deserializeVoidResponse
  };
  sendMessages = wrapCommand(SEND_MESSAGES);
});

// node_modules/@iggy.rs/sdk/dist/wire/message/index.js
var init_message = __esm(() => {
  init_poll_utils();
  init_partitioning_utils();
  init_header_utils();
  init_poll_messages_command();
  init_send_messages_command();
});

// node_modules/@iggy.rs/sdk/dist/wire/offset/get-offset.command.js
var GET_OFFSET, getOffset;
var init_get_offset_command = __esm(() => {
  init_offset_utils();
  GET_OFFSET = {
    code: 120,
    serialize: ({ streamId, topicId, consumer, partitionId = 1 }) => {
      return serializeGetOffset(streamId, topicId, consumer, partitionId);
    },
    deserialize: (r) => {
      const partitionId = r.data.readUInt32LE(0);
      const currentOffset = r.data.readBigUInt64LE(4);
      const storedOffset = r.data.readBigUInt64LE(12);
      return {
        partitionId,
        currentOffset,
        storedOffset
      };
    }
  };
  getOffset = wrapCommand(GET_OFFSET);
});

// node_modules/@iggy.rs/sdk/dist/wire/offset/store-offset.command.js
var STORE_OFFSET, storeOffset;
var init_store_offset_command = __esm(() => {
  init_client_utils();
  init_offset_utils();
  STORE_OFFSET = {
    code: 121,
    serialize: ({ streamId, topicId, consumer, partitionId, offset }) => serializeStoreOffset(streamId, topicId, consumer, partitionId, offset),
    deserialize: deserializeVoidResponse
  };
  storeOffset = wrapCommand(STORE_OFFSET);
});

// node_modules/@iggy.rs/sdk/dist/wire/offset/index.js
var init_offset = __esm(() => {
  init_offset_utils();
  init_get_offset_command();
  init_store_offset_command();
});

// node_modules/@iggy.rs/sdk/dist/wire/partition/partition.utils.js
var serializePartitionParams = (streamId, topicId, partitionCount = 1) => {
  if (partitionCount < 1 || partitionCount > 1000)
    throw new Error("Topic partition_count must be between 1 and 1000");
  const streamIdentifier = serializeIdentifier(streamId);
  const topicIdentifier = serializeIdentifier(topicId);
  const b = Buffer.alloc(4);
  b.writeUInt32LE(partitionCount, 0);
  return Buffer.concat([
    streamIdentifier,
    topicIdentifier,
    b
  ]);
};
var init_partition_utils = () => {};

// node_modules/@iggy.rs/sdk/dist/wire/partition/create-partition.command.js
var CREATE_PARTITION, createPartition;
var init_create_partition_command = __esm(() => {
  init_client_utils();
  init_partition_utils();
  CREATE_PARTITION = {
    code: 402,
    serialize: ({ streamId, topicId, partitionCount = 1 }) => {
      return serializePartitionParams(streamId, topicId, partitionCount);
    },
    deserialize: deserializeVoidResponse
  };
  createPartition = wrapCommand(CREATE_PARTITION);
});

// node_modules/@iggy.rs/sdk/dist/wire/partition/delete-partition.command.js
var DELETE_PARTITION, deletePartition;
var init_delete_partition_command = __esm(() => {
  init_client_utils();
  init_partition_utils();
  DELETE_PARTITION = {
    code: 403,
    serialize: ({ streamId, topicId, partitionCount }) => {
      return serializePartitionParams(streamId, topicId, partitionCount);
    },
    deserialize: deserializeVoidResponse
  };
  deletePartition = wrapCommand(DELETE_PARTITION);
});

// node_modules/@iggy.rs/sdk/dist/wire/partition/index.js
var init_partition = __esm(() => {
  init_create_partition_command();
  init_delete_partition_command();
});

// node_modules/@iggy.rs/sdk/dist/wire/session/login.command.js
var LOGIN, login;
var init_login_command = __esm(() => {
  LOGIN = {
    code: 38,
    serialize: ({ username, password, version, context }) => {
      const bUsername = Buffer.from(username);
      const bPassword = Buffer.from(password);
      if (bUsername.length < 1 || bUsername.length > 255)
        throw new Error("Username should be between 1 and 255 bytes");
      if (bPassword.length < 1 || bPassword.length > 255)
        throw new Error("Password should be between 1 and 255 bytes");
      const l1 = Buffer.allocUnsafe(1);
      const l2 = Buffer.allocUnsafe(1);
      l1.writeUInt8(bUsername.length);
      l2.writeUInt8(bPassword.length);
      const binVersion = [];
      const l3 = Buffer.allocUnsafe(4);
      if (version && version.length > 0) {
        const bVersion = Buffer.from(version);
        l3.writeUInt32LE(bVersion.length);
        binVersion.push(l3, bVersion);
      } else {
        l3.writeUInt32LE(0);
        binVersion.push(l3);
      }
      const binContext = [];
      const l4 = Buffer.allocUnsafe(4);
      if (context && context.length > 0) {
        const bContext = Buffer.from(context);
        l4.writeUInt32LE(bContext.length);
        binContext.push(l4, bContext);
      } else {
        l4.writeUInt32LE(0);
        binContext.push(l4);
      }
      return Buffer.concat([
        l1,
        bUsername,
        l2,
        bPassword,
        ...binVersion,
        ...binContext
      ]);
    },
    deserialize: (r) => ({
      userId: r.data.readUInt32LE(0)
    })
  };
  login = wrapCommand(LOGIN);
});

// node_modules/@iggy.rs/sdk/dist/wire/session/login-with-token.command.js
var LOGIN_WITH_TOKEN, loginWithToken;
var init_login_with_token_command = __esm(() => {
  LOGIN_WITH_TOKEN = {
    code: 44,
    serialize: ({ token }) => {
      const bToken = Buffer.from(token);
      if (bToken.length < 1 || bToken.length > 255)
        throw new Error("Token length should be between 1 and 255 bytes");
      const b = Buffer.alloc(1);
      b.writeUInt8(bToken.length);
      return Buffer.concat([
        b,
        bToken
      ]);
    },
    deserialize: (r) => ({
      userId: r.data.readUInt32LE(0)
    })
  };
  loginWithToken = wrapCommand(LOGIN_WITH_TOKEN);
});

// node_modules/@iggy.rs/sdk/dist/wire/session/logout.command.js
var LOGOUT, logout;
var init_logout_command = __esm(() => {
  init_client_utils();
  LOGOUT = {
    code: 39,
    serialize: () => {
      return Buffer.alloc(0);
    },
    deserialize: deserializeVoidResponse
  };
  logout = wrapCommand(LOGOUT);
});

// node_modules/@iggy.rs/sdk/dist/wire/session/index.js
var init_session = __esm(() => {
  init_login_command();
  init_login_with_token_command();
  init_logout_command();
});

// node_modules/@iggy.rs/sdk/dist/wire/stream/stream.utils.js
var deserializeToStream = (r, pos = 0) => {
  const id = r.readUInt32LE(pos);
  const createdAt = toDate(r.readBigUint64LE(pos + 4));
  const topicsCount = r.readUInt32LE(pos + 12);
  const sizeBytes = r.readBigUint64LE(pos + 16);
  const messagesCount = r.readBigUint64LE(pos + 24);
  const nameLength = r.readUInt8(pos + 32);
  const name = r.subarray(pos + 33, pos + 33 + nameLength).toString();
  return {
    bytesRead: 33 + nameLength,
    data: {
      id,
      name,
      topicsCount,
      messagesCount,
      sizeBytes,
      createdAt
    }
  };
};
var init_stream_utils = () => {};

// node_modules/@iggy.rs/sdk/dist/wire/stream/create-stream.command.js
var CREATE_STREAM, createStream;
var init_create_stream_command = __esm(() => {
  init_stream_utils();
  CREATE_STREAM = {
    code: 202,
    serialize: ({ streamId, name }) => {
      const bName = Buffer.from(name);
      if (bName.length < 1 || bName.length > 255)
        throw new Error("Stream name should be between 1 and 255 bytes");
      const b = Buffer.allocUnsafe(4 + 1);
      b.writeUInt32LE(streamId, 0);
      b.writeUInt8(bName.length, 4);
      return Buffer.concat([
        b,
        bName
      ]);
    },
    deserialize: (r) => {
      return deserializeToStream(r.data, 0).data;
    }
  };
  createStream = wrapCommand(CREATE_STREAM);
});

// node_modules/@iggy.rs/sdk/dist/wire/stream/delete-stream.command.js
var DELETE_STREAM, deleteStream;
var init_delete_stream_command = __esm(() => {
  init_client_utils();
  DELETE_STREAM = {
    code: 203,
    serialize: ({ streamId }) => {
      return serializeIdentifier(streamId);
    },
    deserialize: deserializeVoidResponse
  };
  deleteStream = wrapCommand(DELETE_STREAM);
});

// node_modules/@iggy.rs/sdk/dist/wire/stream/get-stream.command.js
var GET_STREAM, getStream;
var init_get_stream_command = __esm(() => {
  init_stream_utils();
  GET_STREAM = {
    code: 200,
    serialize: ({ streamId }) => {
      return serializeIdentifier(streamId);
    },
    deserialize: (r) => {
      return deserializeToStream(r.data, 0).data;
    }
  };
  getStream = wrapCommand(GET_STREAM);
});

// node_modules/@iggy.rs/sdk/dist/wire/stream/get-streams.command.js
var GET_STREAMS, getStreams;
var init_get_streams_command = __esm(() => {
  init_stream_utils();
  GET_STREAMS = {
    code: 201,
    serialize: () => Buffer.alloc(0),
    deserialize: (r) => {
      const payloadSize = r.data.length;
      const streams = [];
      let pos = 0;
      while (pos < payloadSize) {
        const { bytesRead, data } = deserializeToStream(r.data, pos);
        streams.push(data);
        pos += bytesRead;
      }
      return streams;
    }
  };
  getStreams = wrapCommand(GET_STREAMS);
});

// node_modules/@iggy.rs/sdk/dist/wire/stream/purge-stream.command.js
var PURGE_STREAM, purgeStream;
var init_purge_stream_command = __esm(() => {
  init_client_utils();
  PURGE_STREAM = {
    code: 205,
    serialize: ({ streamId }) => {
      return serializeIdentifier(streamId);
    },
    deserialize: deserializeVoidResponse
  };
  purgeStream = wrapCommand(PURGE_STREAM);
});

// node_modules/@iggy.rs/sdk/dist/wire/stream/update-stream.command.js
var UPDATE_STREAM, updateStream;
var init_update_stream_command = __esm(() => {
  init_client_utils();
  UPDATE_STREAM = {
    code: 204,
    serialize: ({ streamId, name }) => {
      const bId = serializeIdentifier(streamId);
      const bName = Buffer.from(name);
      if (bName.length < 1 || bName.length > 255)
        throw new Error("Stream name should be between 1 and 255 bytes");
      return Buffer.concat([
        bId,
        uint8ToBuf(bName.length),
        bName
      ]);
    },
    deserialize: deserializeVoidResponse
  };
  updateStream = wrapCommand(UPDATE_STREAM);
});

// node_modules/@iggy.rs/sdk/dist/wire/stream/index.js
var init_stream = __esm(() => {
  init_create_stream_command();
  init_delete_stream_command();
  init_get_stream_command();
  init_get_streams_command();
  init_purge_stream_command();
  init_update_stream_command();
});

// node_modules/@iggy.rs/sdk/dist/wire/system/get-stats.command.js
var GET_STATS, getStats;
var init_get_stats_command = __esm(() => {
  GET_STATS = {
    code: 10,
    serialize: () => Buffer.alloc(0),
    deserialize: (r) => {
      const processId = r.data.readUInt32LE(0);
      const cpuUsage = r.data.readFloatLE(4);
      const totalCpuUsage = r.data.readFloatLE(8);
      const memoryUsage = r.data.readBigUInt64LE(12);
      const totalMemory = r.data.readBigUInt64LE(20);
      const availableMemory = r.data.readBigUInt64LE(28);
      const runTime = r.data.readBigUInt64LE(36);
      const startTime = r.data.readBigUInt64LE(44);
      const readBytes = r.data.readBigUInt64LE(52);
      const writtenBytes = r.data.readBigUInt64LE(60);
      const messagesSizeBytes = r.data.readBigUInt64LE(68);
      const streamsCount = r.data.readUInt32LE(76);
      const topicsCount = r.data.readUInt32LE(80);
      const partitionsCount = r.data.readUInt32LE(84);
      const segmentsCount = r.data.readUInt32LE(88);
      const messagesCount = r.data.readBigUInt64LE(92);
      const clientsCount = r.data.readUInt32LE(100);
      const consumersGroupsCount = r.data.readUInt32LE(104);
      let position = 104 + 4;
      const hostnameLength = r.data.readUInt32LE(position);
      const hostname = r.data.subarray(position + 4, position + 4 + hostnameLength).toString();
      position += 4 + hostnameLength;
      const osNameLength = r.data.readUInt32LE(position);
      const osName = r.data.subarray(position + 4, position + 4 + osNameLength).toString();
      position += 4 + osNameLength;
      const osVersionLength = r.data.readUInt32LE(position);
      const osVersion = r.data.subarray(position + 4, position + 4 + osVersionLength).toString();
      position += 4 + osVersionLength;
      const kernelVersionLength = r.data.readUInt32LE(position);
      const kernelVersion = r.data.subarray(position + 4, position + 4 + kernelVersionLength).toString();
      return {
        processId,
        cpuUsage,
        totalCpuUsage,
        memoryUsage,
        totalMemory,
        availableMemory,
        runTime,
        startTime,
        readBytes,
        writtenBytes,
        messagesSizeBytes,
        streamsCount,
        topicsCount,
        partitionsCount,
        segmentsCount,
        messagesCount,
        clientsCount,
        consumersGroupsCount,
        hostname,
        osName,
        osVersion,
        kernelVersion
      };
    }
  };
  getStats = wrapCommand(GET_STATS);
});

// node_modules/@iggy.rs/sdk/dist/wire/system/ping.command.js
var PING, ping;
var init_ping_command = __esm(() => {
  init_client_utils();
  PING = {
    code: 1,
    serialize: () => {
      return Buffer.alloc(0);
    },
    deserialize: deserializeVoidResponse
  };
  ping = wrapCommand(PING);
});

// node_modules/@iggy.rs/sdk/dist/wire/system/index.js
var init_system = __esm(() => {
  init_get_stats_command();
  init_ping_command();
});

// node_modules/@iggy.rs/sdk/dist/wire/token/token.utils.js
var deserializeCreateToken = (p, pos = 0) => {
  const len = p.readUInt8(pos);
  const token = p.subarray(pos + 1, pos + 1 + len).toString();
  return { bytesRead: 1 + len, data: { token } };
}, deserializeToken = (p, pos = 0) => {
  const nameLength = p.readUInt8(pos);
  const name = p.subarray(pos + 1, pos + 1 + nameLength).toString();
  const rest = p.subarray(pos + 1 + nameLength);
  let expiry = null;
  let bytesRead = pos + 1 + nameLength;
  if (rest.length >= 8) {
    expiry = toDate(rest.readBigUInt64LE(0));
    bytesRead += 8;
  }
  return {
    bytesRead,
    data: {
      name,
      expiry
    }
  };
}, deserializeTokens = (p, pos = 0) => {
  const tokens = [];
  const len = p.length;
  while (pos < len) {
    const { bytesRead, data } = deserializeToken(p, pos);
    tokens.push(data);
    pos += bytesRead;
  }
  return tokens;
};
var init_token_utils = () => {};

// node_modules/@iggy.rs/sdk/dist/wire/token/create-token.command.js
var CREATE_TOKEN, createToken;
var init_create_token_command = __esm(() => {
  init_token_utils();
  CREATE_TOKEN = {
    code: 42,
    serialize: ({ name, expiry = 600n }) => {
      const bName = Buffer.from(name);
      if (bName.length < 1 || bName.length > 255)
        throw new Error("Token name should be between 1 and 255 bytes");
      const b1 = Buffer.alloc(1);
      b1.writeUInt8(bName.length);
      const b2 = Buffer.alloc(8);
      b2.writeBigUInt64LE(expiry);
      return Buffer.concat([
        b1,
        bName,
        b2
      ]);
    },
    deserialize: (r) => deserializeCreateToken(r.data).data
  };
  createToken = wrapCommand(CREATE_TOKEN);
});

// node_modules/@iggy.rs/sdk/dist/wire/token/delete-token.command.js
var DELETE_TOKEN, deleteToken;
var init_delete_token_command = __esm(() => {
  init_client_utils();
  DELETE_TOKEN = {
    code: 43,
    serialize: ({ name }) => {
      const bName = Buffer.from(name);
      if (bName.length < 1 || bName.length > 255)
        throw new Error("Token name should be between 1 and 255 bytes");
      const b = Buffer.alloc(1);
      b.writeUInt8(bName.length);
      return Buffer.concat([
        b,
        bName
      ]);
    },
    deserialize: deserializeVoidResponse
  };
  deleteToken = wrapCommand(DELETE_TOKEN);
});

// node_modules/@iggy.rs/sdk/dist/wire/token/get-tokens.command.js
var GET_TOKENS, getTokens;
var init_get_tokens_command = __esm(() => {
  init_token_utils();
  GET_TOKENS = {
    code: 41,
    serialize: () => Buffer.alloc(0),
    deserialize: (r) => deserializeTokens(r.data)
  };
  getTokens = wrapCommand(GET_TOKENS);
});

// node_modules/@iggy.rs/sdk/dist/wire/token/index.js
var init_token = __esm(() => {
  init_create_token_command();
  init_delete_token_command();
  init_get_tokens_command();
});

// node_modules/@iggy.rs/sdk/dist/wire/topic/topic.utils.js
var exports_topic_utils = {};
__export(exports_topic_utils, {
  isValidCompressionAlgorithm: () => isValidCompressionAlgorithm,
  deserializeTopics: () => deserializeTopics,
  deserializeTopic: () => deserializeTopic,
  deserializePartition: () => deserializePartition,
  deserializeBaseTopic: () => deserializeBaseTopic,
  CompressionAlgorithmKind: () => CompressionAlgorithmKind
});
var CompressionAlgorithmKind, isValidCompressionAlgorithm = (ca) => Object.values(CompressionAlgorithmKind).includes(ca), deserializeBaseTopic = (p, pos = 0) => {
  const id = p.readUInt32LE(pos);
  const createdAt = toDate(p.readBigUint64LE(pos + 4));
  const partitionsCount = p.readUInt32LE(pos + 12);
  const compressionAlgorithm = p.readUInt8(pos + 16);
  const messageExpiry = p.readBigUInt64LE(pos + 17);
  const maxTopicSize = p.readBigUInt64LE(pos + 25);
  const replicationFactor = p.readUInt8(pos + 33);
  const sizeBytes = p.readBigUInt64LE(pos + 34);
  const messagesCount = p.readBigUInt64LE(pos + 42);
  const nameLength = p.readUInt8(pos + 50);
  const name = p.subarray(pos + 51, pos + 51 + nameLength).toString();
  return {
    bytesRead: 4 + 8 + 4 + 1 + 8 + 8 + 1 + 8 + 8 + 1 + nameLength,
    data: {
      id,
      name,
      createdAt,
      partitionsCount,
      compressionAlgorithm,
      maxTopicSize,
      replicationFactor,
      messageExpiry,
      messagesCount,
      sizeBytes
    }
  };
}, deserializePartition = (p, pos = 0) => {
  return {
    bytesRead: 4 + 8 + 4 + 8 + 8 + 8,
    data: {
      id: p.readUInt32LE(pos),
      createdAt: toDate(p.readBigUint64LE(pos + 4)),
      segmentsCount: p.readUInt32LE(pos + 12),
      currentOffset: p.readBigUint64LE(pos + 16),
      sizeBytes: p.readBigUint64LE(pos + 24),
      messagesCount: p.readBigUint64LE(pos + 24)
    }
  };
}, deserializeTopic = (p, pos = 0) => {
  const start = pos;
  const { bytesRead, data } = deserializeBaseTopic(p, pos);
  pos += bytesRead;
  const partitions = [];
  const end = p.length;
  while (pos < end) {
    const { bytesRead: bytesRead2, data: data2 } = deserializePartition(p, pos);
    partitions.push(data2);
    pos += bytesRead2;
  }
  return { bytesRead: pos - start, data: { ...data, partitions } };
}, deserializeTopics = (p, pos = 0) => {
  const topics = [];
  const len = p.length;
  while (pos < len) {
    const { bytesRead, data } = deserializeTopic(p, pos);
    topics.push(data);
    pos += bytesRead;
  }
  return topics;
};
var init_topic_utils = __esm(() => {
  CompressionAlgorithmKind = {
    None: 1,
    Gzip: 2
  };
});

// node_modules/@iggy.rs/sdk/dist/wire/topic/create-topic.command.js
var CREATE_TOPIC, createTopic;
var init_create_topic_command = __esm(() => {
  init_topic_utils();
  CREATE_TOPIC = {
    code: 302,
    serialize: ({ streamId, topicId, name, partitionCount, compressionAlgorithm = CompressionAlgorithmKind.None, messageExpiry = 0n, maxTopicSize = 0n, replicationFactor = 1 }) => {
      const streamIdentifier = serializeIdentifier(streamId);
      const bName = Buffer.from(name);
      if (replicationFactor < 1 || replicationFactor > 255)
        throw new Error("Topic replication factor should be between 1 and 255");
      if (bName.length < 1 || bName.length > 255)
        throw new Error("Topic name should be between 1 and 255 bytes");
      if (!isValidCompressionAlgorithm(compressionAlgorithm))
        throw new Error(`createTopic: invalid compressionAlgorithm (${compressionAlgorithm})`);
      const b = Buffer.allocUnsafe(4 + 4 + 1 + 8 + 8 + 1 + 1);
      b.writeUInt32LE(topicId, 0);
      b.writeUInt32LE(partitionCount, 4);
      b.writeUInt8(compressionAlgorithm, 8);
      b.writeBigUInt64LE(messageExpiry, 9);
      b.writeBigUInt64LE(maxTopicSize, 17);
      b.writeUInt8(replicationFactor, 25);
      b.writeUInt8(bName.length, 26);
      return Buffer.concat([
        streamIdentifier,
        b,
        bName
      ]);
    },
    deserialize: (r) => {
      return deserializeTopic(r.data).data;
    }
  };
  createTopic = wrapCommand(CREATE_TOPIC);
});

// node_modules/@iggy.rs/sdk/dist/wire/topic/delete-topic.command.js
var DELETE_TOPIC, deleteTopic;
var init_delete_topic_command = __esm(() => {
  init_client_utils();
  DELETE_TOPIC = {
    code: 303,
    serialize: ({ streamId, topicId, partitionsCount }) => {
      return Buffer.concat([
        serializeIdentifier(streamId),
        serializeIdentifier(topicId),
        uint32ToBuf(partitionsCount)
      ]);
    },
    deserialize: deserializeVoidResponse
  };
  deleteTopic = wrapCommand(DELETE_TOPIC);
});

// node_modules/@iggy.rs/sdk/dist/wire/topic/get-topic.command.js
var GET_TOPIC, getTopic;
var init_get_topic_command = __esm(() => {
  init_topic_utils();
  GET_TOPIC = {
    code: 300,
    serialize: ({ streamId, topicId }) => {
      return Buffer.concat([
        serializeIdentifier(streamId),
        serializeIdentifier(topicId)
      ]);
    },
    deserialize: (r) => {
      return deserializeTopic(r.data).data;
    }
  };
  getTopic = wrapCommand(GET_TOPIC);
});

// node_modules/@iggy.rs/sdk/dist/wire/topic/get-topics.command.js
var GET_TOPICS, getTopics;
var init_get_topics_command = __esm(() => {
  init_topic_utils();
  GET_TOPICS = {
    code: 301,
    serialize: ({ streamId }) => {
      return serializeIdentifier(streamId);
    },
    deserialize: (r) => {
      return deserializeTopics(r.data);
    }
  };
  getTopics = wrapCommand(GET_TOPICS);
});

// node_modules/@iggy.rs/sdk/dist/wire/topic/purge-topic.command.js
var PURGE_TOPIC, purgeTopic;
var init_purge_topic_command = __esm(() => {
  init_client_utils();
  PURGE_TOPIC = {
    code: 305,
    serialize: ({ streamId, topicId }) => {
      return Buffer.concat([
        serializeIdentifier(streamId),
        serializeIdentifier(topicId)
      ]);
    },
    deserialize: deserializeVoidResponse
  };
  purgeTopic = wrapCommand(PURGE_TOPIC);
});

// node_modules/@iggy.rs/sdk/dist/wire/topic/update-topic.command.js
var UPDATE_TOPIC, updateTopic;
var init_update_topic_command = __esm(() => {
  init_client_utils();
  init_topic_utils();
  UPDATE_TOPIC = {
    code: 304,
    serialize: ({ streamId, topicId, name, compressionAlgorithm = CompressionAlgorithmKind.None, messageExpiry = 0n, maxTopicSize = 0n, replicationFactor = 1 }) => {
      const streamIdentifier = serializeIdentifier(streamId);
      const topicIdentifier = serializeIdentifier(topicId);
      const bName = Buffer.from(name);
      if (bName.length < 1 || bName.length > 255)
        throw new Error("Topic name should be between 1 and 255 bytes");
      if (!isValidCompressionAlgorithm(compressionAlgorithm))
        throw new Error(`createTopic: invalid compressionAlgorithm (${compressionAlgorithm})`);
      const b = Buffer.allocUnsafe(8 + 8 + 1 + 1 + 1);
      b.writeUInt8(compressionAlgorithm, 0);
      b.writeBigUInt64LE(messageExpiry, 1);
      b.writeBigUInt64LE(maxTopicSize, 9);
      b.writeUInt8(replicationFactor, 17);
      b.writeUInt8(bName.length, 18);
      return Buffer.concat([
        streamIdentifier,
        topicIdentifier,
        b,
        bName
      ]);
    },
    deserialize: deserializeVoidResponse
  };
  updateTopic = wrapCommand(UPDATE_TOPIC);
});

// node_modules/@iggy.rs/sdk/dist/wire/topic/index.js
var init_topic = __esm(() => {
  init_create_topic_command();
  init_delete_topic_command();
  init_get_topic_command();
  init_get_topics_command();
  init_purge_topic_command();
  init_update_topic_command();
});

// node_modules/@iggy.rs/sdk/dist/wire/user/change-password.command.js
var CHANGE_PASSWORD, changePassword;
var init_change_password_command = __esm(() => {
  init_client_utils();
  CHANGE_PASSWORD = {
    code: 37,
    serialize: ({ userId, currentPassword, newPassword }) => {
      const bId = serializeIdentifier(userId);
      const bCur = Buffer.from(currentPassword);
      const bNew = Buffer.from(newPassword);
      if (bCur.length < 1 || bCur.length > 255)
        throw new Error("User password should be between 1 and 255 bytes (current)");
      if (bNew.length < 1 || bNew.length > 255)
        throw new Error("User password should be between 1 and 255 bytes (new)");
      return Buffer.concat([
        bId,
        uint8ToBuf(bCur.length),
        bCur,
        uint8ToBuf(bNew.length),
        bNew
      ]);
    },
    deserialize: deserializeVoidResponse
  };
  changePassword = wrapCommand(CHANGE_PASSWORD);
});

// node_modules/@iggy.rs/sdk/dist/wire/user/permissions.utils.js
var toBool = (u) => u === 1, boolToByte = (b) => b ? 1 : 0, deserializeGlobalPermissions = (p, pos = 0) => {
  return {
    bytesRead: 10,
    data: {
      ManageServers: toBool(p.readUInt8(pos)),
      ReadServers: toBool(p.readUInt8(pos + 1)),
      ManageUsers: toBool(p.readUInt8(pos + 2)),
      ReadUsers: toBool(p.readUInt8(pos + 3)),
      ManageStreams: toBool(p.readUInt8(pos + 4)),
      ReadStreams: toBool(p.readUInt8(pos + 5)),
      ManageTopics: toBool(p.readUInt8(pos + 6)),
      ReadTopics: toBool(p.readUInt8(pos + 7)),
      PollMessages: toBool(p.readUInt8(pos + 8)),
      SendMessages: toBool(p.readUInt8(pos + 9))
    }
  };
}, serializeGlobalPermission = (p) => {
  return Buffer.concat([
    uint8ToBuf(boolToByte(p.ManageServers)),
    uint8ToBuf(boolToByte(p.ReadServers)),
    uint8ToBuf(boolToByte(p.ManageUsers)),
    uint8ToBuf(boolToByte(p.ReadUsers)),
    uint8ToBuf(boolToByte(p.ManageStreams)),
    uint8ToBuf(boolToByte(p.ReadStreams)),
    uint8ToBuf(boolToByte(p.ManageTopics)),
    uint8ToBuf(boolToByte(p.ReadTopics)),
    uint8ToBuf(boolToByte(p.PollMessages)),
    uint8ToBuf(boolToByte(p.SendMessages))
  ]);
}, deserializeTopicPermissions = (p, pos = 0) => {
  const topicId = p.readUInt32LE(pos);
  const permissions = {
    manage: toBool(p.readUInt8(pos + 4)),
    read: toBool(p.readUInt8(pos + 5)),
    pollMessages: toBool(p.readUInt8(pos + 6)),
    sendMessages: toBool(p.readUInt8(pos + 7))
  };
  return {
    bytesRead: 8,
    topicId,
    permissions
  };
}, serializeTopicPermissions = (p) => {
  return Buffer.concat([
    uint32ToBuf(p.topicId),
    uint8ToBuf(boolToByte(p.permissions.manage)),
    uint8ToBuf(boolToByte(p.permissions.read)),
    uint8ToBuf(boolToByte(p.permissions.pollMessages)),
    uint8ToBuf(boolToByte(p.permissions.sendMessages))
  ]);
}, deserializeStreamPermissions = (p, pos = 0) => {
  const start = pos;
  const streamId = p.readUInt32LE(pos);
  const permissions = {
    manageStream: toBool(p.readUInt8(pos + 4)),
    readStream: toBool(p.readUInt8(pos + 5)),
    manageTopics: toBool(p.readUInt8(pos + 6)),
    readTopics: toBool(p.readUInt8(pos + 7)),
    pollMessages: toBool(p.readUInt8(pos + 8)),
    sendMessages: toBool(p.readUInt8(pos + 9))
  };
  pos += 10;
  const topics = [];
  const hasTopics = toBool(p.readUInt8(pos));
  if (hasTopics) {
    let read = true;
    pos += 1;
    while (read) {
      const { bytesRead, topicId, permissions: permissions2 } = deserializeTopicPermissions(p, pos);
      pos += bytesRead;
      topics.push({ topicId, permissions: permissions2 });
      if (p.readUInt8(pos) === 0)
        read = false;
    }
  }
  return {
    bytesRead: pos - start,
    streamId,
    permissions,
    topics
  };
}, serializeStreamPermissions = (p) => {
  const bStream = Buffer.concat([
    uint32ToBuf(p.streamId),
    uint8ToBuf(boolToByte(p.permissions.manageStream)),
    uint8ToBuf(boolToByte(p.permissions.readStream)),
    uint8ToBuf(boolToByte(p.permissions.manageTopics)),
    uint8ToBuf(boolToByte(p.permissions.readTopics)),
    uint8ToBuf(boolToByte(p.permissions.pollMessages)),
    uint8ToBuf(boolToByte(p.permissions.sendMessages))
  ]);
  const hasTopic = p.topics.length > 0;
  const bHasTopic = uint8ToBuf(boolToByte(hasTopic));
  const bHead = Buffer.concat([bStream, bHasTopic]);
  if (!hasTopic)
    return bHead;
  return p.topics.reduce((ac, c) => Buffer.concat([
    ac,
    serializeTopicPermissions(c)
  ]), bHead);
}, deserializePermissions = (p, pos = 0) => {
  const { bytesRead, data } = deserializeGlobalPermissions(p, pos);
  pos += bytesRead;
  const streams = [];
  const hasStream = toBool(p.readUInt8(pos));
  if (hasStream) {
    let readStream = true;
    pos += 1;
    while (readStream) {
      const { bytesRead: bytesRead2, streamId, permissions, topics } = deserializeStreamPermissions(p, pos);
      streams.push({ streamId, permissions, topics });
      pos += bytesRead2;
      if (p.readUInt8(pos) === 0)
        readStream = false;
    }
  }
  return {
    global: data,
    streams
  };
}, serializePermissions = (p) => {
  if (!p)
    return uint8ToBuf(0);
  const bGlobal = serializeGlobalPermission(p.global);
  const hasStream = p.streams.length > 0;
  const bHasStream = uint8ToBuf(boolToByte(hasStream));
  const bHead = Buffer.concat([bGlobal, bHasStream]);
  if (!hasStream)
    return bHead;
  return p.streams.reduce((ac, c) => Buffer.concat([
    ac,
    serializeStreamPermissions(c)
  ]), bHead);
};
var init_permissions_utils = () => {};

// node_modules/@iggy.rs/sdk/dist/wire/user/user.utils.js
var UserStatus, statusString = (t) => {
  switch (t.toString()) {
    case "1":
      return "Active";
    case "2":
      return "Inactive";
    default:
      return `unknown_status_${t}`;
  }
}, deserializeBaseUser = (p, pos = 0) => {
  const id = p.readUInt32LE(pos);
  const createdAt = toDate(p.readBigUInt64LE(pos + 4));
  const status = statusString(p.readUInt8(pos + 12));
  const userNameLength = p.readUInt8(pos + 13);
  const userName = p.subarray(pos + 14, pos + 14 + userNameLength).toString();
  return {
    bytesRead: 14 + userNameLength,
    data: {
      id,
      createdAt,
      status,
      userName
    }
  };
}, deserializeUser = (p, pos = 0) => {
  const { bytesRead, data } = deserializeBaseUser(p, pos);
  pos += bytesRead;
  const hasPerm = p.readUInt8(pos) === 1;
  let permissions = null;
  if (hasPerm) {
    pos += 1;
    const permLength = p.readUInt32LE(pos);
    const permBuffer = p.subarray(pos + 4, pos + 4 + permLength);
    permissions = deserializePermissions(permBuffer, 0);
  }
  return { ...data, permissions };
}, deserializeUsers = (p, pos = 0) => {
  const users = [];
  const end = p.length;
  while (pos < end) {
    const { bytesRead, data } = deserializeBaseUser(p, pos);
    users.push(data);
    pos += bytesRead;
  }
  return users;
};
var init_user_utils = __esm(() => {
  init_permissions_utils();
  (function(UserStatus2) {
    UserStatus2[UserStatus2["Active"] = 1] = "Active";
    UserStatus2[UserStatus2["Inactive"] = 2] = "Inactive";
  })(UserStatus || (UserStatus = {}));
});

// node_modules/@iggy.rs/sdk/dist/wire/user/create-user.command.js
var CREATE_USER, createUser;
var init_create_user_command = __esm(() => {
  init_user_utils();
  init_permissions_utils();
  CREATE_USER = {
    code: 33,
    serialize: ({ username, password, status, permissions }) => {
      const bUsername = Buffer.from(username);
      const bPassword = Buffer.from(password);
      if (bUsername.length < 1 || bUsername.length > 255)
        throw new Error("User username should be between 1 and 255 bytes");
      if (bPassword.length < 1 || bPassword.length > 255)
        throw new Error("User password should be between 1 and 255 bytes");
      const bPermissions = serializePermissions(permissions);
      return Buffer.concat([
        uint8ToBuf(bUsername.length),
        bUsername,
        uint8ToBuf(bPassword.length),
        bPassword,
        uint8ToBuf(status),
        boolToBuf(!!permissions),
        uint32ToBuf(bPermissions.length),
        bPermissions
      ]);
    },
    deserialize: (r) => deserializeUser(r.data)
  };
  createUser = wrapCommand(CREATE_USER);
});

// node_modules/@iggy.rs/sdk/dist/wire/user/delete-user.command.js
var DELETE_USER, deleteUser;
var init_delete_user_command = __esm(() => {
  init_client_utils();
  DELETE_USER = {
    code: 34,
    serialize: ({ userId }) => {
      return serializeIdentifier(userId);
    },
    deserialize: deserializeVoidResponse
  };
  deleteUser = wrapCommand(DELETE_USER);
});

// node_modules/@iggy.rs/sdk/dist/wire/user/get-user.command.js
var GET_USER, getUser;
var init_get_user_command = __esm(() => {
  init_user_utils();
  GET_USER = {
    code: 31,
    serialize: ({ userId }) => {
      return serializeIdentifier(userId);
    },
    deserialize: (r) => deserializeUser(r.data)
  };
  getUser = wrapCommand(GET_USER);
});

// node_modules/@iggy.rs/sdk/dist/wire/user/get-users.command.js
var GET_USERS, getUsers;
var init_get_users_command = __esm(() => {
  init_user_utils();
  GET_USERS = {
    code: 32,
    serialize: () => Buffer.alloc(0),
    deserialize: (r) => deserializeUsers(r.data)
  };
  getUsers = wrapCommand(GET_USERS);
});

// node_modules/@iggy.rs/sdk/dist/wire/user/update-permissions.command.js
var UPDATE_PERMISSIONS, updatePermissions;
var init_update_permissions_command = __esm(() => {
  init_client_utils();
  init_permissions_utils();
  UPDATE_PERMISSIONS = {
    code: 36,
    serialize: ({ userId, permissions }) => {
      const bPermissions = serializePermissions(permissions);
      return Buffer.concat([
        serializeIdentifier(userId),
        boolToBuf(!!permissions),
        uint32ToBuf(bPermissions.length),
        bPermissions
      ]);
    },
    deserialize: deserializeVoidResponse
  };
  updatePermissions = wrapCommand(UPDATE_PERMISSIONS);
});

// node_modules/@iggy.rs/sdk/dist/wire/user/update-user.command.js
var UPDATE_USER, updateUser;
var init_update_user_command = __esm(() => {
  init_client_utils();
  UPDATE_USER = {
    code: 35,
    serialize: ({ userId, username, status }) => {
      const bId = serializeIdentifier(userId);
      let bUsername, bStatus;
      if (username) {
        const bn = Buffer.from(username);
        if (bn.length < 1 || bn.length > 255)
          throw new Error("User username should be between 1 and 255 bytes");
        bUsername = Buffer.concat([
          uint8ToBuf(1),
          uint8ToBuf(bn.length),
          bn
        ]);
      } else
        bUsername = uint8ToBuf(0);
      if (status)
        bStatus = Buffer.concat([uint8ToBuf(1), uint8ToBuf(status)]);
      else
        bStatus = uint8ToBuf(0);
      return Buffer.concat([
        bId,
        bUsername,
        bStatus
      ]);
    },
    deserialize: deserializeVoidResponse
  };
  updateUser = wrapCommand(UPDATE_USER);
});

// node_modules/@iggy.rs/sdk/dist/wire/user/index.js
var init_user = __esm(() => {
  init_change_password_command();
  init_create_user_command();
  init_delete_user_command();
  init_get_user_command();
  init_get_users_command();
  init_update_permissions_command();
  init_update_user_command();
});

// node_modules/@iggy.rs/sdk/dist/wire/command-set.js
class AbstractAPI {
  clientProvider;
  constructor(getClient2) {
    this.clientProvider = getClient2;
  }
}
var userAPI = (c) => ({
  get: getUser(c),
  list: getUsers(c),
  create: createUser(c),
  update: updateUser(c),
  updatePermissions: updatePermissions(c),
  changePassword: changePassword(c),
  delete: deleteUser(c)
}), sessionAPI = (c) => ({
  login: login(c),
  loginWithToken: loginWithToken(c),
  logout: logout(c)
}), clientAPI = (c) => ({
  get: getClient(c),
  getMe: getMe(c),
  list: getClients(c)
}), tokenAPI = (c) => ({
  list: getTokens(c),
  create: createToken(c),
  delete: deleteToken(c)
}), streamAPI = (c) => ({
  get: getStream(c),
  list: getStreams(c),
  create: createStream(c),
  update: updateStream(c),
  delete: deleteStream(c),
  purge: purgeStream(c)
}), topicAPI = (c) => ({
  get: getTopic(c),
  list: getTopics(c),
  create: createTopic(c),
  update: updateTopic(c),
  delete: deleteTopic(c),
  purge: purgeTopic(c)
}), partitionAPI = (c) => ({
  create: createPartition(c),
  delete: deletePartition(c)
}), groupAPI = (c) => ({
  get: getGroup(c),
  list: getGroups(c),
  create: createGroup(c),
  join: joinGroup(c),
  leave: leaveGroup(c),
  delete: deleteGroup(c)
}), offsetAPI = (c) => ({
  get: getOffset(c),
  store: storeOffset(c)
}), messageAPI = (c) => ({
  poll: pollMessages(c),
  send: sendMessages(c)
}), systemAPI = (c) => ({
  ping: ping(c),
  getStats: getStats(c)
}), CommandAPI;
var init_command_set = __esm(() => {
  init_login_command();
  init_logout_command();
  init_login_with_token_command();
  init_get_me_command();
  init_get_clients_command();
  init_get_client_command();
  init_create_group_command();
  init_join_group_command();
  init_get_group_command();
  init_get_groups_command();
  init_leave_group_command();
  init_delete_group_command();
  init_purge_topic_command();
  init_create_topic_command();
  init_update_topic_command();
  init_get_topic_command();
  init_get_topics_command();
  init_delete_topic_command();
  init_get_offset_command();
  init_store_offset_command();
  init_send_messages_command();
  init_poll_messages_command();
  init_create_stream_command();
  init_update_stream_command();
  init_get_stream_command();
  init_get_streams_command();
  init_delete_stream_command();
  init_purge_stream_command();
  init_create_partition_command();
  init_delete_partition_command();
  init_get_stats_command();
  init_ping_command();
  init_get_tokens_command();
  init_create_token_command();
  init_delete_token_command();
  init_get_user_command();
  init_create_user_command();
  init_change_password_command();
  init_update_user_command();
  init_update_permissions_command();
  init_delete_user_command();
  init_get_users_command();
  CommandAPI = class CommandAPI extends AbstractAPI {
    user = userAPI(this.clientProvider);
    session = sessionAPI(this.clientProvider);
    client = clientAPI(this.clientProvider);
    token = tokenAPI(this.clientProvider);
    stream = streamAPI(this.clientProvider);
    topic = topicAPI(this.clientProvider);
    partition = partitionAPI(this.clientProvider);
    group = groupAPI(this.clientProvider);
    offset = offsetAPI(this.clientProvider);
    message = messageAPI(this.clientProvider);
    system = systemAPI(this.clientProvider);
    constructor(c) {
      super(c);
    }
  };
});

// node_modules/@iggy.rs/sdk/dist/wire/index.js
var init_wire = __esm(() => {
  init_client();
  init_consumer_group();
  init_message();
  init_offset();
  init_partition();
  init_session();
  init_stream();
  init_system();
  init_token();
  init_topic();
  init_user();
  init_command_set();
});

// node_modules/generic-pool/lib/factoryValidator.js
var require_factoryValidator = __commonJS((exports, module) => {
  module.exports = function(factory) {
    if (typeof factory.create !== "function") {
      throw new TypeError("factory.create must be a function");
    }
    if (typeof factory.destroy !== "function") {
      throw new TypeError("factory.destroy must be a function");
    }
    if (typeof factory.validate !== "undefined" && typeof factory.validate !== "function") {
      throw new TypeError("factory.validate must be a function");
    }
  };
});

// node_modules/generic-pool/lib/PoolDefaults.js
var require_PoolDefaults = __commonJS((exports, module) => {
  class PoolDefaults {
    constructor() {
      this.fifo = true;
      this.priorityRange = 1;
      this.testOnBorrow = false;
      this.testOnReturn = false;
      this.autostart = true;
      this.evictionRunIntervalMillis = 0;
      this.numTestsPerEvictionRun = 3;
      this.softIdleTimeoutMillis = -1;
      this.idleTimeoutMillis = 30000;
      this.acquireTimeoutMillis = null;
      this.destroyTimeoutMillis = null;
      this.maxWaitingClients = null;
      this.min = null;
      this.max = null;
      this.Promise = Promise;
    }
  }
  module.exports = PoolDefaults;
});

// node_modules/generic-pool/lib/PoolOptions.js
var require_PoolOptions = __commonJS((exports, module) => {
  var PoolDefaults = require_PoolDefaults();

  class PoolOptions {
    constructor(opts) {
      const poolDefaults = new PoolDefaults;
      opts = opts || {};
      this.fifo = typeof opts.fifo === "boolean" ? opts.fifo : poolDefaults.fifo;
      this.priorityRange = opts.priorityRange || poolDefaults.priorityRange;
      this.testOnBorrow = typeof opts.testOnBorrow === "boolean" ? opts.testOnBorrow : poolDefaults.testOnBorrow;
      this.testOnReturn = typeof opts.testOnReturn === "boolean" ? opts.testOnReturn : poolDefaults.testOnReturn;
      this.autostart = typeof opts.autostart === "boolean" ? opts.autostart : poolDefaults.autostart;
      if (opts.acquireTimeoutMillis) {
        this.acquireTimeoutMillis = parseInt(opts.acquireTimeoutMillis, 10);
      }
      if (opts.destroyTimeoutMillis) {
        this.destroyTimeoutMillis = parseInt(opts.destroyTimeoutMillis, 10);
      }
      if (opts.maxWaitingClients !== undefined) {
        this.maxWaitingClients = parseInt(opts.maxWaitingClients, 10);
      }
      this.max = parseInt(opts.max, 10);
      this.min = parseInt(opts.min, 10);
      this.max = Math.max(isNaN(this.max) ? 1 : this.max, 1);
      this.min = Math.min(isNaN(this.min) ? 0 : this.min, this.max);
      this.evictionRunIntervalMillis = opts.evictionRunIntervalMillis || poolDefaults.evictionRunIntervalMillis;
      this.numTestsPerEvictionRun = opts.numTestsPerEvictionRun || poolDefaults.numTestsPerEvictionRun;
      this.softIdleTimeoutMillis = opts.softIdleTimeoutMillis || poolDefaults.softIdleTimeoutMillis;
      this.idleTimeoutMillis = opts.idleTimeoutMillis || poolDefaults.idleTimeoutMillis;
      this.Promise = opts.Promise != null ? opts.Promise : poolDefaults.Promise;
    }
  }
  module.exports = PoolOptions;
});

// node_modules/generic-pool/lib/Deferred.js
var require_Deferred = __commonJS((exports, module) => {
  class Deferred {
    constructor(Promise2) {
      this._state = Deferred.PENDING;
      this._resolve = undefined;
      this._reject = undefined;
      this._promise = new Promise2((resolve, reject) => {
        this._resolve = resolve;
        this._reject = reject;
      });
    }
    get state() {
      return this._state;
    }
    get promise() {
      return this._promise;
    }
    reject(reason) {
      if (this._state !== Deferred.PENDING) {
        return;
      }
      this._state = Deferred.REJECTED;
      this._reject(reason);
    }
    resolve(value) {
      if (this._state !== Deferred.PENDING) {
        return;
      }
      this._state = Deferred.FULFILLED;
      this._resolve(value);
    }
  }
  Deferred.PENDING = "PENDING";
  Deferred.FULFILLED = "FULFILLED";
  Deferred.REJECTED = "REJECTED";
  module.exports = Deferred;
});

// node_modules/generic-pool/lib/errors.js
var require_errors = __commonJS((exports, module) => {
  class ExtendableError extends Error {
    constructor(message3) {
      super(message3);
      this.name = this.constructor.name;
      this.message = message3;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message3).stack;
      }
    }
  }

  class TimeoutError extends ExtendableError {
    constructor(m) {
      super(m);
    }
  }
  module.exports = {
    TimeoutError
  };
});

// node_modules/generic-pool/lib/ResourceRequest.js
var require_ResourceRequest = __commonJS((exports, module) => {
  var Deferred = require_Deferred();
  var errors = require_errors();
  function fbind(fn, ctx) {
    return function bound() {
      return fn.apply(ctx, arguments);
    };
  }

  class ResourceRequest extends Deferred {
    constructor(ttl, Promise2) {
      super(Promise2);
      this._creationTimestamp = Date.now();
      this._timeout = null;
      if (ttl !== undefined) {
        this.setTimeout(ttl);
      }
    }
    setTimeout(delay) {
      if (this._state !== ResourceRequest.PENDING) {
        return;
      }
      const ttl = parseInt(delay, 10);
      if (isNaN(ttl) || ttl <= 0) {
        throw new Error("delay must be a positive int");
      }
      const age = Date.now() - this._creationTimestamp;
      if (this._timeout) {
        this.removeTimeout();
      }
      this._timeout = setTimeout(fbind(this._fireTimeout, this), Math.max(ttl - age, 0));
    }
    removeTimeout() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeout = null;
    }
    _fireTimeout() {
      this.reject(new errors.TimeoutError("ResourceRequest timed out"));
    }
    reject(reason) {
      this.removeTimeout();
      super.reject(reason);
    }
    resolve(value) {
      this.removeTimeout();
      super.resolve(value);
    }
  }
  module.exports = ResourceRequest;
});

// node_modules/generic-pool/lib/ResourceLoan.js
var require_ResourceLoan = __commonJS((exports, module) => {
  var Deferred = require_Deferred();

  class ResourceLoan extends Deferred {
    constructor(pooledResource, Promise2) {
      super(Promise2);
      this._creationTimestamp = Date.now();
      this.pooledResource = pooledResource;
    }
    reject() {}
  }
  module.exports = ResourceLoan;
});

// node_modules/generic-pool/lib/PooledResourceStateEnum.js
var require_PooledResourceStateEnum = __commonJS((exports, module) => {
  var PooledResourceStateEnum = {
    ALLOCATED: "ALLOCATED",
    IDLE: "IDLE",
    INVALID: "INVALID",
    RETURNING: "RETURNING",
    VALIDATION: "VALIDATION"
  };
  module.exports = PooledResourceStateEnum;
});

// node_modules/generic-pool/lib/PooledResource.js
var require_PooledResource = __commonJS((exports, module) => {
  var PooledResourceStateEnum = require_PooledResourceStateEnum();

  class PooledResource {
    constructor(resource) {
      this.creationTime = Date.now();
      this.lastReturnTime = null;
      this.lastBorrowTime = null;
      this.lastIdleTime = null;
      this.obj = resource;
      this.state = PooledResourceStateEnum.IDLE;
    }
    allocate() {
      this.lastBorrowTime = Date.now();
      this.state = PooledResourceStateEnum.ALLOCATED;
    }
    deallocate() {
      this.lastReturnTime = Date.now();
      this.state = PooledResourceStateEnum.IDLE;
    }
    invalidate() {
      this.state = PooledResourceStateEnum.INVALID;
    }
    test() {
      this.state = PooledResourceStateEnum.VALIDATION;
    }
    idle() {
      this.lastIdleTime = Date.now();
      this.state = PooledResourceStateEnum.IDLE;
    }
    returning() {
      this.state = PooledResourceStateEnum.RETURNING;
    }
  }
  module.exports = PooledResource;
});

// node_modules/generic-pool/lib/DefaultEvictor.js
var require_DefaultEvictor = __commonJS((exports, module) => {
  class DefaultEvictor {
    evict(config, pooledResource, availableObjectsCount) {
      const idleTime = Date.now() - pooledResource.lastIdleTime;
      if (config.softIdleTimeoutMillis > 0 && config.softIdleTimeoutMillis < idleTime && config.min < availableObjectsCount) {
        return true;
      }
      if (config.idleTimeoutMillis < idleTime) {
        return true;
      }
      return false;
    }
  }
  module.exports = DefaultEvictor;
});

// node_modules/generic-pool/lib/DoublyLinkedList.js
var require_DoublyLinkedList = __commonJS((exports, module) => {
  class DoublyLinkedList {
    constructor() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    insertBeginning(node) {
      if (this.head === null) {
        this.head = node;
        this.tail = node;
        node.prev = null;
        node.next = null;
        this.length++;
      } else {
        this.insertBefore(this.head, node);
      }
    }
    insertEnd(node) {
      if (this.tail === null) {
        this.insertBeginning(node);
      } else {
        this.insertAfter(this.tail, node);
      }
    }
    insertAfter(node, newNode) {
      newNode.prev = node;
      newNode.next = node.next;
      if (node.next === null) {
        this.tail = newNode;
      } else {
        node.next.prev = newNode;
      }
      node.next = newNode;
      this.length++;
    }
    insertBefore(node, newNode) {
      newNode.prev = node.prev;
      newNode.next = node;
      if (node.prev === null) {
        this.head = newNode;
      } else {
        node.prev.next = newNode;
      }
      node.prev = newNode;
      this.length++;
    }
    remove(node) {
      if (node.prev === null) {
        this.head = node.next;
      } else {
        node.prev.next = node.next;
      }
      if (node.next === null) {
        this.tail = node.prev;
      } else {
        node.next.prev = node.prev;
      }
      node.prev = null;
      node.next = null;
      this.length--;
    }
    static createNode(data) {
      return {
        prev: null,
        next: null,
        data
      };
    }
  }
  module.exports = DoublyLinkedList;
});

// node_modules/generic-pool/lib/DoublyLinkedListIterator.js
var require_DoublyLinkedListIterator = __commonJS((exports, module) => {
  class DoublyLinkedListIterator {
    constructor(doublyLinkedList, reverse) {
      this._list = doublyLinkedList;
      this._direction = reverse === true ? "prev" : "next";
      this._startPosition = reverse === true ? "tail" : "head";
      this._started = false;
      this._cursor = null;
      this._done = false;
    }
    _start() {
      this._cursor = this._list[this._startPosition];
      this._started = true;
    }
    _advanceCursor() {
      if (this._started === false) {
        this._started = true;
        this._cursor = this._list[this._startPosition];
        return;
      }
      this._cursor = this._cursor[this._direction];
    }
    reset() {
      this._done = false;
      this._started = false;
      this._cursor = null;
    }
    remove() {
      if (this._started === false || this._done === true || this._isCursorDetached()) {
        return false;
      }
      this._list.remove(this._cursor);
    }
    next() {
      if (this._done === true) {
        return { done: true };
      }
      this._advanceCursor();
      if (this._cursor === null || this._isCursorDetached()) {
        this._done = true;
        return { done: true };
      }
      return {
        value: this._cursor,
        done: false
      };
    }
    _isCursorDetached() {
      return this._cursor.prev === null && this._cursor.next === null && this._list.tail !== this._cursor && this._list.head !== this._cursor;
    }
  }
  module.exports = DoublyLinkedListIterator;
});

// node_modules/generic-pool/lib/DequeIterator.js
var require_DequeIterator = __commonJS((exports, module) => {
  var DoublyLinkedListIterator = require_DoublyLinkedListIterator();

  class DequeIterator extends DoublyLinkedListIterator {
    next() {
      const result = super.next();
      if (result.value) {
        result.value = result.value.data;
      }
      return result;
    }
  }
  module.exports = DequeIterator;
});

// node_modules/generic-pool/lib/Deque.js
var require_Deque = __commonJS((exports, module) => {
  var DoublyLinkedList = require_DoublyLinkedList();
  var DequeIterator = require_DequeIterator();

  class Deque {
    constructor() {
      this._list = new DoublyLinkedList;
    }
    shift() {
      if (this.length === 0) {
        return;
      }
      const node = this._list.head;
      this._list.remove(node);
      return node.data;
    }
    unshift(element) {
      const node = DoublyLinkedList.createNode(element);
      this._list.insertBeginning(node);
    }
    push(element) {
      const node = DoublyLinkedList.createNode(element);
      this._list.insertEnd(node);
    }
    pop() {
      if (this.length === 0) {
        return;
      }
      const node = this._list.tail;
      this._list.remove(node);
      return node.data;
    }
    [Symbol.iterator]() {
      return new DequeIterator(this._list);
    }
    iterator() {
      return new DequeIterator(this._list);
    }
    reverseIterator() {
      return new DequeIterator(this._list, true);
    }
    get head() {
      if (this.length === 0) {
        return;
      }
      const node = this._list.head;
      return node.data;
    }
    get tail() {
      if (this.length === 0) {
        return;
      }
      const node = this._list.tail;
      return node.data;
    }
    get length() {
      return this._list.length;
    }
  }
  module.exports = Deque;
});

// node_modules/generic-pool/lib/Queue.js
var require_Queue = __commonJS((exports, module) => {
  var DoublyLinkedList = require_DoublyLinkedList();
  var Deque = require_Deque();

  class Queue extends Deque {
    push(resourceRequest) {
      const node = DoublyLinkedList.createNode(resourceRequest);
      resourceRequest.promise.catch(this._createTimeoutRejectionHandler(node));
      this._list.insertEnd(node);
    }
    _createTimeoutRejectionHandler(node) {
      return (reason) => {
        if (reason.name === "TimeoutError") {
          this._list.remove(node);
        }
      };
    }
  }
  module.exports = Queue;
});

// node_modules/generic-pool/lib/PriorityQueue.js
var require_PriorityQueue = __commonJS((exports, module) => {
  var Queue = require_Queue();

  class PriorityQueue {
    constructor(size) {
      this._size = Math.max(+size | 0, 1);
      this._slots = [];
      for (let i = 0;i < this._size; i++) {
        this._slots.push(new Queue);
      }
    }
    get length() {
      let _length = 0;
      for (let i = 0, slots = this._slots.length;i < slots; i++) {
        _length += this._slots[i].length;
      }
      return _length;
    }
    enqueue(obj, priority) {
      priority = priority && +priority | 0 || 0;
      if (priority) {
        if (priority < 0 || priority >= this._size) {
          priority = this._size - 1;
        }
      }
      this._slots[priority].push(obj);
    }
    dequeue() {
      for (let i = 0, sl = this._slots.length;i < sl; i += 1) {
        if (this._slots[i].length) {
          return this._slots[i].shift();
        }
      }
      return;
    }
    get head() {
      for (let i = 0, sl = this._slots.length;i < sl; i += 1) {
        if (this._slots[i].length > 0) {
          return this._slots[i].head;
        }
      }
      return;
    }
    get tail() {
      for (let i = this._slots.length - 1;i >= 0; i--) {
        if (this._slots[i].length > 0) {
          return this._slots[i].tail;
        }
      }
      return;
    }
  }
  module.exports = PriorityQueue;
});

// node_modules/generic-pool/lib/utils.js
var require_utils = __commonJS((exports) => {
  function noop() {}
  exports.reflector = function(promise) {
    return promise.then(noop, noop);
  };
});

// node_modules/generic-pool/lib/Pool.js
var require_Pool = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var factoryValidator = require_factoryValidator();
  var PoolOptions = require_PoolOptions();
  var ResourceRequest = require_ResourceRequest();
  var ResourceLoan = require_ResourceLoan();
  var PooledResource = require_PooledResource();
  var DefaultEvictor = require_DefaultEvictor();
  var Deque = require_Deque();
  var Deferred = require_Deferred();
  var PriorityQueue = require_PriorityQueue();
  var DequeIterator = require_DequeIterator();
  var reflector = require_utils().reflector;
  var FACTORY_CREATE_ERROR = "factoryCreateError";
  var FACTORY_DESTROY_ERROR = "factoryDestroyError";

  class Pool extends EventEmitter {
    constructor(Evictor, Deque2, PriorityQueue2, factory, options) {
      super();
      factoryValidator(factory);
      this._config = new PoolOptions(options);
      this._Promise = this._config.Promise;
      this._factory = factory;
      this._draining = false;
      this._started = false;
      this._waitingClientsQueue = new PriorityQueue2(this._config.priorityRange);
      this._factoryCreateOperations = new Set;
      this._factoryDestroyOperations = new Set;
      this._availableObjects = new Deque2;
      this._testOnBorrowResources = new Set;
      this._testOnReturnResources = new Set;
      this._validationOperations = new Set;
      this._allObjects = new Set;
      this._resourceLoans = new Map;
      this._evictionIterator = this._availableObjects.iterator();
      this._evictor = new Evictor;
      this._scheduledEviction = null;
      if (this._config.autostart === true) {
        this.start();
      }
    }
    _destroy(pooledResource) {
      pooledResource.invalidate();
      this._allObjects.delete(pooledResource);
      const destroyPromise = this._factory.destroy(pooledResource.obj);
      const wrappedDestroyPromise = this._config.destroyTimeoutMillis ? this._Promise.resolve(this._applyDestroyTimeout(destroyPromise)) : this._Promise.resolve(destroyPromise);
      this._trackOperation(wrappedDestroyPromise, this._factoryDestroyOperations).catch((reason) => {
        this.emit(FACTORY_DESTROY_ERROR, reason);
      });
      this._ensureMinimum();
    }
    _applyDestroyTimeout(promise) {
      const timeoutPromise = new this._Promise((resolve, reject) => {
        setTimeout(() => {
          reject(new Error("destroy timed out"));
        }, this._config.destroyTimeoutMillis).unref();
      });
      return this._Promise.race([timeoutPromise, promise]);
    }
    _testOnBorrow() {
      if (this._availableObjects.length < 1) {
        return false;
      }
      const pooledResource = this._availableObjects.shift();
      pooledResource.test();
      this._testOnBorrowResources.add(pooledResource);
      const validationPromise = this._factory.validate(pooledResource.obj);
      const wrappedValidationPromise = this._Promise.resolve(validationPromise);
      this._trackOperation(wrappedValidationPromise, this._validationOperations).then((isValid) => {
        this._testOnBorrowResources.delete(pooledResource);
        if (isValid === false) {
          pooledResource.invalidate();
          this._destroy(pooledResource);
          this._dispense();
          return;
        }
        this._dispatchPooledResourceToNextWaitingClient(pooledResource);
      });
      return true;
    }
    _dispatchResource() {
      if (this._availableObjects.length < 1) {
        return false;
      }
      const pooledResource = this._availableObjects.shift();
      this._dispatchPooledResourceToNextWaitingClient(pooledResource);
      return false;
    }
    _dispense() {
      const numWaitingClients = this._waitingClientsQueue.length;
      if (numWaitingClients < 1) {
        return;
      }
      const resourceShortfall = numWaitingClients - this._potentiallyAllocableResourceCount;
      const actualNumberOfResourcesToCreate = Math.min(this.spareResourceCapacity, resourceShortfall);
      for (let i = 0;actualNumberOfResourcesToCreate > i; i++) {
        this._createResource();
      }
      if (this._config.testOnBorrow === true) {
        const desiredNumberOfResourcesToMoveIntoTest = numWaitingClients - this._testOnBorrowResources.size;
        const actualNumberOfResourcesToMoveIntoTest = Math.min(this._availableObjects.length, desiredNumberOfResourcesToMoveIntoTest);
        for (let i = 0;actualNumberOfResourcesToMoveIntoTest > i; i++) {
          this._testOnBorrow();
        }
      }
      if (this._config.testOnBorrow === false) {
        const actualNumberOfResourcesToDispatch = Math.min(this._availableObjects.length, numWaitingClients);
        for (let i = 0;actualNumberOfResourcesToDispatch > i; i++) {
          this._dispatchResource();
        }
      }
    }
    _dispatchPooledResourceToNextWaitingClient(pooledResource) {
      const clientResourceRequest = this._waitingClientsQueue.dequeue();
      if (clientResourceRequest === undefined || clientResourceRequest.state !== Deferred.PENDING) {
        this._addPooledResourceToAvailableObjects(pooledResource);
        return false;
      }
      const loan = new ResourceLoan(pooledResource, this._Promise);
      this._resourceLoans.set(pooledResource.obj, loan);
      pooledResource.allocate();
      clientResourceRequest.resolve(pooledResource.obj);
      return true;
    }
    _trackOperation(operation, set) {
      set.add(operation);
      return operation.then((v) => {
        set.delete(operation);
        return this._Promise.resolve(v);
      }, (e) => {
        set.delete(operation);
        return this._Promise.reject(e);
      });
    }
    _createResource() {
      const factoryPromise = this._factory.create();
      const wrappedFactoryPromise = this._Promise.resolve(factoryPromise).then((resource) => {
        const pooledResource = new PooledResource(resource);
        this._allObjects.add(pooledResource);
        this._addPooledResourceToAvailableObjects(pooledResource);
      });
      this._trackOperation(wrappedFactoryPromise, this._factoryCreateOperations).then(() => {
        this._dispense();
        return null;
      }).catch((reason) => {
        this.emit(FACTORY_CREATE_ERROR, reason);
        this._dispense();
      });
    }
    _ensureMinimum() {
      if (this._draining === true) {
        return;
      }
      const minShortfall = this._config.min - this._count;
      for (let i = 0;i < minShortfall; i++) {
        this._createResource();
      }
    }
    _evict() {
      const testsToRun = Math.min(this._config.numTestsPerEvictionRun, this._availableObjects.length);
      const evictionConfig = {
        softIdleTimeoutMillis: this._config.softIdleTimeoutMillis,
        idleTimeoutMillis: this._config.idleTimeoutMillis,
        min: this._config.min
      };
      for (let testsHaveRun = 0;testsHaveRun < testsToRun; ) {
        const iterationResult = this._evictionIterator.next();
        if (iterationResult.done === true && this._availableObjects.length < 1) {
          this._evictionIterator.reset();
          return;
        }
        if (iterationResult.done === true && this._availableObjects.length > 0) {
          this._evictionIterator.reset();
          continue;
        }
        const resource = iterationResult.value;
        const shouldEvict = this._evictor.evict(evictionConfig, resource, this._availableObjects.length);
        testsHaveRun++;
        if (shouldEvict === true) {
          this._evictionIterator.remove();
          this._destroy(resource);
        }
      }
    }
    _scheduleEvictorRun() {
      if (this._config.evictionRunIntervalMillis > 0) {
        this._scheduledEviction = setTimeout(() => {
          this._evict();
          this._scheduleEvictorRun();
        }, this._config.evictionRunIntervalMillis).unref();
      }
    }
    _descheduleEvictorRun() {
      if (this._scheduledEviction) {
        clearTimeout(this._scheduledEviction);
      }
      this._scheduledEviction = null;
    }
    start() {
      if (this._draining === true) {
        return;
      }
      if (this._started === true) {
        return;
      }
      this._started = true;
      this._scheduleEvictorRun();
      this._ensureMinimum();
    }
    acquire(priority) {
      if (this._started === false && this._config.autostart === false) {
        this.start();
      }
      if (this._draining) {
        return this._Promise.reject(new Error("pool is draining and cannot accept work"));
      }
      if (this.spareResourceCapacity < 1 && this._availableObjects.length < 1 && this._config.maxWaitingClients !== undefined && this._waitingClientsQueue.length >= this._config.maxWaitingClients) {
        return this._Promise.reject(new Error("max waitingClients count exceeded"));
      }
      const resourceRequest = new ResourceRequest(this._config.acquireTimeoutMillis, this._Promise);
      this._waitingClientsQueue.enqueue(resourceRequest, priority);
      this._dispense();
      return resourceRequest.promise;
    }
    use(fn, priority) {
      return this.acquire(priority).then((resource) => {
        return fn(resource).then((result) => {
          this.release(resource);
          return result;
        }, (err) => {
          this.destroy(resource);
          throw err;
        });
      });
    }
    isBorrowedResource(resource) {
      return this._resourceLoans.has(resource);
    }
    release(resource) {
      const loan = this._resourceLoans.get(resource);
      if (loan === undefined) {
        return this._Promise.reject(new Error("Resource not currently part of this pool"));
      }
      this._resourceLoans.delete(resource);
      loan.resolve();
      const pooledResource = loan.pooledResource;
      pooledResource.deallocate();
      this._addPooledResourceToAvailableObjects(pooledResource);
      this._dispense();
      return this._Promise.resolve();
    }
    destroy(resource) {
      const loan = this._resourceLoans.get(resource);
      if (loan === undefined) {
        return this._Promise.reject(new Error("Resource not currently part of this pool"));
      }
      this._resourceLoans.delete(resource);
      loan.resolve();
      const pooledResource = loan.pooledResource;
      pooledResource.deallocate();
      this._destroy(pooledResource);
      this._dispense();
      return this._Promise.resolve();
    }
    _addPooledResourceToAvailableObjects(pooledResource) {
      pooledResource.idle();
      if (this._config.fifo === true) {
        this._availableObjects.push(pooledResource);
      } else {
        this._availableObjects.unshift(pooledResource);
      }
    }
    drain() {
      this._draining = true;
      return this.__allResourceRequestsSettled().then(() => {
        return this.__allResourcesReturned();
      }).then(() => {
        this._descheduleEvictorRun();
      });
    }
    __allResourceRequestsSettled() {
      if (this._waitingClientsQueue.length > 0) {
        return reflector(this._waitingClientsQueue.tail.promise);
      }
      return this._Promise.resolve();
    }
    __allResourcesReturned() {
      const ps = Array.from(this._resourceLoans.values()).map((loan) => loan.promise).map(reflector);
      return this._Promise.all(ps);
    }
    clear() {
      const reflectedCreatePromises = Array.from(this._factoryCreateOperations).map(reflector);
      return this._Promise.all(reflectedCreatePromises).then(() => {
        for (const resource of this._availableObjects) {
          this._destroy(resource);
        }
        const reflectedDestroyPromises = Array.from(this._factoryDestroyOperations).map(reflector);
        return reflector(this._Promise.all(reflectedDestroyPromises));
      });
    }
    ready() {
      return new this._Promise((resolve) => {
        const isReady = () => {
          if (this.available >= this.min) {
            resolve();
          } else {
            setTimeout(isReady, 100);
          }
        };
        isReady();
      });
    }
    get _potentiallyAllocableResourceCount() {
      return this._availableObjects.length + this._testOnBorrowResources.size + this._testOnReturnResources.size + this._factoryCreateOperations.size;
    }
    get _count() {
      return this._allObjects.size + this._factoryCreateOperations.size;
    }
    get spareResourceCapacity() {
      return this._config.max - (this._allObjects.size + this._factoryCreateOperations.size);
    }
    get size() {
      return this._count;
    }
    get available() {
      return this._availableObjects.length;
    }
    get borrowed() {
      return this._resourceLoans.size;
    }
    get pending() {
      return this._waitingClientsQueue.length;
    }
    get max() {
      return this._config.max;
    }
    get min() {
      return this._config.min;
    }
  }
  module.exports = Pool;
});

// node_modules/generic-pool/index.js
var require_generic_pool = __commonJS((exports, module) => {
  var Pool = require_Pool();
  var Deque = require_Deque();
  var PriorityQueue = require_PriorityQueue();
  var DefaultEvictor = require_DefaultEvictor();
  module.exports = {
    Pool,
    Deque,
    PriorityQueue,
    DefaultEvictor,
    createPool: function(factory, config) {
      return new Pool(DefaultEvictor, Deque, PriorityQueue, factory, config);
    }
  };
});

// node_modules/@iggy.rs/sdk/dist/wire/error.code.js
var translateErrorCode = (code) => {
  switch (code.toString()) {
    case "1":
      return "error";
    case "2":
      return "invalid_configuration";
    case "3":
      return "invalid_command";
    case "4":
      return "invalid_format";
    case "5":
      return "feature_unavailable";
    case "10":
      return "cannot_create_base_directory";
    case "20":
      return "resource_not_found";
    case "21":
      return "cannot_load_resource";
    case "22":
      return "cannot_save_resource";
    case "23":
      return "cannot_delete_resource";
    case "24":
      return "cannot_serialize_resource";
    case "25":
      return "cannot_deserialize_resource";
    case "40":
      return "unauthenticated";
    case "41":
      return "unauthorized";
    case "42":
      return "invalid_credentials";
    case "43":
      return "invalid_username";
    case "44":
      return "invalid_password";
    case "51":
      return "not_connected";
    case "52":
      return "request_error";
    case "60":
      return "invalid_encryption_key";
    case "61":
      return "cannot_encrypt_data";
    case "62":
      return "cannot_decrypt_data";
    case "100":
      return "client_not_found";
    case "101":
      return "invalid_client_id";
    case "200":
      return "io_error";
    case "201":
      return "write_error";
    case "202":
      return "cannot_parse_utf8";
    case "203":
      return "cannot_parse_int";
    case "204":
      return "cannot_parse_slice";
    case "300":
      return "http_response_error";
    case "301":
      return "request_middleware_error";
    case "302":
      return "cannot_create_endpoint";
    case "303":
      return "cannot_parse_url";
    case "304":
      return "invalid_response";
    case "305":
      return "empty_response";
    case "306":
      return "cannot_parse_address";
    case "307":
      return "read_error";
    case "308":
      return "connection_error";
    case "309":
      return "read_to_end_error";
    case "1000":
      return "cannot_create_streams_directory";
    case "1001":
      return "cannot_create_stream_directory";
    case "1002":
      return "cannot_create_stream_info";
    case "1003":
      return "cannot_update_stream_info";
    case "1004":
      return "cannot_open_stream_info";
    case "1005":
      return "cannot_read_stream_info";
    case "1006":
      return "cannot_create_stream";
    case "1007":
      return "cannot_delete_stream";
    case "1008":
      return "cannot_delete_stream_directory";
    case "1009":
      return "stream_id_not_found";
    case "1010":
      return "stream_name_not_found";
    case "1011":
      return "stream_id_already_exists";
    case "1012":
      return "stream_name_already_exists";
    case "1013":
      return "invalid_stream_name";
    case "1014":
      return "invalid_stream_id";
    case "1015":
      return "cannot_read_streams";
    case "2000":
      return "cannot_create_topics_directory";
    case "2001":
      return "cannot_create_topic_directory";
    case "2002":
      return "cannot_create_topic_info";
    case "2003":
      return "cannot_update_topic_info";
    case "2004":
      return "cannot_open_topic_info";
    case "2005":
      return "cannot_read_topic_info";
    case "2006":
      return "cannot_create_topic";
    case "2007":
      return "cannot_delete_topic";
    case "2008":
      return "cannot_delete_topic_directory";
    case "2009":
      return "cannot_poll_topic";
    case "2010":
      return "topic_id_not_found";
    case "2011":
      return "topic_name_not_found";
    case "2012":
      return "topic_id_already_exists";
    case "2013":
      return "topic_name_already_exists";
    case "2014":
      return "invalid_topic_name";
    case "2015":
      return "too_many_partitions";
    case "2016":
      return "invalid_topic_id";
    case "2017":
      return "cannot_read_topics";
    case "3000":
      return "cannot_create_partition";
    case "3001":
      return "cannot_create_partitions_directory";
    case "3002":
      return "cannot_create_partition_directory";
    case "3003":
      return "cannot_open_partition_log_file";
    case "3004":
      return "cannot_read_partitions";
    case "3005":
      return "cannot_delete_partition";
    case "3006":
      return "cannot_delete_partition_directory";
    case "3007":
      return "partition_not_found";
    case "3008":
      return "no_partitions";
    case "4000":
      return "segment_not_found";
    case "4001":
      return "segment_closed";
    case "4002":
      return "invalid_segment_size";
    case "4003":
      return "cannot_create_segment_log_file";
    case "4004":
      return "cannot_create_segment_index_file";
    case "4005":
      return "cannot_create_segment_time_index_file";
    case "4006":
      return "cannot_save_messages_to_segment";
    case "4007":
      return "cannot_save_index_to_segment";
    case "4008":
      return "cannot_save_time_index_to_segment";
    case "4009":
      return "invalid_messages_count";
    case "4010":
      return "cannot_append_message";
    case "4011":
      return "cannot_read_message";
    case "4012":
      return "cannot_read_message_id";
    case "4013":
      return "cannot_read_message_state";
    case "4014":
      return "cannot_read_message_timestamp";
    case "4015":
      return "cannot_read_headers_length";
    case "4016":
      return "cannot_read_headers_payload";
    case "4017":
      return "too_big_headers_payload";
    case "4018":
      return "invalid_header_key";
    case "4019":
      return "invalid_header_value";
    case "4020":
      return "cannot_read_message_length";
    case "4021":
      return "cannot_read_message_payload";
    case "4022":
      return "too_big_message_payload";
    case "4023":
      return "too_many_messages";
    case "4024":
      return "empty_message_payload";
    case "4025":
      return "invalid_message_payload_length";
    case "4026":
      return "cannot_read_message_checksum";
    case "4027":
      return "invalid_message_checksum";
    case "4028":
      return "invalid_key_value_length";
    case "4100":
      return "invalid_offset";
    case "4101":
      return "cannot_read_consumer_offsets";
    case "5000":
      return "consumer_group_not_found";
    case "5001":
      return "consumer_group_already_exists";
    case "5002":
      return "consumer_group_member_not_found";
    case "5003":
      return "invalid_consumer_group_id";
    case "5004":
      return "cannot_create_consumer_groups_directory";
    case "5005":
      return "cannot_read_consumer_groups";
    case "5006":
      return "cannot_create_consumer_group_info";
    case "5007":
      return "cannot_delete_consumer_group_info";
    default:
      return "error";
  }
};

// node_modules/@iggy.rs/sdk/dist/wire/error.utils.js
var responseError = (cmdCode, errCode) => new Error(`command: { code: ${cmdCode}, name: ${translateCommandCode(cmdCode)} } ` + `error: {code: ${errCode}, message: ${translateErrorCode(errCode)} }`);
var init_error_utils = __esm(() => {
  init_command_code();
});

// node_modules/@iggy.rs/sdk/dist/client/client.socket.js
var { Duplex } = __require("node:stream");
var wrapSocket = (socket) => new Promise((resolve, reject) => {
  const responseStream = new CommandResponseStream(socket);
  socket.on("error", (err) => {
    console.error("RESPONSESTREAM ERROR", err);
    reject(err);
  });
  socket.once("connect", () => {
    debug("responseStream.connect event");
    resolve(responseStream);
  });
  socket.on("close", () => {
    debug("socket#close");
    reject();
  });
  socket.on("end", () => {
    console.error("socket#end");
    reject();
  });
}), CommandResponseStream;
var init_client_socket = __esm(() => {
  init_client_utils();
  init_error_utils();
  init_login_command();
  init_login_with_token_command();
  init_client_debug();
  CommandResponseStream = class CommandResponseStream extends Duplex {
    _socket;
    _readPaused;
    _execQueue;
    busy;
    isAuthenticated;
    userId;
    constructor(socket) {
      super();
      this._socket = this._wrapSocket(socket);
      this._readPaused = false;
      this.busy = false;
      this._execQueue = [];
      this.isAuthenticated = false;
    }
    _destroy() {
      this._socket.destroy();
    }
    _read(size) {
      this._readPaused = false;
      debug("stream#_read", size);
      setImmediate(this._onReadable.bind(this));
    }
    _write(chunk, encoding, cb) {
      return this._socket.write(chunk, encoding, cb);
    }
    writeCommand(command, payload) {
      const cmd = serializeCommand(command, payload);
      return this._socket.write(cmd);
    }
    sendCommand(command, payload, handleResponse2 = true) {
      return new Promise((resolve, reject) => {
        this._execQueue.push({ command, payload, resolve, reject });
        this._processQueue(handleResponse2);
      });
    }
    async authenticate(creds) {
      const r = "token" in creds ? await this._authWithToken(creds) : await this._authWithPassword(creds);
      this.isAuthenticated = true;
      this.userId = r.userId;
      return this.isAuthenticated;
    }
    async _authWithPassword(creds) {
      const pl = LOGIN.serialize(creds);
      const logr = await this.sendCommand(LOGIN.code, pl);
      return LOGIN.deserialize(logr);
    }
    async _authWithToken(creds) {
      const pl = LOGIN_WITH_TOKEN.serialize(creds);
      const logr = await this.sendCommand(LOGIN_WITH_TOKEN.code, pl);
      return LOGIN_WITH_TOKEN.deserialize(logr);
    }
    async _processQueue(handleResponse2 = true) {
      if (this.busy)
        return;
      this.busy = true;
      while (this._execQueue.length > 0) {
        const next = this._execQueue.shift();
        if (!next)
          break;
        const { command, payload, resolve, reject } = next;
        try {
          resolve(await this._processNext(command, payload, handleResponse2));
        } catch (err) {
          reject(err);
        }
      }
      this.busy = false;
      this.emit("finishQueue");
    }
    _processNext(command, payload, handleResp = true) {
      debug("==> writeCommand", this.writeCommand(command, payload));
      return new Promise((resolve, reject) => {
        const errCb = (err) => reject(err);
        this.once("error", errCb);
        this.once("data", (resp) => {
          this.removeListener("error", errCb);
          if (!handleResp)
            return resolve(resp);
          const r = handleResponse(resp);
          if (r.status !== 0) {
            return reject(responseError(command, r.status));
          }
          return resolve(r);
        });
      });
    }
    getReadStream() {
      return this;
    }
    _wrapSocket(socket) {
      socket.on("close", (hadError) => this.emit("close", hadError));
      socket.on("connect", () => this.emit("connect"));
      socket.on("drain", () => this.emit("drain"));
      socket.on("end", () => this.emit("end"));
      socket.on("error", (err) => this.emit("error", err));
      socket.on("lookup", (err, address, family, host) => this.emit("lookup", err, address, family, host));
      socket.on("ready", () => this.emit("ready"));
      socket.on("timeout", () => this.emit("timeout"));
      socket.on("readable", () => this._onReadable());
      return socket;
    }
    _onReadable() {
      while (!this._readPaused) {
        const head = this._socket.read(8);
        if (!head || head.length === 0)
          return;
        if (head.length < 8) {
          this._socket.unshift(head);
          return;
        }
        const responseSize = head.readUInt32LE(4);
        if (responseSize === 0) {
          this.push(head);
          return;
        }
        const payload = this._socket.read(responseSize);
        debug("payload", payload, responseSize, head.readUInt32LE(0));
        if (!payload) {
          this._socket.unshift(head);
          return;
        }
        if (payload.length < responseSize) {
          this._socket.unshift(Buffer.concat([head, payload]));
          return;
        }
        const pushOk = this.push(Buffer.concat([head, payload]));
        if (!pushOk)
          this._readPaused = true;
      }
    }
  };
});

// node_modules/@iggy.rs/sdk/dist/client/tcp.client.js
var { createConnection } = __require("node:net");
var createTcpSocket = (options) => {
  const socket = createConnection(options);
  return wrapSocket(socket);
}, TcpClient = ({ host, port, keepAlive = true }) => createTcpSocket({ host, port, keepAlive });
var init_tcp_client = __esm(() => {
  init_client_socket();
});

// node_modules/@iggy.rs/sdk/dist/client/tls.client.js
var { connect } = __require("node:tls");
var createTlsSocket = (port, options) => {
  const socket = connect(port, options);
  socket.setEncoding("utf8");
  return wrapSocket(socket);
}, TlsClient = ({ port, ...options }) => {
  return createTlsSocket(port, options);
};
var init_tls_client = __esm(() => {
  init_client_socket();
});

// node_modules/@iggy.rs/sdk/dist/client/client.js
var import_generic_pool, rawClientGetter = (config) => {
  const { transport, options } = config;
  switch (transport) {
    case "TLS":
      return TlsClient(options);
    case "TCP":
    default:
      return TcpClient(options);
  }
}, createPoolFactory = (config) => ({
  create: function() {
    return rawClientGetter(config);
  },
  destroy: async function(client2) {
    return client2.destroy();
  }
}), Client, SingleClient, SimpleClient;
var init_client2 = __esm(() => {
  init_command_set();
  init_tcp_client();
  init_tls_client();
  init_client_debug();
  import_generic_pool = __toESM(require_generic_pool(), 1);
  Client = class Client extends CommandAPI {
    _config;
    _pool;
    destroy;
    constructor(config) {
      const min = config.poolSize?.min || 1;
      const max = config.poolSize?.max || 4;
      const pool = import_generic_pool.createPool(createPoolFactory(config), { min, max });
      const getFromPool = async () => {
        const c = await pool.acquire();
        if (!c.isAuthenticated)
          await c.authenticate(config.credentials);
        debug("client acquired from pool. pool size is", pool.size);
        c.once("finishQueue", () => {
          pool.release(c);
          debug("client released to pool. pool size is", pool.size);
        });
        return c;
      };
      super(getFromPool);
      this._config = config;
      this._pool = pool;
      this.destroy = async () => {
        debug("destroying client pool. pool size is", pool.size);
        await this._pool.drain();
        await this._pool.clear();
        debug("destroyed client pool. pool size is", pool.size);
      };
    }
  };
  SingleClient = class SingleClient extends CommandAPI {
    _config;
    destroy;
    constructor(config) {
      const cliP = rawClientGetter(config);
      const init = async () => {
        const c = await cliP;
        if (!c.isAuthenticated)
          await c.authenticate(config.credentials);
        return c;
      };
      super(init);
      this._config = config;
      this.destroy = async () => {
        const s = await this.clientProvider();
        s.destroy();
      };
    }
  };
  SimpleClient = class SimpleClient extends CommandAPI {
    constructor(client2) {
      super(() => Promise.resolve(client2));
    }
  };
});

// node_modules/@iggy.rs/sdk/dist/client/client.type.js
var Transports;
var init_client_type = __esm(() => {
  Transports = ["TCP", "TLS"];
});

// node_modules/@iggy.rs/sdk/dist/client/index.js
var init_client3 = __esm(() => {
  init_client2();
  init_tcp_client();
  init_tls_client();
  init_client_utils();
  init_client_socket();
  init_client_type();
});

// node_modules/@iggy.rs/sdk/dist/stream/consumer-stream.js
var { Readable, pipeline, PassThrough } = __require("node:stream");
async function* genAutoCommitedPoll(c, poll, interval = 1000) {
  const state = new Map;
  while (true) {
    const r = await c.message.poll(poll);
    yield r;
    const k = `${r.partitionId}`;
    let part = state.get(k) || 0;
    part = r.messageCount;
    state.set(k, part);
    if (Array.from(state).every(([, last]) => last === 0)) {
      await wait(interval);
    }
  }
}
async function* genPoll(c, poll) {
  const pl = POLL_MESSAGES.serialize(poll);
  yield await c.sendCommand(POLL_MESSAGES.code, pl, false);
}
var wait = (interval, cb) => new Promise((resolve) => {
  setTimeout(() => resolve(cb ? cb() : undefined), interval);
}), singleConsumerStream = (config) => async (poll) => {
  const c = await rawClientGetter(config);
  if (!c.isAuthenticated)
    await c.authenticate(config.credentials);
  const ps = Readable.from(genPoll(c, poll), { objectMode: true });
  return pipeline(ps, new PassThrough({ objectMode: true }), (err) => console.error("pipeline error", err));
}, groupConsumerStream = (config) => async function groupConsumerStream2({ groupId, streamId, topicId, pollingStrategy, count, interval = 1000, autocommit = true }) {
  const c = await rawClientGetter(config);
  const s = new SimpleClient(c);
  if (!c.isAuthenticated)
    await c.authenticate(config.credentials);
  try {
    await s.group.get({ streamId, topicId, groupId });
  } catch (err) {
    await s.group.create({ streamId, topicId, groupId, name: `auto-${groupId}` });
  }
  await s.group.join({ streamId, topicId, groupId });
  const poll = {
    streamId,
    topicId,
    consumer: { kind: ConsumerKind.Group, id: groupId },
    partitionId: 0,
    pollingStrategy,
    count,
    autocommit
  };
  const ps = Readable.from(genAutoCommitedPoll(s, poll, interval), { objectMode: true });
  return ps;
};
var init_consumer_stream = __esm(() => {
  init_client2();
  init_poll_messages_command();
  init_wire();
});

// node_modules/@iggy.rs/sdk/dist/stream/index.js
var init_stream2 = __esm(() => {
  init_consumer_stream();
});

// node_modules/@iggy.rs/sdk/dist/index.js
var exports_dist = {};
__export(exports_dist, {
  wrapSocket: () => wrapSocket,
  singleConsumerStream: () => singleConsumerStream,
  serializeCommand: () => serializeCommand,
  handleResponseTransform: () => handleResponseTransform,
  handleResponse: () => handleResponse,
  groupConsumerStream: () => groupConsumerStream,
  deserializeVoidResponse: () => deserializeVoidResponse,
  Transports: () => Transports,
  TlsClient: () => TlsClient,
  TcpClient: () => TcpClient,
  SingleClient: () => SingleClient,
  SimpleClient: () => SimpleClient,
  PollingStrategy: () => PollingStrategy,
  Partitioning: () => Partitioning,
  HeaderValue: () => HeaderValue,
  ConsumerKind: () => ConsumerKind,
  CommandResponseStream: () => CommandResponseStream,
  Client: () => Client
});
var init_dist = __esm(() => {
  init_wire();
  init_client3();
  init_stream2();
});

// node_modules/unleash-client/lib/events.js
var require_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnleashEvents = undefined;
  exports.createImpressionEvent = createImpressionEvent;
  var UnleashEvents;
  (function(UnleashEvents2) {
    UnleashEvents2["Ready"] = "ready";
    UnleashEvents2["Error"] = "error";
    UnleashEvents2["Warn"] = "warn";
    UnleashEvents2["Unchanged"] = "unchanged";
    UnleashEvents2["Changed"] = "changed";
    UnleashEvents2["Synchronized"] = "synchronized";
    UnleashEvents2["Count"] = "count";
    UnleashEvents2["CountVariant"] = "countVariant";
    UnleashEvents2["Sent"] = "sent";
    UnleashEvents2["Registered"] = "registered";
    UnleashEvents2["Impression"] = "impression";
    UnleashEvents2["Mode"] = "mode";
  })(UnleashEvents || (exports.UnleashEvents = UnleashEvents = {}));
  function createImpressionEvent(evt) {
    return evt;
  }
});

// node_modules/unleash-client/lib/repository/storage-provider-in-mem.js
var require_storage_provider_in_mem = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class InMemStorageProvider {
    store = new Map;
    async set(key, data) {
      this.store.set(key, data);
      return Promise.resolve();
    }
    async get(key) {
      return Promise.resolve(this.store.get(key));
    }
  }
  exports.default = InMemStorageProvider;
});

// node_modules/murmurhash3js/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS((exports, module) => {
  (function(root, undefined2) {
    var library = {
      version: "3.0.1",
      x86: {},
      x64: {}
    };
    function _x86Multiply(m, n) {
      return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
    }
    function _x86Rotl(m, n) {
      return m << n | m >>> 32 - n;
    }
    function _x86Fmix(h) {
      h ^= h >>> 16;
      h = _x86Multiply(h, 2246822507);
      h ^= h >>> 13;
      h = _x86Multiply(h, 3266489909);
      h ^= h >>> 16;
      return h;
    }
    function _x64Add(m, n) {
      m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
      n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m[3] + n[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m[2] + n[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m[1] + n[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m[0] + n[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Multiply(m, n) {
      m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
      n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m[3] * n[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m[2] * n[3];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[2] += m[3] * n[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m[1] * n[3];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m[2] * n[2];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m[3] * n[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Rotl(m, n) {
      n %= 64;
      if (n === 32) {
        return [m[1], m[0]];
      } else if (n < 32) {
        return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
      } else {
        n -= 32;
        return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
      }
    }
    function _x64LeftShift(m, n) {
      n %= 64;
      if (n === 0) {
        return m;
      } else if (n < 32) {
        return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
      } else {
        return [m[1] << n - 32, 0];
      }
    }
    function _x64Xor(m, n) {
      return [m[0] ^ n[0], m[1] ^ n[1]];
    }
    function _x64Fmix(h) {
      h = _x64Xor(h, [0, h[0] >>> 1]);
      h = _x64Multiply(h, [4283543511, 3981806797]);
      h = _x64Xor(h, [0, h[0] >>> 1]);
      h = _x64Multiply(h, [3301882366, 444984403]);
      h = _x64Xor(h, [0, h[0] >>> 1]);
      return h;
    }
    library.x86.hash32 = function(key, seed) {
      key = key || "";
      seed = seed || 0;
      var remainder = key.length % 4;
      var bytes = key.length - remainder;
      var h1 = seed;
      var k1 = 0;
      var c1 = 3432918353;
      var c2 = 461845907;
      for (var i = 0;i < bytes; i = i + 4) {
        k1 = key.charCodeAt(i) & 255 | (key.charCodeAt(i + 1) & 255) << 8 | (key.charCodeAt(i + 2) & 255) << 16 | (key.charCodeAt(i + 3) & 255) << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 13);
        h1 = _x86Multiply(h1, 5) + 3864292196;
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= (key.charCodeAt(i + 2) & 255) << 16;
        case 2:
          k1 ^= (key.charCodeAt(i + 1) & 255) << 8;
        case 1:
          k1 ^= key.charCodeAt(i) & 255;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= key.length;
      h1 = _x86Fmix(h1);
      return h1 >>> 0;
    };
    library.x86.hash128 = function(key, seed) {
      key = key || "";
      seed = seed || 0;
      var remainder = key.length % 16;
      var bytes = key.length - remainder;
      var h1 = seed;
      var h2 = seed;
      var h3 = seed;
      var h4 = seed;
      var k1 = 0;
      var k2 = 0;
      var k3 = 0;
      var k4 = 0;
      var c1 = 597399067;
      var c2 = 2869860233;
      var c3 = 951274213;
      var c4 = 2716044179;
      for (var i = 0;i < bytes; i = i + 16) {
        k1 = key.charCodeAt(i) & 255 | (key.charCodeAt(i + 1) & 255) << 8 | (key.charCodeAt(i + 2) & 255) << 16 | (key.charCodeAt(i + 3) & 255) << 24;
        k2 = key.charCodeAt(i + 4) & 255 | (key.charCodeAt(i + 5) & 255) << 8 | (key.charCodeAt(i + 6) & 255) << 16 | (key.charCodeAt(i + 7) & 255) << 24;
        k3 = key.charCodeAt(i + 8) & 255 | (key.charCodeAt(i + 9) & 255) << 8 | (key.charCodeAt(i + 10) & 255) << 16 | (key.charCodeAt(i + 11) & 255) << 24;
        k4 = key.charCodeAt(i + 12) & 255 | (key.charCodeAt(i + 13) & 255) << 8 | (key.charCodeAt(i + 14) & 255) << 16 | (key.charCodeAt(i + 15) & 255) << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 19);
        h1 += h2;
        h1 = _x86Multiply(h1, 5) + 1444728091;
        k2 = _x86Multiply(k2, c2);
        k2 = _x86Rotl(k2, 16);
        k2 = _x86Multiply(k2, c3);
        h2 ^= k2;
        h2 = _x86Rotl(h2, 17);
        h2 += h3;
        h2 = _x86Multiply(h2, 5) + 197830471;
        k3 = _x86Multiply(k3, c3);
        k3 = _x86Rotl(k3, 17);
        k3 = _x86Multiply(k3, c4);
        h3 ^= k3;
        h3 = _x86Rotl(h3, 15);
        h3 += h4;
        h3 = _x86Multiply(h3, 5) + 2530024501;
        k4 = _x86Multiply(k4, c4);
        k4 = _x86Rotl(k4, 18);
        k4 = _x86Multiply(k4, c1);
        h4 ^= k4;
        h4 = _x86Rotl(h4, 13);
        h4 += h1;
        h4 = _x86Multiply(h4, 5) + 850148119;
      }
      k1 = 0;
      k2 = 0;
      k3 = 0;
      k4 = 0;
      switch (remainder) {
        case 15:
          k4 ^= key.charCodeAt(i + 14) << 16;
        case 14:
          k4 ^= key.charCodeAt(i + 13) << 8;
        case 13:
          k4 ^= key.charCodeAt(i + 12);
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
        case 12:
          k3 ^= key.charCodeAt(i + 11) << 24;
        case 11:
          k3 ^= key.charCodeAt(i + 10) << 16;
        case 10:
          k3 ^= key.charCodeAt(i + 9) << 8;
        case 9:
          k3 ^= key.charCodeAt(i + 8);
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
        case 8:
          k2 ^= key.charCodeAt(i + 7) << 24;
        case 7:
          k2 ^= key.charCodeAt(i + 6) << 16;
        case 6:
          k2 ^= key.charCodeAt(i + 5) << 8;
        case 5:
          k2 ^= key.charCodeAt(i + 4);
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
        case 4:
          k1 ^= key.charCodeAt(i + 3) << 24;
        case 3:
          k1 ^= key.charCodeAt(i + 2) << 16;
        case 2:
          k1 ^= key.charCodeAt(i + 1) << 8;
        case 1:
          k1 ^= key.charCodeAt(i);
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= key.length;
      h2 ^= key.length;
      h3 ^= key.length;
      h4 ^= key.length;
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      h1 = _x86Fmix(h1);
      h2 = _x86Fmix(h2);
      h3 = _x86Fmix(h3);
      h4 = _x86Fmix(h4);
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
    };
    library.x64.hash128 = function(key, seed) {
      key = key || "";
      seed = seed || 0;
      var remainder = key.length % 16;
      var bytes = key.length - remainder;
      var h1 = [0, seed];
      var h2 = [0, seed];
      var k1 = [0, 0];
      var k2 = [0, 0];
      var c1 = [2277735313, 289559509];
      var c2 = [1291169091, 658871167];
      for (var i = 0;i < bytes; i = i + 16) {
        k1 = [key.charCodeAt(i + 4) & 255 | (key.charCodeAt(i + 5) & 255) << 8 | (key.charCodeAt(i + 6) & 255) << 16 | (key.charCodeAt(i + 7) & 255) << 24, key.charCodeAt(i) & 255 | (key.charCodeAt(i + 1) & 255) << 8 | (key.charCodeAt(i + 2) & 255) << 16 | (key.charCodeAt(i + 3) & 255) << 24];
        k2 = [key.charCodeAt(i + 12) & 255 | (key.charCodeAt(i + 13) & 255) << 8 | (key.charCodeAt(i + 14) & 255) << 16 | (key.charCodeAt(i + 15) & 255) << 24, key.charCodeAt(i + 8) & 255 | (key.charCodeAt(i + 9) & 255) << 8 | (key.charCodeAt(i + 10) & 255) << 16 | (key.charCodeAt(i + 11) & 255) << 24];
        k1 = _x64Multiply(k1, c1);
        k1 = _x64Rotl(k1, 31);
        k1 = _x64Multiply(k1, c2);
        h1 = _x64Xor(h1, k1);
        h1 = _x64Rotl(h1, 27);
        h1 = _x64Add(h1, h2);
        h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
        k2 = _x64Multiply(k2, c2);
        k2 = _x64Rotl(k2, 33);
        k2 = _x64Multiply(k2, c1);
        h2 = _x64Xor(h2, k2);
        h2 = _x64Rotl(h2, 31);
        h2 = _x64Add(h2, h1);
        h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
      }
      k1 = [0, 0];
      k2 = [0, 0];
      switch (remainder) {
        case 15:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i + 14)], 48));
        case 14:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i + 13)], 40));
        case 13:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i + 12)], 32));
        case 12:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i + 11)], 24));
        case 11:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i + 10)], 16));
        case 10:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i + 9)], 8));
        case 9:
          k2 = _x64Xor(k2, [0, key.charCodeAt(i + 8)]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
        case 8:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i + 7)], 56));
        case 7:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i + 6)], 48));
        case 6:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i + 5)], 40));
        case 5:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i + 4)], 32));
        case 4:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i + 3)], 24));
        case 3:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i + 2)], 16));
        case 2:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i + 1)], 8));
        case 1:
          k1 = _x64Xor(k1, [0, key.charCodeAt(i)]);
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
      }
      h1 = _x64Xor(h1, [0, key.length]);
      h2 = _x64Xor(h2, [0, key.length]);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      h1 = _x64Fmix(h1);
      h2 = _x64Fmix(h2);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
    };
    if (typeof exports !== "undefined") {
      if (typeof module !== "undefined" && module.exports) {
        exports = module.exports = library;
      }
      exports.murmurHash3 = library;
    } else if (typeof define === "function" && define.amd) {
      define([], function() {
        return library;
      });
    } else {
      library._murmurHash3 = root.murmurHash3;
      library.noConflict = function() {
        root.murmurHash3 = library._murmurHash3;
        library._murmurHash3 = undefined2;
        library.noConflict = undefined2;
        return library;
      };
      root.murmurHash3 = library;
    }
  })(exports);
});

// node_modules/unleash-client/lib/helpers.js
var require_helpers = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFallbackFunction = createFallbackFunction;
  exports.resolveContextValue = resolveContextValue;
  exports.safeName = safeName;
  exports.generateInstanceId = generateInstanceId;
  exports.generateHashOfConfig = generateHashOfConfig;
  exports.getAppliedJitter = getAppliedJitter;
  var node_os_1 = __require("node:os");
  var murmurHash3 = __importStar(require_murmurHash3js());
  function createFallbackFunction(name, context, fallback) {
    if (typeof fallback === "function") {
      return () => fallback(name, context);
    }
    if (typeof fallback === "boolean") {
      return () => fallback;
    }
    return () => false;
  }
  function resolveContextValue(context, field) {
    const contextValue = context[field] ?? context.properties?.[field];
    return contextValue !== undefined && contextValue !== null ? String(contextValue) : undefined;
  }
  function safeName(str = "") {
    return str.replace(/\//g, "_");
  }
  function generateInstanceId(instanceId) {
    if (instanceId) {
      return instanceId;
    }
    let info;
    try {
      info = (0, node_os_1.userInfo)();
    } catch (_e) {}
    const prefix = info ? info.username : `generated-${Math.round(Math.random() * 1e6)}-${process.pid}`;
    return `${prefix}-${(0, node_os_1.hostname)()}`;
  }
  function generateHashOfConfig(o) {
    const oAsString = JSON.stringify(o);
    return murmurHash3.x86.hash128(oAsString);
  }
  function getAppliedJitter(jitter) {
    const appliedJitter = Math.random() * jitter;
    return Math.random() < 0.5 ? -appliedJitter : appliedJitter;
  }
});

// node_modules/unleash-client/lib/strategy/util.js
var require_util = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalizedStrategyValue = normalizedStrategyValue;
  exports.normalizedVariantValue = normalizedVariantValue;
  var murmurHash3 = __importStar(require_murmurHash3js());
  function normalizedValue(id, groupId, normalizer, seed = 0) {
    const hash = murmurHash3.x86.hash32(`${groupId}:${id}`, seed);
    return hash % normalizer + 1;
  }
  var STRATEGY_SEED = 0;
  function normalizedStrategyValue(id, groupId) {
    return normalizedValue(id, groupId, 100, STRATEGY_SEED);
  }
  var VARIANT_SEED = 86028157;
  function normalizedVariantValue(id, groupId, normalizer) {
    return normalizedValue(id, groupId, normalizer, VARIANT_SEED);
  }
});

// node_modules/unleash-client/lib/variant.js
var require_variant = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultVariant = exports.PayloadType = undefined;
  exports.getDefaultVariant = getDefaultVariant;
  exports.selectVariantDefinition = selectVariantDefinition;
  exports.selectVariant = selectVariant;
  var helpers_1 = require_helpers();
  var util_1 = require_util();
  var PayloadType;
  (function(PayloadType2) {
    PayloadType2["STRING"] = "string";
    PayloadType2["JSON"] = "json";
    PayloadType2["CSV"] = "csv";
    PayloadType2["NUMBER"] = "number";
  })(PayloadType || (exports.PayloadType = PayloadType = {}));
  exports.defaultVariant = {
    name: "disabled",
    enabled: false,
    feature_enabled: false
  };
  function getDefaultVariant() {
    return exports.defaultVariant;
  }
  function randomString() {
    return String(Math.round(Math.random() * 1e5));
  }
  var stickinessSelectors = ["userId", "sessionId", "remoteAddress"];
  function getSeed(context, stickiness = "default") {
    if (stickiness !== "default") {
      const value = (0, helpers_1.resolveContextValue)(context, stickiness);
      return value ? value.toString() : randomString();
    }
    let result;
    stickinessSelectors.some((key) => {
      const value = context[key];
      if (typeof value === "string" && value !== "") {
        result = value;
        return true;
      }
      return false;
    });
    return result || randomString();
  }
  function overrideMatchesContext(context) {
    return (o) => o.values.some((value) => value === (0, helpers_1.resolveContextValue)(context, o.contextName));
  }
  function findOverride(variants, context) {
    return variants.filter((variant) => variant.overrides).find((variant) => variant.overrides?.some(overrideMatchesContext(context)));
  }
  function selectVariantDefinition(groupId, stickiness, variants, context) {
    const totalWeight = variants.reduce((acc, v) => acc + v.weight, 0);
    if (totalWeight <= 0) {
      return null;
    }
    const variantOverride = findOverride(variants, context);
    if (variantOverride) {
      return variantOverride;
    }
    const target = (0, util_1.normalizedVariantValue)(getSeed(context, stickiness), groupId, totalWeight);
    let counter = 0;
    const variant = variants.find((v) => {
      if (v.weight === 0) {
        return;
      }
      counter += v.weight;
      if (counter < target) {
        return;
      }
      return v;
    });
    return variant || null;
  }
  function selectVariant(feature, context) {
    const stickiness = feature.variants?.[0]?.stickiness ?? undefined;
    return selectVariantDefinition(feature.name, stickiness, feature.variants || [], context);
  }
});

// node_modules/unleash-client/lib/client.js
var require_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var node_events_1 = __require("node:events");
  var events_1 = require_events();
  var variant_1 = require_variant();

  class UnleashClient extends node_events_1.EventEmitter {
    repository;
    strategies;
    warnedStrategies;
    warnedDependencies;
    constructor(repository, strategies) {
      super();
      this.repository = repository;
      this.strategies = strategies || [];
      this.warnedStrategies = {};
      this.warnedDependencies = {};
      this.strategies.forEach((strategy) => {
        if (!strategy || !strategy.name || !strategy.isEnabled || typeof strategy.isEnabled !== "function") {
          throw new Error("Invalid strategy data / interface");
        }
      });
    }
    getStrategy(name) {
      return this.strategies.find((strategy) => strategy.name === name);
    }
    warnStrategyOnce(missingStrategy, name, strategies) {
      if (!this.warnedStrategies[missingStrategy + name]) {
        this.warnedStrategies[missingStrategy + name] = true;
        this.emit(events_1.UnleashEvents.Warn, `Missing strategy "${missingStrategy}" for toggle "${name}". Ensure that "${strategies.map(({ name: n }) => n).join(", ")}" are supported before using this toggle`);
      }
    }
    warnDependencyOnce(missingDependency, name) {
      if (!this.warnedDependencies[missingDependency + name]) {
        this.warnedDependencies[missingDependency + name] = true;
        this.emit(events_1.UnleashEvents.Warn, `Missing dependency "${missingDependency}" for toggle "${name}"`);
      }
    }
    isParentDependencySatisfied(feature, context) {
      if (!feature?.dependencies?.length) {
        return true;
      }
      return feature.dependencies.every((parent) => {
        const parentToggle = this.repository.getToggle(parent.feature);
        if (!parentToggle) {
          this.warnDependencyOnce(parent.feature, feature.name);
          return false;
        }
        if (parentToggle.dependencies?.length) {
          return false;
        }
        if (parent.enabled !== false) {
          if (parent.variants?.length) {
            const { name, feature_enabled: featureEnabled } = this.getVariant(parent.feature, context);
            return featureEnabled && parent.variants.includes(name);
          }
          return this.isEnabled(parent.feature, context, () => false);
        }
        return !this.isEnabled(parent.feature, context, () => false);
      });
    }
    isEnabled(name, context, fallback) {
      const feature = this.repository.getToggle(name);
      const enabled = this.isFeatureEnabled(feature, context, fallback).enabled;
      if (feature?.impressionData) {
        this.emit(events_1.UnleashEvents.Impression, (0, events_1.createImpressionEvent)({
          featureName: name,
          context,
          enabled,
          eventType: "isEnabled"
        }));
      }
      return enabled;
    }
    isFeatureEnabled(feature, context, fallback) {
      if (!feature) {
        return { enabled: fallback() };
      }
      if (!feature || !this.isParentDependencySatisfied(feature, context) || !feature.enabled) {
        return { enabled: false };
      }
      if (!Array.isArray(feature.strategies)) {
        const msg = `Malformed feature, strategies not an array, is a ${typeof feature.strategies}`;
        this.emit(events_1.UnleashEvents.Error, new Error(msg));
        return { enabled: false };
      }
      if (feature.strategies.length === 0) {
        return { enabled: feature.enabled };
      }
      let strategyResult = { enabled: false };
      feature.strategies?.some((strategySelector) => {
        const strategy = this.getStrategy(strategySelector.name);
        if (!strategy) {
          this.warnStrategyOnce(strategySelector.name, feature.name, feature.strategies || []);
          return false;
        }
        const constraints = this.yieldConstraintsFor(strategySelector);
        const result = strategy.getResult(strategySelector.parameters, context, constraints, strategySelector.variants);
        if (result.enabled) {
          strategyResult = result;
          return true;
        }
        return false;
      });
      return strategyResult;
    }
    *yieldConstraintsFor(strategy) {
      if (strategy.constraints) {
        yield* strategy.constraints;
      }
      const segments = strategy.segments?.map((segmentId) => this.repository.getSegment(segmentId));
      if (!segments) {
        return;
      }
      yield* this.yieldSegmentConstraints(segments);
    }
    *yieldSegmentConstraints(segments) {
      for (const segment of segments) {
        if (segment) {
          for (const constraint of segment.constraints ?? []) {
            yield constraint;
          }
        } else {
          yield undefined;
        }
      }
    }
    getVariant(name, context, fallbackVariant) {
      const feature = this.repository.getToggle(name);
      const variant = this.resolveVariant(feature, context, true, fallbackVariant);
      if (feature?.impressionData) {
        this.emit(events_1.UnleashEvents.Impression, (0, events_1.createImpressionEvent)({
          featureName: name,
          context,
          enabled: variant.enabled,
          eventType: "getVariant",
          variant: variant.name
        }));
      }
      return variant;
    }
    forceGetVariant(name, context, fallbackVariant) {
      const feature = this.repository.getToggle(name);
      return this.resolveVariant(feature, context, true, fallbackVariant);
    }
    resolveVariant(feature, context, checkToggle, fallbackVariant) {
      const fallback = fallbackVariant || variant_1.defaultVariant;
      if (typeof feature === "undefined") {
        return { ...fallback, feature_enabled: false, featureEnabled: false };
      }
      let featureEnabled = !checkToggle;
      if (checkToggle) {
        const result = this.isFeatureEnabled(feature, context, () => !!fallbackVariant?.enabled);
        featureEnabled = result.enabled;
        if (result.enabled && result.variant) {
          return { ...result.variant, feature_enabled: featureEnabled, featureEnabled };
        }
        if (!result.enabled) {
          return { ...fallback, feature_enabled: featureEnabled, featureEnabled };
        }
      }
      if (!feature.variants || !Array.isArray(feature.variants) || feature.variants.length === 0) {
        return { ...fallback, feature_enabled: featureEnabled, featureEnabled };
      }
      const variant = (0, variant_1.selectVariant)(feature, context);
      if (variant === null) {
        return { ...fallback, feature_enabled: featureEnabled, featureEnabled };
      }
      return {
        name: variant.name,
        payload: variant.payload,
        enabled: true,
        feature_enabled: featureEnabled,
        featureEnabled
      };
    }
  }
  exports.default = UnleashClient;
});

// node_modules/unleash-client/lib/impact-metrics/environment-resolver.js
var require_environment_resolver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extractEnvironmentFromCustomHeaders = undefined;
  var findAuthorizationHeaderKey = (customHeaders) => {
    const headerKeys = Object.keys(customHeaders);
    return headerKeys.find((key) => key.toLowerCase() === "authorization");
  };
  var extractAuthorizationHeader = (customHeaders) => {
    if (!customHeaders) {
      return;
    }
    const authHeaderKey = findAuthorizationHeaderKey(customHeaders);
    if (!authHeaderKey) {
      return;
    }
    return customHeaders[authHeaderKey];
  };
  var extractEnvironmentFromHeader = (authorizationHeader) => {
    if (!authorizationHeader) {
      return;
    }
    const parts = authorizationHeader.split(":");
    if (parts.length >= 2 && parts[1]) {
      const envParts = parts[1].split(".");
      return envParts[0] || undefined;
    }
    return;
  };
  var extractEnvironmentFromCustomHeaders = (customHeaders) => {
    const authorizationHeader = extractAuthorizationHeader(customHeaders);
    return extractEnvironmentFromHeader(authorizationHeader);
  };
  exports.extractEnvironmentFromCustomHeaders = extractEnvironmentFromCustomHeaders;
});

// node_modules/unleash-client/lib/impact-metrics/context.js
var require_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildImpactMetricContext = undefined;
  var environment_resolver_1 = require_environment_resolver();
  var buildImpactMetricContext = (customHeaders, staticContext) => {
    const metricsContext = { ...staticContext };
    if (customHeaders) {
      const environment = (0, environment_resolver_1.extractEnvironmentFromCustomHeaders)(customHeaders);
      if (environment) {
        metricsContext.environment = environment;
      }
    }
    return metricsContext;
  };
  exports.buildImpactMetricContext = buildImpactMetricContext;
});

// node_modules/unleash-client/lib/impact-metrics/metric-api.js
var require_metric_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricsAPI = undefined;
  var node_stream_1 = __require("node:stream");
  var unleash_1 = require_unleash();

  class MetricsAPI extends node_stream_1.EventEmitter {
    metricRegistry;
    variantResolver;
    staticContext;
    constructor(metricRegistry, variantResolver, staticContext) {
      super();
      this.metricRegistry = metricRegistry;
      this.variantResolver = variantResolver;
      this.staticContext = staticContext;
    }
    defineCounter(name, help) {
      if (!name || !help) {
        this.emit(unleash_1.UnleashEvents.Warn, `Counter name or help cannot be empty: ${name}, ${help}.`);
        return;
      }
      const labelNames = ["featureName", "appName", "environment"];
      this.metricRegistry.counter({ name, help, labelNames });
    }
    defineGauge(name, help) {
      if (!name || !help) {
        this.emit(unleash_1.UnleashEvents.Warn, `Gauge name or help cannot be empty: ${name}, ${help}.`);
        return;
      }
      const labelNames = ["featureName", "appName", "environment"];
      this.metricRegistry.gauge({ name, help, labelNames });
    }
    defineHistogram(name, help, buckets) {
      if (!name || !help) {
        this.emit(unleash_1.UnleashEvents.Warn, `Histogram name or help cannot be empty: ${name}, ${help}.`);
        return;
      }
      const labelNames = ["featureName", "appName", "environment"];
      this.metricRegistry.histogram({ name, help, labelNames, buckets: buckets || [] });
    }
    getFlagLabels(flagContext) {
      const flagLabels = {};
      if (flagContext) {
        for (const flag of flagContext.flagNames) {
          const variant = this.variantResolver.forceGetVariant(flag, flagContext.context);
          if (variant.enabled) {
            flagLabels[flag] = variant.name;
          } else if (variant.feature_enabled) {
            flagLabels[flag] = "enabled";
          } else {
            flagLabels[flag] = "disabled";
          }
        }
      }
      return flagLabels;
    }
    incrementCounter(name, value, flagContext) {
      const counter = this.metricRegistry.getCounter(name);
      if (!counter) {
        this.emit(unleash_1.UnleashEvents.Warn, `Counter ${name} not defined, this counter will not be incremented.`);
        return;
      }
      const flagLabels = this.getFlagLabels(flagContext);
      const labels = {
        ...flagLabels,
        ...this.staticContext
      };
      counter.inc(value, labels);
    }
    updateGauge(name, value, flagContext) {
      const gauge = this.metricRegistry.getGauge(name);
      if (!gauge) {
        this.emit(unleash_1.UnleashEvents.Warn, `Gauge ${name} not defined, this gauge will not be updated.`);
        return;
      }
      const flagLabels = this.getFlagLabels(flagContext);
      const labels = {
        ...flagLabels,
        ...this.staticContext
      };
      gauge.set(value, labels);
    }
    observeHistogram(name, value, flagContext) {
      const histogram = this.metricRegistry.getHistogram(name);
      if (!histogram) {
        this.emit(unleash_1.UnleashEvents.Warn, `Histogram ${name} not defined, this histogram will not be updated.`);
        return;
      }
      const flagLabels = this.getFlagLabels(flagContext);
      const labels = {
        ...flagLabels,
        ...this.staticContext
      };
      histogram.observe(value, labels);
    }
  }
  exports.MetricsAPI = MetricsAPI;
});

// node_modules/unleash-client/lib/impact-metrics/metric-types.js
var require_metric_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InMemoryMetricRegistry = undefined;
  function isInvalidValue(value) {
    return value !== undefined && !Number.isFinite(value);
  }
  function getLabelKey(labels) {
    if (!labels)
      return "";
    return Object.keys(labels).sort().map((k) => `${k}=${labels[k]}`).join(",");
  }
  function parseLabelKey(key) {
    const labels = {};
    if (!key)
      return labels;
    for (const pair of key.split(",")) {
      const [k, v] = pair.split("=");
      labels[k] = v;
    }
    return labels;
  }
  var isNumericMetricSample = (sample) => ("value" in sample);
  var isBucketMetricSample = (sample) => ("buckets" in sample);

  class CounterImpl {
    opts;
    values = new Map;
    constructor(opts) {
      this.opts = opts;
    }
    inc(value, labels) {
      if (isInvalidValue(value))
        return;
      const delta = value ?? 1;
      if (delta <= 0)
        return;
      const key = getLabelKey(labels);
      const current = this.values.get(key) ?? 0;
      this.values.set(key, current + delta);
    }
    collect() {
      const samples = [...this.values.entries()].map(([key, value]) => ({
        labels: parseLabelKey(key),
        value
      }));
      this.values.clear();
      if (samples.length === 0) {
        samples.push({
          labels: {},
          value: 0
        });
      }
      return {
        name: this.opts.name,
        help: this.opts.help,
        type: "counter",
        samples
      };
    }
  }

  class GaugeImpl {
    opts;
    values = new Map;
    constructor(opts) {
      this.opts = opts;
    }
    inc(value, labels) {
      if (isInvalidValue(value))
        return;
      const delta = value ?? 1;
      const key = getLabelKey(labels);
      const current = this.values.get(key) ?? 0;
      this.values.set(key, current + delta);
    }
    dec(value, labels) {
      if (isInvalidValue(value))
        return;
      const delta = value ?? 1;
      const key = getLabelKey(labels);
      const current = this.values.get(key) ?? 0;
      this.values.set(key, current - delta);
    }
    set(value, labels) {
      if (isInvalidValue(value))
        return;
      const key = getLabelKey(labels);
      this.values.set(key, value);
    }
    collect() {
      const samples = [...this.values.entries()].map(([key, value]) => ({
        labels: parseLabelKey(key),
        value
      }));
      this.values.clear();
      return {
        name: this.opts.name,
        help: this.opts.help,
        type: "gauge",
        samples
      };
    }
  }

  class HistogramImpl {
    opts;
    values = new Map;
    buckets;
    constructor(opts) {
      this.opts = opts;
      const buckets = opts.buckets || [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10];
      const sortedBuckets = [...new Set(buckets.filter((b) => b !== Infinity))].sort((a, b) => a - b);
      this.buckets = [...sortedBuckets, Infinity];
    }
    restore(sample) {
      const key = getLabelKey(sample.labels);
      const data = {
        count: sample.count,
        sum: sample.sum,
        buckets: new Map(sample.buckets.map((b) => [b.le === "+Inf" ? Infinity : b.le, b.count]))
      };
      this.values.set(key, data);
    }
    observe(value, labels) {
      if (isInvalidValue(value))
        return;
      const key = getLabelKey(labels);
      let data = this.values.get(key);
      if (!data) {
        const buckets = new Map;
        for (const bucket of this.buckets) {
          buckets.set(bucket, 0);
        }
        data = {
          count: 0,
          sum: 0,
          buckets
        };
        this.values.set(key, data);
      }
      data.count++;
      data.sum += value;
      for (const bucket of this.buckets) {
        if (value <= bucket) {
          const currentCount = data.buckets.get(bucket) ?? 0;
          data.buckets.set(bucket, currentCount + 1);
        }
      }
    }
    collect() {
      const samples = Array.from(this.values.entries()).map(([key, data]) => ({
        labels: parseLabelKey(key),
        count: data.count,
        sum: data.sum,
        buckets: Array.from(data.buckets.entries()).map(([le, count]) => ({
          le: le === Infinity ? "+Inf" : le,
          count
        }))
      }));
      this.values.clear();
      if (samples.length === 0) {
        samples.push({
          labels: {},
          count: 0,
          sum: 0,
          buckets: this.buckets.map((le) => ({
            le: le === Infinity ? "+Inf" : le,
            count: 0
          }))
        });
      }
      return {
        name: this.opts.name,
        help: this.opts.help,
        type: "histogram",
        samples
      };
    }
  }

  class InMemoryMetricRegistry {
    counters = new Map;
    gauges = new Map;
    histograms = new Map;
    getCounter(counterName) {
      return this.counters.get(counterName);
    }
    getGauge(gaugeName) {
      return this.gauges.get(gaugeName);
    }
    getHistogram(histogramName) {
      return this.histograms.get(histogramName);
    }
    counter(opts) {
      const key = opts.name;
      let counter = this.counters.get(key);
      if (!counter) {
        counter = new CounterImpl(opts);
        this.counters.set(key, counter);
      }
      return counter;
    }
    gauge(opts) {
      const key = opts.name;
      let gauge = this.gauges.get(key);
      if (!gauge) {
        gauge = new GaugeImpl(opts);
        this.gauges.set(key, gauge);
      }
      return gauge;
    }
    histogram(opts) {
      const key = opts.name;
      let histogram = this.histograms.get(key);
      if (!histogram) {
        histogram = new HistogramImpl(opts);
        this.histograms.set(key, histogram);
      }
      return histogram;
    }
    collect() {
      const allCounters = [...this.counters.values()].map((c) => c.collect());
      const allGauges = [...this.gauges.values()].map((g) => g.collect());
      const allHistograms = [...this.histograms.values()].map((h) => h.collect());
      const allMetrics = [...allCounters, ...allGauges, ...allHistograms];
      const nonEmpty = allMetrics.filter((metric) => metric.samples.length > 0);
      return nonEmpty.length > 0 ? nonEmpty : [];
    }
    restore(metrics) {
      for (const metric of metrics) {
        switch (metric.type) {
          case "counter": {
            const counter = this.counter({ name: metric.name, help: metric.help });
            for (const sample of metric.samples) {
              if (isNumericMetricSample(sample)) {
                counter.inc(sample.value, sample.labels);
              }
            }
            break;
          }
          case "gauge": {
            const gauge = this.gauge({ name: metric.name, help: metric.help });
            for (const sample of metric.samples) {
              if (isNumericMetricSample(sample)) {
                gauge.set(sample.value, sample.labels);
              }
            }
            break;
          }
          case "histogram": {
            const firstSample = metric.samples.find(isBucketMetricSample);
            if (firstSample) {
              const buckets = firstSample.buckets.map((b) => b.le === "+Inf" ? Infinity : b.le);
              const histogram = this.histogram({
                name: metric.name,
                help: metric.help,
                buckets
              });
              metric.samples.filter(isBucketMetricSample).forEach((sample) => {
                histogram.restore(sample);
              });
            }
            break;
          }
        }
      }
    }
  }
  exports.InMemoryMetricRegistry = InMemoryMetricRegistry;
});

// node_modules/unleash-client/lib/details.json
var require_details = __commonJS((exports, module) => {
  module.exports = { name: "unleash-node-sdk", version: "6.9.6", sdkVersion: "unleash-node-sdk:6.9.6" };
});

// node_modules/unleash-client/lib/feature.js
var require_feature = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseApiResponse = undefined;
  var parseApiResponse = (data) => {
    if (typeof data !== "object" || data === null) {
      throw new Error(`Invalid API response: ${JSON.stringify(data, null, 2)}`);
    }
    if ("events" in data && Array.isArray(data.events)) {
      return { ...data, type: "delta" };
    } else if ("features" in data && Array.isArray(data.features)) {
      return { ...data, type: "full" };
    }
    throw new Error(`Client features was neither a delta nor a full response: ${JSON.stringify(data, null, 2)}`);
  };
  exports.parseApiResponse = parseApiResponse;
});

// node_modules/http-proxy-agent/node_modules/debug/src/common.js
var require_common2 = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug3(...args) {
        if (!debug3.enabled) {
          return;
        }
        const self2 = debug3;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug3.namespace = namespace;
      debug3.useColors = createDebug.useColors();
      debug3.color = createDebug.selectColor(namespace);
      debug3.extend = extend;
      debug3.destroy = createDebug.destroy;
      Object.defineProperty(debug3, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug3);
      }
      return debug3;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/http-proxy-agent/node_modules/debug/src/browser.js
var require_browser2 = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common2()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/http-proxy-agent/node_modules/debug/src/node.js
var require_node2 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug3) {
    debug3.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug3.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common2()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/http-proxy-agent/node_modules/debug/src/index.js
var require_src2 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser2();
  } else {
    module.exports = require_node2();
  }
});

// node_modules/agent-base/dist/helpers.js
var require_helpers2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.req = exports.json = exports.toBuffer = undefined;
  var http = __importStar(__require("http"));
  var https = __importStar(__require("https"));
  async function toBuffer(stream3) {
    let length = 0;
    const chunks = [];
    for await (const chunk of stream3) {
      length += chunk.length;
      chunks.push(chunk);
    }
    return Buffer.concat(chunks, length);
  }
  exports.toBuffer = toBuffer;
  async function json(stream3) {
    const buf = await toBuffer(stream3);
    const str = buf.toString("utf8");
    try {
      return JSON.parse(str);
    } catch (_err) {
      const err = _err;
      err.message += ` (input: ${str})`;
      throw err;
    }
  }
  exports.json = json;
  function req(url, opts = {}) {
    const href = typeof url === "string" ? url : url.href;
    const req2 = (href.startsWith("https:") ? https : http).request(url, opts);
    const promise = new Promise((resolve, reject) => {
      req2.once("response", resolve).once("error", reject).end();
    });
    req2.then = promise.then.bind(promise);
    return req2;
  }
  exports.req = req;
});

// node_modules/agent-base/dist/index.js
var require_dist = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Agent = undefined;
  var net = __importStar(__require("net"));
  var http = __importStar(__require("http"));
  var https_1 = __require("https");
  __exportStar(require_helpers2(), exports);
  var INTERNAL = Symbol("AgentBaseInternalState");

  class Agent extends http.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    isSecureEndpoint(options) {
      if (options) {
        if (typeof options.secureEndpoint === "boolean") {
          return options.secureEndpoint;
        }
        if (typeof options.protocol === "string") {
          return options.protocol === "https:";
        }
      }
      const { stack } = new Error;
      if (typeof stack !== "string")
        return false;
      return stack.split(`
`).some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    incrementSockets(name) {
      if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
        return null;
      }
      if (!this.sockets[name]) {
        this.sockets[name] = [];
      }
      const fakeSocket = new net.Socket({ writable: false });
      this.sockets[name].push(fakeSocket);
      this.totalSocketCount++;
      return fakeSocket;
    }
    decrementSockets(name, socket) {
      if (!this.sockets[name] || socket === null) {
        return;
      }
      const sockets = this.sockets[name];
      const index = sockets.indexOf(socket);
      if (index !== -1) {
        sockets.splice(index, 1);
        this.totalSocketCount--;
        if (sockets.length === 0) {
          delete this.sockets[name];
        }
      }
    }
    getName(options) {
      const secureEndpoint = this.isSecureEndpoint(options);
      if (secureEndpoint) {
        return https_1.Agent.prototype.getName.call(this, options);
      }
      return super.getName(options);
    }
    createSocket(req, options, cb) {
      const connectOpts = {
        ...options,
        secureEndpoint: this.isSecureEndpoint(options)
      };
      const name = this.getName(connectOpts);
      const fakeSocket = this.incrementSockets(name);
      Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
        this.decrementSockets(name, fakeSocket);
        if (socket instanceof http.Agent) {
          try {
            return socket.addRequest(req, connectOpts);
          } catch (err) {
            return cb(err);
          }
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req, options, cb);
      }, (err) => {
        this.decrementSockets(name, fakeSocket);
        cb(err);
      });
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = undefined;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v;
      }
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v;
      }
    }
  }
  exports.Agent = Agent;
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpProxyAgent = undefined;
  var net = __importStar(__require("net"));
  var tls = __importStar(__require("tls"));
  var debug_1 = __importDefault(require_src2());
  var events_1 = __require("events");
  var agent_base_1 = require_dist();
  var url_1 = __require("url");
  var debug3 = (0, debug_1.default)("http-proxy-agent");

  class HttpProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
      super(opts);
      this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
      this.proxyHeaders = opts?.headers ?? {};
      debug3("Creating new HttpProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    addRequest(req, opts) {
      req._header = null;
      this.setRequestProps(req, opts);
      super.addRequest(req, opts);
    }
    setRequestProps(req, opts) {
      const { proxy } = this;
      const protocol = opts.secureEndpoint ? "https:" : "http:";
      const hostname = req.getHeader("host") || "localhost";
      const base = `${protocol}//${hostname}`;
      const url = new url_1.URL(req.path, base);
      if (opts.port !== 80) {
        url.port = String(opts.port);
      }
      req.path = String(url);
      const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      if (proxy.username || proxy.password) {
        const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      if (!headers["Proxy-Connection"]) {
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers)) {
        const value = headers[name];
        if (value) {
          req.setHeader(name, value);
        }
      }
    }
    async connect(req, opts) {
      req._header = null;
      if (!req.path.includes("://")) {
        this.setRequestProps(req, opts);
      }
      let first;
      let endOfHeaders;
      debug3("Regenerating stored HTTP header string for request");
      req._implicitHeader();
      if (req.outputData && req.outputData.length > 0) {
        debug3("Patching connection write() output buffer with updated header");
        first = req.outputData[0].data;
        endOfHeaders = first.indexOf(`\r
\r
`) + 4;
        req.outputData[0].data = req._header + first.substring(endOfHeaders);
        debug3("Output buffer: %o", req.outputData[0].data);
      }
      let socket;
      if (this.proxy.protocol === "https:") {
        debug3("Creating `tls.Socket`: %o", this.connectOpts);
        socket = tls.connect(this.connectOpts);
      } else {
        debug3("Creating `net.Socket`: %o", this.connectOpts);
        socket = net.connect(this.connectOpts);
      }
      await (0, events_1.once)(socket, "connect");
      return socket;
    }
  }
  HttpProxyAgent.protocols = ["http", "https"];
  exports.HttpProxyAgent = HttpProxyAgent;
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
});

// node_modules/https-proxy-agent/node_modules/debug/src/common.js
var require_common3 = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug3(...args) {
        if (!debug3.enabled) {
          return;
        }
        const self2 = debug3;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug3.namespace = namespace;
      debug3.useColors = createDebug.useColors();
      debug3.color = createDebug.selectColor(namespace);
      debug3.extend = extend;
      debug3.destroy = createDebug.destroy;
      Object.defineProperty(debug3, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug3);
      }
      return debug3;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/https-proxy-agent/node_modules/debug/src/browser.js
var require_browser3 = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common3()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/https-proxy-agent/node_modules/debug/src/node.js
var require_node3 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug3) {
    debug3.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug3.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common3()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/https-proxy-agent/node_modules/debug/src/index.js
var require_src3 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser3();
  } else {
    module.exports = require_node3();
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseProxyResponse = undefined;
  var debug_1 = __importDefault(require_src3());
  var debug3 = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("readable", read);
      }
      function onend() {
        cleanup();
        debug3("onend");
        reject(new Error("Proxy connection ended before receiving CONNECT response"));
      }
      function onerror(err) {
        cleanup();
        debug3("onerror %o", err);
        reject(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf(`\r
\r
`);
        if (endOfHeaders === -1) {
          debug3("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split(`\r
`);
        const firstLine = headerParts.shift();
        if (!firstLine) {
          socket.destroy();
          return reject(new Error("No header received from proxy CONNECT response"));
        }
        const firstLineParts = firstLine.split(" ");
        const statusCode = +firstLineParts[1];
        const statusText = firstLineParts.slice(2).join(" ");
        const headers = {};
        for (const header of headerParts) {
          if (!header)
            continue;
          const firstColon = header.indexOf(":");
          if (firstColon === -1) {
            socket.destroy();
            return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
          }
          const key = header.slice(0, firstColon).toLowerCase();
          const value = header.slice(firstColon + 1).trimStart();
          const current = headers[key];
          if (typeof current === "string") {
            headers[key] = [current, value];
          } else if (Array.isArray(current)) {
            current.push(value);
          } else {
            headers[key] = value;
          }
        }
        debug3("got proxy server response: %o %o", firstLine, headers);
        cleanup();
        resolve({
          connect: {
            statusCode,
            statusText,
            headers
          },
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("end", onend);
      read();
    });
  }
  exports.parseProxyResponse = parseProxyResponse;
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpsProxyAgent = undefined;
  var net = __importStar(__require("net"));
  var tls = __importStar(__require("tls"));
  var assert_1 = __importDefault(__require("assert"));
  var debug_1 = __importDefault(require_src3());
  var agent_base_1 = require_dist();
  var url_1 = __require("url");
  var parse_proxy_response_1 = require_parse_proxy_response();
  var debug3 = (0, debug_1.default)("https-proxy-agent");
  var setServernameFromNonIpHost = (options) => {
    if (options.servername === undefined && options.host && !net.isIP(options.host)) {
      return {
        ...options,
        servername: options.host
      };
    }
    return options;
  };

  class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
      super(opts);
      this.options = { path: undefined };
      this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
      this.proxyHeaders = opts?.headers ?? {};
      debug3("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ALPNProtocols: ["http/1.1"],
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    async connect(req, opts) {
      const { proxy } = this;
      if (!opts.host) {
        throw new TypeError('No "host" provided');
      }
      let socket;
      if (proxy.protocol === "https:") {
        debug3("Creating `tls.Socket`: %o", this.connectOpts);
        socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
      } else {
        debug3("Creating `net.Socket`: %o", this.connectOpts);
        socket = net.connect(this.connectOpts);
      }
      const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
      let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
      if (proxy.username || proxy.password) {
        const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      headers.Host = `${host}:${opts.port}`;
      if (!headers["Proxy-Connection"]) {
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers)) {
        payload += `${name}: ${headers[name]}\r
`;
      }
      const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
      socket.write(`${payload}\r
`);
      const { connect: connect2, buffered } = await proxyResponsePromise;
      req.emit("proxyConnect", connect2);
      this.emit("proxyConnect", connect2, req);
      if (connect2.statusCode === 200) {
        req.once("socket", resume);
        if (opts.secureEndpoint) {
          debug3("Upgrading socket connection to TLS");
          return tls.connect({
            ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
            socket
          });
        }
        return socket;
      }
      socket.destroy();
      const fakeSocket = new net.Socket({ writable: false });
      fakeSocket.readable = true;
      req.once("socket", (s) => {
        debug3("Replaying proxy buffer for failed request");
        (0, assert_1.default)(s.listenerCount("data") > 0);
        s.push(buffered);
        s.push(null);
      });
      return fakeSocket;
    }
  }
  HttpsProxyAgent.protocols = ["http", "https"];
  exports.HttpsProxyAgent = HttpsProxyAgent;
  function resume(socket) {
    socket.resume();
  }
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
});

// node_modules/minipass/dist/commonjs/index.js
var require_commonjs = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = undefined;
  var proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  var node_events_1 = __require("node:events");
  var node_stream_1 = __importDefault(__require("node:stream"));
  var node_string_decoder_1 = __require("node:string_decoder");
  var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof node_stream_1.default || (0, exports.isReadable)(s) || (0, exports.isWritable)(s));
  exports.isStream = isStream;
  var isReadable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.pipe === "function" && s.pipe !== node_stream_1.default.Writable.prototype.pipe;
  exports.isReadable = isReadable;
  var isWritable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
  exports.isWritable = isWritable;
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var EMITTED_ERROR = Symbol("emittedError");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFER = Symbol("buffer");
  var PIPES = Symbol("pipes");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var ERROR = Symbol("error");
  var EMITDATA = Symbol("emitData");
  var EMITEND = Symbol("emitEnd");
  var EMITEND2 = Symbol("emitEnd2");
  var ASYNC = Symbol("async");
  var ABORT = Symbol("abort");
  var ABORTED = Symbol("aborted");
  var SIGNAL = Symbol("signal");
  var DATALISTENERS = Symbol("dataListeners");
  var DISCARDED = Symbol("discarded");
  var defer = (fn) => Promise.resolve().then(fn);
  var nodefer = (fn) => fn();
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

  class Pipe {
    src;
    dest;
    opts;
    ondrain;
    constructor(src, dest, opts) {
      this.src = src;
      this.dest = dest;
      this.opts = opts;
      this.ondrain = () => src[RESUME]();
      this.dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    proxyErrors(_er) {}
    end() {
      this.unpipe();
      if (this.opts.end)
        this.dest.end();
    }
  }

  class PipeProxyErrors extends Pipe {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => this.dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  }
  var isObjectModeOptions = (o) => !!o.objectMode;
  var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";

  class Minipass extends node_events_1.EventEmitter {
    [FLOWING] = false;
    [PAUSED] = false;
    [PIPES] = [];
    [BUFFER] = [];
    [OBJECTMODE];
    [ENCODING];
    [ASYNC];
    [DECODER];
    [EOF] = false;
    [EMITTED_END] = false;
    [EMITTING_END] = false;
    [CLOSED] = false;
    [EMITTED_ERROR] = null;
    [BUFFERLENGTH] = 0;
    [DESTROYED] = false;
    [SIGNAL];
    [ABORTED] = false;
    [DATALISTENERS] = 0;
    [DISCARDED] = false;
    writable = true;
    readable = true;
    constructor(...args) {
      const options = args[0] || {};
      super();
      if (options.objectMode && typeof options.encoding === "string") {
        throw new TypeError("Encoding and objectMode may not be used together");
      }
      if (isObjectModeOptions(options)) {
        this[OBJECTMODE] = true;
        this[ENCODING] = null;
      } else if (isEncodingOptions(options)) {
        this[ENCODING] = options.encoding;
        this[OBJECTMODE] = false;
      } else {
        this[OBJECTMODE] = false;
        this[ENCODING] = null;
      }
      this[ASYNC] = !!options.async;
      this[DECODER] = this[ENCODING] ? new node_string_decoder_1.StringDecoder(this[ENCODING]) : null;
      if (options && options.debugExposeBuffer === true) {
        Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
      }
      if (options && options.debugExposePipes === true) {
        Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
      }
      const { signal } = options;
      if (signal) {
        this[SIGNAL] = signal;
        if (signal.aborted) {
          this[ABORT]();
        } else {
          signal.addEventListener("abort", () => this[ABORT]());
        }
      }
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    setEncoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(_om) {
      throw new Error("objectMode must be set at instantiation time");
    }
    get ["async"]() {
      return this[ASYNC];
    }
    set ["async"](a) {
      this[ASYNC] = this[ASYNC] || !!a;
    }
    [ABORT]() {
      this[ABORTED] = true;
      this.emit("abort", this[SIGNAL]?.reason);
      this.destroy(this[SIGNAL]?.reason);
    }
    get aborted() {
      return this[ABORTED];
    }
    set aborted(_) {}
    write(chunk, encoding, cb) {
      if (this[ABORTED])
        return false;
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
        return true;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC] ? defer : nodefer;
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk)) {
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        } else if (isArrayBufferLike(chunk)) {
          chunk = Buffer.from(chunk);
        } else if (typeof chunk !== "string") {
          throw new Error("Non-contiguous data written to non-objectMode stream");
        }
      }
      if (this[OBJECTMODE]) {
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      if (typeof chunk === "string" && !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING]) {
        chunk = this[DECODER].write(chunk);
      }
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    read(n) {
      if (this[DESTROYED])
        return null;
      this[DISCARDED] = false;
      if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
        this[MAYBE_EMIT_END]();
        return null;
      }
      if (this[OBJECTMODE])
        n = null;
      if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
        this[BUFFER] = [
          this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
        ];
      }
      const ret = this[READ](n || null, this[BUFFER][0]);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [READ](n, chunk) {
      if (this[OBJECTMODE])
        this[BUFFERSHIFT]();
      else {
        const c = chunk;
        if (n === c.length || n === null)
          this[BUFFERSHIFT]();
        else if (typeof c === "string") {
          this[BUFFER][0] = c.slice(n);
          chunk = c.slice(0, n);
          this[BUFFERLENGTH] -= n;
        } else {
          this[BUFFER][0] = c.subarray(n);
          chunk = c.subarray(0, n);
          this[BUFFERLENGTH] -= n;
        }
      }
      this.emit("data", chunk);
      if (!this[BUFFER].length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = undefined;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (chunk !== undefined)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this[FLOWING] || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    [RESUME]() {
      if (this[DESTROYED])
        return;
      if (!this[DATALISTENERS] && !this[PIPES].length) {
        this[DISCARDED] = true;
      }
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this[BUFFER].length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
      this[DISCARDED] = false;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1;
      else
        this[BUFFERLENGTH] -= this[BUFFER][0].length;
      return this[BUFFER].shift();
    }
    [FLUSH](noDrain = false) {
      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
      if (!noDrain && !this[BUFFER].length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      this.emit("data", chunk);
      return this[FLOWING];
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return dest;
      this[DISCARDED] = false;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === proc.stdout || dest === proc.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
        if (this[ASYNC])
          defer(() => this[RESUME]());
        else
          this[RESUME]();
      }
      return dest;
    }
    unpipe(dest) {
      const p = this[PIPES].find((p2) => p2.dest === dest);
      if (p) {
        if (this[PIPES].length === 1) {
          if (this[FLOWING] && this[DATALISTENERS] === 0) {
            this[FLOWING] = false;
          }
          this[PIPES] = [];
        } else
          this[PIPES].splice(this[PIPES].indexOf(p), 1);
        p.unpipe();
      }
    }
    addListener(ev, handler) {
      return this.on(ev, handler);
    }
    on(ev, handler) {
      const ret = super.on(ev, handler);
      if (ev === "data") {
        this[DISCARDED] = false;
        this[DATALISTENERS]++;
        if (!this[PIPES].length && !this[FLOWING]) {
          this[RESUME]();
        }
      } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
        super.emit("readable");
      } else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR]) {
        const h = handler;
        if (this[ASYNC])
          defer(() => h.call(this, this[EMITTED_ERROR]));
        else
          h.call(this, this[EMITTED_ERROR]);
      }
      return ret;
    }
    removeListener(ev, handler) {
      return this.off(ev, handler);
    }
    off(ev, handler) {
      const ret = super.off(ev, handler);
      if (ev === "data") {
        this[DATALISTENERS] = this.listeners("data").length;
        if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
          this[FLOWING] = false;
        }
      }
      return ret;
    }
    removeAllListeners(ev) {
      const ret = super.removeAllListeners(ev);
      if (ev === "data" || ev === undefined) {
        this[DATALISTENERS] = 0;
        if (!this[DISCARDED] && !this[PIPES].length) {
          this[FLOWING] = false;
        }
      }
      return ret;
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    emit(ev, ...args) {
      const data = args[0];
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
        return false;
      } else if (ev === "data") {
        return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
      } else if (ev === "end") {
        return this[EMITEND]();
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return false;
        const ret2 = super.emit("close");
        this.removeAllListeners("close");
        return ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR] = data;
        super.emit(ERROR, data);
        const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret2;
      }
      const ret = super.emit(ev, ...args);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITDATA](data) {
      for (const p of this[PIPES]) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret = this[DISCARDED] ? false : super.emit("data", data);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITEND]() {
      if (this[EMITTED_END])
        return false;
      this[EMITTED_END] = true;
      this.readable = false;
      return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
    }
    [EMITEND2]() {
      if (this[DECODER]) {
        const data = this[DECODER].end();
        if (data) {
          for (const p of this[PIPES]) {
            p.dest.write(data);
          }
          if (!this[DISCARDED])
            super.emit("data", data);
        }
      }
      for (const p of this[PIPES]) {
        p.end();
      }
      const ret = super.emit("end");
      this.removeAllListeners("end");
      return ret;
    }
    async collect() {
      const buf = Object.assign([], {
        dataLength: 0
      });
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      await p;
      return buf;
    }
    async concat() {
      if (this[OBJECTMODE]) {
        throw new Error("cannot concat in objectMode");
      }
      const buf = await this.collect();
      return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
    }
    async promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve());
      });
    }
    [Symbol.asyncIterator]() {
      this[DISCARDED] = false;
      let stopped = false;
      const stop = async () => {
        this.pause();
        stopped = true;
        return { value: undefined, done: true };
      };
      const next = () => {
        if (stopped)
          return stop();
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF])
          return stop();
        let resolve;
        let reject;
        const onerr = (er) => {
          this.off("data", ondata);
          this.off("end", onend);
          this.off(DESTROYED, ondestroy);
          stop();
          reject(er);
        };
        const ondata = (value) => {
          this.off("error", onerr);
          this.off("end", onend);
          this.off(DESTROYED, ondestroy);
          this.pause();
          resolve({ value, done: !!this[EOF] });
        };
        const onend = () => {
          this.off("error", onerr);
          this.off("data", ondata);
          this.off(DESTROYED, ondestroy);
          stop();
          resolve({ done: true, value: undefined });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.asyncIterator]() {
          return this;
        },
        [Symbol.asyncDispose]: async () => {}
      };
    }
    [Symbol.iterator]() {
      this[DISCARDED] = false;
      let stopped = false;
      const stop = () => {
        this.pause();
        this.off(ERROR, stop);
        this.off(DESTROYED, stop);
        this.off("end", stop);
        stopped = true;
        return { done: true, value: undefined };
      };
      const next = () => {
        if (stopped)
          return stop();
        const value = this.read();
        return value === null ? stop() : { done: false, value };
      };
      this.once("end", stop);
      this.once(ERROR, stop);
      this.once(DESTROYED, stop);
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.iterator]() {
          return this;
        },
        [Symbol.dispose]: () => {}
      };
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this[DISCARDED] = true;
      this[BUFFER].length = 0;
      this[BUFFERLENGTH] = 0;
      const wc = this;
      if (typeof wc.close === "function" && !this[CLOSED])
        wc.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static get isStream() {
      return exports.isStream;
    }
  }
  exports.Minipass = Minipass;
});

// node_modules/minizlib/dist/commonjs/constants.js
var require_constants = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.constants = undefined;
  var zlib_1 = __importDefault(__require("zlib"));
  var realZlibConstants = zlib_1.default.constants || { ZLIB_VERNUM: 4736 };
  exports.constants = Object.freeze(Object.assign(Object.create(null), {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
  }, realZlibConstants));
});

// node_modules/minizlib/dist/commonjs/index.js
var require_commonjs2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ZstdDecompress = exports.ZstdCompress = exports.BrotliDecompress = exports.BrotliCompress = exports.Unzip = exports.InflateRaw = exports.DeflateRaw = exports.Gunzip = exports.Gzip = exports.Inflate = exports.Deflate = exports.Zlib = exports.ZlibError = exports.constants = undefined;
  var assert_1 = __importDefault(__require("assert"));
  var buffer_1 = __require("buffer");
  var minipass_1 = require_commonjs();
  var realZlib = __importStar(__require("zlib"));
  var constants_js_1 = require_constants();
  var constants_js_2 = require_constants();
  Object.defineProperty(exports, "constants", { enumerable: true, get: function() {
    return constants_js_2.constants;
  } });
  var OriginalBufferConcat = buffer_1.Buffer.concat;
  var desc = Object.getOwnPropertyDescriptor(buffer_1.Buffer, "concat");
  var noop = (args) => args;
  var passthroughBufferConcat = desc?.writable === true || desc?.set !== undefined ? (makeNoOp) => {
    buffer_1.Buffer.concat = makeNoOp ? noop : OriginalBufferConcat;
  } : (_) => {};
  var _superWrite = Symbol("_superWrite");

  class ZlibError extends Error {
    code;
    errno;
    constructor(err, origin) {
      super("zlib: " + err.message, { cause: err });
      this.code = err.code;
      this.errno = err.errno;
      if (!this.code)
        this.code = "ZLIB_ERROR";
      this.message = "zlib: " + err.message;
      Error.captureStackTrace(this, origin ?? this.constructor);
    }
    get name() {
      return "ZlibError";
    }
  }
  exports.ZlibError = ZlibError;
  var _flushFlag = Symbol("flushFlag");

  class ZlibBase extends minipass_1.Minipass {
    #sawError = false;
    #ended = false;
    #flushFlag;
    #finishFlushFlag;
    #fullFlushFlag;
    #handle;
    #onError;
    get sawError() {
      return this.#sawError;
    }
    get handle() {
      return this.#handle;
    }
    get flushFlag() {
      return this.#flushFlag;
    }
    constructor(opts, mode) {
      if (!opts || typeof opts !== "object")
        throw new TypeError("invalid options for ZlibBase constructor");
      super(opts);
      this.#flushFlag = opts.flush ?? 0;
      this.#finishFlushFlag = opts.finishFlush ?? 0;
      this.#fullFlushFlag = opts.fullFlushFlag ?? 0;
      if (typeof realZlib[mode] !== "function") {
        throw new TypeError("Compression method not supported: " + mode);
      }
      try {
        this.#handle = new realZlib[mode](opts);
      } catch (er) {
        throw new ZlibError(er, this.constructor);
      }
      this.#onError = (err) => {
        if (this.#sawError)
          return;
        this.#sawError = true;
        this.close();
        this.emit("error", err);
      };
      this.#handle?.on("error", (er) => this.#onError(new ZlibError(er)));
      this.once("end", () => this.close);
    }
    close() {
      if (this.#handle) {
        this.#handle.close();
        this.#handle = undefined;
        this.emit("close");
      }
    }
    reset() {
      if (!this.#sawError) {
        (0, assert_1.default)(this.#handle, "zlib binding closed");
        return this.#handle.reset?.();
      }
    }
    flush(flushFlag) {
      if (this.ended)
        return;
      if (typeof flushFlag !== "number")
        flushFlag = this.#fullFlushFlag;
      this.write(Object.assign(buffer_1.Buffer.alloc(0), { [_flushFlag]: flushFlag }));
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function") {
        cb = chunk;
        encoding = undefined;
        chunk = undefined;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = undefined;
      }
      if (chunk) {
        if (encoding)
          this.write(chunk, encoding);
        else
          this.write(chunk);
      }
      this.flush(this.#finishFlushFlag);
      this.#ended = true;
      return super.end(cb);
    }
    get ended() {
      return this.#ended;
    }
    [_superWrite](data) {
      return super.write(data);
    }
    write(chunk, encoding, cb) {
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (typeof chunk === "string")
        chunk = buffer_1.Buffer.from(chunk, encoding);
      if (this.#sawError)
        return;
      (0, assert_1.default)(this.#handle, "zlib binding closed");
      const nativeHandle = this.#handle._handle;
      const originalNativeClose = nativeHandle.close;
      nativeHandle.close = () => {};
      const originalClose = this.#handle.close;
      this.#handle.close = () => {};
      passthroughBufferConcat(true);
      let result = undefined;
      try {
        const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this.#flushFlag;
        result = this.#handle._processChunk(chunk, flushFlag);
        passthroughBufferConcat(false);
      } catch (err) {
        passthroughBufferConcat(false);
        this.#onError(new ZlibError(err, this.write));
      } finally {
        if (this.#handle) {
          this.#handle._handle = nativeHandle;
          nativeHandle.close = originalNativeClose;
          this.#handle.close = originalClose;
          this.#handle.removeAllListeners("error");
        }
      }
      if (this.#handle)
        this.#handle.on("error", (er) => this.#onError(new ZlibError(er, this.write)));
      let writeReturn;
      if (result) {
        if (Array.isArray(result) && result.length > 0) {
          const r = result[0];
          writeReturn = this[_superWrite](buffer_1.Buffer.from(r));
          for (let i = 1;i < result.length; i++) {
            writeReturn = this[_superWrite](result[i]);
          }
        } else {
          writeReturn = this[_superWrite](buffer_1.Buffer.from(result));
        }
      }
      if (cb)
        cb();
      return writeReturn;
    }
  }

  class Zlib extends ZlibBase {
    #level;
    #strategy;
    constructor(opts, mode) {
      opts = opts || {};
      opts.flush = opts.flush || constants_js_1.constants.Z_NO_FLUSH;
      opts.finishFlush = opts.finishFlush || constants_js_1.constants.Z_FINISH;
      opts.fullFlushFlag = constants_js_1.constants.Z_FULL_FLUSH;
      super(opts, mode);
      this.#level = opts.level;
      this.#strategy = opts.strategy;
    }
    params(level, strategy) {
      if (this.sawError)
        return;
      if (!this.handle)
        throw new Error("cannot switch params when binding is closed");
      if (!this.handle.params)
        throw new Error("not supported in this implementation");
      if (this.#level !== level || this.#strategy !== strategy) {
        this.flush(constants_js_1.constants.Z_SYNC_FLUSH);
        (0, assert_1.default)(this.handle, "zlib binding closed");
        const origFlush = this.handle.flush;
        this.handle.flush = (flushFlag, cb) => {
          if (typeof flushFlag === "function") {
            cb = flushFlag;
            flushFlag = this.flushFlag;
          }
          this.flush(flushFlag);
          cb?.();
        };
        try {
          this.handle.params(level, strategy);
        } finally {
          this.handle.flush = origFlush;
        }
        if (this.handle) {
          this.#level = level;
          this.#strategy = strategy;
        }
      }
    }
  }
  exports.Zlib = Zlib;

  class Deflate extends Zlib {
    constructor(opts) {
      super(opts, "Deflate");
    }
  }
  exports.Deflate = Deflate;

  class Inflate extends Zlib {
    constructor(opts) {
      super(opts, "Inflate");
    }
  }
  exports.Inflate = Inflate;

  class Gzip extends Zlib {
    #portable;
    constructor(opts) {
      super(opts, "Gzip");
      this.#portable = opts && !!opts.portable;
    }
    [_superWrite](data) {
      if (!this.#portable)
        return super[_superWrite](data);
      this.#portable = false;
      data[9] = 255;
      return super[_superWrite](data);
    }
  }
  exports.Gzip = Gzip;

  class Gunzip extends Zlib {
    constructor(opts) {
      super(opts, "Gunzip");
    }
  }
  exports.Gunzip = Gunzip;

  class DeflateRaw extends Zlib {
    constructor(opts) {
      super(opts, "DeflateRaw");
    }
  }
  exports.DeflateRaw = DeflateRaw;

  class InflateRaw extends Zlib {
    constructor(opts) {
      super(opts, "InflateRaw");
    }
  }
  exports.InflateRaw = InflateRaw;

  class Unzip extends Zlib {
    constructor(opts) {
      super(opts, "Unzip");
    }
  }
  exports.Unzip = Unzip;

  class Brotli extends ZlibBase {
    constructor(opts, mode) {
      opts = opts || {};
      opts.flush = opts.flush || constants_js_1.constants.BROTLI_OPERATION_PROCESS;
      opts.finishFlush = opts.finishFlush || constants_js_1.constants.BROTLI_OPERATION_FINISH;
      opts.fullFlushFlag = constants_js_1.constants.BROTLI_OPERATION_FLUSH;
      super(opts, mode);
    }
  }

  class BrotliCompress extends Brotli {
    constructor(opts) {
      super(opts, "BrotliCompress");
    }
  }
  exports.BrotliCompress = BrotliCompress;

  class BrotliDecompress extends Brotli {
    constructor(opts) {
      super(opts, "BrotliDecompress");
    }
  }
  exports.BrotliDecompress = BrotliDecompress;

  class Zstd extends ZlibBase {
    constructor(opts, mode) {
      opts = opts || {};
      opts.flush = opts.flush || constants_js_1.constants.ZSTD_e_continue;
      opts.finishFlush = opts.finishFlush || constants_js_1.constants.ZSTD_e_end;
      opts.fullFlushFlag = constants_js_1.constants.ZSTD_e_flush;
      super(opts, mode);
    }
  }

  class ZstdCompress extends Zstd {
    constructor(opts) {
      super(opts, "ZstdCompress");
    }
  }
  exports.ZstdCompress = ZstdCompress;

  class ZstdDecompress extends Zstd {
    constructor(opts) {
      super(opts, "ZstdDecompress");
    }
  }
  exports.ZstdDecompress = ZstdDecompress;
});

// node_modules/minipass-sized/dist/commonjs/index.js
var require_commonjs3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MinipassSized = exports.SizeError = undefined;
  var minipass_1 = require_commonjs();
  var isBufferEncoding = (enc) => typeof enc === "string";

  class SizeError extends Error {
    expect;
    found;
    code = "EBADSIZE";
    constructor(found, expect, from) {
      super(`Bad data size: expected ${expect} bytes, but got ${found}`);
      this.expect = expect;
      this.found = found;
      Error.captureStackTrace(this, from ?? this.constructor);
    }
    get name() {
      return "SizeError";
    }
  }
  exports.SizeError = SizeError;

  class MinipassSized extends minipass_1.Minipass {
    found = 0;
    expect;
    constructor(options) {
      const size = options?.size;
      if (typeof size !== "number" || size > Number.MAX_SAFE_INTEGER || isNaN(size) || size < 0 || !isFinite(size) || size !== Math.floor(size)) {
        throw new Error("invalid expected size: " + size);
      }
      super(options);
      if (options.objectMode) {
        throw new TypeError(`${this.constructor.name} streams only work with string and buffer data`);
      }
      this.expect = size;
    }
    write(chunk, encoding, cb) {
      const buffer = Buffer.isBuffer(chunk) ? chunk : typeof chunk === "string" ? Buffer.from(chunk, isBufferEncoding(encoding) ? encoding : "utf8") : chunk;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (!Buffer.isBuffer(buffer)) {
        this.emit("error", new TypeError(`${this.constructor.name} streams only work with string and buffer data`));
        return false;
      }
      this.found += buffer.length;
      if (this.found > this.expect)
        this.emit("error", new SizeError(this.found, this.expect));
      return super.write(chunk, encoding, cb);
    }
    emit(ev, ...args) {
      if (ev === "end") {
        if (this.found !== this.expect) {
          this.emit("error", new SizeError(this.found, this.expect, this.emit));
        }
      }
      return super.emit(ev, ...args);
    }
  }
  exports.MinipassSized = MinipassSized;
});

// node_modules/minipass-fetch/lib/blob.js
var require_blob = __commonJS((exports, module) => {
  var { Minipass } = require_commonjs();
  var TYPE = Symbol("type");
  var BUFFER = Symbol("buffer");

  class Blob2 {
    constructor(blobParts, options) {
      this[TYPE] = "";
      const buffers = [];
      let size = 0;
      if (blobParts) {
        const a = blobParts;
        const length = Number(a.length);
        for (let i = 0;i < length; i++) {
          const element = a[i];
          const buffer = element instanceof Buffer ? element : ArrayBuffer.isView(element) ? Buffer.from(element.buffer, element.byteOffset, element.byteLength) : element instanceof ArrayBuffer ? Buffer.from(element) : element instanceof Blob2 ? element[BUFFER] : typeof element === "string" ? Buffer.from(element) : Buffer.from(String(element));
          size += buffer.length;
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers, size);
      const type = options && options.type !== undefined && String(options.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    text() {
      return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
      const buf = this[BUFFER];
      const off = buf.byteOffset;
      const len = buf.byteLength;
      const ab = buf.buffer.slice(off, off + len);
      return Promise.resolve(ab);
    }
    stream() {
      return new Minipass().end(this[BUFFER]);
    }
    slice(start, end, type) {
      const size = this.size;
      const relativeStart = start === undefined ? 0 : start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
      const relativeEnd = end === undefined ? size : end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob2([], { type });
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
    get [Symbol.toStringTag]() {
      return "Blob";
    }
    static get BUFFER() {
      return BUFFER;
    }
  }
  Object.defineProperties(Blob2.prototype, {
    size: { enumerable: true },
    type: { enumerable: true }
  });
  module.exports = Blob2;
});

// node_modules/minipass-fetch/lib/fetch-error.js
var require_fetch_error = __commonJS((exports, module) => {
  class FetchError extends Error {
    constructor(message3, type, systemError) {
      super(message3);
      this.code = "FETCH_ERROR";
      if (systemError) {
        Object.assign(this, systemError);
      }
      this.errno = this.code;
      this.type = this.code === "EBADSIZE" && this.found > this.expect ? "max-size" : type;
      this.message = message3;
      Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return "FetchError";
    }
    set name(n) {}
    get [Symbol.toStringTag]() {
      return "FetchError";
    }
  }
  module.exports = FetchError;
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS((exports, module) => {
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key))
      continue;
    if (key === "SlowBuffer" || key === "Buffer")
      continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key))
      continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow")
      continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {}
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  module.exports = safer;
});

// node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS((exports) => {
  var BOMChar = "\uFEFF";
  exports.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder2, options) {
    this.encoder = encoder2;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  exports.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder2, options) {
    this.decoder = decoder2;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res) {
      return res;
    }
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function") {
        this.options.stripBOM();
      }
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
});

// node_modules/iconv-lite/lib/helpers/merge-exports.js
var require_merge_exports = __commonJS((exports, module) => {
  var hasOwn = typeof Object.hasOwn === "undefined" ? Function.call.bind(Object.prototype.hasOwnProperty) : Object.hasOwn;
  function mergeModules(target, module2) {
    for (var key in module2) {
      if (hasOwn(module2, key)) {
        target[key] = module2[key];
      }
    }
  }
  module.exports = mergeModules;
});

// node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  module.exports = {
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64") {
      this.encoder = InternalEncoderBase64;
    } else if (this.enc === "utf8") {
      this.encoder = InternalEncoderUtf8;
    } else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "\uD83D\uDCA9") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = __require("string_decoder").StringDecoder;
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
  }
  InternalDecoder.prototype.write = function(buf) {
    if (!Buffer2.isBuffer(buf)) {
      buf = Buffer2.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function() {
    return this.decoder.end();
  };
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {};
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {}
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3);
    var bufIdx = 0;
    for (var i = 0;i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128) {
        buf[bufIdx++] = charCode;
      } else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {};
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc;
    var contBytes = this.contBytes;
    var accBytes = this.accBytes;
    var res = "";
    for (var i = 0;i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0) {
              res += this.defaultCharUnicode;
            } else if (accBytes === 3 && acc < 2048) {
              res += this.defaultCharUnicode;
            } else {
              res += String.fromCharCode(acc);
            }
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0) {
      res += this.defaultCharUnicode;
    }
    return res;
  };
  function InternalEncoderUtf8(options, codec) {
    this.highSurrogate = "";
  }
  InternalEncoderUtf8.prototype.write = function(str) {
    if (this.highSurrogate) {
      str = this.highSurrogate + str;
      this.highSurrogate = "";
    }
    if (str.length > 0) {
      var charCode = str.charCodeAt(str.length - 1);
      if (charCode >= 55296 && charCode < 56320) {
        this.highSurrogate = str[str.length - 1];
        str = str.slice(0, str.length - 1);
      }
    }
    return Buffer2.from(str, this.enc);
  };
  InternalEncoderUtf8.prototype.end = function() {
    if (this.highSurrogate) {
      var str = this.highSurrogate;
      this.highSurrogate = "";
      return Buffer2.from(str, this.enc);
    }
  };
});

// node_modules/iconv-lite/encodings/utf32.js
var require_utf32 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  exports.utf32le = { type: "_utf32", isLE: true };
  exports.utf32be = { type: "_utf32", isLE: false };
  exports.ucs4le = "utf32le";
  exports.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str) {
    var src = Buffer2.from(str, "ucs2");
    var dst = Buffer2.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset2 = 0;
    for (var i = 0;i < src.length; i += 2) {
      var code = src.readUInt16LE(i);
      var isHighSurrogate = code >= 55296 && code < 56320;
      var isLowSurrogate = code >= 56320 && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset2);
          offset2 += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset2);
          offset2 += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate) {
        this.highSurrogate = code;
      } else {
        write32.call(dst, code, offset2);
        offset2 += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset2 < dst.length) {
      dst = dst.slice(0, offset2);
    }
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate) {
      return;
    }
    var buf = Buffer2.alloc(4);
    if (this.isLE) {
      buf.writeUInt32LE(this.highSurrogate, 0);
    } else {
      buf.writeUInt32BE(this.highSurrogate, 0);
    }
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function(src) {
    if (src.length === 0) {
      return "";
    }
    var i = 0;
    var codepoint = 0;
    var dst = Buffer2.alloc(src.length + 4);
    var offset2 = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (;i < src.length && overflow.length < 4; i++) {
        overflow.push(src[i]);
      }
      if (overflow.length === 4) {
        if (isLE) {
          codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
        } else {
          codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
        }
        overflow.length = 0;
        offset2 = _writeCodepoint(dst, offset2, codepoint, badChar);
      }
    }
    for (;i < src.length - 3; i += 4) {
      if (isLE) {
        codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
      } else {
        codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
      }
      offset2 = _writeCodepoint(dst, offset2, codepoint, badChar);
    }
    for (;i < src.length; i++) {
      overflow.push(src[i]);
    }
    return dst.slice(0, offset2).toString("ucs2");
  };
  function _writeCodepoint(dst, offset2, codepoint, badChar) {
    if (codepoint < 0 || codepoint > 1114111) {
      codepoint = badChar;
    }
    if (codepoint >= 65536) {
      codepoint -= 65536;
      var high = 55296 | codepoint >> 10;
      dst[offset2++] = high & 255;
      dst[offset2++] = high >> 8;
      var codepoint = 56320 | codepoint & 1023;
    }
    dst[offset2++] = codepoint & 255;
    dst[offset2++] = codepoint >> 8;
    return offset2;
  }
  Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
  };
  exports.utf32 = Utf32AutoCodec;
  exports.ucs4 = "utf32";
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined) {
      options.addBOM = true;
    }
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32) {
        return "";
      }
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0;i < this.initialBufs.length; i++) {
        resStr += this.decoder.write(this.initialBufs[i]);
      }
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0;i < this.initialBufs.length; i++) {
        resStr += this.decoder.write(this.initialBufs[i]);
      }
      var trail = this.decoder.end();
      if (trail) {
        resStr += trail;
      }
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0;
    var invalidBE = 0;
    var bmpCharsLE = 0;
    var bmpCharsBE = 0;
    outerLoop:
      for (var i = 0;i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0;j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 4) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                return "utf-32le";
              }
              if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                return "utf-32be";
              }
            }
            if (b[0] !== 0 || b[1] > 16)
              invalidBE++;
            if (b[3] !== 0 || b[2] > 16)
              invalidLE++;
            if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0))
              bmpCharsBE++;
            if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0)
              bmpCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outerLoop;
            }
          }
        }
      }
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE)
      return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE)
      return "utf-32le";
    return defaultEncoding || "utf-32le";
  }
});

// node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports.utf16be = Utf16BECodec;
  function Utf16BECodec() {}
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {}
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0;i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {};
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0) {
      return "";
    }
    var buf2 = Buffer2.alloc(buf.length + 1);
    var i = 0;
    var j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (;i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
  };
  exports.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined) {
      options.addBOM = true;
    }
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16) {
        return "";
      }
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0;i < this.initialBufs.length; i++) {
        resStr += this.decoder.write(this.initialBufs[i]);
      }
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0;i < this.initialBufs.length; i++) {
        resStr += this.decoder.write(this.initialBufs[i]);
      }
      var trail = this.decoder.end();
      if (trail) {
        resStr += trail;
      }
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0;
    var asciiCharsBE = 0;
    outerLoop:
      for (var i = 0;i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0;j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 2) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254)
                return "utf-16le";
              if (b[0] === 254 && b[1] === 255)
                return "utf-16be";
            }
            if (b[0] === 0 && b[1] !== 0)
              asciiCharsBE++;
            if (b[0] !== 0 && b[1] === 0)
              asciiCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outerLoop;
            }
          }
        }
      }
    if (asciiCharsBE > asciiCharsLE)
      return "utf-16be";
    if (asciiCharsBE < asciiCharsLE)
      return "utf-16le";
    return defaultEncoding || "utf-16le";
  }
});

// node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports.utf7 = Utf7Codec;
  exports.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {};
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (i = 0;i < 256; i++) {
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  }
  var i;
  var plusChar = 43;
  var minusChar = 45;
  var andChar = 38;
  Utf7Decoder.prototype.write = function(buf) {
    var res = "";
    var lastI = 0;
    var inBase64 = this.inBase64;
    var base64Accum = this.base64Accum;
    for (var i2 = 0;i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar) {
            i2--;
          }
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) {
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    }
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  exports.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64;
    var base64Accum = this.base64Accum;
    var base64AccumIdx = this.base64AccumIdx;
    var buf = Buffer2.alloc(str.length * 5 + 10);
    var bufIdx = 0;
    for (var i2 = 0;i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (uChar >= 32 && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar) {
            buf[bufIdx++] = minusChar;
          }
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10);
    var bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[44] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "";
    var lastI = 0;
    var inBase64 = this.inBase64;
    var base64Accum = this.base64Accum;
    for (var i2 = 0;i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar) {
            i2--;
          }
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) {
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    }
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
});

// node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions) {
      throw new Error("SBCS codec is called without the data.");
    }
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) {
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    }
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0;i < 128; i++) {
        asciiString += String.fromCharCode(i);
      }
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0;i < codecOptions.chars.length; i++) {
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    }
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0;i < str.length; i++) {
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    }
    return buf;
  };
  SBCSEncoder.prototype.end = function() {};
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0;
    var idx2 = 0;
    for (var i = 0;i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {};
});

// node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS((exports, module) => {
  module.exports = {
    10029: "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: ""
    },
    808: "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: ""
    },
    mik: {
      type: "_sbcs",
      chars: ""
    },
    cp720: {
      type: "_sbcs",
      chars: ""
    },
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    1e4: "macroman",
    10006: "macgreek",
    10007: "maccyrillic",
    10079: "maciceland",
    10081: "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    20866: "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    21866: "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  };
});

// node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS((exports, module) => {
  module.exports = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    windows874: {
      type: "_sbcs",
      chars: ""
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: ""
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: ""
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: ""
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: ""
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: ""
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: ""
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: ""
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: ""
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: ""
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: ""
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: ""
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: ""
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: ""
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: ""
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: ""
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: ""
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: ""
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: ""
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: ""
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: ""
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: ""
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: ""
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: ""
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: ""
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: ""
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: ""
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: ""
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: ""
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: ""
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: ""
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: ""
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: ""
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: ""
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: ""
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: ""
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: ""
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: ""
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: ""
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: ""
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: ""
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: ""
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: ""
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: ""
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: ""
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: ""
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: ""
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: ""
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: ""
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: ""
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: ""
    },
    maccyrillic: {
      type: "_sbcs",
      chars: ""
    },
    macgreek: {
      type: "_sbcs",
      chars: ""
    },
    maciceland: {
      type: "_sbcs",
      chars: ""
    },
    macroman: {
      type: "_sbcs",
      chars: ""
    },
    macromania: {
      type: "_sbcs",
      chars: ""
    },
    macthai: {
      type: "_sbcs",
      chars: "\uFEFF"
    },
    macturkish: {
      type: "_sbcs",
      chars: ""
    },
    macukraine: {
      type: "_sbcs",
      chars: ""
    },
    koi8r: {
      type: "_sbcs",
      chars: ""
    },
    koi8u: {
      type: "_sbcs",
      chars: ""
    },
    koi8ru: {
      type: "_sbcs",
      chars: ""
    },
    koi8t: {
      type: "_sbcs",
      chars: ""
    },
    armscii8: {
      type: "_sbcs",
      chars: ")(.,-"
    },
    rk1048: {
      type: "_sbcs",
      chars: ""
    },
    tcvn: {
      type: "_sbcs",
      chars: `\x00\x03\x07\b	
\v\f\r\x0E\x0F\x10\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    georgianacademy: {
      type: "_sbcs",
      chars: ""
    },
    georgianps: {
      type: "_sbcs",
      chars: ""
    },
    pt154: {
      type: "_sbcs",
      chars: ""
    },
    viscii: {
      type: "_sbcs",
      chars: `\x00\x01\x03\x04\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x15\x16\x17\x18\x1A\x1B\x1C\x1D\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    iso646cn: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    iso646jp: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    hproman8: {
      type: "_sbcs",
      chars: ""
    },
    macintosh: {
      type: "_sbcs",
      chars: ""
    },
    ascii: {
      type: "_sbcs",
      chars: ""
    },
    tis620: {
      type: "_sbcs",
      chars: ""
    }
  };
});

// node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._dbcs = DBCSCodec;
  var UNASSIGNED = -1;
  var GB18030_CODE = -2;
  var SEQ_START = -10;
  var NODE_START = -1000;
  var UNASSIGNED_NODE = new Array(256);
  var DEF_CHAR = -1;
  for (i = 0;i < 256; i++) {
    UNASSIGNED_NODE[i] = UNASSIGNED;
  }
  var i;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions) {
      throw new Error("DBCS codec is called without the data.");
    }
    if (!codecOptions.table) {
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    }
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0;i2 < mappingTable.length; i2++) {
      this._addDecodeChunk(mappingTable[i2]);
    }
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var firstByteNode = this.decodeTables[0];
      for (var i2 = 129;i2 <= 254; i2++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
        for (var j = 48;j <= 57; j++) {
          if (secondByteNode[j] === UNASSIGNED) {
            secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
          for (var k = 129;k <= 254; k++) {
            if (thirdByteNode[k] === UNASSIGNED) {
              thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
            for (var l = 48;l <= 57; l++) {
              if (fourthByteNode[l] === UNASSIGNED) {
                fourthByteNode[l] = GB18030_CODE;
              }
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals) {
      for (var i2 = 0;i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number") {
          skipEncodeChars[val] = true;
        } else {
          for (var j = val.from;j <= val.to; j++) {
            skipEncodeChars[j] = true;
          }
        }
      }
    }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd) {
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) {
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
        }
      }
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = 63;
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (;addr > 0; addr >>>= 8) {
      bytes.push(addr & 255);
    }
    if (bytes.length == 0) {
      bytes.push(0);
    }
    var node = this.decodeTables[0];
    for (var i2 = bytes.length - 1;i2 > 0; i2--) {
      var val = node[bytes[i2]];
      if (val == UNASSIGNED) {
        node[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else {
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
      }
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1;k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0;l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (code >= 55296 && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (codeTrail >= 56320 && codeTrail < 57344) {
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            } else {
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
            }
          } else if (code > 4080 && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m = 0;m < len; m++) {
              seq.push(part.charCodeAt(l++));
            }
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else {
            writeTable[curAddr++] = code;
          }
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0;l < part; l++) {
          writeTable[curAddr++] = charCode++;
        }
      } else {
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
      }
    }
    if (curAddr > 255) {
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    }
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === undefined) {
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    }
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START) {
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    } else if (bucket[low] == UNASSIGNED) {
      bucket[low] = dbcsCode;
    }
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED)
        node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j = 1;j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object") {
        node = oldVal;
      } else {
        node = node[uCode] = {};
        if (oldVal !== undefined) {
          node[DEF_CHAR] = oldVal;
        }
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i2 = 0;i2 < 256; i2++) {
      var uCode = node[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode]) {
        continue;
      }
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          var newPrefix = mbCode << 8 >>> 0;
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) {
            hasValues = true;
          } else {
            subNodeEmpty[subNodeIdx] = true;
          }
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3));
    var leadSurrogate = this.leadSurrogate;
    var seqObj = this.seqObj;
    var nextChar = -1;
    var i2 = 0;
    var j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length)
          break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (uCode >= 55296 && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== undefined && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode === "number") {
          dbcsCode = resCode;
        } else if (resCode == undefined) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== undefined) {
            dbcsCode = resCode;
            nextChar = uCode;
          } else {}
        }
        seqObj = undefined;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== undefined) {
          dbcsCode = subtable[uCode & 255];
        }
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED) {
        dbcsCode = this.defaultCharSingleByte;
      }
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else if (dbcsCode < 16777216) {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >>> 24;
        newBuf[j++] = dbcsCode >>> 16 & 255;
        newBuf[j++] = dbcsCode >>> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined) {
      return;
    }
    var newBuf = Buffer2.alloc(10);
    var j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== undefined) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      } else {}
      this.seqObj = undefined;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBytes = [];
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2);
    var nodeIdx = this.nodeIdx;
    var prevBytes = this.prevBytes;
    var prevOffset = this.prevBytes.length;
    var seqStart = -this.prevBytes.length;
    var uCode;
    for (var i2 = 0, j = 0;i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) {} else if (uCode === UNASSIGNED) {
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i2 = seqStart;
      } else if (uCode === GB18030_CODE) {
        if (i2 >= 3) {
          var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
        } else {
          var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0;k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else {
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      }
      if (uCode >= 65536) {
        uCode -= 65536;
        var uCodeLead = 55296 | uCode >> 10;
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 | uCode & 1023;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBytes.length > 0) {
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0) {
        ret += this.write(bytesArr);
      }
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val) {
      return -1;
    }
    var l = 0;
    var r = table.length;
    while (l < r - 1) {
      var mid = l + (r - l + 1 >> 1);
      if (table[mid] <= val) {
        l = mid;
      } else {
        r = mid;
      }
    }
    return l;
  }
});

// node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 128],
    ["a1", "", 62],
    ["8140", "", 9, ""],
    ["8180", ""],
    ["81b8", ""],
    ["81c8", ""],
    ["81da", ""],
    ["81f0", ""],
    ["81fc", ""],
    ["824f", "", 9],
    ["8260", "", 25],
    ["8281", "", 25],
    ["829f", "", 82],
    ["8340", "", 62],
    ["8380", "", 22],
    ["839f", "", 16, "", 6],
    ["83bf", "", 16, "", 6],
    ["8440", "", 5, "", 25],
    ["8470", "", 5, "", 7],
    ["8480", "", 17],
    ["849f", ""],
    ["8740", "", 19, "", 9],
    ["875f", ""],
    ["877e", ""],
    ["8780", "", 4, ""],
    ["889f", ""],
    ["8940", ""],
    ["8980", ""],
    ["8a40", ""],
    ["8a80", ""],
    ["8b40", ""],
    ["8b80", ""],
    ["8c40", ""],
    ["8c80", ""],
    ["8d40", ""],
    ["8d80", ""],
    ["8e40", ""],
    ["8e80", ""],
    ["8f40", ""],
    ["8f80", ""],
    ["9040", ""],
    ["9080", ""],
    ["9140", ""],
    ["9180", ""],
    ["9240", ""],
    ["9280", ""],
    ["9340", ""],
    ["9380", ""],
    ["9440", ""],
    ["9480", ""],
    ["9540", ""],
    ["9580", ""],
    ["9640", ""],
    ["9680", ""],
    ["9740", ""],
    ["9780", ""],
    ["9840", ""],
    ["989f", ""],
    ["9940", ""],
    ["9980", ""],
    ["9a40", ""],
    ["9a80", ""],
    ["9b40", ""],
    ["9b80", ""],
    ["9c40", ""],
    ["9c80", ""],
    ["9d40", ""],
    ["9d80", ""],
    ["9e40", ""],
    ["9e80", ""],
    ["9f40", ""],
    ["9f80", ""],
    ["e040", ""],
    ["e080", ""],
    ["e140", ""],
    ["e180", ""],
    ["e240", ""],
    ["e280", ""],
    ["e340", ""],
    ["e380", ""],
    ["e440", ""],
    ["e480", ""],
    ["e540", ""],
    ["e580", ""],
    ["e640", ""],
    ["e680", ""],
    ["e740", ""],
    ["e780", ""],
    ["e840", ""],
    ["e880", ""],
    ["e940", ""],
    ["e980", ""],
    ["ea40", ""],
    ["ea80", ""],
    ["ed40", ""],
    ["ed80", ""],
    ["ee40", ""],
    ["ee80", ""],
    ["eeef", "", 9, ""],
    ["f040", "", 62],
    ["f080", "", 124],
    ["f140", "", 62],
    ["f180", "", 124],
    ["f240", "", 62],
    ["f280", "", 124],
    ["f340", "", 62],
    ["f380", "", 124],
    ["f440", "", 62],
    ["f480", "", 124],
    ["f540", "", 62],
    ["f580", "", 124],
    ["f640", "", 62],
    ["f680", "", 124],
    ["f740", "", 62],
    ["f780", "", 124],
    ["f840", "", 62],
    ["f880", "", 124],
    ["f940", ""],
    ["fa40", "", 9, "", 9, ""],
    ["fa80", ""],
    ["fb40", ""],
    ["fb80", ""],
    ["fc40", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["8ea1", "", 62],
    ["a1a1", "", 9, ""],
    ["a2a1", ""],
    ["a2ba", ""],
    ["a2ca", ""],
    ["a2dc", ""],
    ["a2f2", ""],
    ["a2fe", ""],
    ["a3b0", "", 9],
    ["a3c1", "", 25],
    ["a3e1", "", 25],
    ["a4a1", "", 82],
    ["a5a1", "", 85],
    ["a6a1", "", 16, "", 6],
    ["a6c1", "", 16, "", 6],
    ["a7a1", "", 5, "", 25],
    ["a7d1", "", 5, "", 25],
    ["a8a1", ""],
    ["ada1", "", 19, "", 9],
    ["adc0", ""],
    ["addf", "", 4, ""],
    ["b0a1", ""],
    ["b1a1", ""],
    ["b2a1", ""],
    ["b3a1", ""],
    ["b4a1", ""],
    ["b5a1", ""],
    ["b6a1", ""],
    ["b7a1", ""],
    ["b8a1", ""],
    ["b9a1", ""],
    ["baa1", ""],
    ["bba1", ""],
    ["bca1", ""],
    ["bda1", ""],
    ["bea1", ""],
    ["bfa1", ""],
    ["c0a1", ""],
    ["c1a1", ""],
    ["c2a1", ""],
    ["c3a1", ""],
    ["c4a1", ""],
    ["c5a1", ""],
    ["c6a1", ""],
    ["c7a1", ""],
    ["c8a1", ""],
    ["c9a1", ""],
    ["caa1", ""],
    ["cba1", ""],
    ["cca1", ""],
    ["cda1", ""],
    ["cea1", ""],
    ["cfa1", ""],
    ["d0a1", ""],
    ["d1a1", ""],
    ["d2a1", ""],
    ["d3a1", ""],
    ["d4a1", ""],
    ["d5a1", ""],
    ["d6a1", ""],
    ["d7a1", ""],
    ["d8a1", ""],
    ["d9a1", ""],
    ["daa1", ""],
    ["dba1", ""],
    ["dca1", ""],
    ["dda1", ""],
    ["dea1", ""],
    ["dfa1", ""],
    ["e0a1", ""],
    ["e1a1", ""],
    ["e2a1", ""],
    ["e3a1", ""],
    ["e4a1", ""],
    ["e5a1", ""],
    ["e6a1", ""],
    ["e7a1", ""],
    ["e8a1", ""],
    ["e9a1", ""],
    ["eaa1", ""],
    ["eba1", ""],
    ["eca1", ""],
    ["eda1", ""],
    ["eea1", ""],
    ["efa1", ""],
    ["f0a1", ""],
    ["f1a1", ""],
    ["f2a1", ""],
    ["f3a1", ""],
    ["f4a1", ""],
    ["f9a1", ""],
    ["faa1", ""],
    ["fba1", ""],
    ["fca1", ""],
    ["fcf1", "", 9, ""],
    ["8fa2af", ""],
    ["8fa2c2", ""],
    ["8fa2eb", ""],
    ["8fa6e1", ""],
    ["8fa6e7", ""],
    ["8fa6e9", ""],
    ["8fa6ec", ""],
    ["8fa6f1", ""],
    ["8fa7c2", "", 10, ""],
    ["8fa7f2", "", 10, ""],
    ["8fa9a1", ""],
    ["8fa9a4", ""],
    ["8fa9a6", ""],
    ["8fa9a8", ""],
    ["8fa9ab", ""],
    ["8fa9af", ""],
    ["8fa9c1", ""],
    ["8faaa1", ""],
    ["8faaba", ""],
    ["8faba1", ""],
    ["8fabbd", ""],
    ["8fabc5", ""],
    ["8fb0a1", ""],
    ["8fb1a1", ""],
    ["8fb2a1", "", 4, ""],
    ["8fb3a1", ""],
    ["8fb4a1", ""],
    ["8fb5a1", ""],
    ["8fb6a1", "", 5, "", 4, ""],
    ["8fb7a1", "", 4, ""],
    ["8fb8a1", ""],
    ["8fb9a1", ""],
    ["8fbaa1", "", 4, ""],
    ["8fbba1", ""],
    ["8fbca1", "", 4, ""],
    ["8fbda1", "", 4, ""],
    ["8fbea1", "", 4, ""],
    ["8fbfa1", ""],
    ["8fc0a1", ""],
    ["8fc1a1", ""],
    ["8fc2a1", ""],
    ["8fc3a1", "", 4, ""],
    ["8fc4a1", ""],
    ["8fc5a1", ""],
    ["8fc6a1", ""],
    ["8fc7a1", ""],
    ["8fc8a1", ""],
    ["8fc9a1", "", 4, "", 4, ""],
    ["8fcaa1", ""],
    ["8fcba1", ""],
    ["8fcca1", "", 9, ""],
    ["8fcda1", "", 5, ""],
    ["8fcea1", "", 6, ""],
    ["8fcfa1", ""],
    ["8fd0a1", ""],
    ["8fd1a1", ""],
    ["8fd2a1", "", 5],
    ["8fd3a1", ""],
    ["8fd4a1", "", 4, ""],
    ["8fd5a1", ""],
    ["8fd6a1", ""],
    ["8fd7a1", ""],
    ["8fd8a1", ""],
    ["8fd9a1", "", 4, "", 6, ""],
    ["8fdaa1", "", 4, ""],
    ["8fdba1", "", 6, ""],
    ["8fdca1", "", 4, ""],
    ["8fdda1", "", 4, ""],
    ["8fdea1", "", 4, ""],
    ["8fdfa1", ""],
    ["8fe0a1", ""],
    ["8fe1a1", "", 4, ""],
    ["8fe2a1", ""],
    ["8fe3a1", "", 5, "", 4, ""],
    ["8fe4a1", "", 4, ""],
    ["8fe5a1", "", 4, ""],
    ["8fe6a1", ""],
    ["8fe7a1", ""],
    ["8fe8a1", "", 4, ""],
    ["8fe9a1", "", 4],
    ["8feaa1", "", 4, ""],
    ["8feba1", "", 4, ""],
    ["8feca1", ""],
    ["8feda1", "", 4, "", 4, ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127, ""],
    ["8140", "", 5, "", 9, "", 6, ""],
    ["8180", "", 6, "", 4, "", 4, "", 5, ""],
    ["8240", "", 4, "", 8, "", 4, "", 11],
    ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""],
    ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""],
    ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5],
    ["8440", "", 5, "", 5, ""],
    ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""],
    ["8540", "", 9, ""],
    ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""],
    ["8640", "", 4, "", 5, "", 4, "", 5, ""],
    ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""],
    ["8740", "", 7, "", 11, "", 4, "", 4],
    ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6],
    ["8840", "", 9, "", 4, "", 4, ""],
    ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7],
    ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""],
    ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""],
    ["8a40", "", 4, "", 12, ""],
    ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5],
    ["8b40", "", 8, "", 17, "", 6, "", 13, ""],
    ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6],
    ["8c40", "", 7, ""],
    ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4],
    ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4],
    ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""],
    ["8e40", "", 21, "", 12, "", 6, "", 12, ""],
    ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6],
    ["8f40", "", 5, "", 11, "", 8, ""],
    ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""],
    ["9040", "", 4, "", 4, "", 6, ""],
    ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6],
    ["9140", "", 6, "", 6, "", 18, "", 4, ""],
    ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""],
    ["9240", "", 6, "", 5, ""],
    ["9280", "", 5, "", 7, "", 6, ""],
    ["9340", "", 6, "", 4, "", 4, "", 5, ""],
    ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""],
    ["9440", "", 24, "", 7, "", 7, "", 4, "", 8],
    ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""],
    ["9540", "", 4, "", 4, "", 6, ""],
    ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""],
    ["9640", "", 5, "", 4, ""],
    ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5],
    ["9740", "", 7, "", 8, "", 7, "", 9, ""],
    ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""],
    ["9840", "", 4, "", 5, "", 9, ""],
    ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""],
    ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5],
    ["9980", "", 114, "", 6],
    ["9a40", "", 11, "", 7, "", 13, ""],
    ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""],
    ["9b40", "", 4, ""],
    ["9b80", "", 5, "", 4, "", 4, "", 5, ""],
    ["9c40", "", 7, ""],
    ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5],
    ["9d40", "", 7, "", 4, "", 9, "", 6, ""],
    ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""],
    ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6],
    ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""],
    ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""],
    ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4],
    ["a040", "", 9, "", 5, "", 9, "", 11, "", 19],
    ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""],
    ["a1a1", "", 7, ""],
    ["a2a1", "", 9],
    ["a2b1", "", 19, "", 19, "", 9],
    ["a2e5", "", 9],
    ["a2f1", "", 11],
    ["a3a1", "", 88, ""],
    ["a4a1", "", 82],
    ["a5a1", "", 85],
    ["a6a1", "", 16, "", 6],
    ["a6c1", "", 16, "", 6],
    ["a6e0", ""],
    ["a6ee", ""],
    ["a6f4", ""],
    ["a7a1", "", 5, "", 25],
    ["a7d1", "", 5, "", 25],
    ["a840", "", 35, "", 6],
    ["a880", "", 7, ""],
    ["a8a1", ""],
    ["a8bd", ""],
    ["a8c0", ""],
    ["a8c5", "", 36],
    ["a940", "", 8, ""],
    ["a959", ""],
    ["a95c", ""],
    ["a960", "", 9, "", 8],
    ["a980", "", 4, ""],
    ["a996", ""],
    ["a9a4", "", 75],
    ["aa40", "", 5, "", 5, "", 8],
    ["aa80", "", 7, "", 10, ""],
    ["ab40", "", 11, "", 4, "", 5, "", 4],
    ["ab80", "", 6, "", 4],
    ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11],
    ["ac80", "", 6, "", 12, "", 4, ""],
    ["ad40", "", 10, "", 7, "", 15, "", 12],
    ["ad80", "", 9, "", 8, "", 6, ""],
    ["ae40", "", 6, "", 7, "", 4, ""],
    ["ae80", "", 7, "", 6, "", 4, ""],
    ["af40", "", 4, ""],
    ["af80", ""],
    ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""],
    ["b080", "", 7, "", 8, "", 9, ""],
    ["b140", "", 4, "", 7, "", 10, ""],
    ["b180", "", 4, "", 7, "", 7, ""],
    ["b240", "", 11, "", 5, "", 11, "", 4],
    ["b280", "", 12, "", 8, "", 4, ""],
    ["b340", "", 5, ""],
    ["b380", "", 11, "", 7, "", 6, ""],
    ["b440", "", 7, "", 9],
    ["b480", "", 4, "", 5, "", 6, ""],
    ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""],
    ["b580", "", 6, "", 4, ""],
    ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""],
    ["b680", "", 6, "", 4, ""],
    ["b740", "", 14, "", 5, "", 9, "", 4, "", 16],
    ["b780", "", 6, ""],
    ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""],
    ["b880", "", 4, ""],
    ["b940", "", 5, "", 10, "", 6, ""],
    ["b980", "", 7, ""],
    ["ba40", "", 4, "", 4, "", 7, "", 5, ""],
    ["ba80", "", 4, "", 5, "", 12, "", 5, ""],
    ["bb40", "", 9, "", 36, "", 5, "", 9],
    ["bb80", "", 6, "", 4, ""],
    ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5],
    ["bc80", "", 14, "", 6, ""],
    ["bd40", "", 54, "", 7],
    ["bd80", "", 32, ""],
    ["be40", "", 12, "", 6, "", 42],
    ["be80", "", 32, ""],
    ["bf40", "", 62],
    ["bf80", "", 4, "", 4, "", 21, ""],
    ["c040", "", 35, "", 23, ""],
    ["c080", "", 6, "", 9, ""],
    ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""],
    ["c180", "", 4, "", 4, "", 5, ""],
    ["c240", "", 6, "", 5, ""],
    ["c280", "", 13, "", 5, "", 11, ""],
    ["c340", "", 5, "", 4, "", 6, ""],
    ["c380", "", 12, "", 4, ""],
    ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""],
    ["c480", "", 7, "", 5, "", 6, ""],
    ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""],
    ["c580", "", 7, "", 7, ""],
    ["c640", ""],
    ["c680", "", 4, "", 9, ""],
    ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""],
    ["c780", ""],
    ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""],
    ["c880", "", 6, "", 4, "", 4, ""],
    ["c940", "", 4, "", 7, "", 12, ""],
    ["c980", "", 4, "", 4, "", 10, ""],
    ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10],
    ["ca80", "", 4, "", 8, ""],
    ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""],
    ["cb80", "", 5, "", 6, "", 14, ""],
    ["cc40", "", 4, "", 10, "", 15, "", 13, ""],
    ["cc80", "", 11, "", 4, "", 7, ""],
    ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""],
    ["cd80", ""],
    ["ce40", "", 6, "", 5, "", 7, ""],
    ["ce80", "", 4, "", 6, "", 4, ""],
    ["cf40", "", 4, "", 4, "", 6, "", 9],
    ["cf80", "", 5, "", 7, "", 4, ""],
    ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""],
    ["d080", "", 4, "", 4, "", 5, ""],
    ["d140", "", 4, "", 4, "", 6, "", 5],
    ["d180", "", 4, "", 4, "", 4, ""],
    ["d240", "", 8, "", 24, "", 5, "", 19, ""],
    ["d280", "", 26, ""],
    ["d340", "", 30, "", 6],
    ["d380", "", 4, "", 5, "", 21, ""],
    ["d440", "", 31, "", 8, "", 21],
    ["d480", "", 25, "", 6, ""],
    ["d540", "", 7, "", 7, "", 46],
    ["d580", "", 32, ""],
    ["d640", "", 34, "", 27],
    ["d680", "", 30, ""],
    ["d740", "", 31, "", 4, "", 25],
    ["d780", "", 24, ""],
    ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""],
    ["d880", "", 6, "", 20, ""],
    ["d940", "", 62],
    ["d980", "", 32, ""],
    ["da40", "", 14, "", 8, "", 4, "", 9, ""],
    ["da80", "", 12, ""],
    ["db40", "", 6, "", 7, "", 4, ""],
    ["db80", "", 4, "", 5, "", 11, ""],
    ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7],
    ["dc80", "", 10, "", 21, ""],
    ["dd40", "", 62],
    ["dd80", "", 32, ""],
    ["de40", "", 32, ""],
    ["de80", "", 4, ""],
    ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""],
    ["df80", "", 4, ""],
    ["e040", "", 19, ""],
    ["e080", "", 10, "", 6, "", 8, ""],
    ["e140", "", 4, "", 6, "", 5, "", 5, ""],
    ["e180", "", 10, "", 9, "", 8, ""],
    ["e240", "", 62],
    ["e280", "", 32, "", 5, ""],
    ["e340", "", 45, "", 16],
    ["e380", "", 7, "", 24, ""],
    ["e440", "", 5, "", 24, "", 31],
    ["e480", "", 32, ""],
    ["e540", "", 51, "", 10],
    ["e580", "", 31, ""],
    ["e640", "", 34, "", 27],
    ["e680", "", 29, ""],
    ["e740", "", 7, "", 54],
    ["e780", "", 32, "", 6, "", 4, ""],
    ["e840", "", 14, "", 43, ""],
    ["e880", "", 20, ""],
    ["e940", "", 7, "", 42],
    ["e980", "", 32, ""],
    ["ea40", "", 27, "", 6, ""],
    ["ea80", "", 4, "", 12, ""],
    ["eb40", "", 9, "", 7, "", 9, "", 6, ""],
    ["eb80", "", 4, ""],
    ["ec40", "", 8, "", 4, "", 18, "", 7],
    ["ec80", "", 4, "", 7, "", 4, "", 4, ""],
    ["ed40", "", 6, "", 46],
    ["ed80", "", 4, "", 23, ""],
    ["ee40", "", 62],
    ["ee80", "", 32, "", 4, "", 6, ""],
    ["ef40", "", 5, "", 37, "", 4],
    ["ef80", "", 30, "", 4, "", 8, ""],
    ["f040", "", 4, "", 28, "", 26],
    ["f080", "", 9, "", 12, "", 4, "", 6, ""],
    ["f140", "", 10, "", 47],
    ["f180", "", 32, ""],
    ["f240", "", 62],
    ["f280", "", 32, ""],
    ["f340", "", 17, "", 6, "", 4, ""],
    ["f380", "", 8, "", 6, ""],
    ["f440", "", 5, "", 10, "", 10, "", 7, "", 5],
    ["f480", "", 32, ""],
    ["f540", "", 62],
    ["f580", "", 32, ""],
    ["f640", "", 62],
    ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""],
    ["f740", "", 62],
    ["f780", "", 4, "", 4, ""],
    ["f840", "", 62],
    ["f880", "", 32],
    ["f940", "", 62],
    ["f980", "", 32],
    ["fa40", "", 62],
    ["fa80", "", 32],
    ["fb40", "", 27, "", 9, ""],
    ["fb80", "", 5, "", 8, "", 5, ""],
    ["fc40", "", 8, "", 4, "", 8, "", 6],
    ["fc80", "", 4, "", 5, "", 8, ""],
    ["fd40", "", 4, "", 4, "", 10, "", 38],
    ["fd80", "", 5, "", 11, "", 4, ""],
    ["fe40", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS((exports, module) => {
  module.exports = [
    ["a140", "", 62],
    ["a180", "", 32],
    ["a240", "", 62],
    ["a280", "", 32],
    ["a2ab", "", 5],
    ["a2e3", ""],
    ["a2ef", ""],
    ["a2fd", ""],
    ["a340", "", 62],
    ["a380", "", 31, ""],
    ["a440", "", 62],
    ["a480", "", 32],
    ["a4f4", "", 10],
    ["a540", "", 62],
    ["a580", "", 32],
    ["a5f7", "", 7],
    ["a640", "", 62],
    ["a680", "", 32],
    ["a6b9", "", 7],
    ["a6d9", "", 6],
    ["a6ec", ""],
    ["a6f3", ""],
    ["a6f6", "", 8],
    ["a740", "", 62],
    ["a780", "", 32],
    ["a7c2", "", 14],
    ["a7f2", "", 12],
    ["a896", "", 10],
    ["a8bc", ""],
    ["a8bf", ""],
    ["a8c1", ""],
    ["a8ea", "", 20],
    ["a958", ""],
    ["a95b", ""],
    ["a95d", ""],
    ["a989", "", 11],
    ["a997", "", 12],
    ["a9f0", "", 14],
    ["aaa1", "", 93],
    ["aba1", "", 93],
    ["aca1", "", 93],
    ["ada1", "", 93],
    ["aea1", "", 93],
    ["afa1", "", 93],
    ["d7fa", "", 4],
    ["f8a1", "", 93],
    ["f9a1", "", 93],
    ["faa1", "", 93],
    ["fba1", "", 93],
    ["fca1", "", 93],
    ["fda1", "", 93],
    ["fe50", ""],
    ["fe80", "", 6, "", 93],
    ["8135f437", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS((exports, module) => {
  module.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189000] };
});

// node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["8141", "", 4, "", 6, ""],
    ["8161", "", 9, "", 5, ""],
    ["8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, ""],
    ["8241", "", 7, "", 5],
    ["8261", "", 6, "", 5, ""],
    ["8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18],
    ["8341", "", 5, "", 5, "", 7],
    ["8361", "", 18, ""],
    ["8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8],
    ["8441", "", 5, "", 8],
    ["8461", "", 18],
    ["8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, ""],
    ["8541", "", 5, "", 4, "", 6, "", 4],
    ["8561", "", 5, "", 5, "", 6, ""],
    ["8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, ""],
    ["8641", "", 6, "", 5, ""],
    ["8661", "", 6, "", 10],
    ["8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, ""],
    ["8741", "", 9, "", 15],
    ["8761", "", 18, ""],
    ["8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4],
    ["8841", "", 4, "", 5, "", 6, "", 4],
    ["8861", "", 4, ""],
    ["8881", "", 15, "", 4, "", 6, "", 5, "", 54, ""],
    ["8941", "", 6, "", 5, ""],
    ["8961", "", 10, "", 5, ""],
    ["8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15],
    ["8a41", "", 10, "", 6, ""],
    ["8a61", "", 4, "", 18, ""],
    ["8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, ""],
    ["8b41", "", 5, "", 4, "", 6, ""],
    ["8b61", "", 6, "", 8],
    ["8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18],
    ["8c41", "", 15, "", 4],
    ["8c61", "", 6, "", 5, "", 6, "", 5],
    ["8c81", "", 12, "", 26, "", 50, "", 5, "", 16],
    ["8d41", "", 16, "", 8],
    ["8d61", "", 17, ""],
    ["8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, ""],
    ["8e41", "", 6, "", 5, "", 8],
    ["8e61", "", 4, "", 19],
    ["8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7],
    ["8f41", "", 7, "", 17],
    ["8f61", "", 7, "", 6, "", 4],
    ["8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5],
    ["9041", "", 6, "", 5, ""],
    ["9061", "", 5, "", 15],
    ["9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, ""],
    ["9141", "", 6, "", 5],
    ["9161", "", 9, "", 5],
    ["9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6],
    ["9241", "", 7, "", 4, ""],
    ["9261", "", 7, "", 7, "", 4],
    ["9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, ""],
    ["9341", "", 4, ""],
    ["9361", "", 6, "", 8],
    ["9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, ""],
    ["9441", "", 5, "", 5, "", 8],
    ["9461", "", 5, "", 6, "", 12],
    ["9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24],
    ["9541", "", 11, "", 5, ""],
    ["9561", "", 6, "", 5, ""],
    ["9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14],
    ["9641", "", 23, ""],
    ["9661", "", 6, "", 5, "", 8],
    ["9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44],
    ["9741", "", 16, "", 8],
    ["9761", "", 17, "", 7],
    ["9781", "", 11, "", 5, "", 6, "", 89, ""],
    ["9841", "", 16, "", 5, ""],
    ["9861", "", 6, "", 15],
    ["9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, ""],
    ["9941", "", 6, "", 5, ""],
    ["9961", "", 6, "", 5, ""],
    ["9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, ""],
    ["9a41", "", 16],
    ["9a61", "", 6, "", 6, ""],
    ["9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, ""],
    ["9b41", "", 6, "", 8],
    ["9b61", "", 17, "", 7],
    ["9b81", "", 25, "", 4, "", 5, "", 50, "", 22, ""],
    ["9c41", "", 4, "", 5, "", 5],
    ["9c61", "", 8, "", 6, "", 9],
    ["9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12],
    ["9d41", "", 13, "", 8],
    ["9d61", "", 25],
    ["9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, ""],
    ["9e41", "", 7, "", 9, ""],
    ["9e61", "", 4, "", 6, ""],
    ["9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, ""],
    ["9f41", "", 5, "", 4, "", 5, ""],
    ["9f61", "", 6, "", 5, ""],
    ["9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, ""],
    ["a041", "", 5, "", 6, ""],
    ["a061", "", 5, "", 13],
    ["a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, ""],
    ["a141", "", 18, ""],
    ["a161", "", 6, "", 5, ""],
    ["a181", "", 14, "", 5, "", 4, "", 9, ""],
    ["a241", "", 5, "", 18],
    ["a261", "", 6, "", 18],
    ["a281", "", 7, "", 6, "", 7, ""],
    ["a341", "", 6, "", 10, ""],
    ["a361", "", 6, "", 16],
    ["a381", "", 16, "", 4, "", 58, "", 32, ""],
    ["a441", "", 5, ""],
    ["a461", "", 5, "", 12],
    ["a481", "", 28, "", 93],
    ["a541", "", 4, "", 6, "", 5, ""],
    ["a561", "", 17, "", 5, ""],
    ["a581", "", 16, "", 14, "", 9],
    ["a5b0", "", 9],
    ["a5c1", "", 16, "", 6],
    ["a5e1", "", 16, "", 6],
    ["a641", "", 19, ""],
    ["a661", "", 5, "", 5, "", 6],
    ["a681", "", 6, "", 18, "", 7],
    ["a741", "", 4, "", 6, "", 7],
    ["a761", "", 22, ""],
    ["a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, ""],
    ["a841", "", 10, "", 14],
    ["a861", "", 18, "", 6],
    ["a881", "", 19, "", 11, ""],
    ["a8a6", ""],
    ["a8a8", ""],
    ["a8b1", "", 27, "", 25, "", 14, ""],
    ["a941", "", 14, "", 10],
    ["a961", "", 18],
    ["a981", "", 14, "", 6, "", 27, "", 25, "", 14, ""],
    ["aa41", "", 6, "", 4, ""],
    ["aa61", "", 4, "", 5, "", 6, ""],
    ["aa81", "", 29, "", 82],
    ["ab41", "", 6, "", 5, ""],
    ["ab61", "", 6, "", 5, "", 5],
    ["ab81", "", 8, "", 6, "", 12, "", 85],
    ["ac41", "", 5, "", 6, ""],
    ["ac61", "", 11, "", 4],
    ["ac81", "", 28, "", 5, "", 25],
    ["acd1", "", 5, "", 25],
    ["ad41", "", 6, "", 5, "", 7],
    ["ad61", "", 6, "", 10, ""],
    ["ad81", "", 5, "", 18, ""],
    ["ae41", "", 5, "", 16],
    ["ae61", "", 5, "", 6, "", 4],
    ["ae81", "", 6, "", 5, ""],
    ["af41", "", 19],
    ["af61", "", 13, "", 5, ""],
    ["af81", "", 5, "", 6, "", 5, ""],
    ["b041", "", 5, "", 5, "", 12],
    ["b061", "", 5, "", 19],
    ["b081", "", 13, "", 6, "", 5, "", 7, "", 4, ""],
    ["b141", "", 6, "", 5, ""],
    ["b161", "", 6, "", 5, "", 11],
    ["b181", "", 14, "", 6, ""],
    ["b241", "", 6, "", 5, ""],
    ["b261", "", 18, "", 5, ""],
    ["b281", "", 5, "", 18, "", 6, ""],
    ["b341", "", 19, ""],
    ["b361", "", 5, "", 5, "", 5],
    ["b381", "", 5, "", 5, "", 19, "", 4, ""],
    ["b441", "", 5, "", 6, "", 5],
    ["b461", "", 6, "", 10, ""],
    ["b481", "", 6, "", 18, "", 4, "", 4, ""],
    ["b541", "", 14, "", 5],
    ["b561", "", 5, "", 5, "", 4],
    ["b581", "", 6, "", 5, "", 11, ""],
    ["b641", "", 7, "", 17],
    ["b661", "", 15, ""],
    ["b681", "", 5, "", 6, "", 5, ""],
    ["b741", "", 13, "", 6, ""],
    ["b761", "", 20, ""],
    ["b781", "", 6, "", 14, ""],
    ["b841", "", 7, "", 17],
    ["b861", "", 8, "", 13],
    ["b881", "", 5, "", 24, "", 4, ""],
    ["b941", "", 6, "", 5, ""],
    ["b961", "", 14, "", 6, ""],
    ["b981", "", 22, "", 4, "", 4, ""],
    ["ba41", "", 5, "", 6, ""],
    ["ba61", "", 5, "", 4, "", 5],
    ["ba81", "", 6, "", 9, ""],
    ["bb41", "", 4, "", 5, "", 4, ""],
    ["bb61", "", 6, "", 5, ""],
    ["bb81", "", 31, ""],
    ["bc41", "", 17, ""],
    ["bc61", "", 5, "", 6, ""],
    ["bc81", "", 4, "", 6, "", 5, "", 5, "", 4, ""],
    ["bd41", "", 7, "", 7, ""],
    ["bd61", "", 5, "", 13],
    ["bd81", "", 5, "", 25, ""],
    ["be41", "", 7, "", 14],
    ["be61", "", 7, "", 7, ""],
    ["be81", "", 4, "", 4, "", 5, "", 8, "", 6, ""],
    ["bf41", "", 10, "", 14],
    ["bf61", "", 18, ""],
    ["bf81", "", 5, "", 7, "", 6, "", 5, ""],
    ["c041", "", 5, "", 6, "", 5],
    ["c061", "", 25],
    ["c081", "", 6, "", 5, "", 7, ""],
    ["c141", "", 5, "", 6, ""],
    ["c161", "", 19, ""],
    ["c181", "", 31, ""],
    ["c241", "", 4, "", 5, ""],
    ["c261", "", 4, "", 5, "", 6, ""],
    ["c281", "", 5, "", 7, "", 9, ""],
    ["c341", "", 4],
    ["c361", "", 4, "", 5, "", 11],
    ["c381", "", 5, "", 7, "", 5, ""],
    ["c441", "", 7, "", 7, ""],
    ["c461", "", 5, "", 4],
    ["c481", "", 5, "", 11, ""],
    ["c541", "", 6, "", 5, ""],
    ["c561", "", 6, "", 5, "", 4],
    ["c581", "", 6, "", 5, ""],
    ["c641", "", 6, "", 5],
    ["c6a1", ""],
    ["c7a1", ""],
    ["c8a1", ""],
    ["caa1", ""],
    ["cba1", ""],
    ["cca1", ""],
    ["cda1", ""],
    ["cea1", ""],
    ["cfa1", ""],
    ["d0a1", ""],
    ["d1a1", "", 5, "", 4, ""],
    ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""],
    ["d3a1", ""],
    ["d4a1", ""],
    ["d5a1", ""],
    ["d6a1", ""],
    ["d7a1", ""],
    ["d8a1", ""],
    ["d9a1", ""],
    ["daa1", ""],
    ["dba1", ""],
    ["dca1", ""],
    ["dda1", ""],
    ["dea1", ""],
    ["dfa1", ""],
    ["e0a1", ""],
    ["e1a1", ""],
    ["e2a1", ""],
    ["e3a1", ""],
    ["e4a1", ""],
    ["e5a1", ""],
    ["e6a1", ""],
    ["e7a1", ""],
    ["e8a1", ""],
    ["e9a1", ""],
    ["eaa1", ""],
    ["eba1", ""],
    ["eca1", ""],
    ["eda1", ""],
    ["eea1", ""],
    ["efa1", ""],
    ["f0a1", ""],
    ["f1a1", ""],
    ["f2a1", ""],
    ["f3a1", ""],
    ["f4a1", ""],
    ["f5a1", ""],
    ["f6a1", ""],
    ["f7a1", ""],
    ["f8a1", ""],
    ["f9a1", ""],
    ["faa1", ""],
    ["fba1", ""],
    ["fca1", ""],
    ["fda1", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["a140", ""],
    ["a1a1", "", 4, ""],
    ["a240", "", 7, ""],
    ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21],
    ["a340", "", 16, "", 6, "", 16, "", 6, "", 10],
    ["a3a1", "", 25, ""],
    ["a3e1", ""],
    ["a440", ""],
    ["a4a1", ""],
    ["a540", ""],
    ["a5a1", ""],
    ["a640", ""],
    ["a6a1", ""],
    ["a740", ""],
    ["a7a1", ""],
    ["a840", ""],
    ["a8a1", ""],
    ["a940", ""],
    ["a9a1", ""],
    ["aa40", ""],
    ["aaa1", ""],
    ["ab40", ""],
    ["aba1", ""],
    ["ac40", ""],
    ["aca1", ""],
    ["ad40", ""],
    ["ada1", ""],
    ["ae40", ""],
    ["aea1", ""],
    ["af40", ""],
    ["afa1", ""],
    ["b040", ""],
    ["b0a1", ""],
    ["b140", ""],
    ["b1a1", ""],
    ["b240", ""],
    ["b2a1", ""],
    ["b340", ""],
    ["b3a1", ""],
    ["b440", ""],
    ["b4a1", ""],
    ["b540", ""],
    ["b5a1", ""],
    ["b640", ""],
    ["b6a1", ""],
    ["b740", ""],
    ["b7a1", ""],
    ["b840", ""],
    ["b8a1", ""],
    ["b940", ""],
    ["b9a1", ""],
    ["ba40", ""],
    ["baa1", ""],
    ["bb40", ""],
    ["bba1", ""],
    ["bc40", ""],
    ["bca1", ""],
    ["bd40", ""],
    ["bda1", ""],
    ["be40", ""],
    ["bea1", ""],
    ["bf40", ""],
    ["bfa1", ""],
    ["c040", ""],
    ["c0a1", ""],
    ["c140", ""],
    ["c1a1", ""],
    ["c240", ""],
    ["c2a1", ""],
    ["c340", ""],
    ["c3a1", ""],
    ["c440", ""],
    ["c4a1", ""],
    ["c540", ""],
    ["c5a1", ""],
    ["c640", ""],
    ["c940", ""],
    ["c9a1", ""],
    ["ca40", ""],
    ["caa1", ""],
    ["cb40", ""],
    ["cba1", ""],
    ["cc40", ""],
    ["cca1", ""],
    ["cd40", ""],
    ["cda1", ""],
    ["ce40", ""],
    ["cea1", ""],
    ["cf40", ""],
    ["cfa1", ""],
    ["d040", ""],
    ["d0a1", ""],
    ["d140", ""],
    ["d1a1", ""],
    ["d240", ""],
    ["d2a1", ""],
    ["d340", ""],
    ["d3a1", ""],
    ["d440", ""],
    ["d4a1", ""],
    ["d540", ""],
    ["d5a1", ""],
    ["d640", ""],
    ["d6a1", ""],
    ["d740", ""],
    ["d7a1", ""],
    ["d840", ""],
    ["d8a1", ""],
    ["d940", ""],
    ["d9a1", ""],
    ["da40", ""],
    ["daa1", ""],
    ["db40", ""],
    ["dba1", ""],
    ["dc40", ""],
    ["dca1", ""],
    ["dd40", ""],
    ["dda1", ""],
    ["de40", ""],
    ["dea1", ""],
    ["df40", ""],
    ["dfa1", ""],
    ["e040", ""],
    ["e0a1", ""],
    ["e140", ""],
    ["e1a1", ""],
    ["e240", ""],
    ["e2a1", ""],
    ["e340", ""],
    ["e3a1", ""],
    ["e440", ""],
    ["e4a1", ""],
    ["e540", ""],
    ["e5a1", ""],
    ["e640", ""],
    ["e6a1", ""],
    ["e740", ""],
    ["e7a1", ""],
    ["e840", ""],
    ["e8a1", ""],
    ["e940", ""],
    ["e9a1", ""],
    ["ea40", ""],
    ["eaa1", ""],
    ["eb40", ""],
    ["eba1", ""],
    ["ec40", ""],
    ["eca1", ""],
    ["ed40", ""],
    ["eda1", ""],
    ["ee40", ""],
    ["eea1", ""],
    ["ef40", ""],
    ["efa1", ""],
    ["f040", ""],
    ["f0a1", ""],
    ["f140", ""],
    ["f1a1", ""],
    ["f240", ""],
    ["f2a1", ""],
    ["f340", ""],
    ["f3a1", ""],
    ["f440", ""],
    ["f4a1", ""],
    ["f540", ""],
    ["f5a1", ""],
    ["f640", ""],
    ["f6a1", ""],
    ["f740", ""],
    ["f7a1", ""],
    ["f840", ""],
    ["f8a1", ""],
    ["f940", ""],
    ["f9a1", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS((exports, module) => {
  module.exports = [
    ["8740", ""],
    ["8767", ""],
    ["87a1", ""],
    ["8840", "", 4, ""],
    ["88a1", ""],
    ["8940", ""],
    ["8943", ""],
    ["8946", ""],
    ["894c", ""],
    ["89a1", ""],
    ["89ab", ""],
    ["89b0", ""],
    ["89b5", ""],
    ["89c1", ""],
    ["89c5", ""],
    ["8a40", ""],
    ["8a43", ""],
    ["8a64", ""],
    ["8a76", ""],
    ["8aa1", ""],
    ["8aac", ""],
    ["8ab2", ""],
    ["8abb", ""],
    ["8ac9", ""],
    ["8ace", ""],
    ["8adf", ""],
    ["8af6", ""],
    ["8b40", ""],
    ["8b55", ""],
    ["8ba1", ""],
    ["8bde", ""],
    ["8c40", ""],
    ["8ca1", ""],
    ["8ca7", ""],
    ["8cc9", ""],
    ["8cce", ""],
    ["8ce6", ""],
    ["8d40", ""],
    ["8d42", ""],
    ["8da1", ""],
    ["8e40", ""],
    ["8ea1", ""],
    ["8f40", ""],
    ["8fa1", ""],
    ["9040", ""],
    ["90a1", ""],
    ["9140", ""],
    ["91a1", ""],
    ["9240", ""],
    ["92a1", ""],
    ["9340", ""],
    ["93a1", ""],
    ["9440", ""],
    ["94a1", ""],
    ["9540", ""],
    ["95a1", ""],
    ["9640", ""],
    ["96a1", ""],
    ["9740", ""],
    ["97a1", ""],
    ["9840", ""],
    ["98a1", ""],
    ["9940", ""],
    ["99a1", ""],
    ["9a40", ""],
    ["9aa1", ""],
    ["9b40", ""],
    ["9b62", ""],
    ["9ba1", ""],
    ["9c40", ""],
    ["9ca1", ""],
    ["9d40", ""],
    ["9da1", ""],
    ["9e40", ""],
    ["9ea1", ""],
    ["9ead", ""],
    ["9ec5", ""],
    ["9ef5", ""],
    ["9f40", ""],
    ["9f4f", ""],
    ["9fa1", ""],
    ["9fae", ""],
    ["9fb2", ""],
    ["9fc1", ""],
    ["9fc9", ""],
    ["9fdb", ""],
    ["9fe7", ""],
    ["9feb", ""],
    ["9ff0", ""],
    ["a040", ""],
    ["a055", ""],
    ["a058", ""],
    ["a05b", ""],
    ["a063", ""],
    ["a073", ""],
    ["a0a1", ""],
    ["a0a6", ""],
    ["a0ae", ""],
    ["a0b0", ""],
    ["a0d4", ""],
    ["a0e2", ""],
    ["a3c0", "", 31, ""],
    ["c6a1", "", 9, "", 9, "", 9, "", 23],
    ["c740", "", 58, ""],
    ["c7a1", "", 81, "", 5, "", 4],
    ["c840", "", 26, "", 25, ""],
    ["c8a1", ""],
    ["c8cd", ""],
    ["c8f5", ""],
    ["f9fe", ""],
    ["fa40", ""],
    ["faa1", ""],
    ["fb40", ""],
    ["fba1", ""],
    ["fc40", ""],
    ["fca1", ""],
    ["fd40", ""],
    ["fda1", ""],
    ["fe40", ""],
    ["fea1", ""]
  ];
});

// node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS((exports, module) => {
  module.exports = {
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return require_shiftjis();
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    932: "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return require_eucjp();
      },
      encodeAdd: { "": 92, "": 126 }
    },
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    windows936: "cp936",
    ms936: "cp936",
    936: "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return require_cp936();
      }
    },
    gbk: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    gb18030: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      },
      gb18030: function() {
        return require_gb18030_ranges();
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    chinese: "gb18030",
    windows949: "cp949",
    ms949: "cp949",
    949: "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return require_cp949();
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    windows950: "cp950",
    ms950: "cp950",
    950: "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return require_cp950();
      }
    },
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return require_cp950().concat(require_big5_added());
      },
      encodeSkipVals: [
        36457,
        36463,
        36478,
        36523,
        36532,
        36557,
        36560,
        36695,
        36713,
        36718,
        36811,
        36862,
        36973,
        36986,
        37060,
        37084,
        37105,
        37311,
        37551,
        37552,
        37553,
        37554,
        37585,
        37959,
        38090,
        38361,
        38652,
        39285,
        39798,
        39800,
        39803,
        39878,
        39902,
        39916,
        39926,
        40002,
        40019,
        40034,
        40040,
        40043,
        40055,
        40124,
        40125,
        40144,
        40279,
        40282,
        40388,
        40431,
        40443,
        40617,
        40687,
        40701,
        40800,
        40907,
        41079,
        41180,
        41183,
        36812,
        37576,
        38468,
        38637,
        41636,
        41637,
        41639,
        41638,
        41676,
        41678
      ]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  };
});

// node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS((exports, module) => {
  var mergeModules = require_merge_exports();
  var modules = [
    require_internal(),
    require_utf32(),
    require_utf16(),
    require_utf7(),
    require_sbcs_codec(),
    require_sbcs_data(),
    require_sbcs_data_generated(),
    require_dbcs_codec(),
    require_dbcs_data()
  ];
  for (i = 0;i < modules.length; i++) {
    module = modules[i];
    mergeModules(exports, module);
  }
  var module;
  var i;
});

// node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  module.exports = function(streamModule) {
    var Transform2 = streamModule.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform2.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform2.prototype, {
      constructor: { value: IconvLiteEncoderStream }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
      if (typeof chunk !== "string") {
        return done(new Error("Iconv encoding stream needs strings as its input."));
      }
      try {
        var res = this.conv.write(chunk);
        if (res && res.length)
          this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length)
          this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform2.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform2.prototype, {
      constructor: { value: IconvLiteDecoderStream }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
      if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array)) {
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      }
      try {
        var res = this.conv.write(chunk);
        if (res && res.length)
          this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length)
          this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
});

// node_modules/iconv-lite/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  var bomHandling = require_bom_handling();
  var mergeModules = require_merge_exports();
  exports.encodings = null;
  exports.defaultCharUnicode = "";
  exports.defaultCharSingleByte = "?";
  exports.encode = function encode2(str, encoding, options) {
    str = "" + (str || "");
    var encoder2 = exports.getEncoder(encoding, options);
    var res = encoder2.write(str);
    var trail = encoder2.end();
    return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
  };
  exports.decode = function decode2(buf, encoding, options) {
    if (typeof buf === "string") {
      if (!exports.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        exports.skipDecodeWarning = true;
      }
      buf = Buffer2.from("" + (buf || ""), "binary");
    }
    var decoder2 = exports.getDecoder(encoding, options);
    var res = decoder2.write(buf);
    var trail = decoder2.end();
    return trail ? res + trail : res;
  };
  exports.encodingExists = function encodingExists(enc) {
    try {
      exports.getCodec(enc);
      return true;
    } catch (e) {
      return false;
    }
  };
  exports.toEncoding = exports.encode;
  exports.fromEncoding = exports.decode;
  exports._codecDataCache = { __proto__: null };
  exports.getCodec = function getCodec(encoding) {
    if (!exports.encodings) {
      var raw = require_encodings();
      exports.encodings = { __proto__: null };
      mergeModules(exports.encodings, raw);
    }
    var enc = exports._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = exports._codecDataCache[enc];
      if (codec) {
        return codec;
      }
      var codecDef = exports.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key in codecDef) {
            codecOptions[key] = codecDef[key];
          }
          if (!codecOptions.encodingName) {
            codecOptions.encodingName = enc;
          }
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName) {
            codecOptions.encodingName = enc;
          }
          codec = new codecDef(codecOptions, exports);
          exports._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  exports._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  exports.getEncoder = function getEncoder(encoding, options) {
    var codec = exports.getCodec(encoding);
    var encoder2 = new codec.encoder(options, codec);
    if (codec.bomAware && options && options.addBOM) {
      encoder2 = new bomHandling.PrependBOM(encoder2, options);
    }
    return encoder2;
  };
  exports.getDecoder = function getDecoder(encoding, options) {
    var codec = exports.getCodec(encoding);
    var decoder2 = new codec.decoder(options, codec);
    if (codec.bomAware && !(options && options.stripBOM === false)) {
      decoder2 = new bomHandling.StripBOM(decoder2, options);
    }
    return decoder2;
  };
  exports.enableStreamingAPI = function enableStreamingAPI(streamModule2) {
    if (exports.supportsStreams) {
      return;
    }
    var streams = require_streams()(streamModule2);
    exports.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
    exports.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
    exports.encodeStream = function encodeStream(encoding, options) {
      return new exports.IconvLiteEncoderStream(exports.getEncoder(encoding, options), options);
    };
    exports.decodeStream = function decodeStream(encoding, options) {
      return new exports.IconvLiteDecoderStream(exports.getDecoder(encoding, options), options);
    };
    exports.supportsStreams = true;
  };
  var streamModule;
  try {
    streamModule = __require("stream");
  } catch (e) {}
  if (streamModule && streamModule.Transform) {
    exports.enableStreamingAPI(streamModule);
  } else {
    exports.encodeStream = exports.decodeStream = function() {
      throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
    };
  }
  if (false) {}
});

// node_modules/minipass-fetch/lib/body.js
var require_body = __commonJS((exports, module) => {
  var { Minipass } = require_commonjs();
  var { MinipassSized } = require_commonjs3();
  var Blob2 = require_blob();
  var { BUFFER } = Blob2;
  var FetchError = require_fetch_error();
  var decode2;
  try {
    decode2 = require_lib().decode;
  } catch (e) {}
  var INTERNALS = Symbol("Body internals");
  var CONSUME_BODY = Symbol("consumeBody");

  class Body {
    constructor(bodyArg, options = {}) {
      const { size = 0, timeout = 0 } = options;
      const body = bodyArg === undefined || bodyArg === null ? null : isURLSearchParams(bodyArg) ? Buffer.from(bodyArg.toString()) : isBlob(bodyArg) ? bodyArg : Buffer.isBuffer(bodyArg) ? bodyArg : Object.prototype.toString.call(bodyArg) === "[object ArrayBuffer]" ? Buffer.from(bodyArg) : ArrayBuffer.isView(bodyArg) ? Buffer.from(bodyArg.buffer, bodyArg.byteOffset, bodyArg.byteLength) : Minipass.isStream(bodyArg) ? bodyArg : Buffer.from(String(bodyArg));
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (Minipass.isStream(body)) {
        body.on("error", (er) => {
          const error = er.name === "AbortError" ? er : new FetchError(`Invalid response while trying to fetch ${this.url}: ${er.message}`, "system", er);
          this[INTERNALS].error = error;
        });
      }
    }
    get body() {
      return this[INTERNALS].body;
    }
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    }
    arrayBuffer() {
      return this[CONSUME_BODY]().then((buf) => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));
    }
    blob() {
      const ct = this.headers && this.headers.get("content-type") || "";
      return this[CONSUME_BODY]().then((buf) => Object.assign(new Blob2([], { type: ct.toLowerCase() }), { [BUFFER]: buf }));
    }
    async json() {
      const buf = await this[CONSUME_BODY]();
      try {
        return JSON.parse(buf.toString());
      } catch (er) {
        throw new FetchError(`invalid json response body at ${this.url} reason: ${er.message}`, "invalid-json");
      }
    }
    text() {
      return this[CONSUME_BODY]().then((buf) => buf.toString());
    }
    buffer() {
      return this[CONSUME_BODY]();
    }
    textConverted() {
      if (typeof decode2 !== "function") {
        throw new Error("The package `iconv-lite` must be installed to use the textConverted() function");
      }
      return this[CONSUME_BODY]().then((buf) => convertBody(buf, this.headers));
    }
    [CONSUME_BODY]() {
      if (this[INTERNALS].disturbed) {
        return Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Promise.reject(this[INTERNALS].error);
      }
      if (this.body === null) {
        return Promise.resolve(Buffer.alloc(0));
      }
      if (Buffer.isBuffer(this.body)) {
        return Promise.resolve(this.body);
      }
      const upstream = isBlob(this.body) ? this.body.stream() : this.body;
      if (!Minipass.isStream(upstream)) {
        return Promise.resolve(Buffer.alloc(0));
      }
      const stream3 = this.size && upstream instanceof MinipassSized ? upstream : !this.size && upstream instanceof Minipass && !(upstream instanceof MinipassSized) ? upstream : this.size ? new MinipassSized({ size: this.size }) : new Minipass;
      const resTimeout = this.timeout && stream3.writable ? setTimeout(() => {
        stream3.emit("error", new FetchError(`Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`, "body-timeout"));
      }, this.timeout) : null;
      if (resTimeout && resTimeout.unref) {
        resTimeout.unref();
      }
      return new Promise((resolve) => {
        if (stream3 !== upstream) {
          upstream.on("error", (er) => stream3.emit("error", er));
          upstream.pipe(stream3);
        }
        resolve();
      }).then(() => stream3.concat()).then((buf) => {
        clearTimeout(resTimeout);
        return buf;
      }).catch((er) => {
        clearTimeout(resTimeout);
        if (er.name === "AbortError" || er.name === "FetchError") {
          throw er;
        } else if (er.name === "RangeError") {
          throw new FetchError(`Could not create Buffer from response body for ${this.url}: ${er.message}`, "system", er);
        } else {
          throw new FetchError(`Invalid response body while trying to fetch ${this.url}: ${er.message}`, "system", er);
        }
      });
    }
    static clone(instance) {
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      const body = instance.body;
      if (Minipass.isStream(body) && typeof body.getBoundary !== "function") {
        const tee = new Minipass;
        const p1 = new Minipass;
        const p2 = new Minipass;
        tee.on("error", (er) => {
          p1.emit("error", er);
          p2.emit("error", er);
        });
        body.on("error", (er) => tee.emit("error", er));
        tee.pipe(p1);
        tee.pipe(p2);
        body.pipe(tee);
        instance[INTERNALS].body = p1;
        return p2;
      } else {
        return instance.body;
      }
    }
    static extractContentType(body) {
      return body === null || body === undefined ? null : typeof body === "string" ? "text/plain;charset=UTF-8" : isURLSearchParams(body) ? "application/x-www-form-urlencoded;charset=UTF-8" : isBlob(body) ? body.type || null : Buffer.isBuffer(body) ? null : Object.prototype.toString.call(body) === "[object ArrayBuffer]" ? null : ArrayBuffer.isView(body) ? null : typeof body.getBoundary === "function" ? `multipart/form-data;boundary=${body.getBoundary()}` : Minipass.isStream(body) ? null : "text/plain;charset=UTF-8";
    }
    static getTotalBytes(instance) {
      const { body } = instance;
      return body === null || body === undefined ? 0 : isBlob(body) ? body.size : Buffer.isBuffer(body) ? body.length : body && typeof body.getLengthSync === "function" && (body._lengthRetrievers && body._lengthRetrievers.length === 0 || body.hasKnownLength && body.hasKnownLength()) ? body.getLengthSync() : null;
    }
    static writeToStream(dest, instance) {
      const { body } = instance;
      if (body === null || body === undefined) {
        dest.end();
      } else if (Buffer.isBuffer(body) || typeof body === "string") {
        dest.end(body);
      } else {
        const stream3 = isBlob(body) ? body.stream() : body;
        stream3.on("error", (er) => dest.emit("error", er)).pipe(dest);
      }
      return dest;
    }
  }
  Object.defineProperties(Body.prototype, {
    body: { enumerable: true },
    bodyUsed: { enumerable: true },
    arrayBuffer: { enumerable: true },
    blob: { enumerable: true },
    json: { enumerable: true },
    text: { enumerable: true }
  });
  var isURLSearchParams = (obj) => typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function" ? false : obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  var isBlob = (obj) => typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
  var convertBody = (buffer, headers) => {
    const ct = headers && headers.get("content-type");
    let charset = "utf-8";
    let res;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    const str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    if (charset === "UTF-8") {
      return buffer.toString("UTF-8");
    }
    charset = charset.toString().trim().replace(/^latin[-_]?(\d+)$/i, "ISO-8859-$1").replace(/^win(?:dows)?[-_]?(\d+)$/i, "WINDOWS-$1").replace(/^utf[-_]?(\d+)$/i, "UTF-$1").replace(/^ks_c_5601-1987$/i, "CP949").replace(/^us[-_]?ascii$/i, "ASCII").toUpperCase();
    try {
      return decode2(buffer, charset).toString();
    } catch {
      return buffer.toString("UTF-8");
    }
  };
  module.exports = Body;
});

// node_modules/minipass-fetch/lib/headers.js
var require_headers = __commonJS((exports, module) => {
  var invalidTokenRegex = /[^^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  var validateName = (name) => {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  };
  var validateValue = (value) => {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  };
  var find = (map, name) => {
    name = name.toLowerCase();
    for (const key in map) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return;
  };
  var MAP = Symbol("map");

  class Headers2 {
    constructor(init = undefined) {
      this[MAP] = Object.create(null);
      if (init instanceof Headers2) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init === undefined || init === null) {
        return;
      }
      if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method !== null && method !== undefined) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            const arrPair = Array.from(pair);
            if (arrPair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            pairs.push(arrPair);
          }
          for (const pair of pairs) {
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key of Object.keys(init)) {
            this.append(key, init[key]);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key === undefined) {
        return null;
      }
      return this[MAP][key].join(", ");
    }
    forEach(callback, thisArg = undefined) {
      let pairs = getHeaders(this);
      for (let i = 0;i < pairs.length; i++) {
        const [name, value] = pairs[i];
        callback.call(thisArg, value, name, this);
        pairs = getHeaders(this);
      }
    }
    set(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      this[MAP][key !== undefined ? key : name] = [value];
    }
    append(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      if (key !== undefined) {
        this[MAP][key].push(value);
      } else {
        this[MAP][name] = [value];
      }
    }
    has(name) {
      name = `${name}`;
      validateName(name);
      return find(this[MAP], name) !== undefined;
    }
    delete(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key !== undefined) {
        delete this[MAP][key];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return new HeadersIterator(this, "key");
    }
    values() {
      return new HeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return new HeadersIterator(this, "key+value");
    }
    entries() {
      return new HeadersIterator(this, "key+value");
    }
    get [Symbol.toStringTag]() {
      return "Headers";
    }
    static exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign(Object.create(null), headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== undefined) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    static createHeadersLenient(obj) {
      const headers = new Headers2;
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === undefined) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
  }
  Object.defineProperties(Headers2.prototype, {
    get: { enumerable: true },
    forEach: { enumerable: true },
    set: { enumerable: true },
    append: { enumerable: true },
    has: { enumerable: true },
    delete: { enumerable: true },
    keys: { enumerable: true },
    values: { enumerable: true },
    entries: { enumerable: true }
  });
  var getHeaders = (headers, kind = "key+value") => Object.keys(headers[MAP]).sort().map(kind === "key" ? (k) => k.toLowerCase() : kind === "value" ? (k) => headers[MAP][k].join(", ") : (k) => [k.toLowerCase(), headers[MAP][k].join(", ")]);
  var INTERNAL = Symbol("internal");

  class HeadersIterator {
    constructor(target, kind) {
      this[INTERNAL] = {
        target,
        kind,
        index: 0
      };
    }
    get [Symbol.toStringTag]() {
      return "HeadersIterator";
    }
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIterator.prototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      const { target, kind, index } = this[INTERNAL];
      const values = getHeaders(target, kind);
      const len = values.length;
      if (index >= len) {
        return {
          value: undefined,
          done: true
        };
      }
      this[INTERNAL].index++;
      return { value: values[index], done: false };
    }
  }
  Object.setPrototypeOf(HeadersIterator.prototype, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  module.exports = Headers2;
});

// node_modules/minipass-fetch/lib/response.js
var require_response = __commonJS((exports, module) => {
  var http = __require("http");
  var { STATUS_CODES } = http;
  var Headers2 = require_headers();
  var Body = require_body();
  var { clone, extractContentType } = Body;
  var INTERNALS = Symbol("Response internals");

  class Response extends Body {
    constructor(body = null, opts = {}) {
      super(body, opts);
      const status = opts.status || 200;
      const headers = new Headers2(opts.headers);
      if (body !== null && body !== undefined && !headers.has("Content-Type")) {
        const contentType = extractContentType(body);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers,
        counter: opts.counter,
        trailer: Promise.resolve(opts.trailer || new Headers2)
      };
    }
    get trailer() {
      return this[INTERNALS].trailer;
    }
    get url() {
      return this[INTERNALS].url || "";
    }
    get status() {
      return this[INTERNALS].status;
    }
    get ok() {
      return this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;
    }
    get redirected() {
      return this[INTERNALS].counter > 0;
    }
    get statusText() {
      return this[INTERNALS].statusText;
    }
    get headers() {
      return this[INTERNALS].headers;
    }
    clone() {
      return new Response(clone(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected,
        trailer: this.trailer
      });
    }
    get [Symbol.toStringTag]() {
      return "Response";
    }
  }
  module.exports = Response;
  Object.defineProperties(Response.prototype, {
    url: { enumerable: true },
    status: { enumerable: true },
    ok: { enumerable: true },
    redirected: { enumerable: true },
    statusText: { enumerable: true },
    headers: { enumerable: true },
    clone: { enumerable: true }
  });
});

// node_modules/minipass-fetch/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "minipass-fetch",
    version: "5.0.2",
    description: "An implementation of window.fetch in Node.js using Minipass streams",
    license: "MIT",
    main: "lib/index.js",
    scripts: {
      "test:tls-fixtures": "./test/fixtures/tls/setup.sh",
      test: "tap",
      snap: "tap",
      lint: "npm run eslint",
      postlint: "template-oss-check",
      lintfix: "npm run eslint -- --fix",
      posttest: "npm run lint",
      "template-oss-apply": "template-oss-apply --force",
      eslint: 'eslint "**/*.{js,cjs,ts,mjs,jsx,tsx}"'
    },
    tap: {
      "coverage-map": "map.js",
      "check-coverage": true,
      "nyc-arg": [
        "--exclude",
        "tap-snapshots/**"
      ]
    },
    devDependencies: {
      "@npmcli/eslint-config": "^5.0.0",
      "@npmcli/template-oss": "4.27.1",
      "@ungap/url-search-params": "^0.2.2",
      "abort-controller": "^3.0.0",
      "abortcontroller-polyfill": "~1.7.3",
      "form-data": "^4.0.0",
      "iconv-lite": "^0.7.2",
      nock: "^13.2.4",
      parted: "^0.1.1",
      "string-to-arraybuffer": "^1.0.2",
      tap: "^16.0.0"
    },
    dependencies: {
      minipass: "^7.0.3",
      "minipass-sized": "^2.0.0",
      minizlib: "^3.0.1"
    },
    optionalDependencies: {
      "iconv-lite": "^0.7.2"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/npm/minipass-fetch.git"
    },
    keywords: [
      "fetch",
      "minipass",
      "node-fetch",
      "window.fetch"
    ],
    files: [
      "bin/",
      "lib/"
    ],
    engines: {
      node: "^20.17.0 || >=22.9.0"
    },
    author: "GitHub Inc.",
    templateOSS: {
      "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
      version: "4.27.1",
      publish: "true"
    }
  };
});

// node_modules/minipass-fetch/lib/request.js
var require_request = __commonJS((exports, module) => {
  var { URL: URL2 } = __require("url");
  var { Minipass } = require_commonjs();
  var Headers2 = require_headers();
  var { exportNodeCompatibleHeaders } = Headers2;
  var Body = require_body();
  var { clone, extractContentType, getTotalBytes } = Body;
  var version = require_package().version;
  var defaultUserAgent = `minipass-fetch/${version} (+https://github.com/isaacs/minipass-fetch)`;
  var INTERNALS = Symbol("Request internals");
  var isRequest = (input) => typeof input === "object" && typeof input[INTERNALS] === "object";
  var isAbortSignal = (signal) => {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  };

  class Request2 extends Body {
    constructor(input, init = {}) {
      const parsedURL = isRequest(input) ? new URL2(input.url) : input && input.href ? new URL2(input.href) : new URL2(`${input}`);
      if (isRequest(input)) {
        init = { ...input[INTERNALS], ...init };
      } else if (!input || typeof input === "string") {
        input = {};
      }
      const method = (init.method || input.method || "GET").toUpperCase();
      const isGETHEAD = method === "GET" || method === "HEAD";
      if ((init.body !== null && init.body !== undefined || isRequest(input) && input.body !== null) && isGETHEAD) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      const inputBody = init.body !== null && init.body !== undefined ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
      super(inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers2(init.headers || input.headers || {});
      if (inputBody !== null && inputBody !== undefined && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      const signal = "signal" in init ? init.signal : null;
      if (signal !== null && signal !== undefined && !isAbortSignal(signal)) {
        throw new TypeError("Expected signal must be an instanceof AbortSignal");
      }
      const {
        ca,
        cert,
        ciphers,
        clientCertEngine,
        crl,
        dhparam,
        ecdhCurve,
        family,
        honorCipherOrder,
        key,
        passphrase,
        pfx,
        rejectUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0",
        secureOptions,
        secureProtocol,
        servername,
        sessionIdContext
      } = init;
      this[INTERNALS] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal,
        ca,
        cert,
        ciphers,
        clientCertEngine,
        crl,
        dhparam,
        ecdhCurve,
        family,
        honorCipherOrder,
        key,
        passphrase,
        pfx,
        rejectUnauthorized,
        secureOptions,
        secureProtocol,
        servername,
        sessionIdContext
      };
      this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
      this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS].method;
    }
    get url() {
      return this[INTERNALS].parsedURL.toString();
    }
    get headers() {
      return this[INTERNALS].headers;
    }
    get redirect() {
      return this[INTERNALS].redirect;
    }
    get signal() {
      return this[INTERNALS].signal;
    }
    clone() {
      return new Request2(this);
    }
    get [Symbol.toStringTag]() {
      return "Request";
    }
    static getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS].parsedURL;
      const headers = new Headers2(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && Minipass.isStream(request.body) && typeof request.body.destroy !== "function") {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported");
      }
      const contentLengthValue = (request.body === null || request.body === undefined) && /^(POST|PUT)$/i.test(request.method) ? "0" : request.body !== null && request.body !== undefined ? getTotalBytes(request) : null;
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue + "");
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", defaultUserAgent);
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      const agent = typeof request.agent === "function" ? request.agent(parsedURL) : request.agent;
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const {
        ca,
        cert,
        ciphers,
        clientCertEngine,
        crl,
        dhparam,
        ecdhCurve,
        family,
        honorCipherOrder,
        key,
        passphrase,
        pfx,
        rejectUnauthorized,
        secureOptions,
        secureProtocol,
        servername,
        sessionIdContext
      } = request[INTERNALS];
      const urlProps = {
        auth: parsedURL.username || parsedURL.password ? `${parsedURL.username}:${parsedURL.password}` : "",
        host: parsedURL.host,
        hostname: parsedURL.hostname,
        path: `${parsedURL.pathname}${parsedURL.search}`,
        port: parsedURL.port,
        protocol: parsedURL.protocol
      };
      return {
        ...urlProps,
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent,
        ca,
        cert,
        ciphers,
        clientCertEngine,
        crl,
        dhparam,
        ecdhCurve,
        family,
        honorCipherOrder,
        key,
        passphrase,
        pfx,
        rejectUnauthorized,
        secureOptions,
        secureProtocol,
        servername,
        sessionIdContext,
        timeout: request.timeout
      };
    }
  }
  module.exports = Request2;
  Object.defineProperties(Request2.prototype, {
    method: { enumerable: true },
    url: { enumerable: true },
    headers: { enumerable: true },
    redirect: { enumerable: true },
    clone: { enumerable: true },
    signal: { enumerable: true }
  });
});

// node_modules/minipass-fetch/lib/abort-error.js
var require_abort_error = __commonJS((exports, module) => {
  class AbortError extends Error {
    constructor(message3) {
      super(message3);
      this.code = "FETCH_ABORTED";
      this.type = "aborted";
      Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return "AbortError";
    }
    set name(s) {}
  }
  module.exports = AbortError;
});

// node_modules/minipass-fetch/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var { URL: URL2 } = __require("url");
  var http = __require("http");
  var https = __require("https");
  var zlib = require_commonjs2();
  var { Minipass } = require_commonjs();
  var Body = require_body();
  var { writeToStream, getTotalBytes } = Body;
  var Response = require_response();
  var Headers2 = require_headers();
  var { createHeadersLenient } = Headers2;
  var Request2 = require_request();
  var { getNodeRequestOptions } = Request2;
  var FetchError = require_fetch_error();
  var AbortError = require_abort_error();
  var fetch2 = async (url, opts) => {
    if (/^data:/.test(url)) {
      const request = new Request2(url, opts);
      return Promise.resolve().then(() => new Promise((resolve, reject) => {
        let type, data;
        try {
          const { pathname, search } = new URL2(url);
          const split = pathname.split(",");
          if (split.length < 2) {
            throw new Error("invalid data: URI");
          }
          const mime = split.shift();
          const base64 = /;base64$/.test(mime);
          type = base64 ? mime.slice(0, -1 * ";base64".length) : mime;
          const rawData = decodeURIComponent(split.join(",") + search);
          data = base64 ? Buffer.from(rawData, "base64") : Buffer.from(rawData);
        } catch (er) {
          return reject(new FetchError(`[${request.method}] ${request.url} invalid URL, ${er.message}`, "system", er));
        }
        const { signal } = request;
        if (signal && signal.aborted) {
          return reject(new AbortError("The user aborted a request."));
        }
        const headers = { "Content-Length": data.length };
        if (type) {
          headers["Content-Type"] = type;
        }
        return resolve(new Response(data, { headers }));
      }));
    }
    return new Promise((resolve, reject) => {
      const request = new Request2(url, opts);
      let options;
      try {
        options = getNodeRequestOptions(request);
      } catch (er) {
        return reject(er);
      }
      const send = (options.protocol === "https:" ? https : http).request;
      const { signal } = request;
      let response = null;
      const abort = () => {
        const error = new AbortError("The user aborted a request.");
        reject(error);
        if (Minipass.isStream(request.body) && typeof request.body.destroy === "function") {
          request.body.destroy(error);
        }
        if (response && response.body) {
          response.body.emit("error", error);
        }
      };
      if (signal && signal.aborted) {
        return abort();
      }
      const abortAndFinalize = () => {
        abort();
        finalize();
      };
      const finalize = () => {
        req.abort();
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
        clearTimeout(reqTimeout);
      };
      const req = send(options);
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      let reqTimeout = null;
      if (request.timeout) {
        req.once("socket", () => {
          reqTimeout = setTimeout(() => {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", (er) => {
        if (req.res) {
          req.res.emit("error", er);
        }
        reject(new FetchError(`request to ${request.url} failed, reason: ${er.message}`, "system", er));
        finalize();
      });
      req.on("response", (res) => {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch2.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          let locationURL = null;
          try {
            locationURL = location === null ? null : new URL2(location, request.url).toString();
          } catch {
            if (request.redirect !== "manual") {
              reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
              finalize();
              return;
            }
          }
          if (request.redirect === "error") {
            reject(new FetchError("uri requested responds with a redirect, " + `redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          } else if (request.redirect === "manual") {
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (err) {
                reject(err);
              }
            }
          } else if (request.redirect === "follow" && locationURL !== null) {
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            request.headers.set("host", new URL2(locationURL).host);
            const requestOpts = {
              headers: new Headers2(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              timeout: request.timeout
            };
            const parsedOriginal = new URL2(request.url);
            const parsedRedirect = new URL2(locationURL);
            if (parsedOriginal.hostname !== parsedRedirect.hostname) {
              requestOpts.headers.delete("authorization");
              requestOpts.headers.delete("cookie");
            }
            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
              requestOpts.method = "GET";
              requestOpts.body = undefined;
              requestOpts.headers.delete("content-length");
            }
            resolve(fetch2(new Request2(locationURL, requestOpts)));
            finalize();
            return;
          }
        }
        res.once("end", () => signal && signal.removeEventListener("abort", abortAndFinalize));
        const body = new Minipass;
        body.on("error", finalize);
        res.on("error", (er) => body.emit("error", er));
        res.on("data", (chunk) => body.write(chunk));
        res.on("end", () => body.end());
        const responseOptions = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter,
          trailer: new Promise((resolveTrailer) => res.on("end", () => resolveTrailer(createHeadersLenient(res.trailers))))
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response(body, responseOptions);
          resolve(response);
          return;
        }
        const zlibOptions = {
          flush: zlib.constants.Z_SYNC_FLUSH,
          finishFlush: zlib.constants.Z_SYNC_FLUSH
        };
        if (codings === "gzip" || codings === "x-gzip") {
          const unzip = new zlib.Gunzip(zlibOptions);
          response = new Response(body.on("error", (er) => unzip.emit("error", er)).pipe(unzip), responseOptions);
          resolve(response);
          return;
        }
        if (codings === "deflate" || codings === "x-deflate") {
          res.once("data", (chunk) => {
            const decoder3 = (chunk[0] & 15) === 8 ? new zlib.Inflate : new zlib.InflateRaw;
            body.on("error", (er) => decoder3.emit("error", er)).pipe(decoder3);
            response = new Response(decoder3, responseOptions);
            resolve(response);
          });
          return;
        }
        if (codings === "br") {
          try {
            var decoder2 = new zlib.BrotliDecompress;
          } catch (err) {
            reject(err);
            finalize();
            return;
          }
          body.on("error", (er) => decoder2.emit("error", er)).pipe(decoder2);
          response = new Response(decoder2, responseOptions);
          resolve(response);
          return;
        }
        response = new Response(body, responseOptions);
        resolve(response);
      });
      writeToStream(req, request);
    });
  };
  module.exports = fetch2;
  fetch2.isRedirect = (code) => code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  fetch2.Headers = Headers2;
  fetch2.Request = Request2;
  fetch2.Response = Response;
  fetch2.FetchError = FetchError;
  fetch2.AbortError = AbortError;
});

// node_modules/make-fetch-happen/lib/options.js
var require_options = __commonJS((exports, module) => {
  var dns = __require("dns");
  var conditionalHeaders = [
    "if-modified-since",
    "if-none-match",
    "if-unmodified-since",
    "if-match",
    "if-range"
  ];
  var configureOptions = (opts) => {
    const { strictSSL, ...options } = { ...opts };
    options.method = options.method ? options.method.toUpperCase() : "GET";
    if (strictSSL === undefined || strictSSL === null) {
      options.rejectUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0";
    } else {
      options.rejectUnauthorized = strictSSL !== false;
    }
    if (!options.retry) {
      options.retry = { retries: 0 };
    } else if (typeof options.retry === "string") {
      const retries = parseInt(options.retry, 10);
      if (isFinite(retries)) {
        options.retry = { retries };
      } else {
        options.retry = { retries: 0 };
      }
    } else if (typeof options.retry === "number") {
      options.retry = { retries: options.retry };
    } else {
      options.retry = { retries: 0, ...options.retry };
    }
    options.dns = { ttl: 5 * 60 * 1000, lookup: dns.lookup, ...options.dns };
    options.cache = options.cache || "default";
    if (options.cache === "default") {
      const hasConditionalHeader = Object.keys(options.headers || {}).some((name) => {
        return conditionalHeaders.includes(name.toLowerCase());
      });
      if (hasConditionalHeader) {
        options.cache = "no-store";
      }
    }
    options.cacheAdditionalHeaders = options.cacheAdditionalHeaders || [];
    if (options.cacheManager && !options.cachePath) {
      options.cachePath = options.cacheManager;
    }
    return options;
  };
  module.exports = configureOptions;
});

// node_modules/http-cache-semantics/index.js
var require_http_cache_semantics = __commonJS((exports, module) => {
  var statusCodeCacheableByDefault = new Set([
    200,
    203,
    204,
    206,
    300,
    301,
    308,
    404,
    405,
    410,
    414,
    501
  ]);
  var understoodStatuses = new Set([
    200,
    203,
    204,
    300,
    301,
    302,
    303,
    307,
    308,
    404,
    405,
    410,
    414,
    501
  ]);
  var errorStatusCodes = new Set([
    500,
    502,
    503,
    504
  ]);
  var hopByHopHeaders = {
    date: true,
    connection: true,
    "keep-alive": true,
    "proxy-authenticate": true,
    "proxy-authorization": true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true
  };
  var excludedFromRevalidationUpdate = {
    "content-length": true,
    "content-encoding": true,
    "transfer-encoding": true,
    "content-range": true
  };
  function toNumberOrZero(s) {
    const n = parseInt(s, 10);
    return isFinite(n) ? n : 0;
  }
  function isErrorResponse(response) {
    if (!response) {
      return true;
    }
    return errorStatusCodes.has(response.status);
  }
  function parseCacheControl(header) {
    const cc = {};
    if (!header)
      return cc;
    const parts = header.trim().split(/,/);
    for (const part of parts) {
      const [k, v] = part.split(/=/, 2);
      cc[k.trim()] = v === undefined ? true : v.trim().replace(/^"|"$/g, "");
    }
    return cc;
  }
  function formatCacheControl(cc) {
    let parts = [];
    for (const k in cc) {
      const v = cc[k];
      parts.push(v === true ? k : k + "=" + v);
    }
    if (!parts.length) {
      return;
    }
    return parts.join(", ");
  }
  module.exports = class CachePolicy {
    constructor(req, res, {
      shared,
      cacheHeuristic,
      immutableMinTimeToLive,
      ignoreCargoCult,
      _fromObject
    } = {}) {
      if (_fromObject) {
        this._fromObject(_fromObject);
        return;
      }
      if (!res || !res.headers) {
        throw Error("Response headers missing");
      }
      this._assertRequestHasHeaders(req);
      this._responseTime = this.now();
      this._isShared = shared !== false;
      this._ignoreCargoCult = !!ignoreCargoCult;
      this._cacheHeuristic = cacheHeuristic !== undefined ? cacheHeuristic : 0.1;
      this._immutableMinTtl = immutableMinTimeToLive !== undefined ? immutableMinTimeToLive : 24 * 3600 * 1000;
      this._status = "status" in res ? res.status : 200;
      this._resHeaders = res.headers;
      this._rescc = parseCacheControl(res.headers["cache-control"]);
      this._method = "method" in req ? req.method : "GET";
      this._url = req.url;
      this._host = req.headers.host;
      this._noAuthorization = !req.headers.authorization;
      this._reqHeaders = res.headers.vary ? req.headers : null;
      this._reqcc = parseCacheControl(req.headers["cache-control"]);
      if (this._ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
        delete this._rescc["pre-check"];
        delete this._rescc["post-check"];
        delete this._rescc["no-cache"];
        delete this._rescc["no-store"];
        delete this._rescc["must-revalidate"];
        this._resHeaders = Object.assign({}, this._resHeaders, {
          "cache-control": formatCacheControl(this._rescc)
        });
        delete this._resHeaders.expires;
        delete this._resHeaders.pragma;
      }
      if (res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma)) {
        this._rescc["no-cache"] = true;
      }
    }
    now() {
      return Date.now();
    }
    storable() {
      return !!(!this._reqcc["no-store"] && (this._method === "GET" || this._method === "HEAD" || this._method === "POST" && this._hasExplicitExpiration()) && understoodStatuses.has(this._status) && !this._rescc["no-store"] && (!this._isShared || !this._rescc.private) && (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (this._resHeaders.expires || this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || statusCodeCacheableByDefault.has(this._status)));
    }
    _hasExplicitExpiration() {
      return !!(this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires);
    }
    _assertRequestHasHeaders(req) {
      if (!req || !req.headers) {
        throw Error("Request headers missing");
      }
    }
    satisfiesWithoutRevalidation(req) {
      const result = this.evaluateRequest(req);
      return !result.revalidation;
    }
    _evaluateRequestHitResult(revalidation) {
      return {
        response: {
          headers: this.responseHeaders()
        },
        revalidation
      };
    }
    _evaluateRequestRevalidation(request, synchronous) {
      return {
        synchronous,
        headers: this.revalidationHeaders(request)
      };
    }
    _evaluateRequestMissResult(request) {
      return {
        response: undefined,
        revalidation: this._evaluateRequestRevalidation(request, true)
      };
    }
    evaluateRequest(req) {
      this._assertRequestHasHeaders(req);
      if (this._rescc["must-revalidate"]) {
        return this._evaluateRequestMissResult(req);
      }
      if (!this._requestMatches(req, false)) {
        return this._evaluateRequestMissResult(req);
      }
      const requestCC = parseCacheControl(req.headers["cache-control"]);
      if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
        return this._evaluateRequestMissResult(req);
      }
      if (requestCC["max-age"] && this.age() > toNumberOrZero(requestCC["max-age"])) {
        return this._evaluateRequestMissResult(req);
      }
      if (requestCC["min-fresh"] && this.maxAge() - this.age() < toNumberOrZero(requestCC["min-fresh"])) {
        return this._evaluateRequestMissResult(req);
      }
      if (this.stale()) {
        const allowsStaleWithoutRevalidation = "max-stale" in requestCC && (requestCC["max-stale"] === true || requestCC["max-stale"] > this.age() - this.maxAge());
        if (allowsStaleWithoutRevalidation) {
          return this._evaluateRequestHitResult(undefined);
        }
        if (this.useStaleWhileRevalidate()) {
          return this._evaluateRequestHitResult(this._evaluateRequestRevalidation(req, false));
        }
        return this._evaluateRequestMissResult(req);
      }
      return this._evaluateRequestHitResult(undefined);
    }
    _requestMatches(req, allowHeadMethod) {
      return !!((!this._url || this._url === req.url) && this._host === req.headers.host && (!req.method || this._method === req.method || allowHeadMethod && req.method === "HEAD") && this._varyMatches(req));
    }
    _allowsStoringAuthenticated() {
      return !!(this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"]);
    }
    _varyMatches(req) {
      if (!this._resHeaders.vary) {
        return true;
      }
      if (this._resHeaders.vary === "*") {
        return false;
      }
      const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
      for (const name of fields) {
        if (req.headers[name] !== this._reqHeaders[name])
          return false;
      }
      return true;
    }
    _copyWithoutHopByHopHeaders(inHeaders) {
      const headers = {};
      for (const name in inHeaders) {
        if (hopByHopHeaders[name])
          continue;
        headers[name] = inHeaders[name];
      }
      if (inHeaders.connection) {
        const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
        for (const name of tokens) {
          delete headers[name];
        }
      }
      if (headers.warning) {
        const warnings = headers.warning.split(/,/).filter((warning) => {
          return !/^\s*1[0-9][0-9]/.test(warning);
        });
        if (!warnings.length) {
          delete headers.warning;
        } else {
          headers.warning = warnings.join(",").trim();
        }
      }
      return headers;
    }
    responseHeaders() {
      const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
      const age = this.age();
      if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
        headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
      }
      headers.age = `${Math.round(age)}`;
      headers.date = new Date(this.now()).toUTCString();
      return headers;
    }
    date() {
      const serverDate = Date.parse(this._resHeaders.date);
      if (isFinite(serverDate)) {
        return serverDate;
      }
      return this._responseTime;
    }
    age() {
      let age = this._ageValue();
      const residentTime = (this.now() - this._responseTime) / 1000;
      return age + residentTime;
    }
    _ageValue() {
      return toNumberOrZero(this._resHeaders.age);
    }
    maxAge() {
      if (!this.storable() || this._rescc["no-cache"]) {
        return 0;
      }
      if (this._isShared && (this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable)) {
        return 0;
      }
      if (this._resHeaders.vary === "*") {
        return 0;
      }
      if (this._isShared) {
        if (this._rescc["proxy-revalidate"]) {
          return 0;
        }
        if (this._rescc["s-maxage"]) {
          return toNumberOrZero(this._rescc["s-maxage"]);
        }
      }
      if (this._rescc["max-age"]) {
        return toNumberOrZero(this._rescc["max-age"]);
      }
      const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
      const serverDate = this.date();
      if (this._resHeaders.expires) {
        const expires = Date.parse(this._resHeaders.expires);
        if (Number.isNaN(expires) || expires < serverDate) {
          return 0;
        }
        return Math.max(defaultMinTtl, (expires - serverDate) / 1000);
      }
      if (this._resHeaders["last-modified"]) {
        const lastModified = Date.parse(this._resHeaders["last-modified"]);
        if (isFinite(lastModified) && serverDate > lastModified) {
          return Math.max(defaultMinTtl, (serverDate - lastModified) / 1000 * this._cacheHeuristic);
        }
      }
      return defaultMinTtl;
    }
    timeToLive() {
      const age = this.maxAge() - this.age();
      const staleIfErrorAge = age + toNumberOrZero(this._rescc["stale-if-error"]);
      const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
      return Math.round(Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000);
    }
    stale() {
      return this.maxAge() <= this.age();
    }
    _useStaleIfError() {
      return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
    }
    useStaleWhileRevalidate() {
      const swr = toNumberOrZero(this._rescc["stale-while-revalidate"]);
      return swr > 0 && this.maxAge() + swr > this.age();
    }
    static fromObject(obj) {
      return new this(undefined, undefined, { _fromObject: obj });
    }
    _fromObject(obj) {
      if (this._responseTime)
        throw Error("Reinitialized");
      if (!obj || obj.v !== 1)
        throw Error("Invalid serialization");
      this._responseTime = obj.t;
      this._isShared = obj.sh;
      this._cacheHeuristic = obj.ch;
      this._immutableMinTtl = obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;
      this._ignoreCargoCult = !!obj.icc;
      this._status = obj.st;
      this._resHeaders = obj.resh;
      this._rescc = obj.rescc;
      this._method = obj.m;
      this._url = obj.u;
      this._host = obj.h;
      this._noAuthorization = obj.a;
      this._reqHeaders = obj.reqh;
      this._reqcc = obj.reqcc;
    }
    toObject() {
      return {
        v: 1,
        t: this._responseTime,
        sh: this._isShared,
        ch: this._cacheHeuristic,
        imm: this._immutableMinTtl,
        icc: this._ignoreCargoCult,
        st: this._status,
        resh: this._resHeaders,
        rescc: this._rescc,
        m: this._method,
        u: this._url,
        h: this._host,
        a: this._noAuthorization,
        reqh: this._reqHeaders,
        reqcc: this._reqcc
      };
    }
    revalidationHeaders(incomingReq) {
      this._assertRequestHasHeaders(incomingReq);
      const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
      delete headers["if-range"];
      if (!this._requestMatches(incomingReq, true) || !this.storable()) {
        delete headers["if-none-match"];
        delete headers["if-modified-since"];
        return headers;
      }
      if (this._resHeaders.etag) {
        headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
      }
      const forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
      if (forbidsWeakValidators) {
        delete headers["if-modified-since"];
        if (headers["if-none-match"]) {
          const etags = headers["if-none-match"].split(/,/).filter((etag) => {
            return !/^\s*W\//.test(etag);
          });
          if (!etags.length) {
            delete headers["if-none-match"];
          } else {
            headers["if-none-match"] = etags.join(",").trim();
          }
        }
      } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) {
        headers["if-modified-since"] = this._resHeaders["last-modified"];
      }
      return headers;
    }
    revalidatedPolicy(request, response) {
      this._assertRequestHasHeaders(request);
      if (this._useStaleIfError() && isErrorResponse(response)) {
        return {
          policy: this,
          modified: false,
          matches: true
        };
      }
      if (!response || !response.headers) {
        throw Error("Response headers missing");
      }
      let matches = false;
      if (response.status !== undefined && response.status != 304) {
        matches = false;
      } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
        matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag;
      } else if (this._resHeaders.etag && response.headers.etag) {
        matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "");
      } else if (this._resHeaders["last-modified"]) {
        matches = this._resHeaders["last-modified"] === response.headers["last-modified"];
      } else {
        if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"]) {
          matches = true;
        }
      }
      const optionsCopy = {
        shared: this._isShared,
        cacheHeuristic: this._cacheHeuristic,
        immutableMinTimeToLive: this._immutableMinTtl,
        ignoreCargoCult: this._ignoreCargoCult
      };
      if (!matches) {
        return {
          policy: new this.constructor(request, response, optionsCopy),
          modified: response.status != 304,
          matches: false
        };
      }
      const headers = {};
      for (const k in this._resHeaders) {
        headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
      }
      const newResponse = Object.assign({}, response, {
        status: this._status,
        method: this._method,
        headers
      });
      return {
        policy: new this.constructor(request, newResponse, optionsCopy),
        modified: false,
        matches: true
      };
    }
  };
});

// node_modules/negotiator/lib/charset.js
var require_charset = __commonJS((exports, module) => {
  module.exports = preferredCharsets;
  module.exports.preferredCharsets = preferredCharsets;
  var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptCharset(accept) {
    var accepts = accept.split(",");
    for (var i = 0, j = 0;i < accepts.length; i++) {
      var charset = parseCharset(accepts[i].trim(), i);
      if (charset) {
        accepts[j++] = charset;
      }
    }
    accepts.length = j;
    return accepts;
  }
  function parseCharset(str, i) {
    var match = simpleCharsetRegExp.exec(str);
    if (!match)
      return null;
    var charset = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0;j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      charset,
      q,
      i
    };
  }
  function getCharsetPriority(charset, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0;i < accepted.length; i++) {
      var spec = specify(charset, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(charset, spec, index) {
    var s = 0;
    if (spec.charset.toLowerCase() === charset.toLowerCase()) {
      s |= 1;
    } else if (spec.charset !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredCharsets(accept, provided) {
    var accepts = parseAcceptCharset(accept === undefined ? "*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getCharsetPriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullCharset(spec) {
    return spec.charset;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// node_modules/negotiator/lib/encoding.js
var require_encoding = __commonJS((exports, module) => {
  module.exports = preferredEncodings;
  module.exports.preferredEncodings = preferredEncodings;
  var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptEncoding(accept) {
    var accepts = accept.split(",");
    var hasIdentity = false;
    var minQuality = 1;
    for (var i = 0, j = 0;i < accepts.length; i++) {
      var encoding = parseEncoding(accepts[i].trim(), i);
      if (encoding) {
        accepts[j++] = encoding;
        hasIdentity = hasIdentity || specify("identity", encoding);
        minQuality = Math.min(minQuality, encoding.q || 1);
      }
    }
    if (!hasIdentity) {
      accepts[j++] = {
        encoding: "identity",
        q: minQuality,
        i
      };
    }
    accepts.length = j;
    return accepts;
  }
  function parseEncoding(str, i) {
    var match = simpleEncodingRegExp.exec(str);
    if (!match)
      return null;
    var encoding = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0;j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      encoding,
      q,
      i
    };
  }
  function getEncodingPriority(encoding, accepted, index) {
    var priority = { encoding, o: -1, q: 0, s: 0 };
    for (var i = 0;i < accepted.length; i++) {
      var spec = specify(encoding, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(encoding, spec, index) {
    var s = 0;
    if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
      s |= 1;
    } else if (spec.encoding !== "*") {
      return null;
    }
    return {
      encoding,
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredEncodings(accept, provided, preferred) {
    var accepts = parseAcceptEncoding(accept || "");
    var comparator = preferred ? function comparator2(a, b) {
      if (a.q !== b.q) {
        return b.q - a.q;
      }
      var aPreferred = preferred.indexOf(a.encoding);
      var bPreferred = preferred.indexOf(b.encoding);
      if (aPreferred === -1 && bPreferred === -1) {
        return b.s - a.s || a.o - b.o || a.i - b.i;
      }
      if (aPreferred !== -1 && bPreferred !== -1) {
        return aPreferred - bPreferred;
      }
      return aPreferred === -1 ? 1 : -1;
    } : compareSpecs;
    if (!provided) {
      return accepts.filter(isQuality).sort(comparator).map(getFullEncoding);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getEncodingPriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(comparator).map(function getEncoding(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i;
  }
  function getFullEncoding(spec) {
    return spec.encoding;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// node_modules/negotiator/lib/language.js
var require_language = __commonJS((exports, module) => {
  module.exports = preferredLanguages;
  module.exports.preferredLanguages = preferredLanguages;
  var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
  function parseAcceptLanguage(accept) {
    var accepts = accept.split(",");
    for (var i = 0, j = 0;i < accepts.length; i++) {
      var language = parseLanguage(accepts[i].trim(), i);
      if (language) {
        accepts[j++] = language;
      }
    }
    accepts.length = j;
    return accepts;
  }
  function parseLanguage(str, i) {
    var match = simpleLanguageRegExp.exec(str);
    if (!match)
      return null;
    var prefix = match[1];
    var suffix = match[2];
    var full = prefix;
    if (suffix)
      full += "-" + suffix;
    var q = 1;
    if (match[3]) {
      var params = match[3].split(";");
      for (var j = 0;j < params.length; j++) {
        var p = params[j].split("=");
        if (p[0] === "q")
          q = parseFloat(p[1]);
      }
    }
    return {
      prefix,
      suffix,
      q,
      i,
      full
    };
  }
  function getLanguagePriority(language, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0;i < accepted.length; i++) {
      var spec = specify(language, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(language, spec, index) {
    var p = parseLanguage(language);
    if (!p)
      return null;
    var s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
      s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
      s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
      s |= 1;
    } else if (spec.full !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredLanguages(accept, provided) {
    var accepts = parseAcceptLanguage(accept === undefined ? "*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getLanguagePriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullLanguage(spec) {
    return spec.full;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// node_modules/negotiator/lib/mediaType.js
var require_mediaType = __commonJS((exports, module) => {
  module.exports = preferredMediaTypes;
  module.exports.preferredMediaTypes = preferredMediaTypes;
  var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
  function parseAccept(accept) {
    var accepts = splitMediaTypes(accept);
    for (var i = 0, j = 0;i < accepts.length; i++) {
      var mediaType = parseMediaType(accepts[i].trim(), i);
      if (mediaType) {
        accepts[j++] = mediaType;
      }
    }
    accepts.length = j;
    return accepts;
  }
  function parseMediaType(str, i) {
    var match = simpleMediaTypeRegExp.exec(str);
    if (!match)
      return null;
    var params = Object.create(null);
    var q = 1;
    var subtype = match[2];
    var type = match[1];
    if (match[3]) {
      var kvps = splitParameters(match[3]).map(splitKeyValuePair);
      for (var j = 0;j < kvps.length; j++) {
        var pair = kvps[j];
        var key = pair[0].toLowerCase();
        var val = pair[1];
        var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.slice(1, -1) : val;
        if (key === "q") {
          q = parseFloat(value);
          break;
        }
        params[key] = value;
      }
    }
    return {
      type,
      subtype,
      params,
      q,
      i
    };
  }
  function getMediaTypePriority(type, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0;i < accepted.length; i++) {
      var spec = specify(type, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(type, spec, index) {
    var p = parseMediaType(type);
    var s = 0;
    if (!p) {
      return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
      s |= 4;
    } else if (spec.type != "*") {
      return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
      s |= 2;
    } else if (spec.subtype != "*") {
      return null;
    }
    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
      if (keys.every(function(k) {
        return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
      })) {
        s |= 1;
      } else {
        return null;
      }
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredMediaTypes(accept, provided) {
    var accepts = parseAccept(accept === undefined ? "*/*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getMediaTypePriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullType(spec) {
    return spec.type + "/" + spec.subtype;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  function quoteCount(string) {
    var count = 0;
    var index = 0;
    while ((index = string.indexOf('"', index)) !== -1) {
      count++;
      index++;
    }
    return count;
  }
  function splitKeyValuePair(str) {
    var index = str.indexOf("=");
    var key;
    var val;
    if (index === -1) {
      key = str;
    } else {
      key = str.slice(0, index);
      val = str.slice(index + 1);
    }
    return [key, val];
  }
  function splitMediaTypes(accept) {
    var accepts = accept.split(",");
    for (var i = 1, j = 0;i < accepts.length; i++) {
      if (quoteCount(accepts[j]) % 2 == 0) {
        accepts[++j] = accepts[i];
      } else {
        accepts[j] += "," + accepts[i];
      }
    }
    accepts.length = j + 1;
    return accepts;
  }
  function splitParameters(str) {
    var parameters = str.split(";");
    for (var i = 1, j = 0;i < parameters.length; i++) {
      if (quoteCount(parameters[j]) % 2 == 0) {
        parameters[++j] = parameters[i];
      } else {
        parameters[j] += ";" + parameters[i];
      }
    }
    parameters.length = j + 1;
    for (var i = 0;i < parameters.length; i++) {
      parameters[i] = parameters[i].trim();
    }
    return parameters;
  }
});

// node_modules/negotiator/index.js
var require_negotiator = __commonJS((exports, module) => {
  /*!
   * negotiator
   * Copyright(c) 2012 Federico Romero
   * Copyright(c) 2012-2014 Isaac Z. Schlueter
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var preferredCharsets = require_charset();
  var preferredEncodings = require_encoding();
  var preferredLanguages = require_language();
  var preferredMediaTypes = require_mediaType();
  module.exports = Negotiator;
  module.exports.Negotiator = Negotiator;
  function Negotiator(request) {
    if (!(this instanceof Negotiator)) {
      return new Negotiator(request);
    }
    this.request = request;
  }
  Negotiator.prototype.charset = function charset(available) {
    var set = this.charsets(available);
    return set && set[0];
  };
  Negotiator.prototype.charsets = function charsets(available) {
    return preferredCharsets(this.request.headers["accept-charset"], available);
  };
  Negotiator.prototype.encoding = function encoding(available, opts) {
    var set = this.encodings(available, opts);
    return set && set[0];
  };
  Negotiator.prototype.encodings = function encodings(available, options) {
    var opts = options || {};
    return preferredEncodings(this.request.headers["accept-encoding"], available, opts.preferred);
  };
  Negotiator.prototype.language = function language(available) {
    var set = this.languages(available);
    return set && set[0];
  };
  Negotiator.prototype.languages = function languages(available) {
    return preferredLanguages(this.request.headers["accept-language"], available);
  };
  Negotiator.prototype.mediaType = function mediaType(available) {
    var set = this.mediaTypes(available);
    return set && set[0];
  };
  Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    return preferredMediaTypes(this.request.headers.accept, available);
  };
  Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
  Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
  Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
  Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
  Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
  Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
  Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
  Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
});

// node_modules/ssri/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  var crypto2 = __require("crypto");
  var { Minipass } = require_commonjs();
  var SPEC_ALGORITHMS = ["sha512", "sha384", "sha256"];
  var DEFAULT_ALGORITHMS = ["sha512"];
  var NODE_HASHES = crypto2.getHashes();
  var BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;
  var SRI_REGEX = /^([a-z0-9]+)-([^?]+)(\?[?\S*]*)?$/;
  var STRICT_SRI_REGEX = /^([a-z0-9]+)-([A-Za-z0-9+/=]{44,88})(\?[\x21-\x7E]*)?$/;
  var VCHAR_REGEX = /^[\x21-\x7E]+$/;
  var DEFAULT_PRIORITY = [
    "md5",
    "whirlpool",
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "sha3",
    "sha3-256",
    "sha3-384",
    "sha3-512",
    "sha3_256",
    "sha3_384",
    "sha3_512"
  ].filter((algo) => NODE_HASHES.includes(algo));
  var getOptString = (options) => options?.length ? `?${options.join("?")}` : "";

  class IntegrityStream extends Minipass {
    #emittedIntegrity;
    #emittedSize;
    #emittedVerified;
    constructor(opts) {
      super();
      this.size = 0;
      this.opts = opts;
      this.#getOptions();
      if (opts?.algorithms) {
        this.algorithms = [...opts.algorithms];
      } else {
        this.algorithms = [...DEFAULT_ALGORITHMS];
      }
      if (this.algorithm !== null && !this.algorithms.includes(this.algorithm)) {
        this.algorithms.push(this.algorithm);
      }
      this.hashes = this.algorithms.map(crypto2.createHash);
    }
    #getOptions() {
      this.sri = this.opts?.integrity ? parse2(this.opts?.integrity, this.opts) : null;
      this.expectedSize = this.opts?.size;
      if (!this.sri) {
        this.algorithm = null;
      } else if (this.sri.isHash) {
        this.goodSri = true;
        this.algorithm = this.sri.algorithm;
      } else {
        this.goodSri = !this.sri.isEmpty();
        this.algorithm = this.sri.pickAlgorithm(this.opts);
      }
      this.digests = this.goodSri ? this.sri[this.algorithm] : null;
      this.optString = getOptString(this.opts?.options);
    }
    on(ev, handler) {
      if (ev === "size" && this.#emittedSize) {
        return handler(this.#emittedSize);
      }
      if (ev === "integrity" && this.#emittedIntegrity) {
        return handler(this.#emittedIntegrity);
      }
      if (ev === "verified" && this.#emittedVerified) {
        return handler(this.#emittedVerified);
      }
      return super.on(ev, handler);
    }
    emit(ev, data) {
      if (ev === "end") {
        this.#onEnd();
      }
      return super.emit(ev, data);
    }
    write(data) {
      this.size += data.length;
      this.hashes.forEach((h) => h.update(data));
      return super.write(data);
    }
    #onEnd() {
      if (!this.goodSri) {
        this.#getOptions();
      }
      const newSri = parse2(this.hashes.map((h, i) => {
        return `${this.algorithms[i]}-${h.digest("base64")}${this.optString}`;
      }).join(" "), this.opts);
      const match = this.goodSri && newSri.match(this.sri, this.opts);
      if (typeof this.expectedSize === "number" && this.size !== this.expectedSize) {
        const err = new Error(`stream size mismatch when checking ${this.sri}.
  Wanted: ${this.expectedSize}
  Found: ${this.size}`);
        err.code = "EBADSIZE";
        err.found = this.size;
        err.expected = this.expectedSize;
        err.sri = this.sri;
        this.emit("error", err);
      } else if (this.sri && !match) {
        const err = new Error(`${this.sri} integrity checksum failed when using ${this.algorithm}: wanted ${this.digests} but got ${newSri}. (${this.size} bytes)`);
        err.code = "EINTEGRITY";
        err.found = newSri;
        err.expected = this.digests;
        err.algorithm = this.algorithm;
        err.sri = this.sri;
        this.emit("error", err);
      } else {
        this.#emittedSize = this.size;
        this.emit("size", this.size);
        this.#emittedIntegrity = newSri;
        this.emit("integrity", newSri);
        if (match) {
          this.#emittedVerified = match;
          this.emit("verified", match);
        }
      }
    }
  }

  class Hash {
    get isHash() {
      return true;
    }
    constructor(hash, opts) {
      const strict = opts?.strict;
      this.source = hash.trim();
      this.digest = "";
      this.algorithm = "";
      this.options = [];
      const match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);
      if (!match) {
        return;
      }
      if (strict && !SPEC_ALGORITHMS.includes(match[1])) {
        return;
      }
      if (!NODE_HASHES.includes(match[1])) {
        return;
      }
      this.algorithm = match[1];
      this.digest = match[2];
      const rawOpts = match[3];
      if (rawOpts) {
        this.options = rawOpts.slice(1).split("?");
      }
    }
    hexDigest() {
      return this.digest && Buffer.from(this.digest, "base64").toString("hex");
    }
    toJSON() {
      return this.toString();
    }
    match(integrity, opts) {
      const other = parse2(integrity, opts);
      if (!other) {
        return false;
      }
      if (other.isIntegrity) {
        const algo = other.pickAlgorithm(opts, [this.algorithm]);
        if (!algo) {
          return false;
        }
        const foundHash = other[algo].find((hash) => hash.digest === this.digest);
        if (foundHash) {
          return foundHash;
        }
        return false;
      }
      return other.digest === this.digest ? other : false;
    }
    toString(opts) {
      if (opts?.strict) {
        if (!(SPEC_ALGORITHMS.includes(this.algorithm) && this.digest.match(BASE64_REGEX) && this.options.every((opt) => opt.match(VCHAR_REGEX)))) {
          return "";
        }
      }
      return `${this.algorithm}-${this.digest}${getOptString(this.options)}`;
    }
  }
  function integrityHashToString(toString, sep, opts, hashes) {
    const toStringIsNotEmpty = toString !== "";
    let shouldAddFirstSep = false;
    let complement = "";
    const lastIndex = hashes.length - 1;
    for (let i = 0;i < lastIndex; i++) {
      const hashString = Hash.prototype.toString.call(hashes[i], opts);
      if (hashString) {
        shouldAddFirstSep = true;
        complement += hashString;
        complement += sep;
      }
    }
    const finalHashString = Hash.prototype.toString.call(hashes[lastIndex], opts);
    if (finalHashString) {
      shouldAddFirstSep = true;
      complement += finalHashString;
    }
    if (toStringIsNotEmpty && shouldAddFirstSep) {
      return toString + sep + complement;
    }
    return toString + complement;
  }

  class Integrity {
    get isIntegrity() {
      return true;
    }
    toJSON() {
      return this.toString();
    }
    isEmpty() {
      return Object.keys(this).length === 0;
    }
    toString(opts) {
      let sep = opts?.sep || " ";
      let toString = "";
      if (opts?.strict) {
        sep = sep.replace(/\S+/g, " ");
        for (const hash of SPEC_ALGORITHMS) {
          if (this[hash]) {
            toString = integrityHashToString(toString, sep, opts, this[hash]);
          }
        }
      } else {
        for (const hash of Object.keys(this)) {
          toString = integrityHashToString(toString, sep, opts, this[hash]);
        }
      }
      return toString;
    }
    concat(integrity, opts) {
      const other = typeof integrity === "string" ? integrity : stringify(integrity, opts);
      return parse2(`${this.toString(opts)} ${other}`, opts);
    }
    hexDigest() {
      return parse2(this, { single: true }).hexDigest();
    }
    merge(integrity, opts) {
      const other = parse2(integrity, opts);
      for (const algo in other) {
        if (this[algo]) {
          if (!this[algo].find((hash) => other[algo].find((otherhash) => hash.digest === otherhash.digest))) {
            throw new Error("hashes do not match, cannot update integrity");
          }
        } else {
          this[algo] = other[algo];
        }
      }
    }
    match(integrity, opts) {
      const other = parse2(integrity, opts);
      if (!other) {
        return false;
      }
      const algo = other.pickAlgorithm(opts, Object.keys(this));
      return !!algo && this[algo].find((hash) => other[algo].find((otherhash) => hash.digest === otherhash.digest)) || false;
    }
    pickAlgorithm(opts, hashes) {
      const pickAlgorithm = opts?.pickAlgorithm || getPrioritizedHash;
      let keys = Object.keys(this);
      if (hashes?.length) {
        keys = keys.filter((k) => hashes.includes(k));
      }
      if (keys.length) {
        return keys.reduce((acc, algo) => pickAlgorithm(acc, algo) || acc);
      }
      return null;
    }
  }
  exports.parse = parse2;
  function parse2(sri, opts) {
    if (!sri) {
      return null;
    }
    if (typeof sri === "string") {
      return _parse(sri, opts);
    } else if (sri.algorithm && sri.digest) {
      const fullSri = new Integrity;
      fullSri[sri.algorithm] = [sri];
      return _parse(stringify(fullSri, opts), opts);
    } else {
      return _parse(stringify(sri, opts), opts);
    }
  }
  function _parse(integrity, opts) {
    if (opts?.single) {
      return new Hash(integrity, opts);
    }
    const hashes = integrity.trim().split(/\s+/).reduce((acc, string) => {
      const hash = new Hash(string, opts);
      if (hash.algorithm && hash.digest) {
        const algo = hash.algorithm;
        if (!Object.keys(acc).includes(algo)) {
          acc[algo] = [];
        }
        acc[algo].push(hash);
      }
      return acc;
    }, new Integrity);
    return hashes.isEmpty() ? null : hashes;
  }
  exports.stringify = stringify;
  function stringify(obj, opts) {
    if (obj.algorithm && obj.digest) {
      return Hash.prototype.toString.call(obj, opts);
    } else if (typeof obj === "string") {
      return stringify(parse2(obj, opts), opts);
    } else {
      return Integrity.prototype.toString.call(obj, opts);
    }
  }
  exports.fromHex = fromHex;
  function fromHex(hexDigest, algorithm, opts) {
    const optString = getOptString(opts?.options);
    return parse2(`${algorithm}-${Buffer.from(hexDigest, "hex").toString("base64")}${optString}`, opts);
  }
  exports.fromData = fromData;
  function fromData(data, opts) {
    const algorithms = opts?.algorithms || [...DEFAULT_ALGORITHMS];
    const optString = getOptString(opts?.options);
    return algorithms.reduce((acc, algo) => {
      const digest = crypto2.createHash(algo).update(data).digest("base64");
      const hash = new Hash(`${algo}-${digest}${optString}`, opts);
      if (hash.algorithm && hash.digest) {
        const hashAlgo = hash.algorithm;
        if (!acc[hashAlgo]) {
          acc[hashAlgo] = [];
        }
        acc[hashAlgo].push(hash);
      }
      return acc;
    }, new Integrity);
  }
  exports.fromStream = fromStream;
  function fromStream(stream3, opts) {
    const istream = integrityStream(opts);
    return new Promise((resolve, reject) => {
      stream3.pipe(istream);
      stream3.on("error", reject);
      istream.on("error", reject);
      let sri;
      istream.on("integrity", (s) => {
        sri = s;
      });
      istream.on("end", () => resolve(sri));
      istream.resume();
    });
  }
  exports.checkData = checkData;
  function checkData(data, sri, opts) {
    sri = parse2(sri, opts);
    if (!sri || !Object.keys(sri).length) {
      if (opts?.error) {
        throw Object.assign(new Error("No valid integrity hashes to check against"), {
          code: "EINTEGRITY"
        });
      } else {
        return false;
      }
    }
    const algorithm = sri.pickAlgorithm(opts);
    const digest = crypto2.createHash(algorithm).update(data).digest("base64");
    const newSri = parse2({ algorithm, digest });
    const match = newSri.match(sri, opts);
    opts = opts || {};
    if (match || !opts.error) {
      return match;
    } else if (typeof opts.size === "number" && data.length !== opts.size) {
      const err = new Error(`data size mismatch when checking ${sri}.
  Wanted: ${opts.size}
  Found: ${data.length}`);
      err.code = "EBADSIZE";
      err.found = data.length;
      err.expected = opts.size;
      err.sri = sri;
      throw err;
    } else {
      const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`);
      err.code = "EINTEGRITY";
      err.found = newSri;
      err.expected = sri;
      err.algorithm = algorithm;
      err.sri = sri;
      throw err;
    }
  }
  exports.checkStream = checkStream;
  function checkStream(stream3, sri, opts) {
    opts = opts || Object.create(null);
    opts.integrity = sri;
    sri = parse2(sri, opts);
    if (!sri || !Object.keys(sri).length) {
      return Promise.reject(Object.assign(new Error("No valid integrity hashes to check against"), {
        code: "EINTEGRITY"
      }));
    }
    const checker = integrityStream(opts);
    return new Promise((resolve, reject) => {
      stream3.pipe(checker);
      stream3.on("error", reject);
      checker.on("error", reject);
      let verified;
      checker.on("verified", (s) => {
        verified = s;
      });
      checker.on("end", () => resolve(verified));
      checker.resume();
    });
  }
  exports.integrityStream = integrityStream;
  function integrityStream(opts = Object.create(null)) {
    return new IntegrityStream(opts);
  }
  exports.create = createIntegrity;
  function createIntegrity(opts) {
    const algorithms = opts?.algorithms || [...DEFAULT_ALGORITHMS];
    const optString = getOptString(opts?.options);
    const hashes = algorithms.map(crypto2.createHash);
    return {
      update: function(chunk, enc) {
        hashes.forEach((h) => h.update(chunk, enc));
        return this;
      },
      digest: function() {
        const integrity = algorithms.reduce((acc, algo) => {
          const digest = hashes.shift().digest("base64");
          const hash = new Hash(`${algo}-${digest}${optString}`, opts);
          if (!acc[hash.algorithm]) {
            acc[hash.algorithm] = [];
          }
          acc[hash.algorithm].push(hash);
          return acc;
        }, new Integrity);
        return integrity;
      }
    };
  }
  function getPrioritizedHash(algo1, algo2) {
    return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;
  }
});

// node_modules/make-fetch-happen/lib/cache/policy.js
var require_policy = __commonJS((exports, module) => {
  var CacheSemantics = require_http_cache_semantics();
  var Negotiator = require_negotiator();
  var ssri = require_lib3();
  var policyOptions = {
    shared: false,
    ignoreCargoCult: true
  };
  var emptyResponse = { status: 200, headers: {} };
  var requestObject = (request) => {
    const _obj = {
      method: request.method,
      url: request.url,
      headers: {},
      compress: request.compress
    };
    request.headers.forEach((value, key) => {
      _obj.headers[key] = value;
    });
    return _obj;
  };
  var responseObject = (response) => {
    const _obj = {
      status: response.status,
      headers: {}
    };
    response.headers.forEach((value, key) => {
      _obj.headers[key] = value;
    });
    return _obj;
  };

  class CachePolicy {
    constructor({ entry, request, response, options }) {
      this.entry = entry;
      this.request = requestObject(request);
      this.response = responseObject(response);
      this.options = options;
      this.policy = new CacheSemantics(this.request, this.response, policyOptions);
      if (this.entry) {
        this.policy._responseTime = this.entry.metadata.time;
      }
    }
    static storable(request, options) {
      if (!options.cachePath) {
        return false;
      }
      if (options.cache === "no-store") {
        return false;
      }
      if (!["GET", "HEAD"].includes(request.method)) {
        return false;
      }
      const policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions);
      return policy.storable();
    }
    satisfies(request) {
      const _req = requestObject(request);
      if (this.request.headers.host !== _req.headers.host) {
        return false;
      }
      if (this.request.compress !== _req.compress) {
        return false;
      }
      const negotiatorA = new Negotiator(this.request);
      const negotiatorB = new Negotiator(_req);
      if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes())) {
        return false;
      }
      if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages())) {
        return false;
      }
      if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings())) {
        return false;
      }
      if (this.options.integrity) {
        return ssri.parse(this.options.integrity).match(this.entry.integrity);
      }
      return true;
    }
    storable() {
      return this.policy.storable();
    }
    get mustRevalidate() {
      return !!this.policy._rescc["must-revalidate"];
    }
    needsRevalidation(request) {
      const _req = requestObject(request);
      _req.method = "GET";
      return !this.policy.satisfiesWithoutRevalidation(_req);
    }
    responseHeaders() {
      return this.policy.responseHeaders();
    }
    revalidationHeaders(request) {
      const _req = requestObject(request);
      return this.policy.revalidationHeaders(_req);
    }
    revalidated(request, response) {
      const _req = requestObject(request);
      const _res = responseObject(response);
      const policy = this.policy.revalidatedPolicy(_req, _res);
      return !policy.modified;
    }
  }
  module.exports = CachePolicy;
});

// node_modules/make-fetch-happen/lib/cache/errors.js
var require_errors2 = __commonJS((exports, module) => {
  class NotCachedError extends Error {
    constructor(url) {
      super(`request to ${url} failed: cache mode is 'only-if-cached' but no cached response is available.`);
      this.code = "ENOTCACHED";
    }
  }
  module.exports = {
    NotCachedError
  };
});

// node_modules/minipass-flush/node_modules/minipass/index.js
var require_minipass = __commonJS((exports, module) => {
  var proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  var EE = __require("events");
  var Stream = __require("stream");
  var SD = __require("string_decoder").StringDecoder;
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var EMITTED_ERROR = Symbol("emittedError");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var EMITDATA = Symbol("emitData");
  var EMITEND = Symbol("emitEnd");
  var EMITEND2 = Symbol("emitEnd2");
  var ASYNC = Symbol("async");
  var defer = (fn) => Promise.resolve().then(fn);
  var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
  var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
  var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

  class Pipe {
    constructor(src, dest, opts) {
      this.src = src;
      this.dest = dest;
      this.opts = opts;
      this.ondrain = () => src[RESUME]();
      dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    proxyErrors() {}
    end() {
      this.unpipe();
      if (this.opts.end)
        this.dest.end();
    }
  }

  class PipeProxyErrors extends Pipe {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  }
  module.exports = class Minipass extends Stream {
    constructor(options) {
      super();
      this[FLOWING] = false;
      this[PAUSED] = false;
      this.pipes = [];
      this.buffer = [];
      this[OBJECTMODE] = options && options.objectMode || false;
      if (this[OBJECTMODE])
        this[ENCODING] = null;
      else
        this[ENCODING] = options && options.encoding || null;
      if (this[ENCODING] === "buffer")
        this[ENCODING] = null;
      this[ASYNC] = options && !!options.async || false;
      this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
      this[EOF] = false;
      this[EMITTED_END] = false;
      this[EMITTING_END] = false;
      this[CLOSED] = false;
      this[EMITTED_ERROR] = null;
      this.writable = true;
      this.readable = true;
      this[BUFFERLENGTH] = 0;
      this[DESTROYED] = false;
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(enc) {
      if (this[OBJECTMODE])
        throw new Error("cannot set encoding in objectMode");
      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
        throw new Error("cannot change encoding");
      if (this[ENCODING] !== enc) {
        this[DECODER] = enc ? new SD(enc) : null;
        if (this.buffer.length)
          this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
      }
      this[ENCODING] = enc;
    }
    setEncoding(enc) {
      this.encoding = enc;
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(om) {
      this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
    get ["async"]() {
      return this[ASYNC];
    }
    set ["async"](a) {
      this[ASYNC] = this[ASYNC] || !!a;
    }
    write(chunk, encoding, cb) {
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
        return true;
      }
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC] ? defer : (f) => f();
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk))
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        else if (isArrayBuffer(chunk))
          chunk = Buffer.from(chunk);
        else if (typeof chunk !== "string")
          this.objectMode = true;
      }
      if (this[OBJECTMODE]) {
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      if (typeof chunk === "string" && !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING])
        chunk = this[DECODER].write(chunk);
      if (this.flowing && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this.flowing)
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this.flowing;
    }
    read(n) {
      if (this[DESTROYED])
        return null;
      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
        this[MAYBE_EMIT_END]();
        return null;
      }
      if (this[OBJECTMODE])
        n = null;
      if (this.buffer.length > 1 && !this[OBJECTMODE]) {
        if (this.encoding)
          this.buffer = [this.buffer.join("")];
        else
          this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
      }
      const ret = this[READ](n || null, this.buffer[0]);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [READ](n, chunk) {
      if (n === chunk.length || n === null)
        this[BUFFERSHIFT]();
      else {
        this.buffer[0] = chunk.slice(n);
        chunk = chunk.slice(0, n);
        this[BUFFERLENGTH] -= n;
      }
      this.emit("data", chunk);
      if (!this.buffer.length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function")
        cb = chunk, chunk = null;
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (chunk)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this.flowing || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    [RESUME]() {
      if (this[DESTROYED])
        return;
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this.buffer.length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      this.buffer.push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this.buffer.length) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this.buffer[0].length;
      }
      return this.buffer.shift();
    }
    [FLUSH](noDrain) {
      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
      if (!noDrain && !this.buffer.length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      return chunk ? (this.emit("data", chunk), this.flowing) : false;
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === proc.stdout || dest === proc.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
        if (this[ASYNC])
          defer(() => this[RESUME]());
        else
          this[RESUME]();
      }
      return dest;
    }
    unpipe(dest) {
      const p = this.pipes.find((p2) => p2.dest === dest);
      if (p) {
        this.pipes.splice(this.pipes.indexOf(p), 1);
        p.unpipe();
      }
    }
    addListener(ev, fn) {
      return this.on(ev, fn);
    }
    on(ev, fn) {
      const ret = super.on(ev, fn);
      if (ev === "data" && !this.pipes.length && !this.flowing)
        this[RESUME]();
      else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
        super.emit("readable");
      else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR]) {
        if (this[ASYNC])
          defer(() => fn.call(this, this[EMITTED_ERROR]));
        else
          fn.call(this, this[EMITTED_ERROR]);
      }
      return ret;
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    emit(ev, data, ...extra) {
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
        return;
      else if (ev === "data") {
        return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
      } else if (ev === "end") {
        return this[EMITEND]();
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return;
        const ret2 = super.emit("close");
        this.removeAllListeners("close");
        return ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR] = data;
        const ret2 = super.emit("error", data);
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret2;
      }
      const ret = super.emit(ev, data, ...extra);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITDATA](data) {
      for (const p of this.pipes) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret = super.emit("data", data);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITEND]() {
      if (this[EMITTED_END])
        return;
      this[EMITTED_END] = true;
      this.readable = false;
      if (this[ASYNC])
        defer(() => this[EMITEND2]());
      else
        this[EMITEND2]();
    }
    [EMITEND2]() {
      if (this[DECODER]) {
        const data = this[DECODER].end();
        if (data) {
          for (const p of this.pipes) {
            p.dest.write(data);
          }
          super.emit("data", data);
        }
      }
      for (const p of this.pipes) {
        p.end();
      }
      const ret = super.emit("end");
      this.removeAllListeners("end");
      return ret;
    }
    collect() {
      const buf = [];
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      return p.then(() => buf);
    }
    concat() {
      return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
    }
    promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve());
      });
    }
    [ASYNCITERATOR]() {
      const next = () => {
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF])
          return Promise.resolve({ done: true });
        let resolve = null;
        let reject = null;
        const onerr = (er) => {
          this.removeListener("data", ondata);
          this.removeListener("end", onend);
          reject(er);
        };
        const ondata = (value) => {
          this.removeListener("error", onerr);
          this.removeListener("end", onend);
          this.pause();
          resolve({ value, done: !!this[EOF] });
        };
        const onend = () => {
          this.removeListener("error", onerr);
          this.removeListener("data", ondata);
          resolve({ done: true });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return { next };
    }
    [ITERATOR]() {
      const next = () => {
        const value = this.read();
        const done = value === null;
        return { value, done };
      };
      return { next };
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this.buffer.length = 0;
      this[BUFFERLENGTH] = 0;
      if (typeof this.close === "function" && !this[CLOSED])
        this.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static isStream(s) {
      return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || typeof s.write === "function" && typeof s.end === "function"));
    }
  };
});

// node_modules/minipass-flush/index.js
var require_minipass_flush = __commonJS((exports, module) => {
  var Minipass = require_minipass();
  var _flush = Symbol("_flush");
  var _flushed = Symbol("_flushed");
  var _flushing = Symbol("_flushing");

  class Flush extends Minipass {
    constructor(opt = {}) {
      if (typeof opt === "function")
        opt = { flush: opt };
      super(opt);
      if (typeof opt.flush !== "function" && typeof this.flush !== "function")
        throw new TypeError("must provide flush function in options");
      this[_flush] = opt.flush || this.flush;
    }
    emit(ev, ...data) {
      if (ev !== "end" && ev !== "finish" || this[_flushed])
        return super.emit(ev, ...data);
      if (this[_flushing])
        return;
      this[_flushing] = true;
      const afterFlush = (er) => {
        this[_flushed] = true;
        er ? super.emit("error", er) : super.emit("end");
      };
      const ret = this[_flush](afterFlush);
      if (ret && ret.then)
        ret.then(() => afterFlush(), (er) => afterFlush(er));
    }
  }
  module.exports = Flush;
});

// node_modules/minipass-collect/index.js
var require_minipass_collect = __commonJS((exports, module) => {
  var { Minipass } = require_commonjs();
  var _data = Symbol("_data");
  var _length = Symbol("_length");

  class Collect extends Minipass {
    constructor(options) {
      super(options);
      this[_data] = [];
      this[_length] = 0;
    }
    write(chunk, encoding, cb) {
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (!encoding)
        encoding = "utf8";
      const c = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
      this[_data].push(c);
      this[_length] += c.length;
      if (cb)
        cb();
      return true;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function")
        cb = chunk, chunk = null;
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (chunk)
        this.write(chunk, encoding);
      const result = Buffer.concat(this[_data], this[_length]);
      super.write(result);
      return super.end(cb);
    }
  }
  module.exports = Collect;

  class CollectPassThrough extends Minipass {
    constructor(options) {
      super(options);
      this[_data] = [];
      this[_length] = 0;
    }
    write(chunk, encoding, cb) {
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (!encoding)
        encoding = "utf8";
      const c = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
      this[_data].push(c);
      this[_length] += c.length;
      return super.write(chunk, encoding, cb);
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function")
        cb = chunk, chunk = null;
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (chunk)
        this.write(chunk, encoding);
      const result = Buffer.concat(this[_data], this[_length]);
      this.emit("collect", result);
      return super.end(cb);
    }
  }
  module.exports.PassThrough = CollectPassThrough;
});

// node_modules/minipass-pipeline/node_modules/minipass/index.js
var require_minipass2 = __commonJS((exports, module) => {
  var proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  var EE = __require("events");
  var Stream = __require("stream");
  var SD = __require("string_decoder").StringDecoder;
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var EMITTED_ERROR = Symbol("emittedError");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var EMITDATA = Symbol("emitData");
  var EMITEND = Symbol("emitEnd");
  var EMITEND2 = Symbol("emitEnd2");
  var ASYNC = Symbol("async");
  var defer = (fn) => Promise.resolve().then(fn);
  var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
  var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
  var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

  class Pipe {
    constructor(src, dest, opts) {
      this.src = src;
      this.dest = dest;
      this.opts = opts;
      this.ondrain = () => src[RESUME]();
      dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    proxyErrors() {}
    end() {
      this.unpipe();
      if (this.opts.end)
        this.dest.end();
    }
  }

  class PipeProxyErrors extends Pipe {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  }
  module.exports = class Minipass extends Stream {
    constructor(options) {
      super();
      this[FLOWING] = false;
      this[PAUSED] = false;
      this.pipes = [];
      this.buffer = [];
      this[OBJECTMODE] = options && options.objectMode || false;
      if (this[OBJECTMODE])
        this[ENCODING] = null;
      else
        this[ENCODING] = options && options.encoding || null;
      if (this[ENCODING] === "buffer")
        this[ENCODING] = null;
      this[ASYNC] = options && !!options.async || false;
      this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
      this[EOF] = false;
      this[EMITTED_END] = false;
      this[EMITTING_END] = false;
      this[CLOSED] = false;
      this[EMITTED_ERROR] = null;
      this.writable = true;
      this.readable = true;
      this[BUFFERLENGTH] = 0;
      this[DESTROYED] = false;
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(enc) {
      if (this[OBJECTMODE])
        throw new Error("cannot set encoding in objectMode");
      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
        throw new Error("cannot change encoding");
      if (this[ENCODING] !== enc) {
        this[DECODER] = enc ? new SD(enc) : null;
        if (this.buffer.length)
          this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
      }
      this[ENCODING] = enc;
    }
    setEncoding(enc) {
      this.encoding = enc;
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(om) {
      this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
    get ["async"]() {
      return this[ASYNC];
    }
    set ["async"](a) {
      this[ASYNC] = this[ASYNC] || !!a;
    }
    write(chunk, encoding, cb) {
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
        return true;
      }
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC] ? defer : (f) => f();
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk))
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        else if (isArrayBuffer(chunk))
          chunk = Buffer.from(chunk);
        else if (typeof chunk !== "string")
          this.objectMode = true;
      }
      if (this[OBJECTMODE]) {
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      if (typeof chunk === "string" && !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING])
        chunk = this[DECODER].write(chunk);
      if (this.flowing && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this.flowing)
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this.flowing;
    }
    read(n) {
      if (this[DESTROYED])
        return null;
      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
        this[MAYBE_EMIT_END]();
        return null;
      }
      if (this[OBJECTMODE])
        n = null;
      if (this.buffer.length > 1 && !this[OBJECTMODE]) {
        if (this.encoding)
          this.buffer = [this.buffer.join("")];
        else
          this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
      }
      const ret = this[READ](n || null, this.buffer[0]);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [READ](n, chunk) {
      if (n === chunk.length || n === null)
        this[BUFFERSHIFT]();
      else {
        this.buffer[0] = chunk.slice(n);
        chunk = chunk.slice(0, n);
        this[BUFFERLENGTH] -= n;
      }
      this.emit("data", chunk);
      if (!this.buffer.length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function")
        cb = chunk, chunk = null;
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (chunk)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this.flowing || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    [RESUME]() {
      if (this[DESTROYED])
        return;
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this.buffer.length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      this.buffer.push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this.buffer.length) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this.buffer[0].length;
      }
      return this.buffer.shift();
    }
    [FLUSH](noDrain) {
      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
      if (!noDrain && !this.buffer.length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      return chunk ? (this.emit("data", chunk), this.flowing) : false;
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === proc.stdout || dest === proc.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
        if (this[ASYNC])
          defer(() => this[RESUME]());
        else
          this[RESUME]();
      }
      return dest;
    }
    unpipe(dest) {
      const p = this.pipes.find((p2) => p2.dest === dest);
      if (p) {
        this.pipes.splice(this.pipes.indexOf(p), 1);
        p.unpipe();
      }
    }
    addListener(ev, fn) {
      return this.on(ev, fn);
    }
    on(ev, fn) {
      const ret = super.on(ev, fn);
      if (ev === "data" && !this.pipes.length && !this.flowing)
        this[RESUME]();
      else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
        super.emit("readable");
      else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR]) {
        if (this[ASYNC])
          defer(() => fn.call(this, this[EMITTED_ERROR]));
        else
          fn.call(this, this[EMITTED_ERROR]);
      }
      return ret;
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    emit(ev, data, ...extra) {
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
        return;
      else if (ev === "data") {
        return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
      } else if (ev === "end") {
        return this[EMITEND]();
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return;
        const ret2 = super.emit("close");
        this.removeAllListeners("close");
        return ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR] = data;
        const ret2 = super.emit("error", data);
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret2;
      }
      const ret = super.emit(ev, data, ...extra);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITDATA](data) {
      for (const p of this.pipes) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret = super.emit("data", data);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITEND]() {
      if (this[EMITTED_END])
        return;
      this[EMITTED_END] = true;
      this.readable = false;
      if (this[ASYNC])
        defer(() => this[EMITEND2]());
      else
        this[EMITEND2]();
    }
    [EMITEND2]() {
      if (this[DECODER]) {
        const data = this[DECODER].end();
        if (data) {
          for (const p of this.pipes) {
            p.dest.write(data);
          }
          super.emit("data", data);
        }
      }
      for (const p of this.pipes) {
        p.end();
      }
      const ret = super.emit("end");
      this.removeAllListeners("end");
      return ret;
    }
    collect() {
      const buf = [];
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      return p.then(() => buf);
    }
    concat() {
      return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
    }
    promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve());
      });
    }
    [ASYNCITERATOR]() {
      const next = () => {
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF])
          return Promise.resolve({ done: true });
        let resolve = null;
        let reject = null;
        const onerr = (er) => {
          this.removeListener("data", ondata);
          this.removeListener("end", onend);
          reject(er);
        };
        const ondata = (value) => {
          this.removeListener("error", onerr);
          this.removeListener("end", onend);
          this.pause();
          resolve({ value, done: !!this[EOF] });
        };
        const onend = () => {
          this.removeListener("error", onerr);
          this.removeListener("data", ondata);
          resolve({ done: true });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return { next };
    }
    [ITERATOR]() {
      const next = () => {
        const value = this.read();
        const done = value === null;
        return { value, done };
      };
      return { next };
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this.buffer.length = 0;
      this[BUFFERLENGTH] = 0;
      if (typeof this.close === "function" && !this[CLOSED])
        this.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static isStream(s) {
      return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || typeof s.write === "function" && typeof s.end === "function"));
    }
  };
});

// node_modules/minipass-pipeline/index.js
var require_minipass_pipeline = __commonJS((exports, module) => {
  var Minipass = require_minipass2();
  var EE = __require("events");
  var isStream = (s) => s && s instanceof EE && (typeof s.pipe === "function" || typeof s.write === "function" && typeof s.end === "function");
  var _head = Symbol("_head");
  var _tail = Symbol("_tail");
  var _linkStreams = Symbol("_linkStreams");
  var _setHead = Symbol("_setHead");
  var _setTail = Symbol("_setTail");
  var _onError = Symbol("_onError");
  var _onData = Symbol("_onData");
  var _onEnd = Symbol("_onEnd");
  var _onDrain = Symbol("_onDrain");
  var _streams = Symbol("_streams");

  class Pipeline extends Minipass {
    constructor(opts, ...streams) {
      if (isStream(opts)) {
        streams.unshift(opts);
        opts = {};
      }
      super(opts);
      this[_streams] = [];
      if (streams.length)
        this.push(...streams);
    }
    [_linkStreams](streams) {
      return streams.reduce((src, dest) => {
        src.on("error", (er) => dest.emit("error", er));
        src.pipe(dest);
        return dest;
      });
    }
    push(...streams) {
      this[_streams].push(...streams);
      if (this[_tail])
        streams.unshift(this[_tail]);
      const linkRet = this[_linkStreams](streams);
      this[_setTail](linkRet);
      if (!this[_head])
        this[_setHead](streams[0]);
    }
    unshift(...streams) {
      this[_streams].unshift(...streams);
      if (this[_head])
        streams.push(this[_head]);
      const linkRet = this[_linkStreams](streams);
      this[_setHead](streams[0]);
      if (!this[_tail])
        this[_setTail](linkRet);
    }
    destroy(er) {
      this[_streams].forEach((s) => typeof s.destroy === "function" && s.destroy());
      return super.destroy(er);
    }
    [_setTail](stream3) {
      this[_tail] = stream3;
      stream3.on("error", (er) => this[_onError](stream3, er));
      stream3.on("data", (chunk) => this[_onData](stream3, chunk));
      stream3.on("end", () => this[_onEnd](stream3));
      stream3.on("finish", () => this[_onEnd](stream3));
    }
    [_onError](stream3, er) {
      if (stream3 === this[_tail])
        this.emit("error", er);
    }
    [_onData](stream3, chunk) {
      if (stream3 === this[_tail])
        super.write(chunk);
    }
    [_onEnd](stream3) {
      if (stream3 === this[_tail])
        super.end();
    }
    pause() {
      super.pause();
      return this[_tail] && this[_tail].pause && this[_tail].pause();
    }
    emit(ev, ...args) {
      if (ev === "resume" && this[_tail] && this[_tail].resume)
        this[_tail].resume();
      return super.emit(ev, ...args);
    }
    [_setHead](stream3) {
      this[_head] = stream3;
      stream3.on("drain", () => this[_onDrain](stream3));
    }
    [_onDrain](stream3) {
      if (stream3 === this[_head])
        this.emit("drain");
    }
    write(chunk, enc, cb) {
      return this[_head].write(chunk, enc, cb) && (this.flowing || this.buffer.length === 0);
    }
    end(chunk, enc, cb) {
      this[_head].end(chunk, enc, cb);
      return this;
    }
  }
  module.exports = Pipeline;
});

// node_modules/imurmurhash/imurmurhash.js
var require_imurmurhash = __commonJS((exports, module) => {
  (function() {
    var cache2;
    function MurmurHash3(key, seed) {
      var m = this instanceof MurmurHash3 ? this : cache2;
      m.reset(seed);
      if (typeof key === "string" && key.length > 0) {
        m.hash(key);
      }
      if (m !== this) {
        return m;
      }
    }
    MurmurHash3.prototype.hash = function(key) {
      var h1, k1, i, top, len;
      len = key.length;
      this.len += len;
      k1 = this.k1;
      i = 0;
      switch (this.rem) {
        case 0:
          k1 ^= len > i ? key.charCodeAt(i++) & 65535 : 0;
        case 1:
          k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 8 : 0;
        case 2:
          k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 16 : 0;
        case 3:
          k1 ^= len > i ? (key.charCodeAt(i) & 255) << 24 : 0;
          k1 ^= len > i ? (key.charCodeAt(i++) & 65280) >> 8 : 0;
      }
      this.rem = len + this.rem & 3;
      len -= this.rem;
      if (len > 0) {
        h1 = this.h1;
        while (true) {
          k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
          h1 ^= k1;
          h1 = h1 << 13 | h1 >>> 19;
          h1 = h1 * 5 + 3864292196 & 4294967295;
          if (i >= len) {
            break;
          }
          k1 = key.charCodeAt(i++) & 65535 ^ (key.charCodeAt(i++) & 65535) << 8 ^ (key.charCodeAt(i++) & 65535) << 16;
          top = key.charCodeAt(i++);
          k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
        }
        k1 = 0;
        switch (this.rem) {
          case 3:
            k1 ^= (key.charCodeAt(i + 2) & 65535) << 16;
          case 2:
            k1 ^= (key.charCodeAt(i + 1) & 65535) << 8;
          case 1:
            k1 ^= key.charCodeAt(i) & 65535;
        }
        this.h1 = h1;
      }
      this.k1 = k1;
      return this;
    };
    MurmurHash3.prototype.result = function() {
      var k1, h1;
      k1 = this.k1;
      h1 = this.h1;
      if (k1 > 0) {
        k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
        h1 ^= k1;
      }
      h1 ^= this.len;
      h1 ^= h1 >>> 16;
      h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295;
      h1 ^= h1 >>> 13;
      h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295;
      h1 ^= h1 >>> 16;
      return h1 >>> 0;
    };
    MurmurHash3.prototype.reset = function(seed) {
      this.h1 = typeof seed === "number" ? seed : 0;
      this.rem = this.k1 = this.len = 0;
      return this;
    };
    cache2 = new MurmurHash3;
    if (typeof module != "undefined") {
      module.exports = MurmurHash3;
    } else {
      this.MurmurHash3 = MurmurHash3;
    }
  })();
});

// node_modules/unique-slug/lib/index.js
var require_lib4 = __commonJS((exports, module) => {
  var MurmurHash3 = require_imurmurhash();
  module.exports = function(uniq) {
    if (uniq) {
      var hash = new MurmurHash3(uniq);
      return ("00000000" + hash.result().toString(16)).slice(-8);
    } else {
      return (Math.random().toString(16) + "0000000").slice(2, 10);
    }
  };
});

// node_modules/unique-filename/lib/index.js
var require_lib5 = __commonJS((exports, module) => {
  var path = __require("path");
  var uniqueSlug = require_lib4();
  module.exports = function(filepath, prefix, uniq) {
    return path.join(filepath, (prefix ? prefix + "-" : "") + uniqueSlug(uniq));
  };
});

// node_modules/cacache/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "cacache",
    version: "20.0.3",
    "cache-version": {
      content: "2",
      index: "5"
    },
    description: "Fast, fault-tolerant, cross-platform, disk-based, data-agnostic, content-addressable cache.",
    main: "lib/index.js",
    files: [
      "bin/",
      "lib/"
    ],
    scripts: {
      test: "tap",
      snap: "tap",
      coverage: "tap",
      "test-docker": 'docker run -it --rm --name pacotest -v "$PWD":/tmp -w /tmp node:latest npm test',
      lint: "npm run eslint",
      npmclilint: "npmcli-lint",
      lintfix: "npm run eslint -- --fix",
      postsnap: "npm run lintfix --",
      postlint: "template-oss-check",
      posttest: "npm run lint",
      "template-oss-apply": "template-oss-apply --force",
      eslint: 'eslint "**/*.{js,cjs,ts,mjs,jsx,tsx}"'
    },
    repository: {
      type: "git",
      url: "git+https://github.com/npm/cacache.git"
    },
    keywords: [
      "cache",
      "caching",
      "content-addressable",
      "sri",
      "sri hash",
      "subresource integrity",
      "cache",
      "storage",
      "store",
      "file store",
      "filesystem",
      "disk cache",
      "disk storage"
    ],
    license: "ISC",
    dependencies: {
      "@npmcli/fs": "^5.0.0",
      "fs-minipass": "^3.0.0",
      glob: "^13.0.0",
      "lru-cache": "^11.1.0",
      minipass: "^7.0.3",
      "minipass-collect": "^2.0.1",
      "minipass-flush": "^1.0.5",
      "minipass-pipeline": "^1.2.4",
      "p-map": "^7.0.2",
      ssri: "^13.0.0",
      "unique-filename": "^5.0.0"
    },
    devDependencies: {
      "@npmcli/eslint-config": "^6.0.1",
      "@npmcli/template-oss": "4.28.0",
      tap: "^16.0.0"
    },
    engines: {
      node: "^20.17.0 || >=22.9.0"
    },
    templateOSS: {
      "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
      windowsCI: false,
      version: "4.28.0",
      publish: "true"
    },
    author: "GitHub Inc.",
    tap: {
      "nyc-arg": [
        "--exclude",
        "tap-snapshots/**"
      ]
    }
  };
});

// node_modules/cacache/lib/util/hash-to-segments.js
var require_hash_to_segments = __commonJS((exports, module) => {
  module.exports = hashToSegments;
  function hashToSegments(hash) {
    return [hash.slice(0, 2), hash.slice(2, 4), hash.slice(4)];
  }
});

// node_modules/cacache/lib/content/path.js
var require_path = __commonJS((exports, module) => {
  var contentVer = require_package2()["cache-version"].content;
  var hashToSegments = require_hash_to_segments();
  var path = __require("path");
  var ssri = require_lib3();
  module.exports = contentPath;
  function contentPath(cache2, integrity) {
    const sri = ssri.parse(integrity, { single: true });
    return path.join(contentDir(cache2), sri.algorithm, ...hashToSegments(sri.hexDigest()));
  }
  module.exports.contentDir = contentDir;
  function contentDir(cache2) {
    return path.join(cache2, `content-v${contentVer}`);
  }
});

// node_modules/@npmcli/fs/lib/common/get-options.js
var require_get_options = __commonJS((exports, module) => {
  var getOptions = (input, { copy, wrap }) => {
    const result = {};
    if (input && typeof input === "object") {
      for (const prop of copy) {
        if (input[prop] !== undefined) {
          result[prop] = input[prop];
        }
      }
    } else {
      result[wrap] = input;
    }
    return result;
  };
  module.exports = getOptions;
});

// node_modules/semver/internal/constants.js
var require_constants2 = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug3 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
  module.exports = debug3;
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants2();
  var debug3 = require_debug();
  exports = module.exports = {};
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var safeSrc = exports.safeSrc = [];
  var t = exports.t = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value) => {
    for (const [token2, max] of safeRegexReplacements) {
      value = value.split(`${token2}*`).join(`${token2}{0,${max}}`).split(`${token2}+`).join(`${token2}{1,${max}}`);
    }
    return value;
  };
  var createToken2 = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug3(name, index, value);
    t[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken2("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken2("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken2("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken2("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
  createToken2("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken2("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
  createToken2("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken2("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken2("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken2("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken2("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken2("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken2("FULL", `^${src[t.FULLPLAIN]}$`);
  createToken2("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken2("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
  createToken2("GTLT", "((?:<|>)?=?)");
  createToken2("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken2("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken2("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken2("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken2("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken2("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken2("COERCEPLAIN", `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken2("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken2("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:$|[^\\d])`);
  createToken2("COERCERTL", src[t.COERCE], true);
  createToken2("COERCERTLFULL", src[t.COERCEFULL], true);
  createToken2("LONETILDE", "(?:~>?)");
  createToken2("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken2("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken2("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken2("LONECARET", "(?:\\^)");
  createToken2("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken2("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken2("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken2("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken2("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken2("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken2("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
  createToken2("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
  createToken2("STAR", "(<|>)?=?\\s*\\*");
  createToken2("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken2("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions;
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    if (typeof a === "number" && typeof b === "number") {
      return a === b ? 0 : a < b ? -1 : 1;
    }
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module) => {
  var debug3 = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
  var { safeRe: re, t } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version, options) {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug3("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug3("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.major < other.major) {
        return -1;
      }
      if (this.major > other.major) {
        return 1;
      }
      if (this.minor < other.minor) {
        return -1;
      }
      if (this.minor > other.minor) {
        return 1;
      }
      if (this.patch < other.patch) {
        return -1;
      }
      if (this.patch > other.patch) {
        return 1;
      }
      return 0;
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug3("prerelease compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug3("build compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse2 = (version, options, throwErrors = false) => {
    if (version instanceof SemVer) {
      return version;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse2;
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse2 = require_parse();
  var valid = (version, options) => {
    const v = parse2(version, options);
    return v ? v.version : null;
  };
  module.exports = valid;
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
  var parse2 = require_parse();
  var clean = (version, options) => {
    const s = parse2(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  module.exports = clean;
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var inc = (version, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module.exports = inc;
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse2 = require_parse();
  var diff = (version1, version2) => {
    const v1 = parse2(version1, null, true);
    const v2 = parse2(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (lowVersion.compareMain(highVersion) === 0) {
        if (lowVersion.minor && !lowVersion.patch) {
          return "minor";
        }
        return "patch";
      }
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var major = (a, loose) => new SemVer(a, loose).major;
  module.exports = major;
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var minor = (a, loose) => new SemVer(a, loose).minor;
  module.exports = minor;
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var patch = (a, loose) => new SemVer(a, loose).patch;
  module.exports = patch;
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse2 = require_parse();
  var prerelease = (version, options) => {
    const parsed = parse2(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module.exports = compare;
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare = require_compare();
  var rcompare = (a, b, loose) => compare(b, a, loose);
  module.exports = rcompare;
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare = require_compare();
  var compareLoose = (a, b) => compare(a, b, true);
  module.exports = compareLoose;
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  module.exports = sort;
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  module.exports = rsort;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt = (a, b, loose) => compare(a, b, loose) > 0;
  module.exports = gt;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt = (a, b, loose) => compare(a, b, loose) < 0;
  module.exports = lt;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq = (a, b, loose) => compare(a, b, loose) === 0;
  module.exports = eq;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module.exports = neq;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte = (a, b, loose) => compare(a, b, loose) >= 0;
  module.exports = gte;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte = (a, b, loose) => compare(a, b, loose) <= 0;
  module.exports = lte;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse2 = require_parse();
  var { safeRe: re, t } = require_re();
  var coerce = (version, options) => {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  module.exports = coerce;
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS((exports, module) => {
  class LRUCache {
    constructor() {
      this.max = 1000;
      this.map = new Map;
    }
    get(key) {
      const value = this.map.get(key);
      if (value === undefined) {
        return;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== undefined) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  module.exports = LRUCache;
});

// node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  var SPACE_CHARACTERS = /\s+/g;

  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.formatted = undefined;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = undefined;
    }
    get range() {
      if (this.formatted === undefined) {
        this.formatted = "";
        for (let i = 0;i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0;k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache2.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug3("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug3("comparator trim", range);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      debug3("tilde trim", range);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      debug3("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug3("loose invalid filter", comp, this.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }
      debug3("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache2.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lrucache();
  var cache2 = new LRU;
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug3 = require_debug();
  var SemVer = require_semver();
  var {
    safeRe: re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    comp = comp.replace(re[t.BUILD], "");
    debug3("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug3("caret", comp);
    comp = replaceTildes(comp, options);
    debug3("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug3("xrange", comp);
    comp = replaceStars(comp, options);
    debug3("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug3("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug3("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug3("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug3("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug3("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug3("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug3("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug3("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug3("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug3("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug3("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug3("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug3("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set, version, options) => {
    for (let i = 0;i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0;i < set.length; i++) {
        debug3(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug3("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug3("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== undefined ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug3("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re, t } = require_re();
  var cmp = require_cmp();
  var debug3 = require_debug();
  var SemVer = require_semver();
  var Range = require_range();
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  };
  module.exports = satisfies;
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module.exports = maxSatisfying;
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module.exports = validRange;
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version, range, hilo, options) => {
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version, range, options) => outside(version, range, ">", options);
  module.exports = gtr;
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version, range, options) => outside(version, range, "<", options);
  module.exports = ltr;
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  module.exports = intersects;
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module.exports = (versions, range, options) => {
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version of v) {
      const included = satisfies(version, range, options);
      if (included) {
        prev = version;
        if (!first) {
          first = version;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  var lowerLT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  module.exports = subset;
});

// node_modules/semver/index.js
var require_semver2 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants = require_constants2();
  var SemVer = require_semver();
  var identifiers = require_identifiers();
  var parse2 = require_parse();
  var valid = require_valid();
  var clean = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt = require_gt();
  var lt = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse: parse2,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// node_modules/@npmcli/fs/lib/common/node.js
var require_node4 = __commonJS((exports, module) => {
  var semver = require_semver2();
  var satisfies = (range) => {
    return semver.satisfies(process.version, range, { includePrerelease: true });
  };
  module.exports = {
    satisfies
  };
});

// node_modules/@npmcli/fs/lib/cp/errors.js
var require_errors3 = __commonJS((exports, module) => {
  var { inspect } = __require("util");

  class SystemError {
    constructor(code, prefix, context) {
      let message3 = `${prefix}: ${context.syscall} returned ` + `${context.code} (${context.message})`;
      if (context.path !== undefined) {
        message3 += ` ${context.path}`;
      }
      if (context.dest !== undefined) {
        message3 += ` => ${context.dest}`;
      }
      this.code = code;
      Object.defineProperties(this, {
        name: {
          value: "SystemError",
          enumerable: false,
          writable: true,
          configurable: true
        },
        message: {
          value: message3,
          enumerable: false,
          writable: true,
          configurable: true
        },
        info: {
          value: context,
          enumerable: true,
          configurable: true,
          writable: false
        },
        errno: {
          get() {
            return context.errno;
          },
          set(value) {
            context.errno = value;
          },
          enumerable: true,
          configurable: true
        },
        syscall: {
          get() {
            return context.syscall;
          },
          set(value) {
            context.syscall = value;
          },
          enumerable: true,
          configurable: true
        }
      });
      if (context.path !== undefined) {
        Object.defineProperty(this, "path", {
          get() {
            return context.path;
          },
          set(value) {
            context.path = value;
          },
          enumerable: true,
          configurable: true
        });
      }
      if (context.dest !== undefined) {
        Object.defineProperty(this, "dest", {
          get() {
            return context.dest;
          },
          set(value) {
            context.dest = value;
          },
          enumerable: true,
          configurable: true
        });
      }
    }
    toString() {
      return `${this.name} [${this.code}]: ${this.message}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](_recurseTimes, ctx) {
      return inspect(this, {
        ...ctx,
        getters: true,
        customInspect: false
      });
    }
  }
  function E(code, message3) {
    exports[code] = class NodeError extends SystemError {
      constructor(ctx) {
        super(code, message3, ctx);
      }
    };
  }
  E("ERR_FS_CP_DIR_TO_NON_DIR", "Cannot overwrite directory with non-directory");
  E("ERR_FS_CP_EEXIST", "Target already exists");
  E("ERR_FS_CP_EINVAL", "Invalid src or dest");
  E("ERR_FS_CP_FIFO_PIPE", "Cannot copy a FIFO pipe");
  E("ERR_FS_CP_NON_DIR_TO_DIR", "Cannot overwrite non-directory with directory");
  E("ERR_FS_CP_SOCKET", "Cannot copy a socket file");
  E("ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY", "Cannot overwrite symlink in subdirectory of self");
  E("ERR_FS_CP_UNKNOWN", "Cannot copy an unknown file type");
  E("ERR_FS_EISDIR", "Path is a directory");
  exports.ERR_INVALID_ARG_TYPE = class ERR_INVALID_ARG_TYPE extends Error {
    constructor(name, expected, actual) {
      super();
      this.code = "ERR_INVALID_ARG_TYPE";
      this.message = `The ${name} argument must be ${expected}. Received ${typeof actual}`;
    }
  };
});

// node_modules/@npmcli/fs/lib/cp/polyfill.js
var require_polyfill = __commonJS((exports, module) => {
  var {
    ERR_FS_CP_DIR_TO_NON_DIR,
    ERR_FS_CP_EEXIST,
    ERR_FS_CP_EINVAL,
    ERR_FS_CP_FIFO_PIPE,
    ERR_FS_CP_NON_DIR_TO_DIR,
    ERR_FS_CP_SOCKET,
    ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,
    ERR_FS_CP_UNKNOWN,
    ERR_FS_EISDIR,
    ERR_INVALID_ARG_TYPE
  } = require_errors3();
  var {
    constants: {
      errno: {
        EEXIST,
        EISDIR,
        EINVAL,
        ENOTDIR
      }
    }
  } = __require("os");
  var {
    chmod,
    copyFile,
    lstat,
    mkdir,
    readdir,
    readlink,
    stat,
    symlink,
    unlink,
    utimes
  } = __require("fs/promises");
  var {
    dirname,
    isAbsolute,
    join,
    parse: parse2,
    resolve,
    sep,
    toNamespacedPath
  } = __require("path");
  var { fileURLToPath } = __require("url");
  var defaultOptions = {
    dereference: false,
    errorOnExist: false,
    filter: undefined,
    force: true,
    preserveTimestamps: false,
    recursive: false
  };
  async function cp(src, dest, opts) {
    if (opts != null && typeof opts !== "object") {
      throw new ERR_INVALID_ARG_TYPE("options", ["Object"], opts);
    }
    return cpFn(toNamespacedPath(getValidatedPath(src)), toNamespacedPath(getValidatedPath(dest)), { ...defaultOptions, ...opts });
  }
  function getValidatedPath(fileURLOrPath) {
    const path = fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin ? fileURLToPath(fileURLOrPath) : fileURLOrPath;
    return path;
  }
  async function cpFn(src, dest, opts) {
    if (opts.preserveTimestamps && process.arch === "ia32") {
      const warning = "Using the preserveTimestamps option in 32-bit " + "node is not recommended";
      process.emitWarning(warning, "TimestampPrecisionWarning");
    }
    const stats = await checkPaths(src, dest, opts);
    const { srcStat, destStat } = stats;
    await checkParentPaths(src, srcStat, dest);
    if (opts.filter) {
      return handleFilter(checkParentDir, destStat, src, dest, opts);
    }
    return checkParentDir(destStat, src, dest, opts);
  }
  async function checkPaths(src, dest, opts) {
    const { 0: srcStat, 1: destStat } = await getStats2(src, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        throw new ERR_FS_CP_EINVAL({
          message: "src and dest cannot be the same",
          path: dest,
          syscall: "cp",
          errno: EINVAL
        });
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new ERR_FS_CP_DIR_TO_NON_DIR({
          message: `cannot overwrite directory ${src} ` + `with non-directory ${dest}`,
          path: dest,
          syscall: "cp",
          errno: EISDIR
        });
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new ERR_FS_CP_NON_DIR_TO_DIR({
          message: `cannot overwrite non-directory ${src} ` + `with directory ${dest}`,
          path: dest,
          syscall: "cp",
          errno: ENOTDIR
        });
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new ERR_FS_CP_EINVAL({
        message: `cannot copy ${src} to a subdirectory of self ${dest}`,
        path: dest,
        syscall: "cp",
        errno: EINVAL
      });
    }
    return { srcStat, destStat };
  }
  function areIdentical(srcStat, destStat) {
    return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
  }
  function getStats2(src, dest, opts) {
    const statFunc = opts.dereference ? (file) => stat(file, { bigint: true }) : (file) => lstat(file, { bigint: true });
    return Promise.all([
      statFunc(src),
      statFunc(dest).catch((err) => {
        if (err.code === "ENOENT") {
          return null;
        }
        throw err;
      })
    ]);
  }
  async function checkParentDir(destStat, src, dest, opts) {
    const destParent = dirname(dest);
    const dirExists = await pathExists(destParent);
    if (dirExists) {
      return getStatsForCopy(destStat, src, dest, opts);
    }
    await mkdir(destParent, { recursive: true });
    return getStatsForCopy(destStat, src, dest, opts);
  }
  function pathExists(dest) {
    return stat(dest).then(() => true, (err) => err.code === "ENOENT" ? false : Promise.reject(err));
  }
  async function checkParentPaths(src, srcStat, dest) {
    const srcParent = resolve(dirname(src));
    const destParent = resolve(dirname(dest));
    if (destParent === srcParent || destParent === parse2(destParent).root) {
      return;
    }
    let destStat;
    try {
      destStat = await stat(destParent, { bigint: true });
    } catch (err) {
      if (err.code === "ENOENT") {
        return;
      }
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new ERR_FS_CP_EINVAL({
        message: `cannot copy ${src} to a subdirectory of self ${dest}`,
        path: dest,
        syscall: "cp",
        errno: EINVAL
      });
    }
    return checkParentPaths(src, srcStat, destParent);
  }
  var normalizePathToArray = (path) => resolve(path).split(sep).filter(Boolean);
  function isSrcSubdir(src, dest) {
    const srcArr = normalizePathToArray(src);
    const destArr = normalizePathToArray(dest);
    return srcArr.every((cur, i) => destArr[i] === cur);
  }
  async function handleFilter(onInclude, destStat, src, dest, opts, cb) {
    const include = await opts.filter(src, dest);
    if (include) {
      return onInclude(destStat, src, dest, opts, cb);
    }
  }
  function startCopy(destStat, src, dest, opts) {
    if (opts.filter) {
      return handleFilter(getStatsForCopy, destStat, src, dest, opts);
    }
    return getStatsForCopy(destStat, src, dest, opts);
  }
  async function getStatsForCopy(destStat, src, dest, opts) {
    const statFn = opts.dereference ? stat : lstat;
    const srcStat = await statFn(src);
    if (srcStat.isDirectory() && opts.recursive) {
      return onDir(srcStat, destStat, src, dest, opts);
    } else if (srcStat.isDirectory()) {
      throw new ERR_FS_EISDIR({
        message: `${src} is a directory (not copied)`,
        path: src,
        syscall: "cp",
        errno: EINVAL
      });
    } else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) {
      return onFile(srcStat, destStat, src, dest, opts);
    } else if (srcStat.isSymbolicLink()) {
      return onLink(destStat, src, dest);
    } else if (srcStat.isSocket()) {
      throw new ERR_FS_CP_SOCKET({
        message: `cannot copy a socket file: ${dest}`,
        path: dest,
        syscall: "cp",
        errno: EINVAL
      });
    } else if (srcStat.isFIFO()) {
      throw new ERR_FS_CP_FIFO_PIPE({
        message: `cannot copy a FIFO pipe: ${dest}`,
        path: dest,
        syscall: "cp",
        errno: EINVAL
      });
    }
    throw new ERR_FS_CP_UNKNOWN({
      message: `cannot copy an unknown file type: ${dest}`,
      path: dest,
      syscall: "cp",
      errno: EINVAL
    });
  }
  function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat) {
      return _copyFile(srcStat, src, dest, opts);
    }
    return mayCopyFile(srcStat, src, dest, opts);
  }
  async function mayCopyFile(srcStat, src, dest, opts) {
    if (opts.force) {
      await unlink(dest);
      return _copyFile(srcStat, src, dest, opts);
    } else if (opts.errorOnExist) {
      throw new ERR_FS_CP_EEXIST({
        message: `${dest} already exists`,
        path: dest,
        syscall: "cp",
        errno: EEXIST
      });
    }
  }
  async function _copyFile(srcStat, src, dest, opts) {
    await copyFile(src, dest);
    if (opts.preserveTimestamps) {
      return handleTimestampsAndMode(srcStat.mode, src, dest);
    }
    return setDestMode(dest, srcStat.mode);
  }
  async function handleTimestampsAndMode(srcMode, src, dest) {
    if (fileIsNotWritable(srcMode)) {
      await makeFileWritable(dest, srcMode);
      return setDestTimestampsAndMode(srcMode, src, dest);
    }
    return setDestTimestampsAndMode(srcMode, src, dest);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode) {
    return setDestMode(dest, srcMode | 128);
  }
  async function setDestTimestampsAndMode(srcMode, src, dest) {
    await setDestTimestamps(src, dest);
    return setDestMode(dest, srcMode);
  }
  function setDestMode(dest, srcMode) {
    return chmod(dest, srcMode);
  }
  async function setDestTimestamps(src, dest) {
    const updatedSrcStat = await stat(src);
    return utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat) {
      return mkDirAndCopy(srcStat.mode, src, dest, opts);
    }
    return copyDir(src, dest, opts);
  }
  async function mkDirAndCopy(srcMode, src, dest, opts) {
    await mkdir(dest);
    await copyDir(src, dest, opts);
    return setDestMode(dest, srcMode);
  }
  async function copyDir(src, dest, opts) {
    const dir = await readdir(src);
    for (let i = 0;i < dir.length; i++) {
      const item = dir[i];
      const srcItem = join(src, item);
      const destItem = join(dest, item);
      const { destStat } = await checkPaths(srcItem, destItem, opts);
      await startCopy(destStat, srcItem, destItem, opts);
    }
  }
  async function onLink(destStat, src, dest) {
    let resolvedSrc = await readlink(src);
    if (!isAbsolute(resolvedSrc)) {
      resolvedSrc = resolve(dirname(src), resolvedSrc);
    }
    if (!destStat) {
      return symlink(resolvedSrc, dest);
    }
    let resolvedDest;
    try {
      resolvedDest = await readlink(dest);
    } catch (err) {
      if (err.code === "EINVAL" || err.code === "UNKNOWN") {
        return symlink(resolvedSrc, dest);
      }
      throw err;
    }
    if (!isAbsolute(resolvedDest)) {
      resolvedDest = resolve(dirname(dest), resolvedDest);
    }
    if (isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new ERR_FS_CP_EINVAL({
        message: `cannot copy ${resolvedSrc} to a subdirectory of self ` + `${resolvedDest}`,
        path: dest,
        syscall: "cp",
        errno: EINVAL
      });
    }
    const srcStat = await stat(src);
    if (srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({
        message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,
        path: dest,
        syscall: "cp",
        errno: EINVAL
      });
    }
    return copyLink(resolvedSrc, dest);
  }
  async function copyLink(resolvedSrc, dest) {
    await unlink(dest);
    return symlink(resolvedSrc, dest);
  }
  module.exports = cp;
});

// node_modules/@npmcli/fs/lib/cp/index.js
var require_cp = __commonJS((exports, module) => {
  var fs = __require("fs/promises");
  var getOptions = require_get_options();
  var node = require_node4();
  var polyfill = require_polyfill();
  var useNative = node.satisfies(">=16.7.0");
  var cp = async (src, dest, opts) => {
    const options = getOptions(opts, {
      copy: ["dereference", "errorOnExist", "filter", "force", "preserveTimestamps", "recursive"]
    });
    return useNative ? fs.cp(src, dest, options) : polyfill(src, dest, options);
  };
  module.exports = cp;
});

// node_modules/@npmcli/fs/lib/with-temp-dir.js
var require_with_temp_dir = __commonJS((exports, module) => {
  var { join, sep } = __require("path");
  var getOptions = require_get_options();
  var { mkdir, mkdtemp, rm } = __require("fs/promises");
  var withTempDir = async (root, fn, opts) => {
    const options = getOptions(opts, {
      copy: ["tmpPrefix"]
    });
    await mkdir(root, { recursive: true });
    const target = await mkdtemp(join(`${root}${sep}`, options.tmpPrefix || ""));
    let err;
    let result;
    try {
      result = await fn(target);
    } catch (_err) {
      err = _err;
    }
    try {
      await rm(target, { force: true, recursive: true });
    } catch {}
    if (err) {
      throw err;
    }
    return result;
  };
  module.exports = withTempDir;
});

// node_modules/@npmcli/fs/lib/readdir-scoped.js
var require_readdir_scoped = __commonJS((exports, module) => {
  var { readdir } = __require("fs/promises");
  var { join } = __require("path");
  var readdirScoped = async (dir) => {
    const results = [];
    for (const item of await readdir(dir)) {
      if (item.startsWith("@")) {
        for (const scopedItem of await readdir(join(dir, item))) {
          results.push(join(item, scopedItem));
        }
      } else {
        results.push(item);
      }
    }
    return results;
  };
  module.exports = readdirScoped;
});

// node_modules/@npmcli/fs/lib/move-file.js
var require_move_file = __commonJS((exports, module) => {
  var { dirname, join, resolve, relative, isAbsolute } = __require("path");
  var fs = __require("fs/promises");
  var pathExists = async (path) => {
    try {
      await fs.access(path);
      return true;
    } catch (er) {
      return er.code !== "ENOENT";
    }
  };
  var moveFile = async (source, destination, options = {}, root = true, symlinks = []) => {
    if (!source || !destination) {
      throw new TypeError("`source` and `destination` file required");
    }
    options = {
      overwrite: true,
      ...options
    };
    if (!options.overwrite && await pathExists(destination)) {
      throw new Error(`The destination file exists: ${destination}`);
    }
    await fs.mkdir(dirname(destination), { recursive: true });
    try {
      await fs.rename(source, destination);
    } catch (error) {
      if (error.code === "EXDEV" || error.code === "EPERM") {
        const sourceStat = await fs.lstat(source);
        if (sourceStat.isDirectory()) {
          const files = await fs.readdir(source);
          await Promise.all(files.map((file) => moveFile(join(source, file), join(destination, file), options, false, symlinks)));
        } else if (sourceStat.isSymbolicLink()) {
          symlinks.push({ source, destination });
        } else {
          await fs.copyFile(source, destination);
        }
      } else {
        throw error;
      }
    }
    if (root) {
      await Promise.all(symlinks.map(async ({ source: symSource, destination: symDestination }) => {
        let target = await fs.readlink(symSource);
        if (isAbsolute(target)) {
          target = resolve(symDestination, relative(symSource, target));
        }
        let targetStat = "file";
        try {
          targetStat = await fs.stat(resolve(dirname(symSource), target));
          if (targetStat.isDirectory()) {
            targetStat = "junction";
          }
        } catch {}
        await fs.symlink(target, symDestination, targetStat);
      }));
      await fs.rm(source, { recursive: true, force: true });
    }
  };
  module.exports = moveFile;
});

// node_modules/@npmcli/fs/lib/index.js
var require_lib6 = __commonJS((exports, module) => {
  var cp = require_cp();
  var withTempDir = require_with_temp_dir();
  var readdirScoped = require_readdir_scoped();
  var moveFile = require_move_file();
  module.exports = {
    cp,
    withTempDir,
    readdirScoped,
    moveFile
  };
});

// node_modules/p-map/index.js
var exports_p_map = {};
__export(exports_p_map, {
  pMapSkip: () => pMapSkip,
  pMapIterable: () => pMapIterable,
  default: () => pMap
});
async function pMap(iterable, mapper, {
  concurrency = Number.POSITIVE_INFINITY,
  stopOnError = true,
  signal
} = {}) {
  return new Promise((resolve_, reject_) => {
    if (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {
      throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof iterable})`);
    }
    if (typeof mapper !== "function") {
      throw new TypeError("Mapper function is required");
    }
    if (!(Number.isSafeInteger(concurrency) && concurrency >= 1 || concurrency === Number.POSITIVE_INFINITY)) {
      throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
    }
    const result = [];
    const errors = [];
    const skippedIndexesMap = new Map;
    let isRejected = false;
    let isResolved = false;
    let isIterableDone = false;
    let resolvingCount = 0;
    let currentIndex = 0;
    const iterator = iterable[Symbol.iterator] === undefined ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
    const signalListener = () => {
      reject(signal.reason);
    };
    const cleanup = () => {
      signal?.removeEventListener("abort", signalListener);
    };
    const resolve = (value) => {
      resolve_(value);
      cleanup();
    };
    const reject = (reason) => {
      isRejected = true;
      isResolved = true;
      reject_(reason);
      cleanup();
    };
    if (signal) {
      if (signal.aborted) {
        reject(signal.reason);
      }
      signal.addEventListener("abort", signalListener, { once: true });
    }
    const next = async () => {
      if (isResolved) {
        return;
      }
      const nextItem = await iterator.next();
      const index = currentIndex;
      currentIndex++;
      if (nextItem.done) {
        isIterableDone = true;
        if (resolvingCount === 0 && !isResolved) {
          if (!stopOnError && errors.length > 0) {
            reject(new AggregateError(errors));
            return;
          }
          isResolved = true;
          if (skippedIndexesMap.size === 0) {
            resolve(result);
            return;
          }
          const pureResult = [];
          for (const [index2, value] of result.entries()) {
            if (skippedIndexesMap.get(index2) === pMapSkip) {
              continue;
            }
            pureResult.push(value);
          }
          resolve(pureResult);
        }
        return;
      }
      resolvingCount++;
      (async () => {
        try {
          const element = await nextItem.value;
          if (isResolved) {
            return;
          }
          const value = await mapper(element, index);
          if (value === pMapSkip) {
            skippedIndexesMap.set(index, value);
          }
          result[index] = value;
          resolvingCount--;
          await next();
        } catch (error) {
          if (stopOnError) {
            reject(error);
          } else {
            errors.push(error);
            resolvingCount--;
            try {
              await next();
            } catch (error2) {
              reject(error2);
            }
          }
        }
      })();
    };
    (async () => {
      for (let index = 0;index < concurrency; index++) {
        try {
          await next();
        } catch (error) {
          reject(error);
          break;
        }
        if (isIterableDone || isRejected) {
          break;
        }
      }
    })();
  });
}
function pMapIterable(iterable, mapper, {
  concurrency = Number.POSITIVE_INFINITY,
  backpressure = concurrency
} = {}) {
  if (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {
    throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof iterable})`);
  }
  if (typeof mapper !== "function") {
    throw new TypeError("Mapper function is required");
  }
  if (!(Number.isSafeInteger(concurrency) && concurrency >= 1 || concurrency === Number.POSITIVE_INFINITY)) {
    throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
  }
  if (!(Number.isSafeInteger(backpressure) && backpressure >= concurrency || backpressure === Number.POSITIVE_INFINITY)) {
    throw new TypeError(`Expected \`backpressure\` to be an integer from \`concurrency\` (${concurrency}) and up or \`Infinity\`, got \`${backpressure}\` (${typeof backpressure})`);
  }
  return {
    async* [Symbol.asyncIterator]() {
      const iterator = iterable[Symbol.asyncIterator] === undefined ? iterable[Symbol.iterator]() : iterable[Symbol.asyncIterator]();
      const promises = [];
      let pendingPromisesCount = 0;
      let isDone = false;
      let index = 0;
      function trySpawn() {
        if (isDone || !(pendingPromisesCount < concurrency && promises.length < backpressure)) {
          return;
        }
        pendingPromisesCount++;
        const promise = (async () => {
          const { done, value } = await iterator.next();
          if (done) {
            pendingPromisesCount--;
            return { done: true };
          }
          trySpawn();
          try {
            const returnValue = await mapper(await value, index++);
            pendingPromisesCount--;
            if (returnValue === pMapSkip) {
              const index2 = promises.indexOf(promise);
              if (index2 > 0) {
                promises.splice(index2, 1);
              }
            }
            trySpawn();
            return { done: false, value: returnValue };
          } catch (error) {
            pendingPromisesCount--;
            isDone = true;
            return { error };
          }
        })();
        promises.push(promise);
      }
      trySpawn();
      while (promises.length > 0) {
        const { error, done, value } = await promises[0];
        promises.shift();
        if (error) {
          throw error;
        }
        if (done) {
          return;
        }
        trySpawn();
        if (value === pMapSkip) {
          continue;
        }
        yield value;
      }
    }
  };
}
var pMapSkip;
var init_p_map = __esm(() => {
  pMapSkip = Symbol("skip");
});

// node_modules/cacache/lib/entry-index.js
var require_entry_index = __commonJS((exports, module) => {
  var crypto2 = __require("crypto");
  var {
    appendFile,
    mkdir,
    readFile,
    readdir,
    rm,
    writeFile
  } = __require("fs/promises");
  var { Minipass } = require_commonjs();
  var path = __require("path");
  var ssri = require_lib3();
  var uniqueFilename = require_lib5();
  var contentPath = require_path();
  var hashToSegments = require_hash_to_segments();
  var indexV = require_package2()["cache-version"].index;
  var { moveFile } = require_lib6();
  var lsStreamConcurrency = 5;
  exports.NotFoundError = class NotFoundError extends Error {
    constructor(cache2, key) {
      super(`No cache entry for ${key} found in ${cache2}`);
      this.code = "ENOENT";
      this.cache = cache2;
      this.key = key;
    }
  };
  exports.compact = compact;
  async function compact(cache2, key, matchFn, opts = {}) {
    const bucket = bucketPath(cache2, key);
    const entries = await bucketEntries(bucket);
    const newEntries = [];
    for (let i = entries.length - 1;i >= 0; --i) {
      const entry = entries[i];
      if (entry.integrity === null && !opts.validateEntry) {
        break;
      }
      if ((!opts.validateEntry || opts.validateEntry(entry) === true) && (newEntries.length === 0 || !newEntries.find((oldEntry) => matchFn(oldEntry, entry)))) {
        newEntries.unshift(entry);
      }
    }
    const newIndex = `
` + newEntries.map((entry) => {
      const stringified = JSON.stringify(entry);
      const hash2 = hashEntry(stringified);
      return `${hash2}	${stringified}`;
    }).join(`
`);
    const setup = async () => {
      const target = uniqueFilename(path.join(cache2, "tmp"), opts.tmpPrefix);
      await mkdir(path.dirname(target), { recursive: true });
      return {
        target,
        moved: false
      };
    };
    const teardown = async (tmp2) => {
      if (!tmp2.moved) {
        return rm(tmp2.target, { recursive: true, force: true });
      }
    };
    const write = async (tmp2) => {
      await writeFile(tmp2.target, newIndex, { flag: "wx" });
      await mkdir(path.dirname(bucket), { recursive: true });
      await moveFile(tmp2.target, bucket);
      tmp2.moved = true;
    };
    const tmp = await setup();
    try {
      await write(tmp);
    } finally {
      await teardown(tmp);
    }
    return newEntries.reverse().map((entry) => formatEntry(cache2, entry, true));
  }
  exports.insert = insert;
  async function insert(cache2, key, integrity, opts = {}) {
    const { metadata, size, time } = opts;
    const bucket = bucketPath(cache2, key);
    const entry = {
      key,
      integrity: integrity && ssri.stringify(integrity),
      time: time || Date.now(),
      size,
      metadata
    };
    try {
      await mkdir(path.dirname(bucket), { recursive: true });
      const stringified = JSON.stringify(entry);
      await appendFile(bucket, `
${hashEntry(stringified)}	${stringified}`);
    } catch (err) {
      if (err.code === "ENOENT") {
        return;
      }
      throw err;
    }
    return formatEntry(cache2, entry);
  }
  exports.find = find;
  async function find(cache2, key) {
    const bucket = bucketPath(cache2, key);
    try {
      const entries = await bucketEntries(bucket);
      return entries.reduce((latest, next) => {
        if (next && next.key === key) {
          return formatEntry(cache2, next);
        } else {
          return latest;
        }
      }, null);
    } catch (err) {
      if (err.code === "ENOENT") {
        return null;
      } else {
        throw err;
      }
    }
  }
  exports.delete = del;
  function del(cache2, key, opts = {}) {
    if (!opts.removeFully) {
      return insert(cache2, key, null, opts);
    }
    const bucket = bucketPath(cache2, key);
    return rm(bucket, { recursive: true, force: true });
  }
  exports.lsStream = lsStream;
  function lsStream(cache2) {
    const indexDir = bucketDir(cache2);
    const stream3 = new Minipass({ objectMode: true });
    Promise.resolve().then(async () => {
      const { default: pMap2 } = await Promise.resolve().then(() => (init_p_map(), exports_p_map));
      const buckets = await readdirOrEmpty(indexDir);
      await pMap2(buckets, async (bucket) => {
        const bucketPath2 = path.join(indexDir, bucket);
        const subbuckets = await readdirOrEmpty(bucketPath2);
        await pMap2(subbuckets, async (subbucket) => {
          const subbucketPath = path.join(bucketPath2, subbucket);
          const subbucketEntries = await readdirOrEmpty(subbucketPath);
          await pMap2(subbucketEntries, async (entry) => {
            const entryPath = path.join(subbucketPath, entry);
            try {
              const entries = await bucketEntries(entryPath);
              const reduced = entries.reduce((acc, entry2) => {
                acc.set(entry2.key, entry2);
                return acc;
              }, new Map);
              for (const entry2 of reduced.values()) {
                const formatted = formatEntry(cache2, entry2);
                if (formatted) {
                  stream3.write(formatted);
                }
              }
            } catch (err) {
              if (err.code === "ENOENT") {
                return;
              }
              throw err;
            }
          }, { concurrency: lsStreamConcurrency });
        }, { concurrency: lsStreamConcurrency });
      }, { concurrency: lsStreamConcurrency });
      stream3.end();
      return stream3;
    }).catch((err) => stream3.emit("error", err));
    return stream3;
  }
  exports.ls = ls;
  async function ls(cache2) {
    const entries = await lsStream(cache2).collect();
    return entries.reduce((acc, xs) => {
      acc[xs.key] = xs;
      return acc;
    }, {});
  }
  exports.bucketEntries = bucketEntries;
  async function bucketEntries(bucket, filter) {
    const data = await readFile(bucket, "utf8");
    return _bucketEntries(data, filter);
  }
  function _bucketEntries(data) {
    const entries = [];
    data.split(`
`).forEach((entry) => {
      if (!entry) {
        return;
      }
      const pieces = entry.split("\t");
      if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {
        return;
      }
      let obj;
      try {
        obj = JSON.parse(pieces[1]);
      } catch (_) {}
      if (obj) {
        entries.push(obj);
      }
    });
    return entries;
  }
  exports.bucketDir = bucketDir;
  function bucketDir(cache2) {
    return path.join(cache2, `index-v${indexV}`);
  }
  exports.bucketPath = bucketPath;
  function bucketPath(cache2, key) {
    const hashed = hashKey(key);
    return path.join.apply(path, [bucketDir(cache2)].concat(hashToSegments(hashed)));
  }
  exports.hashKey = hashKey;
  function hashKey(key) {
    return hash(key, "sha256");
  }
  exports.hashEntry = hashEntry;
  function hashEntry(str) {
    return hash(str, "sha1");
  }
  function hash(str, digest) {
    return crypto2.createHash(digest).update(str).digest("hex");
  }
  function formatEntry(cache2, entry, keepAll) {
    if (!entry.integrity && !keepAll) {
      return null;
    }
    return {
      key: entry.key,
      integrity: entry.integrity,
      path: entry.integrity ? contentPath(cache2, entry.integrity) : undefined,
      size: entry.size,
      time: entry.time,
      metadata: entry.metadata
    };
  }
  function readdirOrEmpty(dir) {
    return readdir(dir).catch((err) => {
      if (err.code === "ENOENT" || err.code === "ENOTDIR") {
        return [];
      }
      throw err;
    });
  }
});

// node_modules/lru-cache/dist/commonjs/index.min.js
var require_index_min = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LRUCache = undefined;
  var x = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date;
  var U = new Set;
  var R = typeof process == "object" && process ? process : {};
  var I = (a, t, e, i) => {
    typeof R.emitWarning == "function" ? R.emitWarning(a, t, e, i) : console.error(`[${e}] ${t}: ${a}`);
  };
  var C = globalThis.AbortController;
  var L = globalThis.AbortSignal;
  if (typeof C > "u") {
    L = class {
      onabort;
      _onabort = [];
      reason;
      aborted = false;
      addEventListener(i, s) {
        this._onabort.push(s);
      }
    }, C = class {
      constructor() {
        t();
      }
      signal = new L;
      abort(i) {
        if (!this.signal.aborted) {
          this.signal.reason = i, this.signal.aborted = true;
          for (let s of this.signal._onabort)
            s(i);
          this.signal.onabort?.(i);
        }
      }
    };
    let a = R.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1", t = () => {
      a && (a = false, I("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", t));
    };
  }
  var G = (a) => !U.has(a);
  var H = Symbol("type");
  var y = (a) => a && a === Math.floor(a) && a > 0 && isFinite(a);
  var M = (a) => y(a) ? a <= Math.pow(2, 8) ? Uint8Array : a <= Math.pow(2, 16) ? Uint16Array : a <= Math.pow(2, 32) ? Uint32Array : a <= Number.MAX_SAFE_INTEGER ? z : null : null;
  var z = class extends Array {
    constructor(t) {
      super(t), this.fill(0);
    }
  };
  var W = class a {
    heap;
    length;
    static #o = false;
    static create(t) {
      let e = M(t);
      if (!e)
        return [];
      a.#o = true;
      let i = new a(t, e);
      return a.#o = false, i;
    }
    constructor(t, e) {
      if (!a.#o)
        throw new TypeError("instantiate Stack using Stack.create(n)");
      this.heap = new e(t), this.length = 0;
    }
    push(t) {
      this.heap[this.length++] = t;
    }
    pop() {
      return this.heap[--this.length];
    }
  };
  var D = class a {
    #o;
    #c;
    #w;
    #C;
    #S;
    #L;
    #U;
    #m;
    get perf() {
      return this.#m;
    }
    ttl;
    ttlResolution;
    ttlAutopurge;
    updateAgeOnGet;
    updateAgeOnHas;
    allowStale;
    noDisposeOnSet;
    noUpdateTTL;
    maxEntrySize;
    sizeCalculation;
    noDeleteOnFetchRejection;
    noDeleteOnStaleGet;
    allowStaleOnFetchAbort;
    allowStaleOnFetchRejection;
    ignoreFetchAbort;
    #n;
    #_;
    #s;
    #i;
    #t;
    #a;
    #u;
    #l;
    #h;
    #b;
    #r;
    #y;
    #A;
    #d;
    #g;
    #T;
    #v;
    #f;
    #I;
    static unsafeExposeInternals(t) {
      return { starts: t.#A, ttls: t.#d, autopurgeTimers: t.#g, sizes: t.#y, keyMap: t.#s, keyList: t.#i, valList: t.#t, next: t.#a, prev: t.#u, get head() {
        return t.#l;
      }, get tail() {
        return t.#h;
      }, free: t.#b, isBackgroundFetch: (e) => t.#e(e), backgroundFetch: (e, i, s, h) => t.#G(e, i, s, h), moveToTail: (e) => t.#D(e), indexes: (e) => t.#F(e), rindexes: (e) => t.#O(e), isStale: (e) => t.#p(e) };
    }
    get max() {
      return this.#o;
    }
    get maxSize() {
      return this.#c;
    }
    get calculatedSize() {
      return this.#_;
    }
    get size() {
      return this.#n;
    }
    get fetchMethod() {
      return this.#L;
    }
    get memoMethod() {
      return this.#U;
    }
    get dispose() {
      return this.#w;
    }
    get onInsert() {
      return this.#C;
    }
    get disposeAfter() {
      return this.#S;
    }
    constructor(t) {
      let { max: e = 0, ttl: i, ttlResolution: s = 1, ttlAutopurge: h, updateAgeOnGet: n, updateAgeOnHas: o, allowStale: r, dispose: f, onInsert: m, disposeAfter: c, noDisposeOnSet: d, noUpdateTTL: g, maxSize: A = 0, maxEntrySize: p = 0, sizeCalculation: _, fetchMethod: l, memoMethod: w, noDeleteOnFetchRejection: b, noDeleteOnStaleGet: S, allowStaleOnFetchRejection: u, allowStaleOnFetchAbort: T, ignoreFetchAbort: F, perf: v } = t;
      if (v !== undefined && typeof v?.now != "function")
        throw new TypeError("perf option must have a now() method if specified");
      if (this.#m = v ?? x, e !== 0 && !y(e))
        throw new TypeError("max option must be a nonnegative integer");
      let O = e ? M(e) : Array;
      if (!O)
        throw new Error("invalid max value: " + e);
      if (this.#o = e, this.#c = A, this.maxEntrySize = p || this.#c, this.sizeCalculation = _, this.sizeCalculation) {
        if (!this.#c && !this.maxEntrySize)
          throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        if (typeof this.sizeCalculation != "function")
          throw new TypeError("sizeCalculation set to non-function");
      }
      if (w !== undefined && typeof w != "function")
        throw new TypeError("memoMethod must be a function if defined");
      if (this.#U = w, l !== undefined && typeof l != "function")
        throw new TypeError("fetchMethod must be a function if specified");
      if (this.#L = l, this.#v = !!l, this.#s = new Map, this.#i = new Array(e).fill(undefined), this.#t = new Array(e).fill(undefined), this.#a = new O(e), this.#u = new O(e), this.#l = 0, this.#h = 0, this.#b = W.create(e), this.#n = 0, this.#_ = 0, typeof f == "function" && (this.#w = f), typeof m == "function" && (this.#C = m), typeof c == "function" ? (this.#S = c, this.#r = []) : (this.#S = undefined, this.#r = undefined), this.#T = !!this.#w, this.#I = !!this.#C, this.#f = !!this.#S, this.noDisposeOnSet = !!d, this.noUpdateTTL = !!g, this.noDeleteOnFetchRejection = !!b, this.allowStaleOnFetchRejection = !!u, this.allowStaleOnFetchAbort = !!T, this.ignoreFetchAbort = !!F, this.maxEntrySize !== 0) {
        if (this.#c !== 0 && !y(this.#c))
          throw new TypeError("maxSize must be a positive integer if specified");
        if (!y(this.maxEntrySize))
          throw new TypeError("maxEntrySize must be a positive integer if specified");
        this.#B();
      }
      if (this.allowStale = !!r, this.noDeleteOnStaleGet = !!S, this.updateAgeOnGet = !!n, this.updateAgeOnHas = !!o, this.ttlResolution = y(s) || s === 0 ? s : 1, this.ttlAutopurge = !!h, this.ttl = i || 0, this.ttl) {
        if (!y(this.ttl))
          throw new TypeError("ttl must be a positive integer if specified");
        this.#j();
      }
      if (this.#o === 0 && this.ttl === 0 && this.#c === 0)
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      if (!this.ttlAutopurge && !this.#o && !this.#c) {
        let E = "LRU_CACHE_UNBOUNDED";
        G(E) && (U.add(E), I("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", E, a));
      }
    }
    getRemainingTTL(t) {
      return this.#s.has(t) ? 1 / 0 : 0;
    }
    #j() {
      let t = new z(this.#o), e = new z(this.#o);
      this.#d = t, this.#A = e;
      let i = this.ttlAutopurge ? new Array(this.#o) : undefined;
      this.#g = i, this.#N = (n, o, r = this.#m.now()) => {
        if (e[n] = o !== 0 ? r : 0, t[n] = o, i?.[n] && (clearTimeout(i[n]), i[n] = undefined), o !== 0 && i) {
          let f = setTimeout(() => {
            this.#p(n) && this.#E(this.#i[n], "expire");
          }, o + 1);
          f.unref && f.unref(), i[n] = f;
        }
      }, this.#R = (n) => {
        e[n] = t[n] !== 0 ? this.#m.now() : 0;
      }, this.#z = (n, o) => {
        if (t[o]) {
          let r = t[o], f = e[o];
          if (!r || !f)
            return;
          n.ttl = r, n.start = f, n.now = s || h();
          let m = n.now - f;
          n.remainingTTL = r - m;
        }
      };
      let s = 0, h = () => {
        let n = this.#m.now();
        if (this.ttlResolution > 0) {
          s = n;
          let o = setTimeout(() => s = 0, this.ttlResolution);
          o.unref && o.unref();
        }
        return n;
      };
      this.getRemainingTTL = (n) => {
        let o = this.#s.get(n);
        if (o === undefined)
          return 0;
        let r = t[o], f = e[o];
        if (!r || !f)
          return 1 / 0;
        let m = (s || h()) - f;
        return r - m;
      }, this.#p = (n) => {
        let o = e[n], r = t[n];
        return !!r && !!o && (s || h()) - o > r;
      };
    }
    #R = () => {};
    #z = () => {};
    #N = () => {};
    #p = () => false;
    #B() {
      let t = new z(this.#o);
      this.#_ = 0, this.#y = t, this.#W = (e) => {
        this.#_ -= t[e], t[e] = 0;
      }, this.#P = (e, i, s, h) => {
        if (this.#e(i))
          return 0;
        if (!y(s))
          if (h) {
            if (typeof h != "function")
              throw new TypeError("sizeCalculation must be a function");
            if (s = h(i, e), !y(s))
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          } else
            throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        return s;
      }, this.#M = (e, i, s) => {
        if (t[e] = i, this.#c) {
          let h = this.#c - t[e];
          for (;this.#_ > h; )
            this.#x(true);
        }
        this.#_ += t[e], s && (s.entrySize = i, s.totalCalculatedSize = this.#_);
      };
    }
    #W = (t) => {};
    #M = (t, e, i) => {};
    #P = (t, e, i, s) => {
      if (i || s)
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      return 0;
    };
    *#F({ allowStale: t = this.allowStale } = {}) {
      if (this.#n)
        for (let e = this.#h;!(!this.#H(e) || ((t || !this.#p(e)) && (yield e), e === this.#l)); )
          e = this.#u[e];
    }
    *#O({ allowStale: t = this.allowStale } = {}) {
      if (this.#n)
        for (let e = this.#l;!(!this.#H(e) || ((t || !this.#p(e)) && (yield e), e === this.#h)); )
          e = this.#a[e];
    }
    #H(t) {
      return t !== undefined && this.#s.get(this.#i[t]) === t;
    }
    *entries() {
      for (let t of this.#F())
        this.#t[t] !== undefined && this.#i[t] !== undefined && !this.#e(this.#t[t]) && (yield [this.#i[t], this.#t[t]]);
    }
    *rentries() {
      for (let t of this.#O())
        this.#t[t] !== undefined && this.#i[t] !== undefined && !this.#e(this.#t[t]) && (yield [this.#i[t], this.#t[t]]);
    }
    *keys() {
      for (let t of this.#F()) {
        let e = this.#i[t];
        e !== undefined && !this.#e(this.#t[t]) && (yield e);
      }
    }
    *rkeys() {
      for (let t of this.#O()) {
        let e = this.#i[t];
        e !== undefined && !this.#e(this.#t[t]) && (yield e);
      }
    }
    *values() {
      for (let t of this.#F())
        this.#t[t] !== undefined && !this.#e(this.#t[t]) && (yield this.#t[t]);
    }
    *rvalues() {
      for (let t of this.#O())
        this.#t[t] !== undefined && !this.#e(this.#t[t]) && (yield this.#t[t]);
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    [Symbol.toStringTag] = "LRUCache";
    find(t, e = {}) {
      for (let i of this.#F()) {
        let s = this.#t[i], h = this.#e(s) ? s.__staleWhileFetching : s;
        if (h !== undefined && t(h, this.#i[i], this))
          return this.get(this.#i[i], e);
      }
    }
    forEach(t, e = this) {
      for (let i of this.#F()) {
        let s = this.#t[i], h = this.#e(s) ? s.__staleWhileFetching : s;
        h !== undefined && t.call(e, h, this.#i[i], this);
      }
    }
    rforEach(t, e = this) {
      for (let i of this.#O()) {
        let s = this.#t[i], h = this.#e(s) ? s.__staleWhileFetching : s;
        h !== undefined && t.call(e, h, this.#i[i], this);
      }
    }
    purgeStale() {
      let t = false;
      for (let e of this.#O({ allowStale: true }))
        this.#p(e) && (this.#E(this.#i[e], "expire"), t = true);
      return t;
    }
    info(t) {
      let e = this.#s.get(t);
      if (e === undefined)
        return;
      let i = this.#t[e], s = this.#e(i) ? i.__staleWhileFetching : i;
      if (s === undefined)
        return;
      let h = { value: s };
      if (this.#d && this.#A) {
        let n = this.#d[e], o = this.#A[e];
        if (n && o) {
          let r = n - (this.#m.now() - o);
          h.ttl = r, h.start = Date.now();
        }
      }
      return this.#y && (h.size = this.#y[e]), h;
    }
    dump() {
      let t = [];
      for (let e of this.#F({ allowStale: true })) {
        let i = this.#i[e], s = this.#t[e], h = this.#e(s) ? s.__staleWhileFetching : s;
        if (h === undefined || i === undefined)
          continue;
        let n = { value: h };
        if (this.#d && this.#A) {
          n.ttl = this.#d[e];
          let o = this.#m.now() - this.#A[e];
          n.start = Math.floor(Date.now() - o);
        }
        this.#y && (n.size = this.#y[e]), t.unshift([i, n]);
      }
      return t;
    }
    load(t) {
      this.clear();
      for (let [e, i] of t) {
        if (i.start) {
          let s = Date.now() - i.start;
          i.start = this.#m.now() - s;
        }
        this.set(e, i.value, i);
      }
    }
    set(t, e, i = {}) {
      if (e === undefined)
        return this.delete(t), this;
      let { ttl: s = this.ttl, start: h, noDisposeOnSet: n = this.noDisposeOnSet, sizeCalculation: o = this.sizeCalculation, status: r } = i, { noUpdateTTL: f = this.noUpdateTTL } = i, m = this.#P(t, e, i.size || 0, o);
      if (this.maxEntrySize && m > this.maxEntrySize)
        return r && (r.set = "miss", r.maxEntrySizeExceeded = true), this.#E(t, "set"), this;
      let c = this.#n === 0 ? undefined : this.#s.get(t);
      if (c === undefined)
        c = this.#n === 0 ? this.#h : this.#b.length !== 0 ? this.#b.pop() : this.#n === this.#o ? this.#x(false) : this.#n, this.#i[c] = t, this.#t[c] = e, this.#s.set(t, c), this.#a[this.#h] = c, this.#u[c] = this.#h, this.#h = c, this.#n++, this.#M(c, m, r), r && (r.set = "add"), f = false, this.#I && this.#C?.(e, t, "add");
      else {
        this.#D(c);
        let d = this.#t[c];
        if (e !== d) {
          if (this.#v && this.#e(d)) {
            d.__abortController.abort(new Error("replaced"));
            let { __staleWhileFetching: g } = d;
            g !== undefined && !n && (this.#T && this.#w?.(g, t, "set"), this.#f && this.#r?.push([g, t, "set"]));
          } else
            n || (this.#T && this.#w?.(d, t, "set"), this.#f && this.#r?.push([d, t, "set"]));
          if (this.#W(c), this.#M(c, m, r), this.#t[c] = e, r) {
            r.set = "replace";
            let g = d && this.#e(d) ? d.__staleWhileFetching : d;
            g !== undefined && (r.oldValue = g);
          }
        } else
          r && (r.set = "update");
        this.#I && this.onInsert?.(e, t, e === d ? "update" : "replace");
      }
      if (s !== 0 && !this.#d && this.#j(), this.#d && (f || this.#N(c, s, h), r && this.#z(r, c)), !n && this.#f && this.#r) {
        let d = this.#r, g;
        for (;g = d?.shift(); )
          this.#S?.(...g);
      }
      return this;
    }
    pop() {
      try {
        for (;this.#n; ) {
          let t = this.#t[this.#l];
          if (this.#x(true), this.#e(t)) {
            if (t.__staleWhileFetching)
              return t.__staleWhileFetching;
          } else if (t !== undefined)
            return t;
        }
      } finally {
        if (this.#f && this.#r) {
          let t = this.#r, e;
          for (;e = t?.shift(); )
            this.#S?.(...e);
        }
      }
    }
    #x(t) {
      let e = this.#l, i = this.#i[e], s = this.#t[e];
      return this.#v && this.#e(s) ? s.__abortController.abort(new Error("evicted")) : (this.#T || this.#f) && (this.#T && this.#w?.(s, i, "evict"), this.#f && this.#r?.push([s, i, "evict"])), this.#W(e), this.#g?.[e] && (clearTimeout(this.#g[e]), this.#g[e] = undefined), t && (this.#i[e] = undefined, this.#t[e] = undefined, this.#b.push(e)), this.#n === 1 ? (this.#l = this.#h = 0, this.#b.length = 0) : this.#l = this.#a[e], this.#s.delete(i), this.#n--, e;
    }
    has(t, e = {}) {
      let { updateAgeOnHas: i = this.updateAgeOnHas, status: s } = e, h = this.#s.get(t);
      if (h !== undefined) {
        let n = this.#t[h];
        if (this.#e(n) && n.__staleWhileFetching === undefined)
          return false;
        if (this.#p(h))
          s && (s.has = "stale", this.#z(s, h));
        else
          return i && this.#R(h), s && (s.has = "hit", this.#z(s, h)), true;
      } else
        s && (s.has = "miss");
      return false;
    }
    peek(t, e = {}) {
      let { allowStale: i = this.allowStale } = e, s = this.#s.get(t);
      if (s === undefined || !i && this.#p(s))
        return;
      let h = this.#t[s];
      return this.#e(h) ? h.__staleWhileFetching : h;
    }
    #G(t, e, i, s) {
      let h = e === undefined ? undefined : this.#t[e];
      if (this.#e(h))
        return h;
      let n = new C, { signal: o } = i;
      o?.addEventListener("abort", () => n.abort(o.reason), { signal: n.signal });
      let r = { signal: n.signal, options: i, context: s }, f = (p, _ = false) => {
        let { aborted: l } = n.signal, w = i.ignoreFetchAbort && p !== undefined, b = i.ignoreFetchAbort || !!(i.allowStaleOnFetchAbort && p !== undefined);
        if (i.status && (l && !_ ? (i.status.fetchAborted = true, i.status.fetchError = n.signal.reason, w && (i.status.fetchAbortIgnored = true)) : i.status.fetchResolved = true), l && !w && !_)
          return c(n.signal.reason, b);
        let S = g, u = this.#t[e];
        return (u === g || w && _ && u === undefined) && (p === undefined ? S.__staleWhileFetching !== undefined ? this.#t[e] = S.__staleWhileFetching : this.#E(t, "fetch") : (i.status && (i.status.fetchUpdated = true), this.set(t, p, r.options))), p;
      }, m = (p) => (i.status && (i.status.fetchRejected = true, i.status.fetchError = p), c(p, false)), c = (p, _) => {
        let { aborted: l } = n.signal, w = l && i.allowStaleOnFetchAbort, b = w || i.allowStaleOnFetchRejection, S = b || i.noDeleteOnFetchRejection, u = g;
        if (this.#t[e] === g && (!S || !_ && u.__staleWhileFetching === undefined ? this.#E(t, "fetch") : w || (this.#t[e] = u.__staleWhileFetching)), b)
          return i.status && u.__staleWhileFetching !== undefined && (i.status.returnedStale = true), u.__staleWhileFetching;
        if (u.__returned === u)
          throw p;
      }, d = (p, _) => {
        let l = this.#L?.(t, h, r);
        l && l instanceof Promise && l.then((w) => p(w === undefined ? undefined : w), _), n.signal.addEventListener("abort", () => {
          (!i.ignoreFetchAbort || i.allowStaleOnFetchAbort) && (p(undefined), i.allowStaleOnFetchAbort && (p = (w) => f(w, true)));
        });
      };
      i.status && (i.status.fetchDispatched = true);
      let g = new Promise(d).then(f, m), A = Object.assign(g, { __abortController: n, __staleWhileFetching: h, __returned: undefined });
      return e === undefined ? (this.set(t, A, { ...r.options, status: undefined }), e = this.#s.get(t)) : this.#t[e] = A, A;
    }
    #e(t) {
      if (!this.#v)
        return false;
      let e = t;
      return !!e && e instanceof Promise && e.hasOwnProperty("__staleWhileFetching") && e.__abortController instanceof C;
    }
    async fetch(t, e = {}) {
      let { allowStale: i = this.allowStale, updateAgeOnGet: s = this.updateAgeOnGet, noDeleteOnStaleGet: h = this.noDeleteOnStaleGet, ttl: n = this.ttl, noDisposeOnSet: o = this.noDisposeOnSet, size: r = 0, sizeCalculation: f = this.sizeCalculation, noUpdateTTL: m = this.noUpdateTTL, noDeleteOnFetchRejection: c = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection: d = this.allowStaleOnFetchRejection, ignoreFetchAbort: g = this.ignoreFetchAbort, allowStaleOnFetchAbort: A = this.allowStaleOnFetchAbort, context: p, forceRefresh: _ = false, status: l, signal: w } = e;
      if (!this.#v)
        return l && (l.fetch = "get"), this.get(t, { allowStale: i, updateAgeOnGet: s, noDeleteOnStaleGet: h, status: l });
      let b = { allowStale: i, updateAgeOnGet: s, noDeleteOnStaleGet: h, ttl: n, noDisposeOnSet: o, size: r, sizeCalculation: f, noUpdateTTL: m, noDeleteOnFetchRejection: c, allowStaleOnFetchRejection: d, allowStaleOnFetchAbort: A, ignoreFetchAbort: g, status: l, signal: w }, S = this.#s.get(t);
      if (S === undefined) {
        l && (l.fetch = "miss");
        let u = this.#G(t, S, b, p);
        return u.__returned = u;
      } else {
        let u = this.#t[S];
        if (this.#e(u)) {
          let E = i && u.__staleWhileFetching !== undefined;
          return l && (l.fetch = "inflight", E && (l.returnedStale = true)), E ? u.__staleWhileFetching : u.__returned = u;
        }
        let T = this.#p(S);
        if (!_ && !T)
          return l && (l.fetch = "hit"), this.#D(S), s && this.#R(S), l && this.#z(l, S), u;
        let F = this.#G(t, S, b, p), O = F.__staleWhileFetching !== undefined && i;
        return l && (l.fetch = T ? "stale" : "refresh", O && T && (l.returnedStale = true)), O ? F.__staleWhileFetching : F.__returned = F;
      }
    }
    async forceFetch(t, e = {}) {
      let i = await this.fetch(t, e);
      if (i === undefined)
        throw new Error("fetch() returned undefined");
      return i;
    }
    memo(t, e = {}) {
      let i = this.#U;
      if (!i)
        throw new Error("no memoMethod provided to constructor");
      let { context: s, forceRefresh: h, ...n } = e, o = this.get(t, n);
      if (!h && o !== undefined)
        return o;
      let r = i(t, o, { options: n, context: s });
      return this.set(t, r, n), r;
    }
    get(t, e = {}) {
      let { allowStale: i = this.allowStale, updateAgeOnGet: s = this.updateAgeOnGet, noDeleteOnStaleGet: h = this.noDeleteOnStaleGet, status: n } = e, o = this.#s.get(t);
      if (o !== undefined) {
        let r = this.#t[o], f = this.#e(r);
        return n && this.#z(n, o), this.#p(o) ? (n && (n.get = "stale"), f ? (n && i && r.__staleWhileFetching !== undefined && (n.returnedStale = true), i ? r.__staleWhileFetching : undefined) : (h || this.#E(t, "expire"), n && i && (n.returnedStale = true), i ? r : undefined)) : (n && (n.get = "hit"), f ? r.__staleWhileFetching : (this.#D(o), s && this.#R(o), r));
      } else
        n && (n.get = "miss");
    }
    #k(t, e) {
      this.#u[e] = t, this.#a[t] = e;
    }
    #D(t) {
      t !== this.#h && (t === this.#l ? this.#l = this.#a[t] : this.#k(this.#u[t], this.#a[t]), this.#k(this.#h, t), this.#h = t);
    }
    delete(t) {
      return this.#E(t, "delete");
    }
    #E(t, e) {
      let i = false;
      if (this.#n !== 0) {
        let s = this.#s.get(t);
        if (s !== undefined)
          if (this.#g?.[s] && (clearTimeout(this.#g?.[s]), this.#g[s] = undefined), i = true, this.#n === 1)
            this.#V(e);
          else {
            this.#W(s);
            let h = this.#t[s];
            if (this.#e(h) ? h.__abortController.abort(new Error("deleted")) : (this.#T || this.#f) && (this.#T && this.#w?.(h, t, e), this.#f && this.#r?.push([h, t, e])), this.#s.delete(t), this.#i[s] = undefined, this.#t[s] = undefined, s === this.#h)
              this.#h = this.#u[s];
            else if (s === this.#l)
              this.#l = this.#a[s];
            else {
              let n = this.#u[s];
              this.#a[n] = this.#a[s];
              let o = this.#a[s];
              this.#u[o] = this.#u[s];
            }
            this.#n--, this.#b.push(s);
          }
      }
      if (this.#f && this.#r?.length) {
        let s = this.#r, h;
        for (;h = s?.shift(); )
          this.#S?.(...h);
      }
      return i;
    }
    clear() {
      return this.#V("delete");
    }
    #V(t) {
      for (let e of this.#O({ allowStale: true })) {
        let i = this.#t[e];
        if (this.#e(i))
          i.__abortController.abort(new Error("deleted"));
        else {
          let s = this.#i[e];
          this.#T && this.#w?.(i, s, t), this.#f && this.#r?.push([i, s, t]);
        }
      }
      if (this.#s.clear(), this.#t.fill(undefined), this.#i.fill(undefined), this.#d && this.#A) {
        this.#d.fill(0), this.#A.fill(0);
        for (let e of this.#g ?? [])
          e !== undefined && clearTimeout(e);
        this.#g?.fill(undefined);
      }
      if (this.#y && this.#y.fill(0), this.#l = 0, this.#h = 0, this.#b.length = 0, this.#_ = 0, this.#n = 0, this.#f && this.#r) {
        let e = this.#r, i;
        for (;i = e?.shift(); )
          this.#S?.(...i);
      }
    }
  };
  exports.LRUCache = D;
});

// node_modules/cacache/lib/memoization.js
var require_memoization = __commonJS((exports, module) => {
  var { LRUCache } = require_index_min();
  var MEMOIZED = new LRUCache({
    max: 500,
    maxSize: 50 * 1024 * 1024,
    ttl: 3 * 60 * 1000,
    sizeCalculation: (entry, key) => key.startsWith("key:") ? entry.data.length : entry.length
  });
  exports.clearMemoized = clearMemoized;
  function clearMemoized() {
    const old = {};
    MEMOIZED.forEach((v, k) => {
      old[k] = v;
    });
    MEMOIZED.clear();
    return old;
  }
  exports.put = put;
  function put(cache2, entry, data, opts) {
    pickMem(opts).set(`key:${cache2}:${entry.key}`, { entry, data });
    putDigest(cache2, entry.integrity, data, opts);
  }
  exports.put.byDigest = putDigest;
  function putDigest(cache2, integrity, data, opts) {
    pickMem(opts).set(`digest:${cache2}:${integrity}`, data);
  }
  exports.get = get;
  function get(cache2, key, opts) {
    return pickMem(opts).get(`key:${cache2}:${key}`);
  }
  exports.get.byDigest = getDigest;
  function getDigest(cache2, integrity, opts) {
    return pickMem(opts).get(`digest:${cache2}:${integrity}`);
  }

  class ObjProxy {
    constructor(obj) {
      this.obj = obj;
    }
    get(key) {
      return this.obj[key];
    }
    set(key, val) {
      this.obj[key] = val;
    }
  }
  function pickMem(opts) {
    if (!opts || !opts.memoize) {
      return MEMOIZED;
    } else if (opts.memoize.get && opts.memoize.set) {
      return opts.memoize;
    } else if (typeof opts.memoize === "object") {
      return new ObjProxy(opts.memoize);
    } else {
      return MEMOIZED;
    }
  }
});

// node_modules/fs-minipass/lib/index.js
var require_lib7 = __commonJS((exports) => {
  var { Minipass } = require_commonjs();
  var EE = __require("events").EventEmitter;
  var fs = __require("fs");
  var writev = fs.writev;
  var _autoClose = Symbol("_autoClose");
  var _close = Symbol("_close");
  var _ended = Symbol("_ended");
  var _fd = Symbol("_fd");
  var _finished = Symbol("_finished");
  var _flags = Symbol("_flags");
  var _flush = Symbol("_flush");
  var _handleChunk = Symbol("_handleChunk");
  var _makeBuf = Symbol("_makeBuf");
  var _mode = Symbol("_mode");
  var _needDrain = Symbol("_needDrain");
  var _onerror = Symbol("_onerror");
  var _onopen = Symbol("_onopen");
  var _onread = Symbol("_onread");
  var _onwrite = Symbol("_onwrite");
  var _open = Symbol("_open");
  var _path = Symbol("_path");
  var _pos = Symbol("_pos");
  var _queue = Symbol("_queue");
  var _read = Symbol("_read");
  var _readSize = Symbol("_readSize");
  var _reading = Symbol("_reading");
  var _remain = Symbol("_remain");
  var _size = Symbol("_size");
  var _write = Symbol("_write");
  var _writing = Symbol("_writing");
  var _defaultFlag = Symbol("_defaultFlag");
  var _errored = Symbol("_errored");

  class ReadStream extends Minipass {
    constructor(path, opt) {
      opt = opt || {};
      super(opt);
      this.readable = true;
      this.writable = false;
      if (typeof path !== "string") {
        throw new TypeError("path must be a string");
      }
      this[_errored] = false;
      this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
      this[_path] = path;
      this[_readSize] = opt.readSize || 16 * 1024 * 1024;
      this[_reading] = false;
      this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
      this[_remain] = this[_size];
      this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
      if (typeof this[_fd] === "number") {
        this[_read]();
      } else {
        this[_open]();
      }
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    write() {
      throw new TypeError("this is a readable stream");
    }
    end() {
      throw new TypeError("this is a readable stream");
    }
    [_open]() {
      fs.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
      if (er) {
        this[_onerror](er);
      } else {
        this[_fd] = fd;
        this.emit("open", fd);
        this[_read]();
      }
    }
    [_makeBuf]() {
      return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
    }
    [_read]() {
      if (!this[_reading]) {
        this[_reading] = true;
        const buf = this[_makeBuf]();
        if (buf.length === 0) {
          return process.nextTick(() => this[_onread](null, 0, buf));
        }
        fs.read(this[_fd], buf, 0, buf.length, null, (er, br, b) => this[_onread](er, br, b));
      }
    }
    [_onread](er, br, buf) {
      this[_reading] = false;
      if (er) {
        this[_onerror](er);
      } else if (this[_handleChunk](br, buf)) {
        this[_read]();
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
    [_onerror](er) {
      this[_reading] = true;
      this[_close]();
      this.emit("error", er);
    }
    [_handleChunk](br, buf) {
      let ret = false;
      this[_remain] -= br;
      if (br > 0) {
        ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
      }
      if (br === 0 || this[_remain] <= 0) {
        ret = false;
        this[_close]();
        super.end();
      }
      return ret;
    }
    emit(ev, data) {
      switch (ev) {
        case "prefinish":
        case "finish":
          break;
        case "drain":
          if (typeof this[_fd] === "number") {
            this[_read]();
          }
          break;
        case "error":
          if (this[_errored]) {
            return;
          }
          this[_errored] = true;
          return super.emit(ev, data);
        default:
          return super.emit(ev, data);
      }
    }
  }

  class ReadStreamSync extends ReadStream {
    [_open]() {
      let threw = true;
      try {
        this[_onopen](null, fs.openSync(this[_path], "r"));
        threw = false;
      } finally {
        if (threw) {
          this[_close]();
        }
      }
    }
    [_read]() {
      let threw = true;
      try {
        if (!this[_reading]) {
          this[_reading] = true;
          do {
            const buf = this[_makeBuf]();
            const br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null);
            if (!this[_handleChunk](br, buf)) {
              break;
            }
          } while (true);
          this[_reading] = false;
        }
        threw = false;
      } finally {
        if (threw) {
          this[_close]();
        }
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs.closeSync(fd);
        this.emit("close");
      }
    }
  }

  class WriteStream extends EE {
    constructor(path, opt) {
      opt = opt || {};
      super(opt);
      this.readable = false;
      this.writable = true;
      this[_errored] = false;
      this[_writing] = false;
      this[_ended] = false;
      this[_needDrain] = false;
      this[_queue] = [];
      this[_path] = path;
      this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
      this[_mode] = opt.mode === undefined ? 438 : opt.mode;
      this[_pos] = typeof opt.start === "number" ? opt.start : null;
      this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
      const defaultFlag = this[_pos] !== null ? "r+" : "w";
      this[_defaultFlag] = opt.flags === undefined;
      this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
      if (this[_fd] === null) {
        this[_open]();
      }
    }
    emit(ev, data) {
      if (ev === "error") {
        if (this[_errored]) {
          return;
        }
        this[_errored] = true;
      }
      return super.emit(ev, data);
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    [_onerror](er) {
      this[_close]();
      this[_writing] = true;
      this.emit("error", er);
    }
    [_open]() {
      fs.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
      if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
        this[_flags] = "w";
        this[_open]();
      } else if (er) {
        this[_onerror](er);
      } else {
        this[_fd] = fd;
        this.emit("open", fd);
        if (!this[_writing]) {
          this[_flush]();
        }
      }
    }
    end(buf, enc) {
      if (buf) {
        this.write(buf, enc);
      }
      this[_ended] = true;
      if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number") {
        this[_onwrite](null, 0);
      }
      return this;
    }
    write(buf, enc) {
      if (typeof buf === "string") {
        buf = Buffer.from(buf, enc);
      }
      if (this[_ended]) {
        this.emit("error", new Error("write() after end()"));
        return false;
      }
      if (this[_fd] === null || this[_writing] || this[_queue].length) {
        this[_queue].push(buf);
        this[_needDrain] = true;
        return false;
      }
      this[_writing] = true;
      this[_write](buf);
      return true;
    }
    [_write](buf) {
      fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
    }
    [_onwrite](er, bw) {
      if (er) {
        this[_onerror](er);
      } else {
        if (this[_pos] !== null) {
          this[_pos] += bw;
        }
        if (this[_queue].length) {
          this[_flush]();
        } else {
          this[_writing] = false;
          if (this[_ended] && !this[_finished]) {
            this[_finished] = true;
            this[_close]();
            this.emit("finish");
          } else if (this[_needDrain]) {
            this[_needDrain] = false;
            this.emit("drain");
          }
        }
      }
    }
    [_flush]() {
      if (this[_queue].length === 0) {
        if (this[_ended]) {
          this[_onwrite](null, 0);
        }
      } else if (this[_queue].length === 1) {
        this[_write](this[_queue].pop());
      } else {
        const iovec = this[_queue];
        this[_queue] = [];
        writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
  }

  class WriteStreamSync extends WriteStream {
    [_open]() {
      let fd;
      if (this[_defaultFlag] && this[_flags] === "r+") {
        try {
          fd = fs.openSync(this[_path], this[_flags], this[_mode]);
        } catch (er) {
          if (er.code === "ENOENT") {
            this[_flags] = "w";
            return this[_open]();
          } else {
            throw er;
          }
        }
      } else {
        fd = fs.openSync(this[_path], this[_flags], this[_mode]);
      }
      this[_onopen](null, fd);
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs.closeSync(fd);
        this.emit("close");
      }
    }
    [_write](buf) {
      let threw = true;
      try {
        this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
        threw = false;
      } finally {
        if (threw) {
          try {
            this[_close]();
          } catch {}
        }
      }
    }
  }
  exports.ReadStream = ReadStream;
  exports.ReadStreamSync = ReadStreamSync;
  exports.WriteStream = WriteStream;
  exports.WriteStreamSync = WriteStreamSync;
});

// node_modules/cacache/lib/content/read.js
var require_read = __commonJS((exports, module) => {
  var fs = __require("fs/promises");
  var fsm = require_lib7();
  var ssri = require_lib3();
  var contentPath = require_path();
  var Pipeline = require_minipass_pipeline();
  module.exports = read;
  var MAX_SINGLE_READ_SIZE = 64 * 1024 * 1024;
  async function read(cache2, integrity, opts = {}) {
    const { size } = opts;
    const { stat, cpath, sri } = await withContentSri(cache2, integrity, async (cpath2, sri2) => {
      const stat2 = size ? { size } : await fs.stat(cpath2);
      return { stat: stat2, cpath: cpath2, sri: sri2 };
    });
    if (stat.size > MAX_SINGLE_READ_SIZE) {
      return readPipeline(cpath, stat.size, sri, new Pipeline).concat();
    }
    const data = await fs.readFile(cpath, { encoding: null });
    if (stat.size !== data.length) {
      throw sizeError(stat.size, data.length);
    }
    if (!ssri.checkData(data, sri)) {
      throw integrityError(sri, cpath);
    }
    return data;
  }
  var readPipeline = (cpath, size, sri, stream3) => {
    stream3.push(new fsm.ReadStream(cpath, {
      size,
      readSize: MAX_SINGLE_READ_SIZE
    }), ssri.integrityStream({
      integrity: sri,
      size
    }));
    return stream3;
  };
  module.exports.stream = readStream;
  module.exports.readStream = readStream;
  function readStream(cache2, integrity, opts = {}) {
    const { size } = opts;
    const stream3 = new Pipeline;
    Promise.resolve().then(async () => {
      const { stat, cpath, sri } = await withContentSri(cache2, integrity, async (cpath2, sri2) => {
        const stat2 = size ? { size } : await fs.stat(cpath2);
        return { stat: stat2, cpath: cpath2, sri: sri2 };
      });
      return readPipeline(cpath, stat.size, sri, stream3);
    }).catch((err) => stream3.emit("error", err));
    return stream3;
  }
  module.exports.copy = copy;
  function copy(cache2, integrity, dest) {
    return withContentSri(cache2, integrity, (cpath) => {
      return fs.copyFile(cpath, dest);
    });
  }
  module.exports.hasContent = hasContent;
  async function hasContent(cache2, integrity) {
    if (!integrity) {
      return false;
    }
    try {
      return await withContentSri(cache2, integrity, async (cpath, sri) => {
        const stat = await fs.stat(cpath);
        return { size: stat.size, sri, stat };
      });
    } catch (err) {
      if (err.code === "ENOENT") {
        return false;
      }
      if (err.code === "EPERM") {
        if (process.platform !== "win32") {
          throw err;
        } else {
          return false;
        }
      }
    }
  }
  async function withContentSri(cache2, integrity, fn) {
    const sri = ssri.parse(integrity);
    const algo = sri.pickAlgorithm();
    const digests = sri[algo];
    if (digests.length <= 1) {
      const cpath = contentPath(cache2, digests[0]);
      return fn(cpath, digests[0]);
    } else {
      const results = await Promise.all(digests.map(async (meta) => {
        try {
          return await withContentSri(cache2, meta, fn);
        } catch (err) {
          if (err.code === "ENOENT") {
            return Object.assign(new Error("No matching content found for " + sri.toString()), { code: "ENOENT" });
          }
          return err;
        }
      }));
      const result = results.find((r) => !(r instanceof Error));
      if (result) {
        return result;
      }
      const enoentError = results.find((r) => r.code === "ENOENT");
      if (enoentError) {
        throw enoentError;
      }
      throw results.find((r) => r instanceof Error);
    }
  }
  function sizeError(expected, found) {
    const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`);
    err.expected = expected;
    err.found = found;
    err.code = "EBADSIZE";
    return err;
  }
  function integrityError(sri, path) {
    const err = new Error(`Integrity verification failed for ${sri} (${path})`);
    err.code = "EINTEGRITY";
    err.sri = sri;
    err.path = path;
    return err;
  }
});

// node_modules/cacache/lib/get.js
var require_get = __commonJS((exports, module) => {
  var Collect = require_minipass_collect();
  var { Minipass } = require_commonjs();
  var Pipeline = require_minipass_pipeline();
  var index = require_entry_index();
  var memo = require_memoization();
  var read = require_read();
  async function getData(cache2, key, opts = {}) {
    const { integrity, memoize, size } = opts;
    const memoized = memo.get(cache2, key, opts);
    if (memoized && memoize !== false) {
      return {
        metadata: memoized.entry.metadata,
        data: memoized.data,
        integrity: memoized.entry.integrity,
        size: memoized.entry.size
      };
    }
    const entry = await index.find(cache2, key, opts);
    if (!entry) {
      throw new index.NotFoundError(cache2, key);
    }
    const data = await read(cache2, entry.integrity, { integrity, size });
    if (memoize) {
      memo.put(cache2, entry, data, opts);
    }
    return {
      data,
      metadata: entry.metadata,
      size: entry.size,
      integrity: entry.integrity
    };
  }
  module.exports = getData;
  async function getDataByDigest(cache2, key, opts = {}) {
    const { integrity, memoize, size } = opts;
    const memoized = memo.get.byDigest(cache2, key, opts);
    if (memoized && memoize !== false) {
      return memoized;
    }
    const res = await read(cache2, key, { integrity, size });
    if (memoize) {
      memo.put.byDigest(cache2, key, res, opts);
    }
    return res;
  }
  module.exports.byDigest = getDataByDigest;
  var getMemoizedStream = (memoized) => {
    const stream3 = new Minipass;
    stream3.on("newListener", function(ev, cb) {
      ev === "metadata" && cb(memoized.entry.metadata);
      ev === "integrity" && cb(memoized.entry.integrity);
      ev === "size" && cb(memoized.entry.size);
    });
    stream3.end(memoized.data);
    return stream3;
  };
  function getStream2(cache2, key, opts = {}) {
    const { memoize, size } = opts;
    const memoized = memo.get(cache2, key, opts);
    if (memoized && memoize !== false) {
      return getMemoizedStream(memoized);
    }
    const stream3 = new Pipeline;
    Promise.resolve().then(async () => {
      const entry = await index.find(cache2, key);
      if (!entry) {
        throw new index.NotFoundError(cache2, key);
      }
      stream3.emit("metadata", entry.metadata);
      stream3.emit("integrity", entry.integrity);
      stream3.emit("size", entry.size);
      stream3.on("newListener", function(ev, cb) {
        ev === "metadata" && cb(entry.metadata);
        ev === "integrity" && cb(entry.integrity);
        ev === "size" && cb(entry.size);
      });
      const src = read.readStream(cache2, entry.integrity, { ...opts, size: typeof size !== "number" ? entry.size : size });
      if (memoize) {
        const memoStream = new Collect.PassThrough;
        memoStream.on("collect", (data) => memo.put(cache2, entry, data, opts));
        stream3.unshift(memoStream);
      }
      stream3.unshift(src);
      return stream3;
    }).catch((err) => stream3.emit("error", err));
    return stream3;
  }
  module.exports.stream = getStream2;
  function getStreamDigest(cache2, integrity, opts = {}) {
    const { memoize } = opts;
    const memoized = memo.get.byDigest(cache2, integrity, opts);
    if (memoized && memoize !== false) {
      const stream3 = new Minipass;
      stream3.end(memoized);
      return stream3;
    } else {
      const stream3 = read.readStream(cache2, integrity, opts);
      if (!memoize) {
        return stream3;
      }
      const memoStream = new Collect.PassThrough;
      memoStream.on("collect", (data) => memo.put.byDigest(cache2, integrity, data, opts));
      return new Pipeline(stream3, memoStream);
    }
  }
  module.exports.stream.byDigest = getStreamDigest;
  function info(cache2, key, opts = {}) {
    const { memoize } = opts;
    const memoized = memo.get(cache2, key, opts);
    if (memoized && memoize !== false) {
      return Promise.resolve(memoized.entry);
    } else {
      return index.find(cache2, key);
    }
  }
  module.exports.info = info;
  async function copy(cache2, key, dest, opts = {}) {
    const entry = await index.find(cache2, key, opts);
    if (!entry) {
      throw new index.NotFoundError(cache2, key);
    }
    await read.copy(cache2, entry.integrity, dest, opts);
    return {
      metadata: entry.metadata,
      size: entry.size,
      integrity: entry.integrity
    };
  }
  module.exports.copy = copy;
  async function copyByDigest(cache2, key, dest, opts = {}) {
    await read.copy(cache2, key, dest, opts);
    return key;
  }
  module.exports.copy.byDigest = copyByDigest;
  module.exports.hasContent = read.hasContent;
});

// node_modules/cacache/lib/content/write.js
var require_write = __commonJS((exports, module) => {
  var events = __require("events");
  var contentPath = require_path();
  var fs = __require("fs/promises");
  var { moveFile } = require_lib6();
  var { Minipass } = require_commonjs();
  var Pipeline = require_minipass_pipeline();
  var Flush = require_minipass_flush();
  var path = __require("path");
  var ssri = require_lib3();
  var uniqueFilename = require_lib5();
  var fsm = require_lib7();
  module.exports = write;
  var moveOperations = new Map;
  async function write(cache2, data, opts = {}) {
    const { algorithms, size, integrity } = opts;
    if (typeof size === "number" && data.length !== size) {
      throw sizeError(size, data.length);
    }
    const sri = ssri.fromData(data, algorithms ? { algorithms } : {});
    if (integrity && !ssri.checkData(data, integrity, opts)) {
      throw checksumError(integrity, sri);
    }
    for (const algo in sri) {
      const tmp = await makeTmp(cache2, opts);
      const hash = sri[algo].toString();
      try {
        await fs.writeFile(tmp.target, data, { flag: "wx" });
        await moveToDestination(tmp, cache2, hash, opts);
      } finally {
        if (!tmp.moved) {
          await fs.rm(tmp.target, { recursive: true, force: true });
        }
      }
    }
    return { integrity: sri, size: data.length };
  }
  module.exports.stream = writeStream;

  class CacacheWriteStream extends Flush {
    constructor(cache2, opts) {
      super();
      this.opts = opts;
      this.cache = cache2;
      this.inputStream = new Minipass;
      this.inputStream.on("error", (er) => this.emit("error", er));
      this.inputStream.on("drain", () => this.emit("drain"));
      this.handleContentP = null;
    }
    write(chunk, encoding, cb) {
      if (!this.handleContentP) {
        this.handleContentP = handleContent(this.inputStream, this.cache, this.opts);
        this.handleContentP.catch((error) => this.emit("error", error));
      }
      return this.inputStream.write(chunk, encoding, cb);
    }
    flush(cb) {
      this.inputStream.end(() => {
        if (!this.handleContentP) {
          const e = new Error("Cache input stream was empty");
          e.code = "ENODATA";
          return Promise.reject(e).catch(cb);
        }
        this.handleContentP.then((res) => {
          res.integrity && this.emit("integrity", res.integrity);
          res.size !== null && this.emit("size", res.size);
          cb();
        }, (er) => cb(er));
      });
    }
  }
  function writeStream(cache2, opts = {}) {
    return new CacacheWriteStream(cache2, opts);
  }
  async function handleContent(inputStream, cache2, opts) {
    const tmp = await makeTmp(cache2, opts);
    try {
      const res = await pipeToTmp(inputStream, cache2, tmp.target, opts);
      await moveToDestination(tmp, cache2, res.integrity, opts);
      return res;
    } finally {
      if (!tmp.moved) {
        await fs.rm(tmp.target, { recursive: true, force: true });
      }
    }
  }
  async function pipeToTmp(inputStream, cache2, tmpTarget, opts) {
    const outStream = new fsm.WriteStream(tmpTarget, {
      flags: "wx"
    });
    if (opts.integrityEmitter) {
      const [integrity2, size2] = await Promise.all([
        events.once(opts.integrityEmitter, "integrity").then((res) => res[0]),
        events.once(opts.integrityEmitter, "size").then((res) => res[0]),
        new Pipeline(inputStream, outStream).promise()
      ]);
      return { integrity: integrity2, size: size2 };
    }
    let integrity;
    let size;
    const hashStream = ssri.integrityStream({
      integrity: opts.integrity,
      algorithms: opts.algorithms,
      size: opts.size
    });
    hashStream.on("integrity", (i) => {
      integrity = i;
    });
    hashStream.on("size", (s) => {
      size = s;
    });
    const pipeline2 = new Pipeline(inputStream, hashStream, outStream);
    await pipeline2.promise();
    return { integrity, size };
  }
  async function makeTmp(cache2, opts) {
    const tmpTarget = uniqueFilename(path.join(cache2, "tmp"), opts.tmpPrefix);
    await fs.mkdir(path.dirname(tmpTarget), { recursive: true });
    return {
      target: tmpTarget,
      moved: false
    };
  }
  async function moveToDestination(tmp, cache2, sri) {
    const destination = contentPath(cache2, sri);
    const destDir = path.dirname(destination);
    if (moveOperations.has(destination)) {
      return moveOperations.get(destination);
    }
    moveOperations.set(destination, fs.mkdir(destDir, { recursive: true }).then(async () => {
      await moveFile(tmp.target, destination, { overwrite: false });
      tmp.moved = true;
      return tmp.moved;
    }).catch((err) => {
      if (!err.message.startsWith("The destination file exists")) {
        throw Object.assign(err, { code: "EEXIST" });
      }
    }).finally(() => {
      moveOperations.delete(destination);
    }));
    return moveOperations.get(destination);
  }
  function sizeError(expected, found) {
    const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`);
    err.expected = expected;
    err.found = found;
    err.code = "EBADSIZE";
    return err;
  }
  function checksumError(expected, found) {
    const err = new Error(`Integrity check failed:
  Wanted: ${expected}
   Found: ${found}`);
    err.code = "EINTEGRITY";
    err.expected = expected;
    err.found = found;
    return err;
  }
});

// node_modules/cacache/lib/put.js
var require_put = __commonJS((exports, module) => {
  var index = require_entry_index();
  var memo = require_memoization();
  var write = require_write();
  var Flush = require_minipass_flush();
  var { PassThrough: PassThrough2 } = require_minipass_collect();
  var Pipeline = require_minipass_pipeline();
  var putOpts = (opts) => ({
    algorithms: ["sha512"],
    ...opts
  });
  module.exports = putData;
  async function putData(cache2, key, data, opts = {}) {
    const { memoize } = opts;
    opts = putOpts(opts);
    const res = await write(cache2, data, opts);
    const entry = await index.insert(cache2, key, res.integrity, { ...opts, size: res.size });
    if (memoize) {
      memo.put(cache2, entry, data, opts);
    }
    return res.integrity;
  }
  module.exports.stream = putStream;
  function putStream(cache2, key, opts = {}) {
    const { memoize } = opts;
    opts = putOpts(opts);
    let integrity;
    let size;
    let error;
    let memoData;
    const pipeline2 = new Pipeline;
    if (memoize) {
      const memoizer = new PassThrough2().on("collect", (data) => {
        memoData = data;
      });
      pipeline2.push(memoizer);
    }
    const contentStream = write.stream(cache2, opts).on("integrity", (int) => {
      integrity = int;
    }).on("size", (s) => {
      size = s;
    }).on("error", (err) => {
      error = err;
    });
    pipeline2.push(contentStream);
    pipeline2.push(new Flush({
      async flush() {
        if (!error) {
          const entry = await index.insert(cache2, key, integrity, { ...opts, size });
          if (memoize && memoData) {
            memo.put(cache2, entry, memoData, opts);
          }
          pipeline2.emit("integrity", integrity);
          pipeline2.emit("size", size);
        }
      }
    }));
    return pipeline2;
  }
});

// node_modules/glob/dist/commonjs/index.min.js
var require_index_min2 = __commonJS((exports) => {
  var R = (n, t) => () => (t || n((t = { exports: {} }).exports, t), t.exports);
  var Ge = R((Y) => {
    Object.defineProperty(Y, "__esModule", { value: true });
    Y.range = Y.balanced = undefined;
    var Gs = (n, t, e) => {
      let s = n instanceof RegExp ? Ie(n, e) : n, i = t instanceof RegExp ? Ie(t, e) : t, r = s !== null && i != null && (0, Y.range)(s, i, e);
      return r && { start: r[0], end: r[1], pre: e.slice(0, r[0]), body: e.slice(r[0] + s.length, r[1]), post: e.slice(r[1] + i.length) };
    };
    Y.balanced = Gs;
    var Ie = (n, t) => {
      let e = t.match(n);
      return e ? e[0] : null;
    }, zs = (n, t, e) => {
      let s, i, r, h, o, a = e.indexOf(n), l = e.indexOf(t, a + 1), f = a;
      if (a >= 0 && l > 0) {
        if (n === t)
          return [a, l];
        for (s = [], r = e.length;f >= 0 && !o; ) {
          if (f === a)
            s.push(f), a = e.indexOf(n, f + 1);
          else if (s.length === 1) {
            let c = s.pop();
            c !== undefined && (o = [c, l]);
          } else
            i = s.pop(), i !== undefined && i < r && (r = i, h = l), l = e.indexOf(t, f + 1);
          f = a < l && a >= 0 ? a : l;
        }
        s.length && h !== undefined && (o = [r, h]);
      }
      return o;
    };
    Y.range = zs;
  });
  var Ke = R((it) => {
    Object.defineProperty(it, "__esModule", { value: true });
    it.EXPANSION_MAX = undefined;
    it.expand = ei;
    var ze = Ge(), Ue = "\x00SLASH" + Math.random() + "\x00", $e = "\x00OPEN" + Math.random() + "\x00", ue = "\x00CLOSE" + Math.random() + "\x00", qe = "\x00COMMA" + Math.random() + "\x00", He = "\x00PERIOD" + Math.random() + "\x00", Us = new RegExp(Ue, "g"), $s = new RegExp($e, "g"), qs = new RegExp(ue, "g"), Hs = new RegExp(qe, "g"), Vs = new RegExp(He, "g"), Ks = /\\\\/g, Xs = /\\{/g, Ys = /\\}/g, Js = /\\,/g, Zs = /\\./g;
    it.EXPANSION_MAX = 1e5;
    function ce(n) {
      return isNaN(n) ? n.charCodeAt(0) : parseInt(n, 10);
    }
    function Qs(n) {
      return n.replace(Ks, Ue).replace(Xs, $e).replace(Ys, ue).replace(Js, qe).replace(Zs, He);
    }
    function ti(n) {
      return n.replace(Us, "\\").replace($s, "{").replace(qs, "}").replace(Hs, ",").replace(Vs, ".");
    }
    function Ve(n) {
      if (!n)
        return [""];
      let t = [], e = (0, ze.balanced)("{", "}", n);
      if (!e)
        return n.split(",");
      let { pre: s, body: i, post: r } = e, h = s.split(",");
      h[h.length - 1] += "{" + i + "}";
      let o = Ve(r);
      return r.length && (h[h.length - 1] += o.shift(), h.push.apply(h, o)), t.push.apply(t, h), t;
    }
    function ei(n, t = {}) {
      if (!n)
        return [];
      let { max: e = it.EXPANSION_MAX } = t;
      return n.slice(0, 2) === "{}" && (n = "\\{\\}" + n.slice(2)), ht(Qs(n), e, true).map(ti);
    }
    function si(n) {
      return "{" + n + "}";
    }
    function ii(n) {
      return /^-?0\d/.test(n);
    }
    function ri(n, t) {
      return n <= t;
    }
    function ni(n, t) {
      return n >= t;
    }
    function ht(n, t, e) {
      let s = [], i = (0, ze.balanced)("{", "}", n);
      if (!i)
        return [n];
      let r = i.pre, h = i.post.length ? ht(i.post, t, false) : [""];
      if (/\$$/.test(i.pre))
        for (let o = 0;o < h.length && o < t; o++) {
          let a = r + "{" + i.body + "}" + h[o];
          s.push(a);
        }
      else {
        let o = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(i.body), a = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(i.body), l = o || a, f = i.body.indexOf(",") >= 0;
        if (!l && !f)
          return i.post.match(/,(?!,).*\}/) ? (n = i.pre + "{" + i.body + ue + i.post, ht(n, t, true)) : [n];
        let c;
        if (l)
          c = i.body.split(/\.\./);
        else if (c = Ve(i.body), c.length === 1 && c[0] !== undefined && (c = ht(c[0], t, false).map(si), c.length === 1))
          return h.map((u) => i.pre + c[0] + u);
        let d;
        if (l && c[0] !== undefined && c[1] !== undefined) {
          let u = ce(c[0]), m = ce(c[1]), p = Math.max(c[0].length, c[1].length), b = c.length === 3 && c[2] !== undefined ? Math.abs(ce(c[2])) : 1, w = ri;
          m < u && (b *= -1, w = ni);
          let E = c.some(ii);
          d = [];
          for (let y = u;w(y, m); y += b) {
            let S;
            if (a)
              S = String.fromCharCode(y), S === "\\" && (S = "");
            else if (S = String(y), E) {
              let B = p - S.length;
              if (B > 0) {
                let U = new Array(B + 1).join("0");
                y < 0 ? S = "-" + U + S.slice(1) : S = U + S;
              }
            }
            d.push(S);
          }
        } else {
          d = [];
          for (let u = 0;u < c.length; u++)
            d.push.apply(d, ht(c[u], t, false));
        }
        for (let u = 0;u < d.length; u++)
          for (let m = 0;m < h.length && s.length < t; m++) {
            let p = r + d[u] + h[m];
            (!e || l || p) && s.push(p);
          }
      }
      return s;
    }
  });
  var Xe = R((Ct) => {
    Object.defineProperty(Ct, "__esModule", { value: true });
    Ct.assertValidPattern = undefined;
    var hi = 1024 * 64, oi = (n) => {
      if (typeof n != "string")
        throw new TypeError("invalid pattern");
      if (n.length > hi)
        throw new TypeError("pattern is too long");
    };
    Ct.assertValidPattern = oi;
  });
  var Je = R((Rt) => {
    Object.defineProperty(Rt, "__esModule", { value: true });
    Rt.parseClass = undefined;
    var ai = { "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true], "[:alpha:]": ["\\p{L}\\p{Nl}", true], "[:ascii:]": ["\\x00-\\x7f", false], "[:blank:]": ["\\p{Zs}\\t", true], "[:cntrl:]": ["\\p{Cc}", true], "[:digit:]": ["\\p{Nd}", true], "[:graph:]": ["\\p{Z}\\p{C}", true, true], "[:lower:]": ["\\p{Ll}", true], "[:print:]": ["\\p{C}", true], "[:punct:]": ["\\p{P}", true], "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true], "[:upper:]": ["\\p{Lu}", true], "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true], "[:xdigit:]": ["A-Fa-f0-9", false] }, ot = (n) => n.replace(/[[\]\\-]/g, "\\$&"), li = (n) => n.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), Ye = (n) => n.join(""), ci = (n, t) => {
      let e = t;
      if (n.charAt(e) !== "[")
        throw new Error("not in a brace expression");
      let s = [], i = [], r = e + 1, h = false, o = false, a = false, l = false, f = e, c = "";
      t:
        for (;r < n.length; ) {
          let p = n.charAt(r);
          if ((p === "!" || p === "^") && r === e + 1) {
            l = true, r++;
            continue;
          }
          if (p === "]" && h && !a) {
            f = r + 1;
            break;
          }
          if (h = true, p === "\\" && !a) {
            a = true, r++;
            continue;
          }
          if (p === "[" && !a) {
            for (let [b, [w, v, E]] of Object.entries(ai))
              if (n.startsWith(b, r)) {
                if (c)
                  return ["$.", false, n.length - e, true];
                r += b.length, E ? i.push(w) : s.push(w), o = o || v;
                continue t;
              }
          }
          if (a = false, c) {
            p > c ? s.push(ot(c) + "-" + ot(p)) : p === c && s.push(ot(p)), c = "", r++;
            continue;
          }
          if (n.startsWith("-]", r + 1)) {
            s.push(ot(p + "-")), r += 2;
            continue;
          }
          if (n.startsWith("-", r + 1)) {
            c = p, r += 2;
            continue;
          }
          s.push(ot(p)), r++;
        }
      if (f < r)
        return ["", false, 0, false];
      if (!s.length && !i.length)
        return ["$.", false, n.length - e, true];
      if (i.length === 0 && s.length === 1 && /^\\?.$/.test(s[0]) && !l) {
        let p = s[0].length === 2 ? s[0].slice(-1) : s[0];
        return [li(p), false, f - e, false];
      }
      let d = "[" + (l ? "^" : "") + Ye(s) + "]", u = "[" + (l ? "" : "^") + Ye(i) + "]";
      return [s.length && i.length ? "(" + d + "|" + u + ")" : s.length ? d : u, o, f - e, true];
    };
    Rt.parseClass = ci;
  });
  var kt = R((At) => {
    Object.defineProperty(At, "__esModule", { value: true });
    At.unescape = undefined;
    var ui = (n, { windowsPathsNoEscape: t = false, magicalBraces: e = true } = {}) => e ? t ? n.replace(/\[([^\/\\])\]/g, "$1") : n.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1") : t ? n.replace(/\[([^\/\\{}])\]/g, "$1") : n.replace(/((?!\\).|^)\[([^\/\\{}])\]/g, "$1$2").replace(/\\([^\/{}])/g, "$1");
    At.unescape = ui;
  });
  var pe = R((Dt) => {
    Object.defineProperty(Dt, "__esModule", { value: true });
    Dt.AST = undefined;
    var fi = Je(), Mt = kt(), di = new Set(["!", "?", "+", "*", "@"]), Ze = (n) => di.has(n), pi = "(?!(?:^|/)\\.\\.?(?:$|/))", Pt = "(?!\\.)", mi = new Set(["[", "."]), gi = new Set(["..", "."]), wi = new Set("().*{}+?[]^$\\!"), bi = (n) => n.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), de = "[^/]", Qe = de + "*?", ts = de + "+?", fe = class n {
      type;
      #t;
      #s;
      #n = false;
      #r = [];
      #h;
      #S;
      #w;
      #c = false;
      #o;
      #f;
      #u = false;
      constructor(t, e, s = {}) {
        this.type = t, t && (this.#s = true), this.#h = e, this.#t = this.#h ? this.#h.#t : this, this.#o = this.#t === this ? s : this.#t.#o, this.#w = this.#t === this ? [] : this.#t.#w, t === "!" && !this.#t.#c && this.#w.push(this), this.#S = this.#h ? this.#h.#r.length : 0;
      }
      get hasMagic() {
        if (this.#s !== undefined)
          return this.#s;
        for (let t of this.#r)
          if (typeof t != "string" && (t.type || t.hasMagic))
            return this.#s = true;
        return this.#s;
      }
      toString() {
        return this.#f !== undefined ? this.#f : this.type ? this.#f = this.type + "(" + this.#r.map((t) => String(t)).join("|") + ")" : this.#f = this.#r.map((t) => String(t)).join("");
      }
      #a() {
        if (this !== this.#t)
          throw new Error("should only call on root");
        if (this.#c)
          return this;
        this.toString(), this.#c = true;
        let t;
        for (;t = this.#w.pop(); ) {
          if (t.type !== "!")
            continue;
          let e = t, s = e.#h;
          for (;s; ) {
            for (let i = e.#S + 1;!s.type && i < s.#r.length; i++)
              for (let r of t.#r) {
                if (typeof r == "string")
                  throw new Error("string part in extglob AST??");
                r.copyIn(s.#r[i]);
              }
            e = s, s = e.#h;
          }
        }
        return this;
      }
      push(...t) {
        for (let e of t)
          if (e !== "") {
            if (typeof e != "string" && !(e instanceof n && e.#h === this))
              throw new Error("invalid part: " + e);
            this.#r.push(e);
          }
      }
      toJSON() {
        let t = this.type === null ? this.#r.slice().map((e) => typeof e == "string" ? e : e.toJSON()) : [this.type, ...this.#r.map((e) => e.toJSON())];
        return this.isStart() && !this.type && t.unshift([]), this.isEnd() && (this === this.#t || this.#t.#c && this.#h?.type === "!") && t.push({}), t;
      }
      isStart() {
        if (this.#t === this)
          return true;
        if (!this.#h?.isStart())
          return false;
        if (this.#S === 0)
          return true;
        let t = this.#h;
        for (let e = 0;e < this.#S; e++) {
          let s = t.#r[e];
          if (!(s instanceof n && s.type === "!"))
            return false;
        }
        return true;
      }
      isEnd() {
        if (this.#t === this || this.#h?.type === "!")
          return true;
        if (!this.#h?.isEnd())
          return false;
        if (!this.type)
          return this.#h?.isEnd();
        let t = this.#h ? this.#h.#r.length : 0;
        return this.#S === t - 1;
      }
      copyIn(t) {
        typeof t == "string" ? this.push(t) : this.push(t.clone(this));
      }
      clone(t) {
        let e = new n(this.type, t);
        for (let s of this.#r)
          e.copyIn(s);
        return e;
      }
      static #i(t, e, s, i) {
        let r = false, h = false, o = -1, a = false;
        if (e.type === null) {
          let u = s, m = "";
          for (;u < t.length; ) {
            let p = t.charAt(u++);
            if (r || p === "\\") {
              r = !r, m += p;
              continue;
            }
            if (h) {
              u === o + 1 ? (p === "^" || p === "!") && (a = true) : p === "]" && !(u === o + 2 && a) && (h = false), m += p;
              continue;
            } else if (p === "[") {
              h = true, o = u, a = false, m += p;
              continue;
            }
            if (!i.noext && Ze(p) && t.charAt(u) === "(") {
              e.push(m), m = "";
              let b = new n(p, e);
              u = n.#i(t, b, u, i), e.push(b);
              continue;
            }
            m += p;
          }
          return e.push(m), u;
        }
        let l = s + 1, f = new n(null, e), c = [], d = "";
        for (;l < t.length; ) {
          let u = t.charAt(l++);
          if (r || u === "\\") {
            r = !r, d += u;
            continue;
          }
          if (h) {
            l === o + 1 ? (u === "^" || u === "!") && (a = true) : u === "]" && !(l === o + 2 && a) && (h = false), d += u;
            continue;
          } else if (u === "[") {
            h = true, o = l, a = false, d += u;
            continue;
          }
          if (Ze(u) && t.charAt(l) === "(") {
            f.push(d), d = "";
            let m = new n(u, f);
            f.push(m), l = n.#i(t, m, l, i);
            continue;
          }
          if (u === "|") {
            f.push(d), d = "", c.push(f), f = new n(null, e);
            continue;
          }
          if (u === ")")
            return d === "" && e.#r.length === 0 && (e.#u = true), f.push(d), d = "", e.push(...c, f), l;
          d += u;
        }
        return e.type = null, e.#s = undefined, e.#r = [t.substring(s - 1)], l;
      }
      static fromGlob(t, e = {}) {
        let s = new n(null, undefined, e);
        return n.#i(t, s, 0, e), s;
      }
      toMMPattern() {
        if (this !== this.#t)
          return this.#t.toMMPattern();
        let t = this.toString(), [e, s, i, r] = this.toRegExpSource();
        if (!(i || this.#s || this.#o.nocase && !this.#o.nocaseMagicOnly && t.toUpperCase() !== t.toLowerCase()))
          return s;
        let o = (this.#o.nocase ? "i" : "") + (r ? "u" : "");
        return Object.assign(new RegExp(`^${e}$`, o), { _src: e, _glob: t });
      }
      get options() {
        return this.#o;
      }
      toRegExpSource(t) {
        let e = t ?? !!this.#o.dot;
        if (this.#t === this && this.#a(), !this.type) {
          let a = this.isStart() && this.isEnd() && !this.#r.some((u) => typeof u != "string"), l = this.#r.map((u) => {
            let [m, p, b, w] = typeof u == "string" ? n.#v(u, this.#s, a) : u.toRegExpSource(t);
            return this.#s = this.#s || b, this.#n = this.#n || w, m;
          }).join(""), f = "";
          if (this.isStart() && typeof this.#r[0] == "string" && !(this.#r.length === 1 && gi.has(this.#r[0]))) {
            let m = mi, p = e && m.has(l.charAt(0)) || l.startsWith("\\.") && m.has(l.charAt(2)) || l.startsWith("\\.\\.") && m.has(l.charAt(4)), b = !e && !t && m.has(l.charAt(0));
            f = p ? pi : b ? Pt : "";
          }
          let c = "";
          return this.isEnd() && this.#t.#c && this.#h?.type === "!" && (c = "(?:$|\\/)"), [f + l + c, (0, Mt.unescape)(l), this.#s = !!this.#s, this.#n];
        }
        let s = this.type === "*" || this.type === "+", i = this.type === "!" ? "(?:(?!(?:" : "(?:", r = this.#d(e);
        if (this.isStart() && this.isEnd() && !r && this.type !== "!") {
          let a = this.toString();
          return this.#r = [a], this.type = null, this.#s = undefined, [a, (0, Mt.unescape)(this.toString()), false, false];
        }
        let h = !s || t || e || !Pt ? "" : this.#d(true);
        h === r && (h = ""), h && (r = `(?:${r})(?:${h})*?`);
        let o = "";
        if (this.type === "!" && this.#u)
          o = (this.isStart() && !e ? Pt : "") + ts;
        else {
          let a = this.type === "!" ? "))" + (this.isStart() && !e && !t ? Pt : "") + Qe + ")" : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && h ? ")" : this.type === "*" && h ? ")?" : `)${this.type}`;
          o = i + r + a;
        }
        return [o, (0, Mt.unescape)(r), this.#s = !!this.#s, this.#n];
      }
      #d(t) {
        return this.#r.map((e) => {
          if (typeof e == "string")
            throw new Error("string type in extglob ast??");
          let [s, i, r, h] = e.toRegExpSource(t);
          return this.#n = this.#n || h, s;
        }).filter((e) => !(this.isStart() && this.isEnd()) || !!e).join("|");
      }
      static #v(t, e, s = false) {
        let i = false, r = "", h = false, o = false;
        for (let a = 0;a < t.length; a++) {
          let l = t.charAt(a);
          if (i) {
            i = false, r += (wi.has(l) ? "\\" : "") + l;
            continue;
          }
          if (l === "*") {
            if (o)
              continue;
            o = true, r += s && /^[*]+$/.test(t) ? ts : Qe, e = true;
            continue;
          } else
            o = false;
          if (l === "\\") {
            a === t.length - 1 ? r += "\\\\" : i = true;
            continue;
          }
          if (l === "[") {
            let [f, c, d, u] = (0, fi.parseClass)(t, a);
            if (d) {
              r += f, h = h || c, a += d - 1, e = e || u;
              continue;
            }
          }
          if (l === "?") {
            r += de, e = true;
            continue;
          }
          r += bi(l);
        }
        return [r, (0, Mt.unescape)(t), !!e, h];
      }
    };
    Dt.AST = fe;
  });
  var me = R((Ft) => {
    Object.defineProperty(Ft, "__esModule", { value: true });
    Ft.escape = undefined;
    var yi = (n, { windowsPathsNoEscape: t = false, magicalBraces: e = false } = {}) => e ? t ? n.replace(/[?*()[\]{}]/g, "[$&]") : n.replace(/[?*()[\]\\{}]/g, "\\$&") : t ? n.replace(/[?*()[\]]/g, "[$&]") : n.replace(/[?*()[\]\\]/g, "\\$&");
    Ft.escape = yi;
  });
  var H = R((g) => {
    Object.defineProperty(g, "__esModule", { value: true });
    g.unescape = g.escape = g.AST = g.Minimatch = g.match = g.makeRe = g.braceExpand = g.defaults = g.filter = g.GLOBSTAR = g.sep = g.minimatch = undefined;
    var Si = Ke(), jt = Xe(), is = pe(), vi = me(), Ei = kt(), _i = (n, t, e = {}) => ((0, jt.assertValidPattern)(t), !e.nocomment && t.charAt(0) === "#" ? false : new J(t, e).match(n));
    g.minimatch = _i;
    var Oi = /^\*+([^+@!?\*\[\(]*)$/, xi = (n) => (t) => !t.startsWith(".") && t.endsWith(n), Ti = (n) => (t) => t.endsWith(n), Ci = (n) => (n = n.toLowerCase(), (t) => !t.startsWith(".") && t.toLowerCase().endsWith(n)), Ri = (n) => (n = n.toLowerCase(), (t) => t.toLowerCase().endsWith(n)), Ai = /^\*+\.\*+$/, ki = (n) => !n.startsWith(".") && n.includes("."), Mi = (n) => n !== "." && n !== ".." && n.includes("."), Pi = /^\.\*+$/, Di = (n) => n !== "." && n !== ".." && n.startsWith("."), Fi = /^\*+$/, ji = (n) => n.length !== 0 && !n.startsWith("."), Ni = (n) => n.length !== 0 && n !== "." && n !== "..", Li = /^\?+([^+@!?\*\[\(]*)?$/, Wi = ([n, t = ""]) => {
      let e = rs([n]);
      return t ? (t = t.toLowerCase(), (s) => e(s) && s.toLowerCase().endsWith(t)) : e;
    }, Bi = ([n, t = ""]) => {
      let e = ns([n]);
      return t ? (t = t.toLowerCase(), (s) => e(s) && s.toLowerCase().endsWith(t)) : e;
    }, Ii = ([n, t = ""]) => {
      let e = ns([n]);
      return t ? (s) => e(s) && s.endsWith(t) : e;
    }, Gi = ([n, t = ""]) => {
      let e = rs([n]);
      return t ? (s) => e(s) && s.endsWith(t) : e;
    }, rs = ([n]) => {
      let t = n.length;
      return (e) => e.length === t && !e.startsWith(".");
    }, ns = ([n]) => {
      let t = n.length;
      return (e) => e.length === t && e !== "." && e !== "..";
    }, hs = typeof process == "object" && process ? typeof process.env == "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix", es = { win32: { sep: "\\" }, posix: { sep: "/" } };
    g.sep = hs === "win32" ? es.win32.sep : es.posix.sep;
    g.minimatch.sep = g.sep;
    g.GLOBSTAR = Symbol("globstar **");
    g.minimatch.GLOBSTAR = g.GLOBSTAR;
    var zi = "[^/]", Ui = zi + "*?", $i = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", qi = "(?:(?!(?:\\/|^)\\.).)*?", Hi = (n, t = {}) => (e) => (0, g.minimatch)(e, n, t);
    g.filter = Hi;
    g.minimatch.filter = g.filter;
    var F = (n, t = {}) => Object.assign({}, n, t), Vi = (n) => {
      if (!n || typeof n != "object" || !Object.keys(n).length)
        return g.minimatch;
      let t = g.minimatch;
      return Object.assign((s, i, r = {}) => t(s, i, F(n, r)), { Minimatch: class extends t.Minimatch {
        constructor(i, r = {}) {
          super(i, F(n, r));
        }
        static defaults(i) {
          return t.defaults(F(n, i)).Minimatch;
        }
      }, AST: class extends t.AST {
        constructor(i, r, h = {}) {
          super(i, r, F(n, h));
        }
        static fromGlob(i, r = {}) {
          return t.AST.fromGlob(i, F(n, r));
        }
      }, unescape: (s, i = {}) => t.unescape(s, F(n, i)), escape: (s, i = {}) => t.escape(s, F(n, i)), filter: (s, i = {}) => t.filter(s, F(n, i)), defaults: (s) => t.defaults(F(n, s)), makeRe: (s, i = {}) => t.makeRe(s, F(n, i)), braceExpand: (s, i = {}) => t.braceExpand(s, F(n, i)), match: (s, i, r = {}) => t.match(s, i, F(n, r)), sep: t.sep, GLOBSTAR: g.GLOBSTAR });
    };
    g.defaults = Vi;
    g.minimatch.defaults = g.defaults;
    var Ki = (n, t = {}) => ((0, jt.assertValidPattern)(n), t.nobrace || !/\{(?:(?!\{).)*\}/.test(n) ? [n] : (0, Si.expand)(n, { max: t.braceExpandMax }));
    g.braceExpand = Ki;
    g.minimatch.braceExpand = g.braceExpand;
    var Xi = (n, t = {}) => new J(n, t).makeRe();
    g.makeRe = Xi;
    g.minimatch.makeRe = g.makeRe;
    var Yi = (n, t, e = {}) => {
      let s = new J(t, e);
      return n = n.filter((i) => s.match(i)), s.options.nonull && !n.length && n.push(t), n;
    };
    g.match = Yi;
    g.minimatch.match = g.match;
    var ss = /[?*]|[+@!]\(.*?\)|\[|\]/, Ji = (n) => n.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), J = class {
      options;
      set;
      pattern;
      windowsPathsNoEscape;
      nonegate;
      negate;
      comment;
      empty;
      preserveMultipleSlashes;
      partial;
      globSet;
      globParts;
      nocase;
      isWindows;
      platform;
      windowsNoMagicRoot;
      regexp;
      constructor(t, e = {}) {
        (0, jt.assertValidPattern)(t), e = e || {}, this.options = e, this.pattern = t, this.platform = e.platform || hs, this.isWindows = this.platform === "win32";
        let s = "allowWindowsEscape";
        this.windowsPathsNoEscape = !!e.windowsPathsNoEscape || e[s] === false, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.preserveMultipleSlashes = !!e.preserveMultipleSlashes, this.regexp = null, this.negate = false, this.nonegate = !!e.nonegate, this.comment = false, this.empty = false, this.partial = !!e.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = e.windowsNoMagicRoot !== undefined ? e.windowsNoMagicRoot : !!(this.isWindows && this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
      }
      hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1)
          return true;
        for (let t of this.set)
          for (let e of t)
            if (typeof e != "string")
              return true;
        return false;
      }
      debug(...t) {}
      make() {
        let t = this.pattern, e = this.options;
        if (!e.nocomment && t.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!t) {
          this.empty = true;
          return;
        }
        this.parseNegate(), this.globSet = [...new Set(this.braceExpand())], e.debug && (this.debug = (...r) => console.error(...r)), this.debug(this.pattern, this.globSet);
        let s = this.globSet.map((r) => this.slashSplit(r));
        this.globParts = this.preprocess(s), this.debug(this.pattern, this.globParts);
        let i = this.globParts.map((r, h, o) => {
          if (this.isWindows && this.windowsNoMagicRoot) {
            let a = r[0] === "" && r[1] === "" && (r[2] === "?" || !ss.test(r[2])) && !ss.test(r[3]), l = /^[a-z]:/i.test(r[0]);
            if (a)
              return [...r.slice(0, 4), ...r.slice(4).map((f) => this.parse(f))];
            if (l)
              return [r[0], ...r.slice(1).map((f) => this.parse(f))];
          }
          return r.map((a) => this.parse(a));
        });
        if (this.debug(this.pattern, i), this.set = i.filter((r) => r.indexOf(false) === -1), this.isWindows)
          for (let r = 0;r < this.set.length; r++) {
            let h = this.set[r];
            h[0] === "" && h[1] === "" && this.globParts[r][2] === "?" && typeof h[3] == "string" && /^[a-z]:$/i.test(h[3]) && (h[2] = "?");
          }
        this.debug(this.pattern, this.set);
      }
      preprocess(t) {
        if (this.options.noglobstar)
          for (let s = 0;s < t.length; s++)
            for (let i = 0;i < t[s].length; i++)
              t[s][i] === "**" && (t[s][i] = "*");
        let { optimizationLevel: e = 1 } = this.options;
        return e >= 2 ? (t = this.firstPhasePreProcess(t), t = this.secondPhasePreProcess(t)) : e >= 1 ? t = this.levelOneOptimize(t) : t = this.adjascentGlobstarOptimize(t), t;
      }
      adjascentGlobstarOptimize(t) {
        return t.map((e) => {
          let s = -1;
          for (;(s = e.indexOf("**", s + 1)) !== -1; ) {
            let i = s;
            for (;e[i + 1] === "**"; )
              i++;
            i !== s && e.splice(s, i - s);
          }
          return e;
        });
      }
      levelOneOptimize(t) {
        return t.map((e) => (e = e.reduce((s, i) => {
          let r = s[s.length - 1];
          return i === "**" && r === "**" ? s : i === ".." && r && r !== ".." && r !== "." && r !== "**" ? (s.pop(), s) : (s.push(i), s);
        }, []), e.length === 0 ? [""] : e));
      }
      levelTwoFileOptimize(t) {
        Array.isArray(t) || (t = this.slashSplit(t));
        let e = false;
        do {
          if (e = false, !this.preserveMultipleSlashes) {
            for (let i = 1;i < t.length - 1; i++) {
              let r = t[i];
              i === 1 && r === "" && t[0] === "" || (r === "." || r === "") && (e = true, t.splice(i, 1), i--);
            }
            t[0] === "." && t.length === 2 && (t[1] === "." || t[1] === "") && (e = true, t.pop());
          }
          let s = 0;
          for (;(s = t.indexOf("..", s + 1)) !== -1; ) {
            let i = t[s - 1];
            i && i !== "." && i !== ".." && i !== "**" && (e = true, t.splice(s - 1, 2), s -= 2);
          }
        } while (e);
        return t.length === 0 ? [""] : t;
      }
      firstPhasePreProcess(t) {
        let e = false;
        do {
          e = false;
          for (let s of t) {
            let i = -1;
            for (;(i = s.indexOf("**", i + 1)) !== -1; ) {
              let h = i;
              for (;s[h + 1] === "**"; )
                h++;
              h > i && s.splice(i + 1, h - i);
              let o = s[i + 1], a = s[i + 2], l = s[i + 3];
              if (o !== ".." || !a || a === "." || a === ".." || !l || l === "." || l === "..")
                continue;
              e = true, s.splice(i, 1);
              let f = s.slice(0);
              f[i] = "**", t.push(f), i--;
            }
            if (!this.preserveMultipleSlashes) {
              for (let h = 1;h < s.length - 1; h++) {
                let o = s[h];
                h === 1 && o === "" && s[0] === "" || (o === "." || o === "") && (e = true, s.splice(h, 1), h--);
              }
              s[0] === "." && s.length === 2 && (s[1] === "." || s[1] === "") && (e = true, s.pop());
            }
            let r = 0;
            for (;(r = s.indexOf("..", r + 1)) !== -1; ) {
              let h = s[r - 1];
              if (h && h !== "." && h !== ".." && h !== "**") {
                e = true;
                let a = r === 1 && s[r + 1] === "**" ? ["."] : [];
                s.splice(r - 1, 2, ...a), s.length === 0 && s.push(""), r -= 2;
              }
            }
          }
        } while (e);
        return t;
      }
      secondPhasePreProcess(t) {
        for (let e = 0;e < t.length - 1; e++)
          for (let s = e + 1;s < t.length; s++) {
            let i = this.partsMatch(t[e], t[s], !this.preserveMultipleSlashes);
            if (i) {
              t[e] = [], t[s] = i;
              break;
            }
          }
        return t.filter((e) => e.length);
      }
      partsMatch(t, e, s = false) {
        let i = 0, r = 0, h = [], o = "";
        for (;i < t.length && r < e.length; )
          if (t[i] === e[r])
            h.push(o === "b" ? e[r] : t[i]), i++, r++;
          else if (s && t[i] === "**" && e[r] === t[i + 1])
            h.push(t[i]), i++;
          else if (s && e[r] === "**" && t[i] === e[r + 1])
            h.push(e[r]), r++;
          else if (t[i] === "*" && e[r] && (this.options.dot || !e[r].startsWith(".")) && e[r] !== "**") {
            if (o === "b")
              return false;
            o = "a", h.push(t[i]), i++, r++;
          } else if (e[r] === "*" && t[i] && (this.options.dot || !t[i].startsWith(".")) && t[i] !== "**") {
            if (o === "a")
              return false;
            o = "b", h.push(e[r]), i++, r++;
          } else
            return false;
        return t.length === e.length && h;
      }
      parseNegate() {
        if (this.nonegate)
          return;
        let t = this.pattern, e = false, s = 0;
        for (let i = 0;i < t.length && t.charAt(i) === "!"; i++)
          e = !e, s++;
        s && (this.pattern = t.slice(s)), this.negate = e;
      }
      matchOne(t, e, s = false) {
        let i = this.options;
        if (this.isWindows) {
          let p = typeof t[0] == "string" && /^[a-z]:$/i.test(t[0]), b = !p && t[0] === "" && t[1] === "" && t[2] === "?" && /^[a-z]:$/i.test(t[3]), w = typeof e[0] == "string" && /^[a-z]:$/i.test(e[0]), v = !w && e[0] === "" && e[1] === "" && e[2] === "?" && typeof e[3] == "string" && /^[a-z]:$/i.test(e[3]), E = b ? 3 : p ? 0 : undefined, y = v ? 3 : w ? 0 : undefined;
          if (typeof E == "number" && typeof y == "number") {
            let [S, B] = [t[E], e[y]];
            S.toLowerCase() === B.toLowerCase() && (e[y] = S, y > E ? e = e.slice(y) : E > y && (t = t.slice(E)));
          }
        }
        let { optimizationLevel: r = 1 } = this.options;
        r >= 2 && (t = this.levelTwoFileOptimize(t)), this.debug("matchOne", this, { file: t, pattern: e }), this.debug("matchOne", t.length, e.length);
        for (var h = 0, o = 0, a = t.length, l = e.length;h < a && o < l; h++, o++) {
          this.debug("matchOne loop");
          var f = e[o], c = t[h];
          if (this.debug(e, f, c), f === false)
            return false;
          if (f === g.GLOBSTAR) {
            this.debug("GLOBSTAR", [e, f, c]);
            var d = h, u = o + 1;
            if (u === l) {
              for (this.debug("** at the end");h < a; h++)
                if (t[h] === "." || t[h] === ".." || !i.dot && t[h].charAt(0) === ".")
                  return false;
              return true;
            }
            for (;d < a; ) {
              var m = t[d];
              if (this.debug(`
globstar while`, t, d, e, u, m), this.matchOne(t.slice(d), e.slice(u), s))
                return this.debug("globstar found match!", d, a, m), true;
              if (m === "." || m === ".." || !i.dot && m.charAt(0) === ".") {
                this.debug("dot detected!", t, d, e, u);
                break;
              }
              this.debug("globstar swallow a segment, and continue"), d++;
            }
            return !!(s && (this.debug(`
>>> no match, partial?`, t, d, e, u), d === a));
          }
          let p;
          if (typeof f == "string" ? (p = c === f, this.debug("string match", f, c, p)) : (p = f.test(c), this.debug("pattern match", f, c, p)), !p)
            return false;
        }
        if (h === a && o === l)
          return true;
        if (h === a)
          return s;
        if (o === l)
          return h === a - 1 && t[h] === "";
        throw new Error("wtf?");
      }
      braceExpand() {
        return (0, g.braceExpand)(this.pattern, this.options);
      }
      parse(t) {
        (0, jt.assertValidPattern)(t);
        let e = this.options;
        if (t === "**")
          return g.GLOBSTAR;
        if (t === "")
          return "";
        let s, i = null;
        (s = t.match(Fi)) ? i = e.dot ? Ni : ji : (s = t.match(Oi)) ? i = (e.nocase ? e.dot ? Ri : Ci : e.dot ? Ti : xi)(s[1]) : (s = t.match(Li)) ? i = (e.nocase ? e.dot ? Bi : Wi : e.dot ? Ii : Gi)(s) : (s = t.match(Ai)) ? i = e.dot ? Mi : ki : (s = t.match(Pi)) && (i = Di);
        let r = is.AST.fromGlob(t, this.options).toMMPattern();
        return i && typeof r == "object" && Reflect.defineProperty(r, "test", { value: i }), r;
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        let t = this.set;
        if (!t.length)
          return this.regexp = false, this.regexp;
        let e = this.options, s = e.noglobstar ? Ui : e.dot ? $i : qi, i = new Set(e.nocase ? ["i"] : []), r = t.map((a) => {
          let l = a.map((c) => {
            if (c instanceof RegExp)
              for (let d of c.flags.split(""))
                i.add(d);
            return typeof c == "string" ? Ji(c) : c === g.GLOBSTAR ? g.GLOBSTAR : c._src;
          });
          l.forEach((c, d) => {
            let u = l[d + 1], m = l[d - 1];
            c !== g.GLOBSTAR || m === g.GLOBSTAR || (m === undefined ? u !== undefined && u !== g.GLOBSTAR ? l[d + 1] = "(?:\\/|" + s + "\\/)?" + u : l[d] = s : u === undefined ? l[d - 1] = m + "(?:\\/|\\/" + s + ")?" : u !== g.GLOBSTAR && (l[d - 1] = m + "(?:\\/|\\/" + s + "\\/)" + u, l[d + 1] = g.GLOBSTAR));
          });
          let f = l.filter((c) => c !== g.GLOBSTAR);
          if (this.partial && f.length >= 1) {
            let c = [];
            for (let d = 1;d <= f.length; d++)
              c.push(f.slice(0, d).join("/"));
            return "(?:" + c.join("|") + ")";
          }
          return f.join("/");
        }).join("|"), [h, o] = t.length > 1 ? ["(?:", ")"] : ["", ""];
        r = "^" + h + r + o + "$", this.partial && (r = "^(?:\\/|" + h + r.slice(1, -1) + o + ")$"), this.negate && (r = "^(?!" + r + ").+$");
        try {
          this.regexp = new RegExp(r, [...i].join(""));
        } catch {
          this.regexp = false;
        }
        return this.regexp;
      }
      slashSplit(t) {
        return this.preserveMultipleSlashes ? t.split("/") : this.isWindows && /^\/\/[^\/]+/.test(t) ? ["", ...t.split(/\/+/)] : t.split(/\/+/);
      }
      match(t, e = this.partial) {
        if (this.debug("match", t, this.pattern), this.comment)
          return false;
        if (this.empty)
          return t === "";
        if (t === "/" && e)
          return true;
        let s = this.options;
        this.isWindows && (t = t.split("\\").join("/"));
        let i = this.slashSplit(t);
        this.debug(this.pattern, "split", i);
        let r = this.set;
        this.debug(this.pattern, "set", r);
        let h = i[i.length - 1];
        if (!h)
          for (let o = i.length - 2;!h && o >= 0; o--)
            h = i[o];
        for (let o = 0;o < r.length; o++) {
          let a = r[o], l = i;
          if (s.matchBase && a.length === 1 && (l = [h]), this.matchOne(l, a, e))
            return s.flipNegate ? true : !this.negate;
        }
        return s.flipNegate ? false : this.negate;
      }
      static defaults(t) {
        return g.minimatch.defaults(t).Minimatch;
      }
    };
    g.Minimatch = J;
    var Zi = pe();
    Object.defineProperty(g, "AST", { enumerable: true, get: function() {
      return Zi.AST;
    } });
    var Qi = me();
    Object.defineProperty(g, "escape", { enumerable: true, get: function() {
      return Qi.escape;
    } });
    var tr = kt();
    Object.defineProperty(g, "unescape", { enumerable: true, get: function() {
      return tr.unescape;
    } });
    g.minimatch.AST = is.AST;
    g.minimatch.Minimatch = J;
    g.minimatch.escape = vi.escape;
    g.minimatch.unescape = Ei.unescape;
  });
  var fs = R((Wt) => {
    Object.defineProperty(Wt, "__esModule", { value: true });
    Wt.LRUCache = undefined;
    var er = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, as = new Set, ge = typeof process == "object" && process ? process : {}, ls = (n, t, e, s) => {
      typeof ge.emitWarning == "function" ? ge.emitWarning(n, t, e, s) : console.error(`[${e}] ${t}: ${n}`);
    }, Lt = globalThis.AbortController, os = globalThis.AbortSignal;
    if (typeof Lt > "u") {
      os = class {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(e, s) {
          this._onabort.push(s);
        }
      }, Lt = class {
        constructor() {
          t();
        }
        signal = new os;
        abort(e) {
          if (!this.signal.aborted) {
            this.signal.reason = e, this.signal.aborted = true;
            for (let s of this.signal._onabort)
              s(e);
            this.signal.onabort?.(e);
          }
        }
      };
      let n = ge.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1", t = () => {
        n && (n = false, ls("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", t));
      };
    }
    var sr = (n) => !as.has(n), V = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n), cs = (n) => V(n) ? n <= Math.pow(2, 8) ? Uint8Array : n <= Math.pow(2, 16) ? Uint16Array : n <= Math.pow(2, 32) ? Uint32Array : n <= Number.MAX_SAFE_INTEGER ? Nt : null : null, Nt = class extends Array {
      constructor(n) {
        super(n), this.fill(0);
      }
    }, ir = class at {
      heap;
      length;
      static #t = false;
      static create(t) {
        let e = cs(t);
        if (!e)
          return [];
        at.#t = true;
        let s = new at(t, e);
        return at.#t = false, s;
      }
      constructor(t, e) {
        if (!at.#t)
          throw new TypeError("instantiate Stack using Stack.create(n)");
        this.heap = new e(t), this.length = 0;
      }
      push(t) {
        this.heap[this.length++] = t;
      }
      pop() {
        return this.heap[--this.length];
      }
    }, rr = class us {
      #t;
      #s;
      #n;
      #r;
      #h;
      #S;
      #w;
      #c;
      get perf() {
        return this.#c;
      }
      ttl;
      ttlResolution;
      ttlAutopurge;
      updateAgeOnGet;
      updateAgeOnHas;
      allowStale;
      noDisposeOnSet;
      noUpdateTTL;
      maxEntrySize;
      sizeCalculation;
      noDeleteOnFetchRejection;
      noDeleteOnStaleGet;
      allowStaleOnFetchAbort;
      allowStaleOnFetchRejection;
      ignoreFetchAbort;
      #o;
      #f;
      #u;
      #a;
      #i;
      #d;
      #v;
      #y;
      #p;
      #R;
      #m;
      #O;
      #x;
      #g;
      #b;
      #E;
      #T;
      #e;
      #F;
      static unsafeExposeInternals(t) {
        return { starts: t.#x, ttls: t.#g, autopurgeTimers: t.#b, sizes: t.#O, keyMap: t.#u, keyList: t.#a, valList: t.#i, next: t.#d, prev: t.#v, get head() {
          return t.#y;
        }, get tail() {
          return t.#p;
        }, free: t.#R, isBackgroundFetch: (e) => t.#l(e), backgroundFetch: (e, s, i, r) => t.#z(e, s, i, r), moveToTail: (e) => t.#N(e), indexes: (e) => t.#k(e), rindexes: (e) => t.#M(e), isStale: (e) => t.#_(e) };
      }
      get max() {
        return this.#t;
      }
      get maxSize() {
        return this.#s;
      }
      get calculatedSize() {
        return this.#f;
      }
      get size() {
        return this.#o;
      }
      get fetchMethod() {
        return this.#S;
      }
      get memoMethod() {
        return this.#w;
      }
      get dispose() {
        return this.#n;
      }
      get onInsert() {
        return this.#r;
      }
      get disposeAfter() {
        return this.#h;
      }
      constructor(t) {
        let { max: e = 0, ttl: s, ttlResolution: i = 1, ttlAutopurge: r, updateAgeOnGet: h, updateAgeOnHas: o, allowStale: a, dispose: l, onInsert: f, disposeAfter: c, noDisposeOnSet: d, noUpdateTTL: u, maxSize: m = 0, maxEntrySize: p = 0, sizeCalculation: b, fetchMethod: w, memoMethod: v, noDeleteOnFetchRejection: E, noDeleteOnStaleGet: y, allowStaleOnFetchRejection: S, allowStaleOnFetchAbort: B, ignoreFetchAbort: U, perf: et } = t;
        if (et !== undefined && typeof et?.now != "function")
          throw new TypeError("perf option must have a now() method if specified");
        if (this.#c = et ?? er, e !== 0 && !V(e))
          throw new TypeError("max option must be a nonnegative integer");
        let st = e ? cs(e) : Array;
        if (!st)
          throw new Error("invalid max value: " + e);
        if (this.#t = e, this.#s = m, this.maxEntrySize = p || this.#s, this.sizeCalculation = b, this.sizeCalculation) {
          if (!this.#s && !this.maxEntrySize)
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          if (typeof this.sizeCalculation != "function")
            throw new TypeError("sizeCalculation set to non-function");
        }
        if (v !== undefined && typeof v != "function")
          throw new TypeError("memoMethod must be a function if defined");
        if (this.#w = v, w !== undefined && typeof w != "function")
          throw new TypeError("fetchMethod must be a function if specified");
        if (this.#S = w, this.#T = !!w, this.#u = new Map, this.#a = new Array(e).fill(undefined), this.#i = new Array(e).fill(undefined), this.#d = new st(e), this.#v = new st(e), this.#y = 0, this.#p = 0, this.#R = ir.create(e), this.#o = 0, this.#f = 0, typeof l == "function" && (this.#n = l), typeof f == "function" && (this.#r = f), typeof c == "function" ? (this.#h = c, this.#m = []) : (this.#h = undefined, this.#m = undefined), this.#E = !!this.#n, this.#F = !!this.#r, this.#e = !!this.#h, this.noDisposeOnSet = !!d, this.noUpdateTTL = !!u, this.noDeleteOnFetchRejection = !!E, this.allowStaleOnFetchRejection = !!S, this.allowStaleOnFetchAbort = !!B, this.ignoreFetchAbort = !!U, this.maxEntrySize !== 0) {
          if (this.#s !== 0 && !V(this.#s))
            throw new TypeError("maxSize must be a positive integer if specified");
          if (!V(this.maxEntrySize))
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          this.#$();
        }
        if (this.allowStale = !!a, this.noDeleteOnStaleGet = !!y, this.updateAgeOnGet = !!h, this.updateAgeOnHas = !!o, this.ttlResolution = V(i) || i === 0 ? i : 1, this.ttlAutopurge = !!r, this.ttl = s || 0, this.ttl) {
          if (!V(this.ttl))
            throw new TypeError("ttl must be a positive integer if specified");
          this.#P();
        }
        if (this.#t === 0 && this.ttl === 0 && this.#s === 0)
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        if (!this.ttlAutopurge && !this.#t && !this.#s) {
          let le = "LRU_CACHE_UNBOUNDED";
          sr(le) && (as.add(le), ls("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", le, us));
        }
      }
      getRemainingTTL(t) {
        return this.#u.has(t) ? 1 / 0 : 0;
      }
      #P() {
        let t = new Nt(this.#t), e = new Nt(this.#t);
        this.#g = t, this.#x = e;
        let s = this.ttlAutopurge ? new Array(this.#t) : undefined;
        this.#b = s, this.#W = (h, o, a = this.#c.now()) => {
          if (e[h] = o !== 0 ? a : 0, t[h] = o, s?.[h] && (clearTimeout(s[h]), s[h] = undefined), o !== 0 && s) {
            let l = setTimeout(() => {
              this.#_(h) && this.#A(this.#a[h], "expire");
            }, o + 1);
            l.unref && l.unref(), s[h] = l;
          }
        }, this.#C = (h) => {
          e[h] = t[h] !== 0 ? this.#c.now() : 0;
        }, this.#D = (h, o) => {
          if (t[o]) {
            let a = t[o], l = e[o];
            if (!a || !l)
              return;
            h.ttl = a, h.start = l, h.now = i || r();
            let f = h.now - l;
            h.remainingTTL = a - f;
          }
        };
        let i = 0, r = () => {
          let h = this.#c.now();
          if (this.ttlResolution > 0) {
            i = h;
            let o = setTimeout(() => i = 0, this.ttlResolution);
            o.unref && o.unref();
          }
          return h;
        };
        this.getRemainingTTL = (h) => {
          let o = this.#u.get(h);
          if (o === undefined)
            return 0;
          let a = t[o], l = e[o];
          if (!a || !l)
            return 1 / 0;
          let f = (i || r()) - l;
          return a - f;
        }, this.#_ = (h) => {
          let o = e[h], a = t[h];
          return !!a && !!o && (i || r()) - o > a;
        };
      }
      #C = () => {};
      #D = () => {};
      #W = () => {};
      #_ = () => false;
      #$() {
        let t = new Nt(this.#t);
        this.#f = 0, this.#O = t, this.#L = (e) => {
          this.#f -= t[e], t[e] = 0;
        }, this.#B = (e, s, i, r) => {
          if (this.#l(s))
            return 0;
          if (!V(i))
            if (r) {
              if (typeof r != "function")
                throw new TypeError("sizeCalculation must be a function");
              if (i = r(s, e), !V(i))
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            } else
              throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
          return i;
        }, this.#j = (e, s, i) => {
          if (t[e] = s, this.#s) {
            let r = this.#s - t[e];
            for (;this.#f > r; )
              this.#G(true);
          }
          this.#f += t[e], i && (i.entrySize = s, i.totalCalculatedSize = this.#f);
        };
      }
      #L = (t) => {};
      #j = (t, e, s) => {};
      #B = (t, e, s, i) => {
        if (s || i)
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        return 0;
      };
      *#k({ allowStale: t = this.allowStale } = {}) {
        if (this.#o)
          for (let e = this.#p;!(!this.#I(e) || ((t || !this.#_(e)) && (yield e), e === this.#y)); )
            e = this.#v[e];
      }
      *#M({ allowStale: t = this.allowStale } = {}) {
        if (this.#o)
          for (let e = this.#y;!(!this.#I(e) || ((t || !this.#_(e)) && (yield e), e === this.#p)); )
            e = this.#d[e];
      }
      #I(t) {
        return t !== undefined && this.#u.get(this.#a[t]) === t;
      }
      *entries() {
        for (let t of this.#k())
          this.#i[t] !== undefined && this.#a[t] !== undefined && !this.#l(this.#i[t]) && (yield [this.#a[t], this.#i[t]]);
      }
      *rentries() {
        for (let t of this.#M())
          this.#i[t] !== undefined && this.#a[t] !== undefined && !this.#l(this.#i[t]) && (yield [this.#a[t], this.#i[t]]);
      }
      *keys() {
        for (let t of this.#k()) {
          let e = this.#a[t];
          e !== undefined && !this.#l(this.#i[t]) && (yield e);
        }
      }
      *rkeys() {
        for (let t of this.#M()) {
          let e = this.#a[t];
          e !== undefined && !this.#l(this.#i[t]) && (yield e);
        }
      }
      *values() {
        for (let t of this.#k())
          this.#i[t] !== undefined && !this.#l(this.#i[t]) && (yield this.#i[t]);
      }
      *rvalues() {
        for (let t of this.#M())
          this.#i[t] !== undefined && !this.#l(this.#i[t]) && (yield this.#i[t]);
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      [Symbol.toStringTag] = "LRUCache";
      find(t, e = {}) {
        for (let s of this.#k()) {
          let i = this.#i[s], r = this.#l(i) ? i.__staleWhileFetching : i;
          if (r !== undefined && t(r, this.#a[s], this))
            return this.get(this.#a[s], e);
        }
      }
      forEach(t, e = this) {
        for (let s of this.#k()) {
          let i = this.#i[s], r = this.#l(i) ? i.__staleWhileFetching : i;
          r !== undefined && t.call(e, r, this.#a[s], this);
        }
      }
      rforEach(t, e = this) {
        for (let s of this.#M()) {
          let i = this.#i[s], r = this.#l(i) ? i.__staleWhileFetching : i;
          r !== undefined && t.call(e, r, this.#a[s], this);
        }
      }
      purgeStale() {
        let t = false;
        for (let e of this.#M({ allowStale: true }))
          this.#_(e) && (this.#A(this.#a[e], "expire"), t = true);
        return t;
      }
      info(t) {
        let e = this.#u.get(t);
        if (e === undefined)
          return;
        let s = this.#i[e], i = this.#l(s) ? s.__staleWhileFetching : s;
        if (i === undefined)
          return;
        let r = { value: i };
        if (this.#g && this.#x) {
          let h = this.#g[e], o = this.#x[e];
          if (h && o) {
            let a = h - (this.#c.now() - o);
            r.ttl = a, r.start = Date.now();
          }
        }
        return this.#O && (r.size = this.#O[e]), r;
      }
      dump() {
        let t = [];
        for (let e of this.#k({ allowStale: true })) {
          let s = this.#a[e], i = this.#i[e], r = this.#l(i) ? i.__staleWhileFetching : i;
          if (r === undefined || s === undefined)
            continue;
          let h = { value: r };
          if (this.#g && this.#x) {
            h.ttl = this.#g[e];
            let o = this.#c.now() - this.#x[e];
            h.start = Math.floor(Date.now() - o);
          }
          this.#O && (h.size = this.#O[e]), t.unshift([s, h]);
        }
        return t;
      }
      load(t) {
        this.clear();
        for (let [e, s] of t) {
          if (s.start) {
            let i = Date.now() - s.start;
            s.start = this.#c.now() - i;
          }
          this.set(e, s.value, s);
        }
      }
      set(t, e, s = {}) {
        if (e === undefined)
          return this.delete(t), this;
        let { ttl: i = this.ttl, start: r, noDisposeOnSet: h = this.noDisposeOnSet, sizeCalculation: o = this.sizeCalculation, status: a } = s, { noUpdateTTL: l = this.noUpdateTTL } = s, f = this.#B(t, e, s.size || 0, o);
        if (this.maxEntrySize && f > this.maxEntrySize)
          return a && (a.set = "miss", a.maxEntrySizeExceeded = true), this.#A(t, "set"), this;
        let c = this.#o === 0 ? undefined : this.#u.get(t);
        if (c === undefined)
          c = this.#o === 0 ? this.#p : this.#R.length !== 0 ? this.#R.pop() : this.#o === this.#t ? this.#G(false) : this.#o, this.#a[c] = t, this.#i[c] = e, this.#u.set(t, c), this.#d[this.#p] = c, this.#v[c] = this.#p, this.#p = c, this.#o++, this.#j(c, f, a), a && (a.set = "add"), l = false, this.#F && this.#r?.(e, t, "add");
        else {
          this.#N(c);
          let d = this.#i[c];
          if (e !== d) {
            if (this.#T && this.#l(d)) {
              d.__abortController.abort(new Error("replaced"));
              let { __staleWhileFetching: u } = d;
              u !== undefined && !h && (this.#E && this.#n?.(u, t, "set"), this.#e && this.#m?.push([u, t, "set"]));
            } else
              h || (this.#E && this.#n?.(d, t, "set"), this.#e && this.#m?.push([d, t, "set"]));
            if (this.#L(c), this.#j(c, f, a), this.#i[c] = e, a) {
              a.set = "replace";
              let u = d && this.#l(d) ? d.__staleWhileFetching : d;
              u !== undefined && (a.oldValue = u);
            }
          } else
            a && (a.set = "update");
          this.#F && this.onInsert?.(e, t, e === d ? "update" : "replace");
        }
        if (i !== 0 && !this.#g && this.#P(), this.#g && (l || this.#W(c, i, r), a && this.#D(a, c)), !h && this.#e && this.#m) {
          let d = this.#m, u;
          for (;u = d?.shift(); )
            this.#h?.(...u);
        }
        return this;
      }
      pop() {
        try {
          for (;this.#o; ) {
            let t = this.#i[this.#y];
            if (this.#G(true), this.#l(t)) {
              if (t.__staleWhileFetching)
                return t.__staleWhileFetching;
            } else if (t !== undefined)
              return t;
          }
        } finally {
          if (this.#e && this.#m) {
            let t = this.#m, e;
            for (;e = t?.shift(); )
              this.#h?.(...e);
          }
        }
      }
      #G(t) {
        let e = this.#y, s = this.#a[e], i = this.#i[e];
        return this.#T && this.#l(i) ? i.__abortController.abort(new Error("evicted")) : (this.#E || this.#e) && (this.#E && this.#n?.(i, s, "evict"), this.#e && this.#m?.push([i, s, "evict"])), this.#L(e), this.#b?.[e] && (clearTimeout(this.#b[e]), this.#b[e] = undefined), t && (this.#a[e] = undefined, this.#i[e] = undefined, this.#R.push(e)), this.#o === 1 ? (this.#y = this.#p = 0, this.#R.length = 0) : this.#y = this.#d[e], this.#u.delete(s), this.#o--, e;
      }
      has(t, e = {}) {
        let { updateAgeOnHas: s = this.updateAgeOnHas, status: i } = e, r = this.#u.get(t);
        if (r !== undefined) {
          let h = this.#i[r];
          if (this.#l(h) && h.__staleWhileFetching === undefined)
            return false;
          if (this.#_(r))
            i && (i.has = "stale", this.#D(i, r));
          else
            return s && this.#C(r), i && (i.has = "hit", this.#D(i, r)), true;
        } else
          i && (i.has = "miss");
        return false;
      }
      peek(t, e = {}) {
        let { allowStale: s = this.allowStale } = e, i = this.#u.get(t);
        if (i === undefined || !s && this.#_(i))
          return;
        let r = this.#i[i];
        return this.#l(r) ? r.__staleWhileFetching : r;
      }
      #z(t, e, s, i) {
        let r = e === undefined ? undefined : this.#i[e];
        if (this.#l(r))
          return r;
        let h = new Lt, { signal: o } = s;
        o?.addEventListener("abort", () => h.abort(o.reason), { signal: h.signal });
        let a = { signal: h.signal, options: s, context: i }, l = (p, b = false) => {
          let { aborted: w } = h.signal, v = s.ignoreFetchAbort && p !== undefined, E = s.ignoreFetchAbort || !!(s.allowStaleOnFetchAbort && p !== undefined);
          if (s.status && (w && !b ? (s.status.fetchAborted = true, s.status.fetchError = h.signal.reason, v && (s.status.fetchAbortIgnored = true)) : s.status.fetchResolved = true), w && !v && !b)
            return c(h.signal.reason, E);
          let y = u, S = this.#i[e];
          return (S === u || v && b && S === undefined) && (p === undefined ? y.__staleWhileFetching !== undefined ? this.#i[e] = y.__staleWhileFetching : this.#A(t, "fetch") : (s.status && (s.status.fetchUpdated = true), this.set(t, p, a.options))), p;
        }, f = (p) => (s.status && (s.status.fetchRejected = true, s.status.fetchError = p), c(p, false)), c = (p, b) => {
          let { aborted: w } = h.signal, v = w && s.allowStaleOnFetchAbort, E = v || s.allowStaleOnFetchRejection, y = E || s.noDeleteOnFetchRejection, S = u;
          if (this.#i[e] === u && (!y || !b && S.__staleWhileFetching === undefined ? this.#A(t, "fetch") : v || (this.#i[e] = S.__staleWhileFetching)), E)
            return s.status && S.__staleWhileFetching !== undefined && (s.status.returnedStale = true), S.__staleWhileFetching;
          if (S.__returned === S)
            throw p;
        }, d = (p, b) => {
          let w = this.#S?.(t, r, a);
          w && w instanceof Promise && w.then((v) => p(v === undefined ? undefined : v), b), h.signal.addEventListener("abort", () => {
            (!s.ignoreFetchAbort || s.allowStaleOnFetchAbort) && (p(undefined), s.allowStaleOnFetchAbort && (p = (v) => l(v, true)));
          });
        };
        s.status && (s.status.fetchDispatched = true);
        let u = new Promise(d).then(l, f), m = Object.assign(u, { __abortController: h, __staleWhileFetching: r, __returned: undefined });
        return e === undefined ? (this.set(t, m, { ...a.options, status: undefined }), e = this.#u.get(t)) : this.#i[e] = m, m;
      }
      #l(t) {
        if (!this.#T)
          return false;
        let e = t;
        return !!e && e instanceof Promise && e.hasOwnProperty("__staleWhileFetching") && e.__abortController instanceof Lt;
      }
      async fetch(t, e = {}) {
        let { allowStale: s = this.allowStale, updateAgeOnGet: i = this.updateAgeOnGet, noDeleteOnStaleGet: r = this.noDeleteOnStaleGet, ttl: h = this.ttl, noDisposeOnSet: o = this.noDisposeOnSet, size: a = 0, sizeCalculation: l = this.sizeCalculation, noUpdateTTL: f = this.noUpdateTTL, noDeleteOnFetchRejection: c = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection: d = this.allowStaleOnFetchRejection, ignoreFetchAbort: u = this.ignoreFetchAbort, allowStaleOnFetchAbort: m = this.allowStaleOnFetchAbort, context: p, forceRefresh: b = false, status: w, signal: v } = e;
        if (!this.#T)
          return w && (w.fetch = "get"), this.get(t, { allowStale: s, updateAgeOnGet: i, noDeleteOnStaleGet: r, status: w });
        let E = { allowStale: s, updateAgeOnGet: i, noDeleteOnStaleGet: r, ttl: h, noDisposeOnSet: o, size: a, sizeCalculation: l, noUpdateTTL: f, noDeleteOnFetchRejection: c, allowStaleOnFetchRejection: d, allowStaleOnFetchAbort: m, ignoreFetchAbort: u, status: w, signal: v }, y = this.#u.get(t);
        if (y === undefined) {
          w && (w.fetch = "miss");
          let S = this.#z(t, y, E, p);
          return S.__returned = S;
        } else {
          let S = this.#i[y];
          if (this.#l(S)) {
            let st = s && S.__staleWhileFetching !== undefined;
            return w && (w.fetch = "inflight", st && (w.returnedStale = true)), st ? S.__staleWhileFetching : S.__returned = S;
          }
          let B = this.#_(y);
          if (!b && !B)
            return w && (w.fetch = "hit"), this.#N(y), i && this.#C(y), w && this.#D(w, y), S;
          let U = this.#z(t, y, E, p), et = U.__staleWhileFetching !== undefined && s;
          return w && (w.fetch = B ? "stale" : "refresh", et && B && (w.returnedStale = true)), et ? U.__staleWhileFetching : U.__returned = U;
        }
      }
      async forceFetch(t, e = {}) {
        let s = await this.fetch(t, e);
        if (s === undefined)
          throw new Error("fetch() returned undefined");
        return s;
      }
      memo(t, e = {}) {
        let s = this.#w;
        if (!s)
          throw new Error("no memoMethod provided to constructor");
        let { context: i, forceRefresh: r, ...h } = e, o = this.get(t, h);
        if (!r && o !== undefined)
          return o;
        let a = s(t, o, { options: h, context: i });
        return this.set(t, a, h), a;
      }
      get(t, e = {}) {
        let { allowStale: s = this.allowStale, updateAgeOnGet: i = this.updateAgeOnGet, noDeleteOnStaleGet: r = this.noDeleteOnStaleGet, status: h } = e, o = this.#u.get(t);
        if (o !== undefined) {
          let a = this.#i[o], l = this.#l(a);
          return h && this.#D(h, o), this.#_(o) ? (h && (h.get = "stale"), l ? (h && s && a.__staleWhileFetching !== undefined && (h.returnedStale = true), s ? a.__staleWhileFetching : undefined) : (r || this.#A(t, "expire"), h && s && (h.returnedStale = true), s ? a : undefined)) : (h && (h.get = "hit"), l ? a.__staleWhileFetching : (this.#N(o), i && this.#C(o), a));
        } else
          h && (h.get = "miss");
      }
      #U(t, e) {
        this.#v[e] = t, this.#d[t] = e;
      }
      #N(t) {
        t !== this.#p && (t === this.#y ? this.#y = this.#d[t] : this.#U(this.#v[t], this.#d[t]), this.#U(this.#p, t), this.#p = t);
      }
      delete(t) {
        return this.#A(t, "delete");
      }
      #A(t, e) {
        let s = false;
        if (this.#o !== 0) {
          let i = this.#u.get(t);
          if (i !== undefined)
            if (this.#b?.[i] && (clearTimeout(this.#b?.[i]), this.#b[i] = undefined), s = true, this.#o === 1)
              this.#q(e);
            else {
              this.#L(i);
              let r = this.#i[i];
              if (this.#l(r) ? r.__abortController.abort(new Error("deleted")) : (this.#E || this.#e) && (this.#E && this.#n?.(r, t, e), this.#e && this.#m?.push([r, t, e])), this.#u.delete(t), this.#a[i] = undefined, this.#i[i] = undefined, i === this.#p)
                this.#p = this.#v[i];
              else if (i === this.#y)
                this.#y = this.#d[i];
              else {
                let h = this.#v[i];
                this.#d[h] = this.#d[i];
                let o = this.#d[i];
                this.#v[o] = this.#v[i];
              }
              this.#o--, this.#R.push(i);
            }
        }
        if (this.#e && this.#m?.length) {
          let i = this.#m, r;
          for (;r = i?.shift(); )
            this.#h?.(...r);
        }
        return s;
      }
      clear() {
        return this.#q("delete");
      }
      #q(t) {
        for (let e of this.#M({ allowStale: true })) {
          let s = this.#i[e];
          if (this.#l(s))
            s.__abortController.abort(new Error("deleted"));
          else {
            let i = this.#a[e];
            this.#E && this.#n?.(s, i, t), this.#e && this.#m?.push([s, i, t]);
          }
        }
        if (this.#u.clear(), this.#i.fill(undefined), this.#a.fill(undefined), this.#g && this.#x) {
          this.#g.fill(0), this.#x.fill(0);
          for (let e of this.#b ?? [])
            e !== undefined && clearTimeout(e);
          this.#b?.fill(undefined);
        }
        if (this.#O && this.#O.fill(0), this.#y = 0, this.#p = 0, this.#R.length = 0, this.#f = 0, this.#o = 0, this.#e && this.#m) {
          let e = this.#m, s;
          for (;s = e?.shift(); )
            this.#h?.(...s);
        }
      }
    };
    Wt.LRUCache = rr;
  });
  var Oe = R((P) => {
    var nr = P && P.__importDefault || function(n) {
      return n && n.__esModule ? n : { default: n };
    };
    Object.defineProperty(P, "__esModule", { value: true });
    P.Minipass = P.isWritable = P.isReadable = P.isStream = undefined;
    var ds = typeof process == "object" && process ? process : { stdout: null, stderr: null }, _e = __require("node:events"), ws = nr(__require("node:stream")), hr = __require("node:string_decoder"), or = (n) => !!n && typeof n == "object" && (n instanceof qt || n instanceof ws.default || (0, P.isReadable)(n) || (0, P.isWritable)(n));
    P.isStream = or;
    var ar = (n) => !!n && typeof n == "object" && n instanceof _e.EventEmitter && typeof n.pipe == "function" && n.pipe !== ws.default.Writable.prototype.pipe;
    P.isReadable = ar;
    var lr = (n) => !!n && typeof n == "object" && n instanceof _e.EventEmitter && typeof n.write == "function" && typeof n.end == "function";
    P.isWritable = lr;
    var $ = Symbol("EOF"), q = Symbol("maybeEmitEnd"), K = Symbol("emittedEnd"), Bt = Symbol("emittingEnd"), lt = Symbol("emittedError"), It = Symbol("closed"), ps = Symbol("read"), Gt = Symbol("flush"), ms = Symbol("flushChunk"), L = Symbol("encoding"), rt = Symbol("decoder"), x = Symbol("flowing"), ct = Symbol("paused"), nt = Symbol("resume"), T = Symbol("buffer"), M = Symbol("pipes"), C = Symbol("bufferLength"), we = Symbol("bufferPush"), zt = Symbol("bufferShift"), k = Symbol("objectMode"), O = Symbol("destroyed"), be = Symbol("error"), ye = Symbol("emitData"), gs = Symbol("emitEnd"), Se = Symbol("emitEnd2"), I = Symbol("async"), ve = Symbol("abort"), Ut = Symbol("aborted"), ut = Symbol("signal"), Z = Symbol("dataListeners"), D = Symbol("discarded"), ft = (n) => Promise.resolve().then(n), cr = (n) => n(), ur = (n) => n === "end" || n === "finish" || n === "prefinish", fr = (n) => n instanceof ArrayBuffer || !!n && typeof n == "object" && n.constructor && n.constructor.name === "ArrayBuffer" && n.byteLength >= 0, dr = (n) => !Buffer.isBuffer(n) && ArrayBuffer.isView(n), $t = class {
      src;
      dest;
      opts;
      ondrain;
      constructor(t, e, s) {
        this.src = t, this.dest = e, this.opts = s, this.ondrain = () => t[nt](), this.dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      proxyErrors(t) {}
      end() {
        this.unpipe(), this.opts.end && this.dest.end();
      }
    }, Ee = class extends $t {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors), super.unpipe();
      }
      constructor(t, e, s) {
        super(t, e, s), this.proxyErrors = (i) => this.dest.emit("error", i), t.on("error", this.proxyErrors);
      }
    }, pr = (n) => !!n.objectMode, mr = (n) => !n.objectMode && !!n.encoding && n.encoding !== "buffer", qt = class extends _e.EventEmitter {
      [x] = false;
      [ct] = false;
      [M] = [];
      [T] = [];
      [k];
      [L];
      [I];
      [rt];
      [$] = false;
      [K] = false;
      [Bt] = false;
      [It] = false;
      [lt] = null;
      [C] = 0;
      [O] = false;
      [ut];
      [Ut] = false;
      [Z] = 0;
      [D] = false;
      writable = true;
      readable = true;
      constructor(...t) {
        let e = t[0] || {};
        if (super(), e.objectMode && typeof e.encoding == "string")
          throw new TypeError("Encoding and objectMode may not be used together");
        pr(e) ? (this[k] = true, this[L] = null) : mr(e) ? (this[L] = e.encoding, this[k] = false) : (this[k] = false, this[L] = null), this[I] = !!e.async, this[rt] = this[L] ? new hr.StringDecoder(this[L]) : null, e && e.debugExposeBuffer === true && Object.defineProperty(this, "buffer", { get: () => this[T] }), e && e.debugExposePipes === true && Object.defineProperty(this, "pipes", { get: () => this[M] });
        let { signal: s } = e;
        s && (this[ut] = s, s.aborted ? this[ve]() : s.addEventListener("abort", () => this[ve]()));
      }
      get bufferLength() {
        return this[C];
      }
      get encoding() {
        return this[L];
      }
      set encoding(t) {
        throw new Error("Encoding must be set at instantiation time");
      }
      setEncoding(t) {
        throw new Error("Encoding must be set at instantiation time");
      }
      get objectMode() {
        return this[k];
      }
      set objectMode(t) {
        throw new Error("objectMode must be set at instantiation time");
      }
      get async() {
        return this[I];
      }
      set async(t) {
        this[I] = this[I] || !!t;
      }
      [ve]() {
        this[Ut] = true, this.emit("abort", this[ut]?.reason), this.destroy(this[ut]?.reason);
      }
      get aborted() {
        return this[Ut];
      }
      set aborted(t) {}
      write(t, e, s) {
        if (this[Ut])
          return false;
        if (this[$])
          throw new Error("write after end");
        if (this[O])
          return this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" })), true;
        typeof e == "function" && (s = e, e = "utf8"), e || (e = "utf8");
        let i = this[I] ? ft : cr;
        if (!this[k] && !Buffer.isBuffer(t)) {
          if (dr(t))
            t = Buffer.from(t.buffer, t.byteOffset, t.byteLength);
          else if (fr(t))
            t = Buffer.from(t);
          else if (typeof t != "string")
            throw new Error("Non-contiguous data written to non-objectMode stream");
        }
        return this[k] ? (this[x] && this[C] !== 0 && this[Gt](true), this[x] ? this.emit("data", t) : this[we](t), this[C] !== 0 && this.emit("readable"), s && i(s), this[x]) : t.length ? (typeof t == "string" && !(e === this[L] && !this[rt]?.lastNeed) && (t = Buffer.from(t, e)), Buffer.isBuffer(t) && this[L] && (t = this[rt].write(t)), this[x] && this[C] !== 0 && this[Gt](true), this[x] ? this.emit("data", t) : this[we](t), this[C] !== 0 && this.emit("readable"), s && i(s), this[x]) : (this[C] !== 0 && this.emit("readable"), s && i(s), this[x]);
      }
      read(t) {
        if (this[O])
          return null;
        if (this[D] = false, this[C] === 0 || t === 0 || t && t > this[C])
          return this[q](), null;
        this[k] && (t = null), this[T].length > 1 && !this[k] && (this[T] = [this[L] ? this[T].join("") : Buffer.concat(this[T], this[C])]);
        let e = this[ps](t || null, this[T][0]);
        return this[q](), e;
      }
      [ps](t, e) {
        if (this[k])
          this[zt]();
        else {
          let s = e;
          t === s.length || t === null ? this[zt]() : typeof s == "string" ? (this[T][0] = s.slice(t), e = s.slice(0, t), this[C] -= t) : (this[T][0] = s.subarray(t), e = s.subarray(0, t), this[C] -= t);
        }
        return this.emit("data", e), !this[T].length && !this[$] && this.emit("drain"), e;
      }
      end(t, e, s) {
        return typeof t == "function" && (s = t, t = undefined), typeof e == "function" && (s = e, e = "utf8"), t !== undefined && this.write(t, e), s && this.once("end", s), this[$] = true, this.writable = false, (this[x] || !this[ct]) && this[q](), this;
      }
      [nt]() {
        this[O] || (!this[Z] && !this[M].length && (this[D] = true), this[ct] = false, this[x] = true, this.emit("resume"), this[T].length ? this[Gt]() : this[$] ? this[q]() : this.emit("drain"));
      }
      resume() {
        return this[nt]();
      }
      pause() {
        this[x] = false, this[ct] = true, this[D] = false;
      }
      get destroyed() {
        return this[O];
      }
      get flowing() {
        return this[x];
      }
      get paused() {
        return this[ct];
      }
      [we](t) {
        this[k] ? this[C] += 1 : this[C] += t.length, this[T].push(t);
      }
      [zt]() {
        return this[k] ? this[C] -= 1 : this[C] -= this[T][0].length, this[T].shift();
      }
      [Gt](t = false) {
        do
          ;
        while (this[ms](this[zt]()) && this[T].length);
        !t && !this[T].length && !this[$] && this.emit("drain");
      }
      [ms](t) {
        return this.emit("data", t), this[x];
      }
      pipe(t, e) {
        if (this[O])
          return t;
        this[D] = false;
        let s = this[K];
        return e = e || {}, t === ds.stdout || t === ds.stderr ? e.end = false : e.end = e.end !== false, e.proxyErrors = !!e.proxyErrors, s ? e.end && t.end() : (this[M].push(e.proxyErrors ? new Ee(this, t, e) : new $t(this, t, e)), this[I] ? ft(() => this[nt]()) : this[nt]()), t;
      }
      unpipe(t) {
        let e = this[M].find((s) => s.dest === t);
        e && (this[M].length === 1 ? (this[x] && this[Z] === 0 && (this[x] = false), this[M] = []) : this[M].splice(this[M].indexOf(e), 1), e.unpipe());
      }
      addListener(t, e) {
        return this.on(t, e);
      }
      on(t, e) {
        let s = super.on(t, e);
        if (t === "data")
          this[D] = false, this[Z]++, !this[M].length && !this[x] && this[nt]();
        else if (t === "readable" && this[C] !== 0)
          super.emit("readable");
        else if (ur(t) && this[K])
          super.emit(t), this.removeAllListeners(t);
        else if (t === "error" && this[lt]) {
          let i = e;
          this[I] ? ft(() => i.call(this, this[lt])) : i.call(this, this[lt]);
        }
        return s;
      }
      removeListener(t, e) {
        return this.off(t, e);
      }
      off(t, e) {
        let s = super.off(t, e);
        return t === "data" && (this[Z] = this.listeners("data").length, this[Z] === 0 && !this[D] && !this[M].length && (this[x] = false)), s;
      }
      removeAllListeners(t) {
        let e = super.removeAllListeners(t);
        return (t === "data" || t === undefined) && (this[Z] = 0, !this[D] && !this[M].length && (this[x] = false)), e;
      }
      get emittedEnd() {
        return this[K];
      }
      [q]() {
        !this[Bt] && !this[K] && !this[O] && this[T].length === 0 && this[$] && (this[Bt] = true, this.emit("end"), this.emit("prefinish"), this.emit("finish"), this[It] && this.emit("close"), this[Bt] = false);
      }
      emit(t, ...e) {
        let s = e[0];
        if (t !== "error" && t !== "close" && t !== O && this[O])
          return false;
        if (t === "data")
          return !this[k] && !s ? false : this[I] ? (ft(() => this[ye](s)), true) : this[ye](s);
        if (t === "end")
          return this[gs]();
        if (t === "close") {
          if (this[It] = true, !this[K] && !this[O])
            return false;
          let r = super.emit("close");
          return this.removeAllListeners("close"), r;
        } else if (t === "error") {
          this[lt] = s, super.emit(be, s);
          let r = !this[ut] || this.listeners("error").length ? super.emit("error", s) : false;
          return this[q](), r;
        } else if (t === "resume") {
          let r = super.emit("resume");
          return this[q](), r;
        } else if (t === "finish" || t === "prefinish") {
          let r = super.emit(t);
          return this.removeAllListeners(t), r;
        }
        let i = super.emit(t, ...e);
        return this[q](), i;
      }
      [ye](t) {
        for (let s of this[M])
          s.dest.write(t) === false && this.pause();
        let e = this[D] ? false : super.emit("data", t);
        return this[q](), e;
      }
      [gs]() {
        return this[K] ? false : (this[K] = true, this.readable = false, this[I] ? (ft(() => this[Se]()), true) : this[Se]());
      }
      [Se]() {
        if (this[rt]) {
          let e = this[rt].end();
          if (e) {
            for (let s of this[M])
              s.dest.write(e);
            this[D] || super.emit("data", e);
          }
        }
        for (let e of this[M])
          e.end();
        let t = super.emit("end");
        return this.removeAllListeners("end"), t;
      }
      async collect() {
        let t = Object.assign([], { dataLength: 0 });
        this[k] || (t.dataLength = 0);
        let e = this.promise();
        return this.on("data", (s) => {
          t.push(s), this[k] || (t.dataLength += s.length);
        }), await e, t;
      }
      async concat() {
        if (this[k])
          throw new Error("cannot concat in objectMode");
        let t = await this.collect();
        return this[L] ? t.join("") : Buffer.concat(t, t.dataLength);
      }
      async promise() {
        return new Promise((t, e) => {
          this.on(O, () => e(new Error("stream destroyed"))), this.on("error", (s) => e(s)), this.on("end", () => t());
        });
      }
      [Symbol.asyncIterator]() {
        this[D] = false;
        let t = false, e = async () => (this.pause(), t = true, { value: undefined, done: true });
        return { next: () => {
          if (t)
            return e();
          let i = this.read();
          if (i !== null)
            return Promise.resolve({ done: false, value: i });
          if (this[$])
            return e();
          let r, h, o = (c) => {
            this.off("data", a), this.off("end", l), this.off(O, f), e(), h(c);
          }, a = (c) => {
            this.off("error", o), this.off("end", l), this.off(O, f), this.pause(), r({ value: c, done: !!this[$] });
          }, l = () => {
            this.off("error", o), this.off("data", a), this.off(O, f), e(), r({ done: true, value: undefined });
          }, f = () => o(new Error("stream destroyed"));
          return new Promise((c, d) => {
            h = d, r = c, this.once(O, f), this.once("error", o), this.once("end", l), this.once("data", a);
          });
        }, throw: e, return: e, [Symbol.asyncIterator]() {
          return this;
        }, [Symbol.asyncDispose]: async () => {} };
      }
      [Symbol.iterator]() {
        this[D] = false;
        let t = false, e = () => (this.pause(), this.off(be, e), this.off(O, e), this.off("end", e), t = true, { done: true, value: undefined }), s = () => {
          if (t)
            return e();
          let i = this.read();
          return i === null ? e() : { done: false, value: i };
        };
        return this.once("end", e), this.once(be, e), this.once(O, e), { next: s, throw: e, return: e, [Symbol.iterator]() {
          return this;
        }, [Symbol.dispose]: () => {} };
      }
      destroy(t) {
        if (this[O])
          return t ? this.emit("error", t) : this.emit(O), this;
        this[O] = true, this[D] = true, this[T].length = 0, this[C] = 0;
        let e = this;
        return typeof e.close == "function" && !this[It] && e.close(), t ? this.emit("error", t) : this.emit(O), this;
      }
      static get isStream() {
        return P.isStream;
      }
    };
    P.Minipass = qt;
  });
  var Ms = R((_) => {
    var gr = _ && _.__createBinding || (Object.create ? function(n, t, e, s) {
      s === undefined && (s = e);
      var i = Object.getOwnPropertyDescriptor(t, e);
      (!i || ("get" in i ? !t.__esModule : i.writable || i.configurable)) && (i = { enumerable: true, get: function() {
        return t[e];
      } }), Object.defineProperty(n, s, i);
    } : function(n, t, e, s) {
      s === undefined && (s = e), n[s] = t[e];
    }), wr = _ && _.__setModuleDefault || (Object.create ? function(n, t) {
      Object.defineProperty(n, "default", { enumerable: true, value: t });
    } : function(n, t) {
      n.default = t;
    }), br = _ && _.__importStar || function(n) {
      if (n && n.__esModule)
        return n;
      var t = {};
      if (n != null)
        for (var e in n)
          e !== "default" && Object.prototype.hasOwnProperty.call(n, e) && gr(t, n, e);
      return wr(t, n), t;
    };
    Object.defineProperty(_, "__esModule", { value: true });
    _.PathScurry = _.Path = _.PathScurryDarwin = _.PathScurryPosix = _.PathScurryWin32 = _.PathScurryBase = _.PathPosix = _.PathWin32 = _.PathBase = _.ChildrenCache = _.ResolveCache = undefined;
    var Qt = fs(), Yt = __require("node:path"), yr = __require("node:url"), pt = __require("fs"), Sr = br(__require("node:fs")), vr = pt.realpathSync.native, Ht = __require("node:fs/promises"), bs = Oe(), mt = { lstatSync: pt.lstatSync, readdir: pt.readdir, readdirSync: pt.readdirSync, readlinkSync: pt.readlinkSync, realpathSync: vr, promises: { lstat: Ht.lstat, readdir: Ht.readdir, readlink: Ht.readlink, realpath: Ht.realpath } }, _s = (n) => !n || n === mt || n === Sr ? mt : { ...mt, ...n, promises: { ...mt.promises, ...n.promises || {} } }, Os = /^\\\\\?\\([a-z]:)\\?$/i, Er = (n) => n.replace(/\//g, "\\").replace(Os, "$1\\"), _r = /[\\\/]/, N = 0, xs = 1, Ts = 2, G = 4, Cs = 6, Rs = 8, Q = 10, As = 12, j = 15, dt = ~j, xe = 16, ys = 32, gt = 64, W = 128, Vt = 256, Xt = 512, Ss = gt | W | Xt, Or = 1023, Te = (n) => n.isFile() ? Rs : n.isDirectory() ? G : n.isSymbolicLink() ? Q : n.isCharacterDevice() ? Ts : n.isBlockDevice() ? Cs : n.isSocket() ? As : n.isFIFO() ? xs : N, vs = new Qt.LRUCache({ max: 2 ** 12 }), wt = (n) => {
      let t = vs.get(n);
      if (t)
        return t;
      let e = n.normalize("NFKD");
      return vs.set(n, e), e;
    }, Es = new Qt.LRUCache({ max: 2 ** 12 }), Kt = (n) => {
      let t = Es.get(n);
      if (t)
        return t;
      let e = wt(n.toLowerCase());
      return Es.set(n, e), e;
    }, bt = class extends Qt.LRUCache {
      constructor() {
        super({ max: 256 });
      }
    };
    _.ResolveCache = bt;
    var Jt = class extends Qt.LRUCache {
      constructor(t = 16 * 1024) {
        super({ maxSize: t, sizeCalculation: (e) => e.length + 1 });
      }
    };
    _.ChildrenCache = Jt;
    var ks = Symbol("PathScurry setAsCwd"), A = class {
      name;
      root;
      roots;
      parent;
      nocase;
      isCWD = false;
      #t;
      #s;
      get dev() {
        return this.#s;
      }
      #n;
      get mode() {
        return this.#n;
      }
      #r;
      get nlink() {
        return this.#r;
      }
      #h;
      get uid() {
        return this.#h;
      }
      #S;
      get gid() {
        return this.#S;
      }
      #w;
      get rdev() {
        return this.#w;
      }
      #c;
      get blksize() {
        return this.#c;
      }
      #o;
      get ino() {
        return this.#o;
      }
      #f;
      get size() {
        return this.#f;
      }
      #u;
      get blocks() {
        return this.#u;
      }
      #a;
      get atimeMs() {
        return this.#a;
      }
      #i;
      get mtimeMs() {
        return this.#i;
      }
      #d;
      get ctimeMs() {
        return this.#d;
      }
      #v;
      get birthtimeMs() {
        return this.#v;
      }
      #y;
      get atime() {
        return this.#y;
      }
      #p;
      get mtime() {
        return this.#p;
      }
      #R;
      get ctime() {
        return this.#R;
      }
      #m;
      get birthtime() {
        return this.#m;
      }
      #O;
      #x;
      #g;
      #b;
      #E;
      #T;
      #e;
      #F;
      #P;
      #C;
      get parentPath() {
        return (this.parent || this).fullpath();
      }
      get path() {
        return this.parentPath;
      }
      constructor(t, e = N, s, i, r, h, o) {
        this.name = t, this.#O = r ? Kt(t) : wt(t), this.#e = e & Or, this.nocase = r, this.roots = i, this.root = s || this, this.#F = h, this.#g = o.fullpath, this.#E = o.relative, this.#T = o.relativePosix, this.parent = o.parent, this.parent ? this.#t = this.parent.#t : this.#t = _s(o.fs);
      }
      depth() {
        return this.#x !== undefined ? this.#x : this.parent ? this.#x = this.parent.depth() + 1 : this.#x = 0;
      }
      childrenCache() {
        return this.#F;
      }
      resolve(t) {
        if (!t)
          return this;
        let e = this.getRootString(t), i = t.substring(e.length).split(this.splitSep);
        return e ? this.getRoot(e).#D(i) : this.#D(i);
      }
      #D(t) {
        let e = this;
        for (let s of t)
          e = e.child(s);
        return e;
      }
      children() {
        let t = this.#F.get(this);
        if (t)
          return t;
        let e = Object.assign([], { provisional: 0 });
        return this.#F.set(this, e), this.#e &= ~xe, e;
      }
      child(t, e) {
        if (t === "" || t === ".")
          return this;
        if (t === "..")
          return this.parent || this;
        let s = this.children(), i = this.nocase ? Kt(t) : wt(t);
        for (let a of s)
          if (a.#O === i)
            return a;
        let r = this.parent ? this.sep : "", h = this.#g ? this.#g + r + t : undefined, o = this.newChild(t, N, { ...e, parent: this, fullpath: h });
        return this.canReaddir() || (o.#e |= W), s.push(o), o;
      }
      relative() {
        if (this.isCWD)
          return "";
        if (this.#E !== undefined)
          return this.#E;
        let t = this.name, e = this.parent;
        if (!e)
          return this.#E = this.name;
        let s = e.relative();
        return s + (!s || !e.parent ? "" : this.sep) + t;
      }
      relativePosix() {
        if (this.sep === "/")
          return this.relative();
        if (this.isCWD)
          return "";
        if (this.#T !== undefined)
          return this.#T;
        let t = this.name, e = this.parent;
        if (!e)
          return this.#T = this.fullpathPosix();
        let s = e.relativePosix();
        return s + (!s || !e.parent ? "" : "/") + t;
      }
      fullpath() {
        if (this.#g !== undefined)
          return this.#g;
        let t = this.name, e = this.parent;
        if (!e)
          return this.#g = this.name;
        let i = e.fullpath() + (e.parent ? this.sep : "") + t;
        return this.#g = i;
      }
      fullpathPosix() {
        if (this.#b !== undefined)
          return this.#b;
        if (this.sep === "/")
          return this.#b = this.fullpath();
        if (!this.parent) {
          let i = this.fullpath().replace(/\\/g, "/");
          return /^[a-z]:\//i.test(i) ? this.#b = `//?/${i}` : this.#b = i;
        }
        let t = this.parent, e = t.fullpathPosix(), s = e + (!e || !t.parent ? "" : "/") + this.name;
        return this.#b = s;
      }
      isUnknown() {
        return (this.#e & j) === N;
      }
      isType(t) {
        return this[`is${t}`]();
      }
      getType() {
        return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : this.isSocket() ? "Socket" : "Unknown";
      }
      isFile() {
        return (this.#e & j) === Rs;
      }
      isDirectory() {
        return (this.#e & j) === G;
      }
      isCharacterDevice() {
        return (this.#e & j) === Ts;
      }
      isBlockDevice() {
        return (this.#e & j) === Cs;
      }
      isFIFO() {
        return (this.#e & j) === xs;
      }
      isSocket() {
        return (this.#e & j) === As;
      }
      isSymbolicLink() {
        return (this.#e & Q) === Q;
      }
      lstatCached() {
        return this.#e & ys ? this : undefined;
      }
      readlinkCached() {
        return this.#P;
      }
      realpathCached() {
        return this.#C;
      }
      readdirCached() {
        let t = this.children();
        return t.slice(0, t.provisional);
      }
      canReadlink() {
        if (this.#P)
          return true;
        if (!this.parent)
          return false;
        let t = this.#e & j;
        return !(t !== N && t !== Q || this.#e & Vt || this.#e & W);
      }
      calledReaddir() {
        return !!(this.#e & xe);
      }
      isENOENT() {
        return !!(this.#e & W);
      }
      isNamed(t) {
        return this.nocase ? this.#O === Kt(t) : this.#O === wt(t);
      }
      async readlink() {
        let t = this.#P;
        if (t)
          return t;
        if (this.canReadlink() && this.parent)
          try {
            let e = await this.#t.promises.readlink(this.fullpath()), s = (await this.parent.realpath())?.resolve(e);
            if (s)
              return this.#P = s;
          } catch (e) {
            this.#M(e.code);
            return;
          }
      }
      readlinkSync() {
        let t = this.#P;
        if (t)
          return t;
        if (this.canReadlink() && this.parent)
          try {
            let e = this.#t.readlinkSync(this.fullpath()), s = this.parent.realpathSync()?.resolve(e);
            if (s)
              return this.#P = s;
          } catch (e) {
            this.#M(e.code);
            return;
          }
      }
      #W(t) {
        this.#e |= xe;
        for (let e = t.provisional;e < t.length; e++) {
          let s = t[e];
          s && s.#_();
        }
      }
      #_() {
        this.#e & W || (this.#e = (this.#e | W) & dt, this.#$());
      }
      #$() {
        let t = this.children();
        t.provisional = 0;
        for (let e of t)
          e.#_();
      }
      #L() {
        this.#e |= Xt, this.#j();
      }
      #j() {
        if (this.#e & gt)
          return;
        let t = this.#e;
        (t & j) === G && (t &= dt), this.#e = t | gt, this.#$();
      }
      #B(t = "") {
        t === "ENOTDIR" || t === "EPERM" ? this.#j() : t === "ENOENT" ? this.#_() : this.children().provisional = 0;
      }
      #k(t = "") {
        t === "ENOTDIR" ? this.parent.#j() : t === "ENOENT" && this.#_();
      }
      #M(t = "") {
        let e = this.#e;
        e |= Vt, t === "ENOENT" && (e |= W), (t === "EINVAL" || t === "UNKNOWN") && (e &= dt), this.#e = e, t === "ENOTDIR" && this.parent && this.parent.#j();
      }
      #I(t, e) {
        return this.#z(t, e) || this.#G(t, e);
      }
      #G(t, e) {
        let s = Te(t), i = this.newChild(t.name, s, { parent: this }), r = i.#e & j;
        return r !== G && r !== Q && r !== N && (i.#e |= gt), e.unshift(i), e.provisional++, i;
      }
      #z(t, e) {
        for (let s = e.provisional;s < e.length; s++) {
          let i = e[s];
          if ((this.nocase ? Kt(t.name) : wt(t.name)) === i.#O)
            return this.#l(t, i, s, e);
        }
      }
      #l(t, e, s, i) {
        let r = e.name;
        return e.#e = e.#e & dt | Te(t), r !== t.name && (e.name = t.name), s !== i.provisional && (s === i.length - 1 ? i.pop() : i.splice(s, 1), i.unshift(e)), i.provisional++, e;
      }
      async lstat() {
        if ((this.#e & W) === 0)
          try {
            return this.#U(await this.#t.promises.lstat(this.fullpath())), this;
          } catch (t) {
            this.#k(t.code);
          }
      }
      lstatSync() {
        if ((this.#e & W) === 0)
          try {
            return this.#U(this.#t.lstatSync(this.fullpath())), this;
          } catch (t) {
            this.#k(t.code);
          }
      }
      #U(t) {
        let { atime: e, atimeMs: s, birthtime: i, birthtimeMs: r, blksize: h, blocks: o, ctime: a, ctimeMs: l, dev: f, gid: c, ino: d, mode: u, mtime: m, mtimeMs: p, nlink: b, rdev: w, size: v, uid: E } = t;
        this.#y = e, this.#a = s, this.#m = i, this.#v = r, this.#c = h, this.#u = o, this.#R = a, this.#d = l, this.#s = f, this.#S = c, this.#o = d, this.#n = u, this.#p = m, this.#i = p, this.#r = b, this.#w = w, this.#f = v, this.#h = E;
        let y = Te(t);
        this.#e = this.#e & dt | y | ys, y !== N && y !== G && y !== Q && (this.#e |= gt);
      }
      #N = [];
      #A = false;
      #q(t) {
        this.#A = false;
        let e = this.#N.slice();
        this.#N.length = 0, e.forEach((s) => s(null, t));
      }
      readdirCB(t, e = false) {
        if (!this.canReaddir()) {
          e ? t(null, []) : queueMicrotask(() => t(null, []));
          return;
        }
        let s = this.children();
        if (this.calledReaddir()) {
          let r = s.slice(0, s.provisional);
          e ? t(null, r) : queueMicrotask(() => t(null, r));
          return;
        }
        if (this.#N.push(t), this.#A)
          return;
        this.#A = true;
        let i = this.fullpath();
        this.#t.readdir(i, { withFileTypes: true }, (r, h) => {
          if (r)
            this.#B(r.code), s.provisional = 0;
          else {
            for (let o of h)
              this.#I(o, s);
            this.#W(s);
          }
          this.#q(s.slice(0, s.provisional));
        });
      }
      #H;
      async readdir() {
        if (!this.canReaddir())
          return [];
        let t = this.children();
        if (this.calledReaddir())
          return t.slice(0, t.provisional);
        let e = this.fullpath();
        if (this.#H)
          await this.#H;
        else {
          let s = () => {};
          this.#H = new Promise((i) => s = i);
          try {
            for (let i of await this.#t.promises.readdir(e, { withFileTypes: true }))
              this.#I(i, t);
            this.#W(t);
          } catch (i) {
            this.#B(i.code), t.provisional = 0;
          }
          this.#H = undefined, s();
        }
        return t.slice(0, t.provisional);
      }
      readdirSync() {
        if (!this.canReaddir())
          return [];
        let t = this.children();
        if (this.calledReaddir())
          return t.slice(0, t.provisional);
        let e = this.fullpath();
        try {
          for (let s of this.#t.readdirSync(e, { withFileTypes: true }))
            this.#I(s, t);
          this.#W(t);
        } catch (s) {
          this.#B(s.code), t.provisional = 0;
        }
        return t.slice(0, t.provisional);
      }
      canReaddir() {
        if (this.#e & Ss)
          return false;
        let t = j & this.#e;
        return t === N || t === G || t === Q;
      }
      shouldWalk(t, e) {
        return (this.#e & G) === G && !(this.#e & Ss) && !t.has(this) && (!e || e(this));
      }
      async realpath() {
        if (this.#C)
          return this.#C;
        if (!((Xt | Vt | W) & this.#e))
          try {
            let t = await this.#t.promises.realpath(this.fullpath());
            return this.#C = this.resolve(t);
          } catch {
            this.#L();
          }
      }
      realpathSync() {
        if (this.#C)
          return this.#C;
        if (!((Xt | Vt | W) & this.#e))
          try {
            let t = this.#t.realpathSync(this.fullpath());
            return this.#C = this.resolve(t);
          } catch {
            this.#L();
          }
      }
      [ks](t) {
        if (t === this)
          return;
        t.isCWD = false, this.isCWD = true;
        let e = new Set([]), s = [], i = this;
        for (;i && i.parent; )
          e.add(i), i.#E = s.join(this.sep), i.#T = s.join("/"), i = i.parent, s.push("..");
        for (i = t;i && i.parent && !e.has(i); )
          i.#E = undefined, i.#T = undefined, i = i.parent;
      }
    };
    _.PathBase = A;
    var yt = class n extends A {
      sep = "\\";
      splitSep = _r;
      constructor(t, e = N, s, i, r, h, o) {
        super(t, e, s, i, r, h, o);
      }
      newChild(t, e = N, s = {}) {
        return new n(t, e, this.root, this.roots, this.nocase, this.childrenCache(), s);
      }
      getRootString(t) {
        return Yt.win32.parse(t).root;
      }
      getRoot(t) {
        if (t = Er(t.toUpperCase()), t === this.root.name)
          return this.root;
        for (let [e, s] of Object.entries(this.roots))
          if (this.sameRoot(t, e))
            return this.roots[t] = s;
        return this.roots[t] = new Et(t, this).root;
      }
      sameRoot(t, e = this.root.name) {
        return t = t.toUpperCase().replace(/\//g, "\\").replace(Os, "$1\\"), t === e;
      }
    };
    _.PathWin32 = yt;
    var St = class n extends A {
      splitSep = "/";
      sep = "/";
      constructor(t, e = N, s, i, r, h, o) {
        super(t, e, s, i, r, h, o);
      }
      getRootString(t) {
        return t.startsWith("/") ? "/" : "";
      }
      getRoot(t) {
        return this.root;
      }
      newChild(t, e = N, s = {}) {
        return new n(t, e, this.root, this.roots, this.nocase, this.childrenCache(), s);
      }
    };
    _.PathPosix = St;
    var vt = class {
      root;
      rootPath;
      roots;
      cwd;
      #t;
      #s;
      #n;
      nocase;
      #r;
      constructor(t = process.cwd(), e, s, { nocase: i, childrenCacheSize: r = 16 * 1024, fs: h = mt } = {}) {
        this.#r = _s(h), (t instanceof URL || t.startsWith("file://")) && (t = (0, yr.fileURLToPath)(t));
        let o = e.resolve(t);
        this.roots = Object.create(null), this.rootPath = this.parseRootPath(o), this.#t = new bt, this.#s = new bt, this.#n = new Jt(r);
        let a = o.substring(this.rootPath.length).split(s);
        if (a.length === 1 && !a[0] && a.pop(), i === undefined)
          throw new TypeError("must provide nocase setting to PathScurryBase ctor");
        this.nocase = i, this.root = this.newRoot(this.#r), this.roots[this.rootPath] = this.root;
        let l = this.root, f = a.length - 1, c = e.sep, d = this.rootPath, u = false;
        for (let m of a) {
          let p = f--;
          l = l.child(m, { relative: new Array(p).fill("..").join(c), relativePosix: new Array(p).fill("..").join("/"), fullpath: d += (u ? "" : c) + m }), u = true;
        }
        this.cwd = l;
      }
      depth(t = this.cwd) {
        return typeof t == "string" && (t = this.cwd.resolve(t)), t.depth();
      }
      childrenCache() {
        return this.#n;
      }
      resolve(...t) {
        let e = "";
        for (let r = t.length - 1;r >= 0; r--) {
          let h = t[r];
          if (!(!h || h === ".") && (e = e ? `${h}/${e}` : h, this.isAbsolute(h)))
            break;
        }
        let s = this.#t.get(e);
        if (s !== undefined)
          return s;
        let i = this.cwd.resolve(e).fullpath();
        return this.#t.set(e, i), i;
      }
      resolvePosix(...t) {
        let e = "";
        for (let r = t.length - 1;r >= 0; r--) {
          let h = t[r];
          if (!(!h || h === ".") && (e = e ? `${h}/${e}` : h, this.isAbsolute(h)))
            break;
        }
        let s = this.#s.get(e);
        if (s !== undefined)
          return s;
        let i = this.cwd.resolve(e).fullpathPosix();
        return this.#s.set(e, i), i;
      }
      relative(t = this.cwd) {
        return typeof t == "string" && (t = this.cwd.resolve(t)), t.relative();
      }
      relativePosix(t = this.cwd) {
        return typeof t == "string" && (t = this.cwd.resolve(t)), t.relativePosix();
      }
      basename(t = this.cwd) {
        return typeof t == "string" && (t = this.cwd.resolve(t)), t.name;
      }
      dirname(t = this.cwd) {
        return typeof t == "string" && (t = this.cwd.resolve(t)), (t.parent || t).fullpath();
      }
      async readdir(t = this.cwd, e = { withFileTypes: true }) {
        typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof A || (e = t, t = this.cwd);
        let { withFileTypes: s } = e;
        if (t.canReaddir()) {
          let i = await t.readdir();
          return s ? i : i.map((r) => r.name);
        } else
          return [];
      }
      readdirSync(t = this.cwd, e = { withFileTypes: true }) {
        typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof A || (e = t, t = this.cwd);
        let { withFileTypes: s = true } = e;
        return t.canReaddir() ? s ? t.readdirSync() : t.readdirSync().map((i) => i.name) : [];
      }
      async lstat(t = this.cwd) {
        return typeof t == "string" && (t = this.cwd.resolve(t)), t.lstat();
      }
      lstatSync(t = this.cwd) {
        return typeof t == "string" && (t = this.cwd.resolve(t)), t.lstatSync();
      }
      async readlink(t = this.cwd, { withFileTypes: e } = { withFileTypes: false }) {
        typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof A || (e = t.withFileTypes, t = this.cwd);
        let s = await t.readlink();
        return e ? s : s?.fullpath();
      }
      readlinkSync(t = this.cwd, { withFileTypes: e } = { withFileTypes: false }) {
        typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof A || (e = t.withFileTypes, t = this.cwd);
        let s = t.readlinkSync();
        return e ? s : s?.fullpath();
      }
      async realpath(t = this.cwd, { withFileTypes: e } = { withFileTypes: false }) {
        typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof A || (e = t.withFileTypes, t = this.cwd);
        let s = await t.realpath();
        return e ? s : s?.fullpath();
      }
      realpathSync(t = this.cwd, { withFileTypes: e } = { withFileTypes: false }) {
        typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof A || (e = t.withFileTypes, t = this.cwd);
        let s = t.realpathSync();
        return e ? s : s?.fullpath();
      }
      async walk(t = this.cwd, e = {}) {
        typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof A || (e = t, t = this.cwd);
        let { withFileTypes: s = true, follow: i = false, filter: r, walkFilter: h } = e, o = [];
        (!r || r(t)) && o.push(s ? t : t.fullpath());
        let a = new Set, l = (c, d) => {
          a.add(c), c.readdirCB((u, m) => {
            if (u)
              return d(u);
            let p = m.length;
            if (!p)
              return d();
            let b = () => {
              --p === 0 && d();
            };
            for (let w of m)
              (!r || r(w)) && o.push(s ? w : w.fullpath()), i && w.isSymbolicLink() ? w.realpath().then((v) => v?.isUnknown() ? v.lstat() : v).then((v) => v?.shouldWalk(a, h) ? l(v, b) : b()) : w.shouldWalk(a, h) ? l(w, b) : b();
          }, true);
        }, f = t;
        return new Promise((c, d) => {
          l(f, (u) => {
            if (u)
              return d(u);
            c(o);
          });
        });
      }
      walkSync(t = this.cwd, e = {}) {
        typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof A || (e = t, t = this.cwd);
        let { withFileTypes: s = true, follow: i = false, filter: r, walkFilter: h } = e, o = [];
        (!r || r(t)) && o.push(s ? t : t.fullpath());
        let a = new Set([t]);
        for (let l of a) {
          let f = l.readdirSync();
          for (let c of f) {
            (!r || r(c)) && o.push(s ? c : c.fullpath());
            let d = c;
            if (c.isSymbolicLink()) {
              if (!(i && (d = c.realpathSync())))
                continue;
              d.isUnknown() && d.lstatSync();
            }
            d.shouldWalk(a, h) && a.add(d);
          }
        }
        return o;
      }
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
      iterate(t = this.cwd, e = {}) {
        return typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof A || (e = t, t = this.cwd), this.stream(t, e)[Symbol.asyncIterator]();
      }
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      *iterateSync(t = this.cwd, e = {}) {
        typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof A || (e = t, t = this.cwd);
        let { withFileTypes: s = true, follow: i = false, filter: r, walkFilter: h } = e;
        (!r || r(t)) && (yield s ? t : t.fullpath());
        let o = new Set([t]);
        for (let a of o) {
          let l = a.readdirSync();
          for (let f of l) {
            (!r || r(f)) && (yield s ? f : f.fullpath());
            let c = f;
            if (f.isSymbolicLink()) {
              if (!(i && (c = f.realpathSync())))
                continue;
              c.isUnknown() && c.lstatSync();
            }
            c.shouldWalk(o, h) && o.add(c);
          }
        }
      }
      stream(t = this.cwd, e = {}) {
        typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof A || (e = t, t = this.cwd);
        let { withFileTypes: s = true, follow: i = false, filter: r, walkFilter: h } = e, o = new bs.Minipass({ objectMode: true });
        (!r || r(t)) && o.write(s ? t : t.fullpath());
        let a = new Set, l = [t], f = 0, c = () => {
          let d = false;
          for (;!d; ) {
            let u = l.shift();
            if (!u) {
              f === 0 && o.end();
              return;
            }
            f++, a.add(u);
            let m = (b, w, v = false) => {
              if (b)
                return o.emit("error", b);
              if (i && !v) {
                let E = [];
                for (let y of w)
                  y.isSymbolicLink() && E.push(y.realpath().then((S) => S?.isUnknown() ? S.lstat() : S));
                if (E.length) {
                  Promise.all(E).then(() => m(null, w, true));
                  return;
                }
              }
              for (let E of w)
                E && (!r || r(E)) && (o.write(s ? E : E.fullpath()) || (d = true));
              f--;
              for (let E of w) {
                let y = E.realpathCached() || E;
                y.shouldWalk(a, h) && l.push(y);
              }
              d && !o.flowing ? o.once("drain", c) : p || c();
            }, p = true;
            u.readdirCB(m, true), p = false;
          }
        };
        return c(), o;
      }
      streamSync(t = this.cwd, e = {}) {
        typeof t == "string" ? t = this.cwd.resolve(t) : t instanceof A || (e = t, t = this.cwd);
        let { withFileTypes: s = true, follow: i = false, filter: r, walkFilter: h } = e, o = new bs.Minipass({ objectMode: true }), a = new Set;
        (!r || r(t)) && o.write(s ? t : t.fullpath());
        let l = [t], f = 0, c = () => {
          let d = false;
          for (;!d; ) {
            let u = l.shift();
            if (!u) {
              f === 0 && o.end();
              return;
            }
            f++, a.add(u);
            let m = u.readdirSync();
            for (let p of m)
              (!r || r(p)) && (o.write(s ? p : p.fullpath()) || (d = true));
            f--;
            for (let p of m) {
              let b = p;
              if (p.isSymbolicLink()) {
                if (!(i && (b = p.realpathSync())))
                  continue;
                b.isUnknown() && b.lstatSync();
              }
              b.shouldWalk(a, h) && l.push(b);
            }
          }
          d && !o.flowing && o.once("drain", c);
        };
        return c(), o;
      }
      chdir(t = this.cwd) {
        let e = this.cwd;
        this.cwd = typeof t == "string" ? this.cwd.resolve(t) : t, this.cwd[ks](e);
      }
    };
    _.PathScurryBase = vt;
    var Et = class extends vt {
      sep = "\\";
      constructor(t = process.cwd(), e = {}) {
        let { nocase: s = true } = e;
        super(t, Yt.win32, "\\", { ...e, nocase: s }), this.nocase = s;
        for (let i = this.cwd;i; i = i.parent)
          i.nocase = this.nocase;
      }
      parseRootPath(t) {
        return Yt.win32.parse(t).root.toUpperCase();
      }
      newRoot(t) {
        return new yt(this.rootPath, G, undefined, this.roots, this.nocase, this.childrenCache(), { fs: t });
      }
      isAbsolute(t) {
        return t.startsWith("/") || t.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(t);
      }
    };
    _.PathScurryWin32 = Et;
    var _t = class extends vt {
      sep = "/";
      constructor(t = process.cwd(), e = {}) {
        let { nocase: s = false } = e;
        super(t, Yt.posix, "/", { ...e, nocase: s }), this.nocase = s;
      }
      parseRootPath(t) {
        return "/";
      }
      newRoot(t) {
        return new St(this.rootPath, G, undefined, this.roots, this.nocase, this.childrenCache(), { fs: t });
      }
      isAbsolute(t) {
        return t.startsWith("/");
      }
    };
    _.PathScurryPosix = _t;
    var Zt = class extends _t {
      constructor(t = process.cwd(), e = {}) {
        let { nocase: s = true } = e;
        super(t, { ...e, nocase: s });
      }
    };
    _.PathScurryDarwin = Zt;
    _.Path = process.platform === "win32" ? yt : St;
    _.PathScurry = process.platform === "win32" ? Et : process.platform === "darwin" ? Zt : _t;
  });
  var Re = R((te) => {
    Object.defineProperty(te, "__esModule", { value: true });
    te.Pattern = undefined;
    var xr = H(), Tr = (n) => n.length >= 1, Cr = (n) => n.length >= 1, Rr = Symbol.for("nodejs.util.inspect.custom"), Ce = class n {
      #t;
      #s;
      #n;
      length;
      #r;
      #h;
      #S;
      #w;
      #c;
      #o;
      #f = true;
      constructor(t, e, s, i) {
        if (!Tr(t))
          throw new TypeError("empty pattern list");
        if (!Cr(e))
          throw new TypeError("empty glob list");
        if (e.length !== t.length)
          throw new TypeError("mismatched pattern list and glob list lengths");
        if (this.length = t.length, s < 0 || s >= this.length)
          throw new TypeError("index out of range");
        if (this.#t = t, this.#s = e, this.#n = s, this.#r = i, this.#n === 0) {
          if (this.isUNC()) {
            let [r, h, o, a, ...l] = this.#t, [f, c, d, u, ...m] = this.#s;
            l[0] === "" && (l.shift(), m.shift());
            let p = [r, h, o, a, ""].join("/"), b = [f, c, d, u, ""].join("/");
            this.#t = [p, ...l], this.#s = [b, ...m], this.length = this.#t.length;
          } else if (this.isDrive() || this.isAbsolute()) {
            let [r, ...h] = this.#t, [o, ...a] = this.#s;
            h[0] === "" && (h.shift(), a.shift());
            let l = r + "/", f = o + "/";
            this.#t = [l, ...h], this.#s = [f, ...a], this.length = this.#t.length;
          }
        }
      }
      [Rr]() {
        return "Pattern <" + this.#s.slice(this.#n).join("/") + ">";
      }
      pattern() {
        return this.#t[this.#n];
      }
      isString() {
        return typeof this.#t[this.#n] == "string";
      }
      isGlobstar() {
        return this.#t[this.#n] === xr.GLOBSTAR;
      }
      isRegExp() {
        return this.#t[this.#n] instanceof RegExp;
      }
      globString() {
        return this.#S = this.#S || (this.#n === 0 ? this.isAbsolute() ? this.#s[0] + this.#s.slice(1).join("/") : this.#s.join("/") : this.#s.slice(this.#n).join("/"));
      }
      hasMore() {
        return this.length > this.#n + 1;
      }
      rest() {
        return this.#h !== undefined ? this.#h : this.hasMore() ? (this.#h = new n(this.#t, this.#s, this.#n + 1, this.#r), this.#h.#o = this.#o, this.#h.#c = this.#c, this.#h.#w = this.#w, this.#h) : this.#h = null;
      }
      isUNC() {
        let t = this.#t;
        return this.#c !== undefined ? this.#c : this.#c = this.#r === "win32" && this.#n === 0 && t[0] === "" && t[1] === "" && typeof t[2] == "string" && !!t[2] && typeof t[3] == "string" && !!t[3];
      }
      isDrive() {
        let t = this.#t;
        return this.#w !== undefined ? this.#w : this.#w = this.#r === "win32" && this.#n === 0 && this.length > 1 && typeof t[0] == "string" && /^[a-z]:$/i.test(t[0]);
      }
      isAbsolute() {
        let t = this.#t;
        return this.#o !== undefined ? this.#o : this.#o = t[0] === "" && t.length > 1 || this.isDrive() || this.isUNC();
      }
      root() {
        let t = this.#t[0];
        return typeof t == "string" && this.isAbsolute() && this.#n === 0 ? t : "";
      }
      checkFollowGlobstar() {
        return !(this.#n === 0 || !this.isGlobstar() || !this.#f);
      }
      markFollowGlobstar() {
        return this.#n === 0 || !this.isGlobstar() || !this.#f ? false : (this.#f = false, true);
      }
    };
    te.Pattern = Ce;
  });
  var ke = R((ee) => {
    Object.defineProperty(ee, "__esModule", { value: true });
    ee.Ignore = undefined;
    var Ps = H(), Ar = Re(), kr = typeof process == "object" && process && typeof process.platform == "string" ? process.platform : "linux", Ae = class {
      relative;
      relativeChildren;
      absolute;
      absoluteChildren;
      platform;
      mmopts;
      constructor(t, { nobrace: e, nocase: s, noext: i, noglobstar: r, platform: h = kr }) {
        this.relative = [], this.absolute = [], this.relativeChildren = [], this.absoluteChildren = [], this.platform = h, this.mmopts = { dot: true, nobrace: e, nocase: s, noext: i, noglobstar: r, optimizationLevel: 2, platform: h, nocomment: true, nonegate: true };
        for (let o of t)
          this.add(o);
      }
      add(t) {
        let e = new Ps.Minimatch(t, this.mmopts);
        for (let s = 0;s < e.set.length; s++) {
          let i = e.set[s], r = e.globParts[s];
          if (!i || !r)
            throw new Error("invalid pattern object");
          for (;i[0] === "." && r[0] === "."; )
            i.shift(), r.shift();
          let h = new Ar.Pattern(i, r, 0, this.platform), o = new Ps.Minimatch(h.globString(), this.mmopts), a = r[r.length - 1] === "**", l = h.isAbsolute();
          l ? this.absolute.push(o) : this.relative.push(o), a && (l ? this.absoluteChildren.push(o) : this.relativeChildren.push(o));
        }
      }
      ignored(t) {
        let e = t.fullpath(), s = `${e}/`, i = t.relative() || ".", r = `${i}/`;
        for (let h of this.relative)
          if (h.match(i) || h.match(r))
            return true;
        for (let h of this.absolute)
          if (h.match(e) || h.match(s))
            return true;
        return false;
      }
      childrenIgnored(t) {
        let e = t.fullpath() + "/", s = (t.relative() || ".") + "/";
        for (let i of this.relativeChildren)
          if (i.match(s))
            return true;
        for (let i of this.absoluteChildren)
          if (i.match(e))
            return true;
        return false;
      }
    };
    ee.Ignore = Ae;
  });
  var Fs = R((z) => {
    Object.defineProperty(z, "__esModule", { value: true });
    z.Processor = z.SubWalks = z.MatchRecord = z.HasWalkedCache = undefined;
    var Ds = H(), se = class n {
      store;
      constructor(t = new Map) {
        this.store = t;
      }
      copy() {
        return new n(new Map(this.store));
      }
      hasWalked(t, e) {
        return this.store.get(t.fullpath())?.has(e.globString());
      }
      storeWalked(t, e) {
        let s = t.fullpath(), i = this.store.get(s);
        i ? i.add(e.globString()) : this.store.set(s, new Set([e.globString()]));
      }
    };
    z.HasWalkedCache = se;
    var ie = class {
      store = new Map;
      add(t, e, s) {
        let i = (e ? 2 : 0) | (s ? 1 : 0), r = this.store.get(t);
        this.store.set(t, r === undefined ? i : i & r);
      }
      entries() {
        return [...this.store.entries()].map(([t, e]) => [t, !!(e & 2), !!(e & 1)]);
      }
    };
    z.MatchRecord = ie;
    var re = class {
      store = new Map;
      add(t, e) {
        if (!t.canReaddir())
          return;
        let s = this.store.get(t);
        s ? s.find((i) => i.globString() === e.globString()) || s.push(e) : this.store.set(t, [e]);
      }
      get(t) {
        let e = this.store.get(t);
        if (!e)
          throw new Error("attempting to walk unknown path");
        return e;
      }
      entries() {
        return this.keys().map((t) => [t, this.store.get(t)]);
      }
      keys() {
        return [...this.store.keys()].filter((t) => t.canReaddir());
      }
    };
    z.SubWalks = re;
    var Me = class n {
      hasWalkedCache;
      matches = new ie;
      subwalks = new re;
      patterns;
      follow;
      dot;
      opts;
      constructor(t, e) {
        this.opts = t, this.follow = !!t.follow, this.dot = !!t.dot, this.hasWalkedCache = e ? e.copy() : new se;
      }
      processPatterns(t, e) {
        this.patterns = e;
        let s = e.map((i) => [t, i]);
        for (let [i, r] of s) {
          this.hasWalkedCache.storeWalked(i, r);
          let h = r.root(), o = r.isAbsolute() && this.opts.absolute !== false;
          if (h) {
            i = i.resolve(h === "/" && this.opts.root !== undefined ? this.opts.root : h);
            let c = r.rest();
            if (c)
              r = c;
            else {
              this.matches.add(i, true, false);
              continue;
            }
          }
          if (i.isENOENT())
            continue;
          let a, l, f = false;
          for (;typeof (a = r.pattern()) == "string" && (l = r.rest()); )
            i = i.resolve(a), r = l, f = true;
          if (a = r.pattern(), l = r.rest(), f) {
            if (this.hasWalkedCache.hasWalked(i, r))
              continue;
            this.hasWalkedCache.storeWalked(i, r);
          }
          if (typeof a == "string") {
            let c = a === ".." || a === "" || a === ".";
            this.matches.add(i.resolve(a), o, c);
            continue;
          } else if (a === Ds.GLOBSTAR) {
            (!i.isSymbolicLink() || this.follow || r.checkFollowGlobstar()) && this.subwalks.add(i, r);
            let c = l?.pattern(), d = l?.rest();
            if (!l || (c === "" || c === ".") && !d)
              this.matches.add(i, o, c === "" || c === ".");
            else if (c === "..") {
              let u = i.parent || i;
              d ? this.hasWalkedCache.hasWalked(u, d) || this.subwalks.add(u, d) : this.matches.add(u, o, true);
            }
          } else
            a instanceof RegExp && this.subwalks.add(i, r);
        }
        return this;
      }
      subwalkTargets() {
        return this.subwalks.keys();
      }
      child() {
        return new n(this.opts, this.hasWalkedCache);
      }
      filterEntries(t, e) {
        let s = this.subwalks.get(t), i = this.child();
        for (let r of e)
          for (let h of s) {
            let o = h.isAbsolute(), a = h.pattern(), l = h.rest();
            a === Ds.GLOBSTAR ? i.testGlobstar(r, h, l, o) : a instanceof RegExp ? i.testRegExp(r, a, l, o) : i.testString(r, a, l, o);
          }
        return i;
      }
      testGlobstar(t, e, s, i) {
        if ((this.dot || !t.name.startsWith(".")) && (e.hasMore() || this.matches.add(t, i, false), t.canReaddir() && (this.follow || !t.isSymbolicLink() ? this.subwalks.add(t, e) : t.isSymbolicLink() && (s && e.checkFollowGlobstar() ? this.subwalks.add(t, s) : e.markFollowGlobstar() && this.subwalks.add(t, e)))), s) {
          let r = s.pattern();
          if (typeof r == "string" && r !== ".." && r !== "" && r !== ".")
            this.testString(t, r, s.rest(), i);
          else if (r === "..") {
            let h = t.parent || t;
            this.subwalks.add(h, s);
          } else
            r instanceof RegExp && this.testRegExp(t, r, s.rest(), i);
        }
      }
      testRegExp(t, e, s, i) {
        e.test(t.name) && (s ? this.subwalks.add(t, s) : this.matches.add(t, i, false));
      }
      testString(t, e, s, i) {
        t.isNamed(e) && (s ? this.subwalks.add(t, s) : this.matches.add(t, i, false));
      }
    };
    z.Processor = Me;
  });
  var Ls = R((X) => {
    Object.defineProperty(X, "__esModule", { value: true });
    X.GlobStream = X.GlobWalker = X.GlobUtil = undefined;
    var Mr = Oe(), js = ke(), Ns = Fs(), Pr = (n, t) => typeof n == "string" ? new js.Ignore([n], t) : Array.isArray(n) ? new js.Ignore(n, t) : n, Ot = class {
      path;
      patterns;
      opts;
      seen = new Set;
      paused = false;
      aborted = false;
      #t = [];
      #s;
      #n;
      signal;
      maxDepth;
      includeChildMatches;
      constructor(t, e, s) {
        if (this.patterns = t, this.path = e, this.opts = s, this.#n = !s.posix && s.platform === "win32" ? "\\" : "/", this.includeChildMatches = s.includeChildMatches !== false, (s.ignore || !this.includeChildMatches) && (this.#s = Pr(s.ignore ?? [], s), !this.includeChildMatches && typeof this.#s.add != "function")) {
          let i = "cannot ignore child matches, ignore lacks add() method.";
          throw new Error(i);
        }
        this.maxDepth = s.maxDepth || 1 / 0, s.signal && (this.signal = s.signal, this.signal.addEventListener("abort", () => {
          this.#t.length = 0;
        }));
      }
      #r(t) {
        return this.seen.has(t) || !!this.#s?.ignored?.(t);
      }
      #h(t) {
        return !!this.#s?.childrenIgnored?.(t);
      }
      pause() {
        this.paused = true;
      }
      resume() {
        if (this.signal?.aborted)
          return;
        this.paused = false;
        let t;
        for (;!this.paused && (t = this.#t.shift()); )
          t();
      }
      onResume(t) {
        this.signal?.aborted || (this.paused ? this.#t.push(t) : t());
      }
      async matchCheck(t, e) {
        if (e && this.opts.nodir)
          return;
        let s;
        if (this.opts.realpath) {
          if (s = t.realpathCached() || await t.realpath(), !s)
            return;
          t = s;
        }
        let r = t.isUnknown() || this.opts.stat ? await t.lstat() : t;
        if (this.opts.follow && this.opts.nodir && r?.isSymbolicLink()) {
          let h = await r.realpath();
          h && (h.isUnknown() || this.opts.stat) && await h.lstat();
        }
        return this.matchCheckTest(r, e);
      }
      matchCheckTest(t, e) {
        return t && (this.maxDepth === 1 / 0 || t.depth() <= this.maxDepth) && (!e || t.canReaddir()) && (!this.opts.nodir || !t.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !t.isSymbolicLink() || !t.realpathCached()?.isDirectory()) && !this.#r(t) ? t : undefined;
      }
      matchCheckSync(t, e) {
        if (e && this.opts.nodir)
          return;
        let s;
        if (this.opts.realpath) {
          if (s = t.realpathCached() || t.realpathSync(), !s)
            return;
          t = s;
        }
        let r = t.isUnknown() || this.opts.stat ? t.lstatSync() : t;
        if (this.opts.follow && this.opts.nodir && r?.isSymbolicLink()) {
          let h = r.realpathSync();
          h && (h?.isUnknown() || this.opts.stat) && h.lstatSync();
        }
        return this.matchCheckTest(r, e);
      }
      matchFinish(t, e) {
        if (this.#r(t))
          return;
        if (!this.includeChildMatches && this.#s?.add) {
          let r = `${t.relativePosix()}/**`;
          this.#s.add(r);
        }
        let s = this.opts.absolute === undefined ? e : this.opts.absolute;
        this.seen.add(t);
        let i = this.opts.mark && t.isDirectory() ? this.#n : "";
        if (this.opts.withFileTypes)
          this.matchEmit(t);
        else if (s) {
          let r = this.opts.posix ? t.fullpathPosix() : t.fullpath();
          this.matchEmit(r + i);
        } else {
          let r = this.opts.posix ? t.relativePosix() : t.relative(), h = this.opts.dotRelative && !r.startsWith(".." + this.#n) ? "." + this.#n : "";
          this.matchEmit(r ? h + r + i : "." + i);
        }
      }
      async match(t, e, s) {
        let i = await this.matchCheck(t, s);
        i && this.matchFinish(i, e);
      }
      matchSync(t, e, s) {
        let i = this.matchCheckSync(t, s);
        i && this.matchFinish(i, e);
      }
      walkCB(t, e, s) {
        this.signal?.aborted && s(), this.walkCB2(t, e, new Ns.Processor(this.opts), s);
      }
      walkCB2(t, e, s, i) {
        if (this.#h(t))
          return i();
        if (this.signal?.aborted && i(), this.paused) {
          this.onResume(() => this.walkCB2(t, e, s, i));
          return;
        }
        s.processPatterns(t, e);
        let r = 1, h = () => {
          --r === 0 && i();
        };
        for (let [o, a, l] of s.matches.entries())
          this.#r(o) || (r++, this.match(o, a, l).then(() => h()));
        for (let o of s.subwalkTargets()) {
          if (this.maxDepth !== 1 / 0 && o.depth() >= this.maxDepth)
            continue;
          r++;
          let a = o.readdirCached();
          o.calledReaddir() ? this.walkCB3(o, a, s, h) : o.readdirCB((l, f) => this.walkCB3(o, f, s, h), true);
        }
        h();
      }
      walkCB3(t, e, s, i) {
        s = s.filterEntries(t, e);
        let r = 1, h = () => {
          --r === 0 && i();
        };
        for (let [o, a, l] of s.matches.entries())
          this.#r(o) || (r++, this.match(o, a, l).then(() => h()));
        for (let [o, a] of s.subwalks.entries())
          r++, this.walkCB2(o, a, s.child(), h);
        h();
      }
      walkCBSync(t, e, s) {
        this.signal?.aborted && s(), this.walkCB2Sync(t, e, new Ns.Processor(this.opts), s);
      }
      walkCB2Sync(t, e, s, i) {
        if (this.#h(t))
          return i();
        if (this.signal?.aborted && i(), this.paused) {
          this.onResume(() => this.walkCB2Sync(t, e, s, i));
          return;
        }
        s.processPatterns(t, e);
        let r = 1, h = () => {
          --r === 0 && i();
        };
        for (let [o, a, l] of s.matches.entries())
          this.#r(o) || this.matchSync(o, a, l);
        for (let o of s.subwalkTargets()) {
          if (this.maxDepth !== 1 / 0 && o.depth() >= this.maxDepth)
            continue;
          r++;
          let a = o.readdirSync();
          this.walkCB3Sync(o, a, s, h);
        }
        h();
      }
      walkCB3Sync(t, e, s, i) {
        s = s.filterEntries(t, e);
        let r = 1, h = () => {
          --r === 0 && i();
        };
        for (let [o, a, l] of s.matches.entries())
          this.#r(o) || this.matchSync(o, a, l);
        for (let [o, a] of s.subwalks.entries())
          r++, this.walkCB2Sync(o, a, s.child(), h);
        h();
      }
    };
    X.GlobUtil = Ot;
    var Pe = class extends Ot {
      matches = new Set;
      constructor(t, e, s) {
        super(t, e, s);
      }
      matchEmit(t) {
        this.matches.add(t);
      }
      async walk() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        return this.path.isUnknown() && await this.path.lstat(), await new Promise((t, e) => {
          this.walkCB(this.path, this.patterns, () => {
            this.signal?.aborted ? e(this.signal.reason) : t(this.matches);
          });
        }), this.matches;
      }
      walkSync() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        return this.path.isUnknown() && this.path.lstatSync(), this.walkCBSync(this.path, this.patterns, () => {
          if (this.signal?.aborted)
            throw this.signal.reason;
        }), this.matches;
      }
    };
    X.GlobWalker = Pe;
    var De = class extends Ot {
      results;
      constructor(t, e, s) {
        super(t, e, s), this.results = new Mr.Minipass({ signal: this.signal, objectMode: true }), this.results.on("drain", () => this.resume()), this.results.on("resume", () => this.resume());
      }
      matchEmit(t) {
        this.results.write(t), this.results.flowing || this.pause();
      }
      stream() {
        let t = this.path;
        return t.isUnknown() ? t.lstat().then(() => {
          this.walkCB(t, this.patterns, () => this.results.end());
        }) : this.walkCB(t, this.patterns, () => this.results.end()), this.results;
      }
      streamSync() {
        return this.path.isUnknown() && this.path.lstatSync(), this.walkCBSync(this.path, this.patterns, () => this.results.end()), this.results;
      }
    };
    X.GlobStream = De;
  });
  var je = R((oe) => {
    Object.defineProperty(oe, "__esModule", { value: true });
    oe.Glob = undefined;
    var Dr = H(), Fr = __require("node:url"), ne = Ms(), jr = Re(), he = Ls(), Nr = typeof process == "object" && process && typeof process.platform == "string" ? process.platform : "linux", Fe = class {
      absolute;
      cwd;
      root;
      dot;
      dotRelative;
      follow;
      ignore;
      magicalBraces;
      mark;
      matchBase;
      maxDepth;
      nobrace;
      nocase;
      nodir;
      noext;
      noglobstar;
      pattern;
      platform;
      realpath;
      scurry;
      stat;
      signal;
      windowsPathsNoEscape;
      withFileTypes;
      includeChildMatches;
      opts;
      patterns;
      constructor(t, e) {
        if (!e)
          throw new TypeError("glob options required");
        if (this.withFileTypes = !!e.withFileTypes, this.signal = e.signal, this.follow = !!e.follow, this.dot = !!e.dot, this.dotRelative = !!e.dotRelative, this.nodir = !!e.nodir, this.mark = !!e.mark, e.cwd ? (e.cwd instanceof URL || e.cwd.startsWith("file://")) && (e.cwd = (0, Fr.fileURLToPath)(e.cwd)) : this.cwd = "", this.cwd = e.cwd || "", this.root = e.root, this.magicalBraces = !!e.magicalBraces, this.nobrace = !!e.nobrace, this.noext = !!e.noext, this.realpath = !!e.realpath, this.absolute = e.absolute, this.includeChildMatches = e.includeChildMatches !== false, this.noglobstar = !!e.noglobstar, this.matchBase = !!e.matchBase, this.maxDepth = typeof e.maxDepth == "number" ? e.maxDepth : 1 / 0, this.stat = !!e.stat, this.ignore = e.ignore, this.withFileTypes && this.absolute !== undefined)
          throw new Error("cannot set absolute and withFileTypes:true");
        if (typeof t == "string" && (t = [t]), this.windowsPathsNoEscape = !!e.windowsPathsNoEscape || e.allowWindowsEscape === false, this.windowsPathsNoEscape && (t = t.map((a) => a.replace(/\\/g, "/"))), this.matchBase) {
          if (e.noglobstar)
            throw new TypeError("base matching requires globstar");
          t = t.map((a) => a.includes("/") ? a : `./**/${a}`);
        }
        if (this.pattern = t, this.platform = e.platform || Nr, this.opts = { ...e, platform: this.platform }, e.scurry) {
          if (this.scurry = e.scurry, e.nocase !== undefined && e.nocase !== e.scurry.nocase)
            throw new Error("nocase option contradicts provided scurry option");
        } else {
          let a = e.platform === "win32" ? ne.PathScurryWin32 : e.platform === "darwin" ? ne.PathScurryDarwin : e.platform ? ne.PathScurryPosix : ne.PathScurry;
          this.scurry = new a(this.cwd, { nocase: e.nocase, fs: e.fs });
        }
        this.nocase = this.scurry.nocase;
        let s = this.platform === "darwin" || this.platform === "win32", i = { braceExpandMax: 1e4, ...e, dot: this.dot, matchBase: this.matchBase, nobrace: this.nobrace, nocase: this.nocase, nocaseMagicOnly: s, nocomment: true, noext: this.noext, nonegate: true, optimizationLevel: 2, platform: this.platform, windowsPathsNoEscape: this.windowsPathsNoEscape, debug: !!this.opts.debug }, r = this.pattern.map((a) => new Dr.Minimatch(a, i)), [h, o] = r.reduce((a, l) => (a[0].push(...l.set), a[1].push(...l.globParts), a), [[], []]);
        this.patterns = h.map((a, l) => {
          let f = o[l];
          if (!f)
            throw new Error("invalid pattern object");
          return new jr.Pattern(a, f, 0, this.platform);
        });
      }
      async walk() {
        return [...await new he.GlobWalker(this.patterns, this.scurry.cwd, { ...this.opts, maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0, platform: this.platform, nocase: this.nocase, includeChildMatches: this.includeChildMatches }).walk()];
      }
      walkSync() {
        return [...new he.GlobWalker(this.patterns, this.scurry.cwd, { ...this.opts, maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0, platform: this.platform, nocase: this.nocase, includeChildMatches: this.includeChildMatches }).walkSync()];
      }
      stream() {
        return new he.GlobStream(this.patterns, this.scurry.cwd, { ...this.opts, maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0, platform: this.platform, nocase: this.nocase, includeChildMatches: this.includeChildMatches }).stream();
      }
      streamSync() {
        return new he.GlobStream(this.patterns, this.scurry.cwd, { ...this.opts, maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0, platform: this.platform, nocase: this.nocase, includeChildMatches: this.includeChildMatches }).streamSync();
      }
      iterateSync() {
        return this.streamSync()[Symbol.iterator]();
      }
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      iterate() {
        return this.stream()[Symbol.asyncIterator]();
      }
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
    };
    oe.Glob = Fe;
  });
  var Ne = R((ae) => {
    Object.defineProperty(ae, "__esModule", { value: true });
    ae.hasMagic = undefined;
    var Lr = H(), Wr = (n, t = {}) => {
      Array.isArray(n) || (n = [n]);
      for (let e of n)
        if (new Lr.Minimatch(e, t).hasMagic())
          return true;
      return false;
    };
    ae.hasMagic = Wr;
  });
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.glob = exports.sync = exports.iterate = exports.iterateSync = exports.stream = exports.streamSync = exports.Ignore = exports.hasMagic = exports.Glob = exports.unescape = exports.escape = undefined;
  exports.globStreamSync = xt;
  exports.globStream = Le;
  exports.globSync = We;
  exports.globIterateSync = Tt;
  exports.globIterate = Be;
  var Ws = H();
  var tt = je();
  var Br = Ne();
  var Is = H();
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return Is.escape;
  } });
  Object.defineProperty(exports, "unescape", { enumerable: true, get: function() {
    return Is.unescape;
  } });
  var Ir = je();
  Object.defineProperty(exports, "Glob", { enumerable: true, get: function() {
    return Ir.Glob;
  } });
  var Gr = Ne();
  Object.defineProperty(exports, "hasMagic", { enumerable: true, get: function() {
    return Gr.hasMagic;
  } });
  var zr = ke();
  Object.defineProperty(exports, "Ignore", { enumerable: true, get: function() {
    return zr.Ignore;
  } });
  function xt(n, t = {}) {
    return new tt.Glob(n, t).streamSync();
  }
  function Le(n, t = {}) {
    return new tt.Glob(n, t).stream();
  }
  function We(n, t = {}) {
    return new tt.Glob(n, t).walkSync();
  }
  async function Bs(n, t = {}) {
    return new tt.Glob(n, t).walk();
  }
  function Tt(n, t = {}) {
    return new tt.Glob(n, t).iterateSync();
  }
  function Be(n, t = {}) {
    return new tt.Glob(n, t).iterate();
  }
  exports.streamSync = xt;
  exports.stream = Object.assign(Le, { sync: xt });
  exports.iterateSync = Tt;
  exports.iterate = Object.assign(Be, { sync: Tt });
  exports.sync = Object.assign(We, { stream: xt, iterate: Tt });
  exports.glob = Object.assign(Bs, { glob: Bs, globSync: We, sync: exports.sync, globStream: Le, stream: exports.stream, globStreamSync: xt, streamSync: exports.streamSync, globIterate: Be, iterate: exports.iterate, globIterateSync: Tt, iterateSync: exports.iterateSync, Glob: tt.Glob, hasMagic: Br.hasMagic, escape: Ws.escape, unescape: Ws.unescape });
  exports.glob.glob = exports.glob;
});

// node_modules/cacache/lib/util/glob.js
var require_glob = __commonJS((exports, module) => {
  var { glob } = require_index_min2();
  var path = __require("path");
  var globify = (pattern) => pattern.split(path.win32.sep).join(path.posix.sep);
  module.exports = (path2, options) => glob(globify(path2), options);
});

// node_modules/cacache/lib/content/rm.js
var require_rm = __commonJS((exports, module) => {
  var fs = __require("fs/promises");
  var contentPath = require_path();
  var { hasContent } = require_read();
  module.exports = rm;
  async function rm(cache2, integrity) {
    const content = await hasContent(cache2, integrity);
    if (content && content.sri) {
      await fs.rm(contentPath(cache2, content.sri), { recursive: true, force: true });
      return true;
    } else {
      return false;
    }
  }
});

// node_modules/cacache/lib/rm.js
var require_rm2 = __commonJS((exports, module) => {
  var { rm } = __require("fs/promises");
  var glob = require_glob();
  var index = require_entry_index();
  var memo = require_memoization();
  var path = __require("path");
  var rmContent = require_rm();
  module.exports = entry;
  module.exports.entry = entry;
  function entry(cache2, key, opts) {
    memo.clearMemoized();
    return index.delete(cache2, key, opts);
  }
  module.exports.content = content;
  function content(cache2, integrity) {
    memo.clearMemoized();
    return rmContent(cache2, integrity);
  }
  module.exports.all = all;
  async function all(cache2) {
    memo.clearMemoized();
    const paths = await glob(path.join(cache2, "*(content-*|index-*)"), { silent: true, nosort: true });
    return Promise.all(paths.map((p) => rm(p, { recursive: true, force: true })));
  }
});

// node_modules/cacache/lib/verify.js
var require_verify = __commonJS((exports, module) => {
  var {
    mkdir,
    readFile,
    rm,
    stat,
    truncate,
    writeFile
  } = __require("fs/promises");
  var contentPath = require_path();
  var fsm = require_lib7();
  var glob = require_glob();
  var index = require_entry_index();
  var path = __require("path");
  var ssri = require_lib3();
  var hasOwnProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
  var verifyOpts = (opts) => ({
    concurrency: 20,
    log: { silly() {} },
    ...opts
  });
  module.exports = verify2;
  async function verify2(cache2, opts) {
    opts = verifyOpts(opts);
    opts.log.silly("verify", "verifying cache at", cache2);
    const steps = [
      markStartTime,
      fixPerms,
      garbageCollect,
      rebuildIndex,
      cleanTmp,
      writeVerifile,
      markEndTime
    ];
    const stats = {};
    for (const step of steps) {
      const label = step.name;
      const start = new Date;
      const s = await step(cache2, opts);
      if (s) {
        Object.keys(s).forEach((k) => {
          stats[k] = s[k];
        });
      }
      const end = new Date;
      if (!stats.runTime) {
        stats.runTime = {};
      }
      stats.runTime[label] = end - start;
    }
    stats.runTime.total = stats.endTime - stats.startTime;
    opts.log.silly("verify", "verification finished for", cache2, "in", `${stats.runTime.total}ms`);
    return stats;
  }
  async function markStartTime() {
    return { startTime: new Date };
  }
  async function markEndTime() {
    return { endTime: new Date };
  }
  async function fixPerms(cache2, opts) {
    opts.log.silly("verify", "fixing cache permissions");
    await mkdir(cache2, { recursive: true });
    return null;
  }
  async function garbageCollect(cache2, opts) {
    opts.log.silly("verify", "garbage collecting content");
    const { default: pMap2 } = await Promise.resolve().then(() => (init_p_map(), exports_p_map));
    const indexStream = index.lsStream(cache2);
    const liveContent = new Set;
    indexStream.on("data", (entry) => {
      if (opts.filter && !opts.filter(entry)) {
        return;
      }
      const integrity = ssri.parse(entry.integrity);
      for (const algo in integrity) {
        liveContent.add(integrity[algo].toString());
      }
    });
    await new Promise((resolve, reject) => {
      indexStream.on("end", resolve).on("error", reject);
    });
    const contentDir = contentPath.contentDir(cache2);
    const files = await glob(path.join(contentDir, "**"), {
      follow: false,
      nodir: true,
      nosort: true
    });
    const stats = {
      verifiedContent: 0,
      reclaimedCount: 0,
      reclaimedSize: 0,
      badContentCount: 0,
      keptSize: 0
    };
    await pMap2(files, async (f) => {
      const split = f.split(/[/\\]/);
      const digest = split.slice(split.length - 3).join("");
      const algo = split[split.length - 4];
      const integrity = ssri.fromHex(digest, algo);
      if (liveContent.has(integrity.toString())) {
        const info = await verifyContent(f, integrity);
        if (!info.valid) {
          stats.reclaimedCount++;
          stats.badContentCount++;
          stats.reclaimedSize += info.size;
        } else {
          stats.verifiedContent++;
          stats.keptSize += info.size;
        }
      } else {
        stats.reclaimedCount++;
        const s = await stat(f);
        await rm(f, { recursive: true, force: true });
        stats.reclaimedSize += s.size;
      }
      return stats;
    }, { concurrency: opts.concurrency });
    return stats;
  }
  async function verifyContent(filepath, sri) {
    const contentInfo = {};
    try {
      const { size } = await stat(filepath);
      contentInfo.size = size;
      contentInfo.valid = true;
      await ssri.checkStream(new fsm.ReadStream(filepath), sri);
    } catch (err) {
      if (err.code === "ENOENT") {
        return { size: 0, valid: false };
      }
      if (err.code !== "EINTEGRITY") {
        throw err;
      }
      await rm(filepath, { recursive: true, force: true });
      contentInfo.valid = false;
    }
    return contentInfo;
  }
  async function rebuildIndex(cache2, opts) {
    opts.log.silly("verify", "rebuilding index");
    const { default: pMap2 } = await Promise.resolve().then(() => (init_p_map(), exports_p_map));
    const entries = await index.ls(cache2);
    const stats = {
      missingContent: 0,
      rejectedEntries: 0,
      totalEntries: 0
    };
    const buckets = {};
    for (const k in entries) {
      if (hasOwnProperty(entries, k)) {
        const hashed = index.hashKey(k);
        const entry = entries[k];
        const excluded = opts.filter && !opts.filter(entry);
        excluded && stats.rejectedEntries++;
        if (buckets[hashed] && !excluded) {
          buckets[hashed].push(entry);
        } else if (buckets[hashed] && excluded) {} else if (excluded) {
          buckets[hashed] = [];
          buckets[hashed]._path = index.bucketPath(cache2, k);
        } else {
          buckets[hashed] = [entry];
          buckets[hashed]._path = index.bucketPath(cache2, k);
        }
      }
    }
    await pMap2(Object.keys(buckets), (key) => {
      return rebuildBucket(cache2, buckets[key], stats, opts);
    }, { concurrency: opts.concurrency });
    return stats;
  }
  async function rebuildBucket(cache2, bucket, stats) {
    await truncate(bucket._path);
    for (const entry of bucket) {
      const content = contentPath(cache2, entry.integrity);
      try {
        await stat(content);
        await index.insert(cache2, entry.key, entry.integrity, {
          metadata: entry.metadata,
          size: entry.size,
          time: entry.time
        });
        stats.totalEntries++;
      } catch (err) {
        if (err.code === "ENOENT") {
          stats.rejectedEntries++;
          stats.missingContent++;
        } else {
          throw err;
        }
      }
    }
  }
  function cleanTmp(cache2, opts) {
    opts.log.silly("verify", "cleaning tmp directory");
    return rm(path.join(cache2, "tmp"), { recursive: true, force: true });
  }
  async function writeVerifile(cache2, opts) {
    const verifile = path.join(cache2, "_lastverified");
    opts.log.silly("verify", "writing verifile to " + verifile);
    return writeFile(verifile, `${Date.now()}`);
  }
  module.exports.lastRun = lastRun;
  async function lastRun(cache2) {
    const data = await readFile(path.join(cache2, "_lastverified"), { encoding: "utf8" });
    return new Date(+data);
  }
});

// node_modules/cacache/lib/util/tmp.js
var require_tmp = __commonJS((exports, module) => {
  var { withTempDir } = require_lib6();
  var fs = __require("fs/promises");
  var path = __require("path");
  exports.mkdir = mktmpdir;
  async function mktmpdir(cache2, opts = {}) {
    const { tmpPrefix } = opts;
    const tmpDir = path.join(cache2, "tmp");
    await fs.mkdir(tmpDir, { recursive: true, owner: "inherit" });
    const target = `${tmpDir}${path.sep}${tmpPrefix || ""}`;
    return fs.mkdtemp(target, { owner: "inherit" });
  }
  exports.withTmp = withTmp;
  function withTmp(cache2, opts, cb) {
    if (!cb) {
      cb = opts;
      opts = {};
    }
    return withTempDir(path.join(cache2, "tmp"), cb, opts);
  }
});

// node_modules/cacache/lib/index.js
var require_lib8 = __commonJS((exports, module) => {
  var get = require_get();
  var put = require_put();
  var rm = require_rm2();
  var verify2 = require_verify();
  var { clearMemoized } = require_memoization();
  var tmp = require_tmp();
  var index = require_entry_index();
  exports.index = {};
  exports.index.compact = index.compact;
  exports.index.insert = index.insert;
  exports.ls = index.ls;
  exports.ls.stream = index.lsStream;
  exports.get = get;
  exports.get.byDigest = get.byDigest;
  exports.get.stream = get.stream;
  exports.get.stream.byDigest = get.stream.byDigest;
  exports.get.copy = get.copy;
  exports.get.copy.byDigest = get.copy.byDigest;
  exports.get.info = get.info;
  exports.get.hasContent = get.hasContent;
  exports.put = put;
  exports.put.stream = put.stream;
  exports.rm = rm.entry;
  exports.rm.all = rm.all;
  exports.rm.entry = exports.rm;
  exports.rm.content = rm.content;
  exports.clearMemoized = clearMemoized;
  exports.tmp = {};
  exports.tmp.mkdir = tmp.mkdir;
  exports.tmp.withTmp = tmp.withTmp;
  exports.verify = verify2;
  exports.verify.lastRun = verify2.lastRun;
});

// node_modules/make-fetch-happen/lib/pipeline.js
var require_pipeline = __commonJS((exports, module) => {
  var MinipassPipeline = require_minipass_pipeline();

  class CachingMinipassPipeline extends MinipassPipeline {
    #events = [];
    #data = new Map;
    constructor(opts, ...streams) {
      super();
      this.#events = opts.events;
      if (streams.length) {
        this.push(...streams);
      }
    }
    on(event, handler) {
      if (this.#events.includes(event) && this.#data.has(event)) {
        return handler(...this.#data.get(event));
      }
      return super.on(event, handler);
    }
    emit(event, ...data) {
      if (this.#events.includes(event)) {
        this.#data.set(event, data);
      }
      return super.emit(event, ...data);
    }
  }
  module.exports = CachingMinipassPipeline;
});

// node_modules/make-fetch-happen/lib/cache/key.js
var require_key = __commonJS((exports, module) => {
  var { URL: URL2, format } = __require("url");
  var formatOptions = {
    auth: false,
    fragment: false,
    search: true,
    unicode: false
  };
  var cacheKey = (request) => {
    const parsed = new URL2(request.url);
    return `make-fetch-happen:request-cache:${format(parsed, formatOptions)}`;
  };
  module.exports = cacheKey;
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS((exports, module) => {
  function RetryOperation(timeouts, options) {
    if (typeof options === "boolean") {
      options = { forever: options };
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = options && options.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    this._timer = null;
    if (this._options.forever) {
      this._cachedTimeouts = this._timeouts.slice(0);
    }
  }
  module.exports = RetryOperation;
  RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts.slice(0);
  };
  RetryOperation.prototype.stop = function() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (this._timer) {
      clearTimeout(this._timer);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
  };
  RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (!err) {
      return false;
    }
    var currentTime = new Date().getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
      this._errors.push(err);
      this._errors.unshift(new Error("RetryOperation timeout occurred"));
      return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === undefined) {
      if (this._cachedTimeouts) {
        this._errors.splice(0, this._errors.length - 1);
        timeout = this._cachedTimeouts.slice(-1);
      } else {
        return false;
      }
    }
    var self2 = this;
    this._timer = setTimeout(function() {
      self2._attempts++;
      if (self2._operationTimeoutCb) {
        self2._timeout = setTimeout(function() {
          self2._operationTimeoutCb(self2._attempts);
        }, self2._operationTimeout);
        if (self2._options.unref) {
          self2._timeout.unref();
        }
      }
      self2._fn(self2._attempts);
    }, timeout);
    if (this._options.unref) {
      this._timer.unref();
    }
    return true;
  };
  RetryOperation.prototype.attempt = function(fn, timeoutOps) {
    this._fn = fn;
    if (timeoutOps) {
      if (timeoutOps.timeout) {
        this._operationTimeout = timeoutOps.timeout;
      }
      if (timeoutOps.cb) {
        this._operationTimeoutCb = timeoutOps.cb;
      }
    }
    var self2 = this;
    if (this._operationTimeoutCb) {
      this._timeout = setTimeout(function() {
        self2._operationTimeoutCb();
      }, self2._operationTimeout);
    }
    this._operationStart = new Date().getTime();
    this._fn(this._attempts);
  };
  RetryOperation.prototype.try = function(fn) {
    console.log("Using RetryOperation.try() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = function(fn) {
    console.log("Using RetryOperation.start() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = RetryOperation.prototype.try;
  RetryOperation.prototype.errors = function() {
    return this._errors;
  };
  RetryOperation.prototype.attempts = function() {
    return this._attempts;
  };
  RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
      return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for (var i = 0;i < this._errors.length; i++) {
      var error = this._errors[i];
      var message3 = error.message;
      var count = (counts[message3] || 0) + 1;
      counts[message3] = count;
      if (count >= mainErrorCount) {
        mainError = error;
        mainErrorCount = count;
      }
    }
    return mainError;
  };
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS((exports) => {
  var RetryOperation = require_retry_operation();
  exports.operation = function(options) {
    var timeouts = exports.timeouts(options);
    return new RetryOperation(timeouts, {
      forever: options && (options.forever || options.retries === Infinity),
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime
    });
  };
  exports.timeouts = function(options) {
    if (options instanceof Array) {
      return [].concat(options);
    }
    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1000,
      maxTimeout: Infinity,
      randomize: false
    };
    for (var key in options) {
      opts[key] = options[key];
    }
    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error("minTimeout is greater than maxTimeout");
    }
    var timeouts = [];
    for (var i = 0;i < opts.retries; i++) {
      timeouts.push(this.createTimeout(i, opts));
    }
    if (options && options.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i, opts));
    }
    timeouts.sort(function(a, b) {
      return a - b;
    });
    return timeouts;
  };
  exports.createTimeout = function(attempt, opts) {
    var random = opts.randomize ? Math.random() + 1 : 1;
    var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);
    return timeout;
  };
  exports.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
      methods = options;
      options = null;
    }
    if (!methods) {
      methods = [];
      for (var key in obj) {
        if (typeof obj[key] === "function") {
          methods.push(key);
        }
      }
    }
    for (var i = 0;i < methods.length; i++) {
      var method = methods[i];
      var original = obj[method];
      obj[method] = function retryWrapper(original2) {
        var op = exports.operation(options);
        var args = Array.prototype.slice.call(arguments, 1);
        var callback = args.pop();
        args.push(function(err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });
        op.attempt(function() {
          original2.apply(obj, args);
        });
      }.bind(obj, original);
      obj[method].options = options;
    }
  };
});

// node_modules/@gar/promise-retry/lib/index.js
var require_lib9 = __commonJS((exports, module) => {
  var retry = require_retry();
  var isRetryError = (err) => err?.code === "EPROMISERETRY" && Object.hasOwn(err, "retried");
  async function promiseRetry(fn, options = {}) {
    const operation = retry.operation(options);
    return new Promise(function(resolve, reject) {
      operation.attempt(async (number) => {
        try {
          const result = await fn((err) => {
            throw Object.assign(new Error("Retrying"), { code: "EPROMISERETRY", retried: err });
          }, number, operation);
          return resolve(result);
        } catch (err) {
          if (isRetryError(err)) {
            if (operation.retry(err.retried || new Error)) {
              return;
            }
            return reject(err.retried);
          }
          return reject(err);
        }
      });
    });
  }
  module.exports = { promiseRetry };
});

// node_modules/proc-log/lib/index.js
var require_lib10 = __commonJS((exports, module) => {
  var META = Symbol("proc-log.meta");
  module.exports = {
    META,
    output: {
      LEVELS: [
        "standard",
        "error",
        "buffer",
        "flush"
      ],
      KEYS: {
        standard: "standard",
        error: "error",
        buffer: "buffer",
        flush: "flush"
      },
      standard: function(...args) {
        return process.emit("output", "standard", ...args);
      },
      error: function(...args) {
        return process.emit("output", "error", ...args);
      },
      buffer: function(...args) {
        return process.emit("output", "buffer", ...args);
      },
      flush: function(...args) {
        return process.emit("output", "flush", ...args);
      }
    },
    log: {
      LEVELS: [
        "notice",
        "error",
        "warn",
        "info",
        "verbose",
        "http",
        "silly",
        "timing",
        "pause",
        "resume"
      ],
      KEYS: {
        notice: "notice",
        error: "error",
        warn: "warn",
        info: "info",
        verbose: "verbose",
        http: "http",
        silly: "silly",
        timing: "timing",
        pause: "pause",
        resume: "resume"
      },
      error: function(...args) {
        return process.emit("log", "error", ...args);
      },
      notice: function(...args) {
        return process.emit("log", "notice", ...args);
      },
      warn: function(...args) {
        return process.emit("log", "warn", ...args);
      },
      info: function(...args) {
        return process.emit("log", "info", ...args);
      },
      verbose: function(...args) {
        return process.emit("log", "verbose", ...args);
      },
      http: function(...args) {
        return process.emit("log", "http", ...args);
      },
      silly: function(...args) {
        return process.emit("log", "silly", ...args);
      },
      timing: function(...args) {
        return process.emit("log", "timing", ...args);
      },
      pause: function() {
        return process.emit("log", "pause");
      },
      resume: function() {
        return process.emit("log", "resume");
      }
    },
    time: {
      LEVELS: [
        "start",
        "end"
      ],
      KEYS: {
        start: "start",
        end: "end"
      },
      start: function(name, fn) {
        process.emit("time", "start", name);
        function end() {
          return process.emit("time", "end", name);
        }
        if (typeof fn === "function") {
          const res = fn();
          if (res && res.finally) {
            return res.finally(end);
          }
          end();
          return res;
        }
        return end;
      },
      end: function(name) {
        return process.emit("time", "end", name);
      }
    },
    input: {
      LEVELS: [
        "start",
        "end",
        "read"
      ],
      KEYS: {
        start: "start",
        end: "end",
        read: "read"
      },
      start: function(...args) {
        let fn;
        if (typeof args[0] === "function") {
          fn = args.shift();
        }
        process.emit("input", "start", ...args);
        function end() {
          return process.emit("input", "end", ...args);
        }
        if (typeof fn === "function") {
          const res = fn();
          if (res && res.finally) {
            return res.finally(end);
          }
          end();
          return res;
        }
        return end;
      },
      end: function(...args) {
        return process.emit("input", "end", ...args);
      },
      read: function(...args) {
        let resolve, reject;
        const promise = new Promise((_resolve, _reject) => {
          resolve = _resolve;
          reject = _reject;
        });
        process.emit("input", "read", resolve, reject, ...args);
        return promise;
      }
    }
  };
});

// node_modules/@npmcli/agent/lib/dns.js
var require_dns = __commonJS((exports, module) => {
  var { LRUCache } = require_index_min();
  var dns = __require("dns");
  var cache2 = new LRUCache({ max: 50 });
  var getOptions = ({
    family = 0,
    hints = dns.ADDRCONFIG,
    all = false,
    verbatim = undefined,
    ttl = 5 * 60 * 1000,
    lookup = dns.lookup
  }) => ({
    hints,
    lookup: (hostname, ...args) => {
      const callback = args.pop();
      const lookupOptions = args[0] ?? {};
      const options = {
        family,
        hints,
        all,
        verbatim,
        ...typeof lookupOptions === "number" ? { family: lookupOptions } : lookupOptions
      };
      const key = JSON.stringify({ hostname, ...options });
      if (cache2.has(key)) {
        const cached = cache2.get(key);
        return process.nextTick(callback, null, ...cached);
      }
      lookup(hostname, options, (err, ...result) => {
        if (err) {
          return callback(err);
        }
        cache2.set(key, result, { ttl });
        return callback(null, ...result);
      });
    }
  });
  module.exports = {
    cache: cache2,
    getOptions
  };
});

// node_modules/@npmcli/agent/lib/options.js
var require_options2 = __commonJS((exports, module) => {
  var dns = require_dns();
  var normalizeOptions = (opts) => {
    const family = parseInt(opts.family ?? "0", 10);
    const keepAlive = opts.keepAlive ?? true;
    const normalized = {
      keepAliveMsecs: keepAlive ? 1000 : undefined,
      maxSockets: opts.maxSockets ?? 15,
      maxTotalSockets: Infinity,
      maxFreeSockets: keepAlive ? 256 : undefined,
      scheduling: "fifo",
      ...opts,
      family,
      keepAlive,
      timeouts: {
        idle: opts.timeout ?? 0,
        connection: 0,
        response: 0,
        transfer: 0,
        ...opts.timeouts
      },
      ...dns.getOptions({ family, ...opts.dns })
    };
    delete normalized.timeout;
    return normalized;
  };
  var createKey = (obj) => {
    let key = "";
    const sorted = Object.entries(obj).sort((a, b) => a[0] - b[0]);
    for (let [k, v] of sorted) {
      if (v == null) {
        v = "null";
      } else if (v instanceof URL) {
        v = v.toString();
      } else if (typeof v === "object") {
        v = createKey(v);
      }
      key += `${k}:${v}:`;
    }
    return key;
  };
  var cacheOptions = ({ secureEndpoint, ...options }) => createKey({
    secureEndpoint: !!secureEndpoint,
    family: options.family,
    hints: options.hints,
    localAddress: options.localAddress,
    strictSsl: secureEndpoint ? !!options.rejectUnauthorized : false,
    ca: secureEndpoint ? options.ca : null,
    cert: secureEndpoint ? options.cert : null,
    key: secureEndpoint ? options.key : null,
    keepAlive: options.keepAlive,
    keepAliveMsecs: options.keepAliveMsecs,
    maxSockets: options.maxSockets,
    maxTotalSockets: options.maxTotalSockets,
    maxFreeSockets: options.maxFreeSockets,
    scheduling: options.scheduling,
    timeouts: options.timeouts,
    proxy: options.proxy
  });
  module.exports = {
    normalizeOptions,
    cacheOptions
  };
});

// node_modules/smart-buffer/build/utils.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var buffer_1 = __require("buffer");
  var ERRORS = {
    INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
    INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
    INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
    INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
    INVALID_OFFSET: "An invalid offset value was provided.",
    INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
    INVALID_LENGTH: "An invalid length value was provided.",
    INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
    INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
    INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
    INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
    INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
  };
  exports.ERRORS = ERRORS;
  function checkEncoding(encoding) {
    if (!buffer_1.Buffer.isEncoding(encoding)) {
      throw new Error(ERRORS.INVALID_ENCODING);
    }
  }
  exports.checkEncoding = checkEncoding;
  function isFiniteInteger(value) {
    return typeof value === "number" && isFinite(value) && isInteger(value);
  }
  exports.isFiniteInteger = isFiniteInteger;
  function checkOffsetOrLengthValue(value, offset2) {
    if (typeof value === "number") {
      if (!isFiniteInteger(value) || value < 0) {
        throw new Error(offset2 ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
      }
    } else {
      throw new Error(offset2 ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
    }
  }
  function checkLengthValue(length) {
    checkOffsetOrLengthValue(length, false);
  }
  exports.checkLengthValue = checkLengthValue;
  function checkOffsetValue(offset2) {
    checkOffsetOrLengthValue(offset2, true);
  }
  exports.checkOffsetValue = checkOffsetValue;
  function checkTargetOffset(offset2, buff) {
    if (offset2 < 0 || offset2 > buff.length) {
      throw new Error(ERRORS.INVALID_TARGET_OFFSET);
    }
  }
  exports.checkTargetOffset = checkTargetOffset;
  function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  }
  function bigIntAndBufferInt64Check(bufferMethod) {
    if (typeof BigInt === "undefined") {
      throw new Error("Platform does not support JS BigInt type.");
    }
    if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
      throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
    }
  }
  exports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
});

// node_modules/smart-buffer/build/smartbuffer.js
var require_smartbuffer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_1 = require_utils2();
  var DEFAULT_SMARTBUFFER_SIZE = 4096;
  var DEFAULT_SMARTBUFFER_ENCODING = "utf8";

  class SmartBuffer {
    constructor(options) {
      this.length = 0;
      this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
      this._writeOffset = 0;
      this._readOffset = 0;
      if (SmartBuffer.isSmartBufferOptions(options)) {
        if (options.encoding) {
          utils_1.checkEncoding(options.encoding);
          this._encoding = options.encoding;
        }
        if (options.size) {
          if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
            this._buff = Buffer.allocUnsafe(options.size);
          } else {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
          }
        } else if (options.buff) {
          if (Buffer.isBuffer(options.buff)) {
            this._buff = options.buff;
            this.length = options.buff.length;
          } else {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
          }
        } else {
          this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
        }
      } else {
        if (typeof options !== "undefined") {
          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
        }
        this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
      }
    }
    static fromSize(size, encoding) {
      return new this({
        size,
        encoding
      });
    }
    static fromBuffer(buff, encoding) {
      return new this({
        buff,
        encoding
      });
    }
    static fromOptions(options) {
      return new this(options);
    }
    static isSmartBufferOptions(options) {
      const castOptions = options;
      return castOptions && (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined);
    }
    readInt8(offset2) {
      return this._readNumberValue(Buffer.prototype.readInt8, 1, offset2);
    }
    readInt16BE(offset2) {
      return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset2);
    }
    readInt16LE(offset2) {
      return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset2);
    }
    readInt32BE(offset2) {
      return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset2);
    }
    readInt32LE(offset2) {
      return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset2);
    }
    readBigInt64BE(offset2) {
      utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
      return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset2);
    }
    readBigInt64LE(offset2) {
      utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
      return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset2);
    }
    writeInt8(value, offset2) {
      this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset2);
      return this;
    }
    insertInt8(value, offset2) {
      return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset2);
    }
    writeInt16BE(value, offset2) {
      return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset2);
    }
    insertInt16BE(value, offset2) {
      return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset2);
    }
    writeInt16LE(value, offset2) {
      return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset2);
    }
    insertInt16LE(value, offset2) {
      return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset2);
    }
    writeInt32BE(value, offset2) {
      return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset2);
    }
    insertInt32BE(value, offset2) {
      return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset2);
    }
    writeInt32LE(value, offset2) {
      return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset2);
    }
    insertInt32LE(value, offset2) {
      return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset2);
    }
    writeBigInt64BE(value, offset2) {
      utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
      return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset2);
    }
    insertBigInt64BE(value, offset2) {
      utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
      return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset2);
    }
    writeBigInt64LE(value, offset2) {
      utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
      return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset2);
    }
    insertBigInt64LE(value, offset2) {
      utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
      return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset2);
    }
    readUInt8(offset2) {
      return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset2);
    }
    readUInt16BE(offset2) {
      return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset2);
    }
    readUInt16LE(offset2) {
      return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset2);
    }
    readUInt32BE(offset2) {
      return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset2);
    }
    readUInt32LE(offset2) {
      return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset2);
    }
    readBigUInt64BE(offset2) {
      utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
      return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset2);
    }
    readBigUInt64LE(offset2) {
      utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
      return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset2);
    }
    writeUInt8(value, offset2) {
      return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset2);
    }
    insertUInt8(value, offset2) {
      return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset2);
    }
    writeUInt16BE(value, offset2) {
      return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset2);
    }
    insertUInt16BE(value, offset2) {
      return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset2);
    }
    writeUInt16LE(value, offset2) {
      return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset2);
    }
    insertUInt16LE(value, offset2) {
      return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset2);
    }
    writeUInt32BE(value, offset2) {
      return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset2);
    }
    insertUInt32BE(value, offset2) {
      return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset2);
    }
    writeUInt32LE(value, offset2) {
      return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset2);
    }
    insertUInt32LE(value, offset2) {
      return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset2);
    }
    writeBigUInt64BE(value, offset2) {
      utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
      return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset2);
    }
    insertBigUInt64BE(value, offset2) {
      utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
      return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset2);
    }
    writeBigUInt64LE(value, offset2) {
      utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
      return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset2);
    }
    insertBigUInt64LE(value, offset2) {
      utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
      return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset2);
    }
    readFloatBE(offset2) {
      return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset2);
    }
    readFloatLE(offset2) {
      return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset2);
    }
    writeFloatBE(value, offset2) {
      return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset2);
    }
    insertFloatBE(value, offset2) {
      return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset2);
    }
    writeFloatLE(value, offset2) {
      return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset2);
    }
    insertFloatLE(value, offset2) {
      return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset2);
    }
    readDoubleBE(offset2) {
      return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset2);
    }
    readDoubleLE(offset2) {
      return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset2);
    }
    writeDoubleBE(value, offset2) {
      return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset2);
    }
    insertDoubleBE(value, offset2) {
      return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset2);
    }
    writeDoubleLE(value, offset2) {
      return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset2);
    }
    insertDoubleLE(value, offset2) {
      return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset2);
    }
    readString(arg1, encoding) {
      let lengthVal;
      if (typeof arg1 === "number") {
        utils_1.checkLengthValue(arg1);
        lengthVal = Math.min(arg1, this.length - this._readOffset);
      } else {
        encoding = arg1;
        lengthVal = this.length - this._readOffset;
      }
      if (typeof encoding !== "undefined") {
        utils_1.checkEncoding(encoding);
      }
      const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
      this._readOffset += lengthVal;
      return value;
    }
    insertString(value, offset2, encoding) {
      utils_1.checkOffsetValue(offset2);
      return this._handleString(value, true, offset2, encoding);
    }
    writeString(value, arg2, encoding) {
      return this._handleString(value, false, arg2, encoding);
    }
    readStringNT(encoding) {
      if (typeof encoding !== "undefined") {
        utils_1.checkEncoding(encoding);
      }
      let nullPos = this.length;
      for (let i = this._readOffset;i < this.length; i++) {
        if (this._buff[i] === 0) {
          nullPos = i;
          break;
        }
      }
      const value = this._buff.slice(this._readOffset, nullPos);
      this._readOffset = nullPos + 1;
      return value.toString(encoding || this._encoding);
    }
    insertStringNT(value, offset2, encoding) {
      utils_1.checkOffsetValue(offset2);
      this.insertString(value, offset2, encoding);
      this.insertUInt8(0, offset2 + value.length);
      return this;
    }
    writeStringNT(value, arg2, encoding) {
      this.writeString(value, arg2, encoding);
      this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
      return this;
    }
    readBuffer(length) {
      if (typeof length !== "undefined") {
        utils_1.checkLengthValue(length);
      }
      const lengthVal = typeof length === "number" ? length : this.length;
      const endPoint = Math.min(this.length, this._readOffset + lengthVal);
      const value = this._buff.slice(this._readOffset, endPoint);
      this._readOffset = endPoint;
      return value;
    }
    insertBuffer(value, offset2) {
      utils_1.checkOffsetValue(offset2);
      return this._handleBuffer(value, true, offset2);
    }
    writeBuffer(value, offset2) {
      return this._handleBuffer(value, false, offset2);
    }
    readBufferNT() {
      let nullPos = this.length;
      for (let i = this._readOffset;i < this.length; i++) {
        if (this._buff[i] === 0) {
          nullPos = i;
          break;
        }
      }
      const value = this._buff.slice(this._readOffset, nullPos);
      this._readOffset = nullPos + 1;
      return value;
    }
    insertBufferNT(value, offset2) {
      utils_1.checkOffsetValue(offset2);
      this.insertBuffer(value, offset2);
      this.insertUInt8(0, offset2 + value.length);
      return this;
    }
    writeBufferNT(value, offset2) {
      if (typeof offset2 !== "undefined") {
        utils_1.checkOffsetValue(offset2);
      }
      this.writeBuffer(value, offset2);
      this.writeUInt8(0, typeof offset2 === "number" ? offset2 + value.length : this._writeOffset);
      return this;
    }
    clear() {
      this._writeOffset = 0;
      this._readOffset = 0;
      this.length = 0;
      return this;
    }
    remaining() {
      return this.length - this._readOffset;
    }
    get readOffset() {
      return this._readOffset;
    }
    set readOffset(offset2) {
      utils_1.checkOffsetValue(offset2);
      utils_1.checkTargetOffset(offset2, this);
      this._readOffset = offset2;
    }
    get writeOffset() {
      return this._writeOffset;
    }
    set writeOffset(offset2) {
      utils_1.checkOffsetValue(offset2);
      utils_1.checkTargetOffset(offset2, this);
      this._writeOffset = offset2;
    }
    get encoding() {
      return this._encoding;
    }
    set encoding(encoding) {
      utils_1.checkEncoding(encoding);
      this._encoding = encoding;
    }
    get internalBuffer() {
      return this._buff;
    }
    toBuffer() {
      return this._buff.slice(0, this.length);
    }
    toString(encoding) {
      const encodingVal = typeof encoding === "string" ? encoding : this._encoding;
      utils_1.checkEncoding(encodingVal);
      return this._buff.toString(encodingVal, 0, this.length);
    }
    destroy() {
      this.clear();
      return this;
    }
    _handleString(value, isInsert, arg3, encoding) {
      let offsetVal = this._writeOffset;
      let encodingVal = this._encoding;
      if (typeof arg3 === "number") {
        offsetVal = arg3;
      } else if (typeof arg3 === "string") {
        utils_1.checkEncoding(arg3);
        encodingVal = arg3;
      }
      if (typeof encoding === "string") {
        utils_1.checkEncoding(encoding);
        encodingVal = encoding;
      }
      const byteLength = Buffer.byteLength(value, encodingVal);
      if (isInsert) {
        this.ensureInsertable(byteLength, offsetVal);
      } else {
        this._ensureWriteable(byteLength, offsetVal);
      }
      this._buff.write(value, offsetVal, byteLength, encodingVal);
      if (isInsert) {
        this._writeOffset += byteLength;
      } else {
        if (typeof arg3 === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
        } else {
          this._writeOffset += byteLength;
        }
      }
      return this;
    }
    _handleBuffer(value, isInsert, offset2) {
      const offsetVal = typeof offset2 === "number" ? offset2 : this._writeOffset;
      if (isInsert) {
        this.ensureInsertable(value.length, offsetVal);
      } else {
        this._ensureWriteable(value.length, offsetVal);
      }
      value.copy(this._buff, offsetVal);
      if (isInsert) {
        this._writeOffset += value.length;
      } else {
        if (typeof offset2 === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
        } else {
          this._writeOffset += value.length;
        }
      }
      return this;
    }
    ensureReadable(length, offset2) {
      let offsetVal = this._readOffset;
      if (typeof offset2 !== "undefined") {
        utils_1.checkOffsetValue(offset2);
        offsetVal = offset2;
      }
      if (offsetVal < 0 || offsetVal + length > this.length) {
        throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
      }
    }
    ensureInsertable(dataLength, offset2) {
      utils_1.checkOffsetValue(offset2);
      this._ensureCapacity(this.length + dataLength);
      if (offset2 < this.length) {
        this._buff.copy(this._buff, offset2 + dataLength, offset2, this._buff.length);
      }
      if (offset2 + dataLength > this.length) {
        this.length = offset2 + dataLength;
      } else {
        this.length += dataLength;
      }
    }
    _ensureWriteable(dataLength, offset2) {
      const offsetVal = typeof offset2 === "number" ? offset2 : this._writeOffset;
      this._ensureCapacity(offsetVal + dataLength);
      if (offsetVal + dataLength > this.length) {
        this.length = offsetVal + dataLength;
      }
    }
    _ensureCapacity(minLength) {
      const oldLength = this._buff.length;
      if (minLength > oldLength) {
        let data = this._buff;
        let newLength = oldLength * 3 / 2 + 1;
        if (newLength < minLength) {
          newLength = minLength;
        }
        this._buff = Buffer.allocUnsafe(newLength);
        data.copy(this._buff, 0, 0, oldLength);
      }
    }
    _readNumberValue(func, byteSize, offset2) {
      this.ensureReadable(byteSize, offset2);
      const value = func.call(this._buff, typeof offset2 === "number" ? offset2 : this._readOffset);
      if (typeof offset2 === "undefined") {
        this._readOffset += byteSize;
      }
      return value;
    }
    _insertNumberValue(func, byteSize, value, offset2) {
      utils_1.checkOffsetValue(offset2);
      this.ensureInsertable(byteSize, offset2);
      func.call(this._buff, value, offset2);
      this._writeOffset += byteSize;
      return this;
    }
    _writeNumberValue(func, byteSize, value, offset2) {
      if (typeof offset2 === "number") {
        if (offset2 < 0) {
          throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
        }
        utils_1.checkOffsetValue(offset2);
      }
      const offsetVal = typeof offset2 === "number" ? offset2 : this._writeOffset;
      this._ensureWriteable(byteSize, offsetVal);
      func.call(this._buff, value, offsetVal);
      if (typeof offset2 === "number") {
        this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
      } else {
        this._writeOffset += byteSize;
      }
      return this;
    }
  }
  exports.SmartBuffer = SmartBuffer;
});

// node_modules/socks/build/common/constants.js
var require_constants3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SOCKS5_NO_ACCEPTABLE_AUTH = exports.SOCKS5_CUSTOM_AUTH_END = exports.SOCKS5_CUSTOM_AUTH_START = exports.SOCKS_INCOMING_PACKET_SIZES = exports.SocksClientState = exports.Socks5Response = exports.Socks5HostType = exports.Socks5Auth = exports.Socks4Response = exports.SocksCommand = exports.ERRORS = exports.DEFAULT_TIMEOUT = undefined;
  var DEFAULT_TIMEOUT = 30000;
  exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
  var ERRORS = {
    InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
    InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
    InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
    InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
    InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
    InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
    InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
    InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
    InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
    InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
    NegotiationError: "Negotiation error",
    SocketClosed: "Socket closed",
    ProxyConnectionTimedOut: "Proxy connection timed out",
    InternalError: "SocksClient internal error (this should not happen)",
    InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
    Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
    InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
    Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
    InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
    InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
    InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
    InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
    Socks5AuthenticationFailed: "Socks5 Authentication failed",
    InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
    InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
    InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
    Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
  };
  exports.ERRORS = ERRORS;
  var SOCKS_INCOMING_PACKET_SIZES = {
    Socks5InitialHandshakeResponse: 2,
    Socks5UserPassAuthenticationResponse: 2,
    Socks5ResponseHeader: 5,
    Socks5ResponseIPv4: 10,
    Socks5ResponseIPv6: 22,
    Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
    Socks4Response: 8
  };
  exports.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
  var SocksCommand;
  (function(SocksCommand2) {
    SocksCommand2[SocksCommand2["connect"] = 1] = "connect";
    SocksCommand2[SocksCommand2["bind"] = 2] = "bind";
    SocksCommand2[SocksCommand2["associate"] = 3] = "associate";
  })(SocksCommand || (exports.SocksCommand = SocksCommand = {}));
  var Socks4Response;
  (function(Socks4Response2) {
    Socks4Response2[Socks4Response2["Granted"] = 90] = "Granted";
    Socks4Response2[Socks4Response2["Failed"] = 91] = "Failed";
    Socks4Response2[Socks4Response2["Rejected"] = 92] = "Rejected";
    Socks4Response2[Socks4Response2["RejectedIdent"] = 93] = "RejectedIdent";
  })(Socks4Response || (exports.Socks4Response = Socks4Response = {}));
  var Socks5Auth;
  (function(Socks5Auth2) {
    Socks5Auth2[Socks5Auth2["NoAuth"] = 0] = "NoAuth";
    Socks5Auth2[Socks5Auth2["GSSApi"] = 1] = "GSSApi";
    Socks5Auth2[Socks5Auth2["UserPass"] = 2] = "UserPass";
  })(Socks5Auth || (exports.Socks5Auth = Socks5Auth = {}));
  var SOCKS5_CUSTOM_AUTH_START = 128;
  exports.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
  var SOCKS5_CUSTOM_AUTH_END = 254;
  exports.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
  var SOCKS5_NO_ACCEPTABLE_AUTH = 255;
  exports.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
  var Socks5Response;
  (function(Socks5Response2) {
    Socks5Response2[Socks5Response2["Granted"] = 0] = "Granted";
    Socks5Response2[Socks5Response2["Failure"] = 1] = "Failure";
    Socks5Response2[Socks5Response2["NotAllowed"] = 2] = "NotAllowed";
    Socks5Response2[Socks5Response2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
    Socks5Response2[Socks5Response2["HostUnreachable"] = 4] = "HostUnreachable";
    Socks5Response2[Socks5Response2["ConnectionRefused"] = 5] = "ConnectionRefused";
    Socks5Response2[Socks5Response2["TTLExpired"] = 6] = "TTLExpired";
    Socks5Response2[Socks5Response2["CommandNotSupported"] = 7] = "CommandNotSupported";
    Socks5Response2[Socks5Response2["AddressNotSupported"] = 8] = "AddressNotSupported";
  })(Socks5Response || (exports.Socks5Response = Socks5Response = {}));
  var Socks5HostType;
  (function(Socks5HostType2) {
    Socks5HostType2[Socks5HostType2["IPv4"] = 1] = "IPv4";
    Socks5HostType2[Socks5HostType2["Hostname"] = 3] = "Hostname";
    Socks5HostType2[Socks5HostType2["IPv6"] = 4] = "IPv6";
  })(Socks5HostType || (exports.Socks5HostType = Socks5HostType = {}));
  var SocksClientState;
  (function(SocksClientState2) {
    SocksClientState2[SocksClientState2["Created"] = 0] = "Created";
    SocksClientState2[SocksClientState2["Connecting"] = 1] = "Connecting";
    SocksClientState2[SocksClientState2["Connected"] = 2] = "Connected";
    SocksClientState2[SocksClientState2["SentInitialHandshake"] = 3] = "SentInitialHandshake";
    SocksClientState2[SocksClientState2["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
    SocksClientState2[SocksClientState2["SentAuthentication"] = 5] = "SentAuthentication";
    SocksClientState2[SocksClientState2["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
    SocksClientState2[SocksClientState2["SentFinalHandshake"] = 7] = "SentFinalHandshake";
    SocksClientState2[SocksClientState2["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
    SocksClientState2[SocksClientState2["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
    SocksClientState2[SocksClientState2["Established"] = 10] = "Established";
    SocksClientState2[SocksClientState2["Disconnected"] = 11] = "Disconnected";
    SocksClientState2[SocksClientState2["Error"] = 99] = "Error";
  })(SocksClientState || (exports.SocksClientState = SocksClientState = {}));
});

// node_modules/socks/build/common/util.js
var require_util2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shuffleArray = exports.SocksClientError = undefined;

  class SocksClientError extends Error {
    constructor(message3, options) {
      super(message3);
      this.options = options;
    }
  }
  exports.SocksClientError = SocksClientError;
  function shuffleArray(array) {
    for (let i = array.length - 1;i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }
  exports.shuffleArray = shuffleArray;
});

// node_modules/socks/node_modules/ip-address/dist/common.js
var require_common4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isInSubnet = isInSubnet;
  exports.isCorrect = isCorrect;
  exports.numberToPaddedHex = numberToPaddedHex;
  exports.stringToPaddedHex = stringToPaddedHex;
  exports.testBit = testBit;
  function isInSubnet(address) {
    if (this.subnetMask < address.subnetMask) {
      return false;
    }
    if (this.mask(address.subnetMask) === address.mask()) {
      return true;
    }
    return false;
  }
  function isCorrect(defaultBits) {
    return function() {
      if (this.addressMinusSuffix !== this.correctForm()) {
        return false;
      }
      if (this.subnetMask === defaultBits && !this.parsedSubnet) {
        return true;
      }
      return this.parsedSubnet === String(this.subnetMask);
    };
  }
  function numberToPaddedHex(number) {
    return number.toString(16).padStart(2, "0");
  }
  function stringToPaddedHex(numberString) {
    return numberToPaddedHex(parseInt(numberString, 10));
  }
  function testBit(binaryValue, position) {
    const { length } = binaryValue;
    if (position > length) {
      return false;
    }
    const positionInString = length - position;
    return binaryValue.substring(positionInString, positionInString + 1) === "1";
  }
});

// node_modules/socks/node_modules/ip-address/dist/v4/constants.js
var require_constants4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RE_SUBNET_STRING = exports.RE_ADDRESS = exports.GROUPS = exports.BITS = undefined;
  exports.BITS = 32;
  exports.GROUPS = 4;
  exports.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
  exports.RE_SUBNET_STRING = /\/\d{1,2}$/;
});

// node_modules/socks/node_modules/ip-address/dist/address-error.js
var require_address_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AddressError = undefined;

  class AddressError extends Error {
    constructor(message3, parseMessage) {
      super(message3);
      this.name = "AddressError";
      this.parseMessage = parseMessage;
    }
  }
  exports.AddressError = AddressError;
});

// node_modules/socks/node_modules/ip-address/dist/ipv4.js
var require_ipv4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Address4 = undefined;
  var common = __importStar(require_common4());
  var constants = __importStar(require_constants4());
  var address_error_1 = require_address_error();

  class Address4 {
    constructor(address) {
      this.groups = constants.GROUPS;
      this.parsedAddress = [];
      this.parsedSubnet = "";
      this.subnet = "/32";
      this.subnetMask = 32;
      this.v4 = true;
      this.isCorrect = common.isCorrect(constants.BITS);
      this.isInSubnet = common.isInSubnet;
      this.address = address;
      const subnet = constants.RE_SUBNET_STRING.exec(address);
      if (subnet) {
        this.parsedSubnet = subnet[0].replace("/", "");
        this.subnetMask = parseInt(this.parsedSubnet, 10);
        this.subnet = `/${this.subnetMask}`;
        if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
          throw new address_error_1.AddressError("Invalid subnet mask.");
        }
        address = address.replace(constants.RE_SUBNET_STRING, "");
      }
      this.addressMinusSuffix = address;
      this.parsedAddress = this.parse(address);
    }
    static isValid(address) {
      try {
        new Address4(address);
        return true;
      } catch (e) {
        return false;
      }
    }
    parse(address) {
      const groups = address.split(".");
      if (!address.match(constants.RE_ADDRESS)) {
        throw new address_error_1.AddressError("Invalid IPv4 address.");
      }
      return groups;
    }
    correctForm() {
      return this.parsedAddress.map((part) => parseInt(part, 10)).join(".");
    }
    static fromHex(hex) {
      const padded = hex.replace(/:/g, "").padStart(8, "0");
      const groups = [];
      let i;
      for (i = 0;i < 8; i += 2) {
        const h = padded.slice(i, i + 2);
        groups.push(parseInt(h, 16));
      }
      return new Address4(groups.join("."));
    }
    static fromInteger(integer) {
      return Address4.fromHex(integer.toString(16));
    }
    static fromArpa(arpaFormAddress) {
      const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
      const address = leader.split(".").reverse().join(".");
      return new Address4(address);
    }
    toHex() {
      return this.parsedAddress.map((part) => common.stringToPaddedHex(part)).join(":");
    }
    toArray() {
      return this.parsedAddress.map((part) => parseInt(part, 10));
    }
    toGroup6() {
      const output = [];
      let i;
      for (i = 0;i < constants.GROUPS; i += 2) {
        output.push(`${common.stringToPaddedHex(this.parsedAddress[i])}${common.stringToPaddedHex(this.parsedAddress[i + 1])}`);
      }
      return output.join(":");
    }
    bigInt() {
      return BigInt(`0x${this.parsedAddress.map((n) => common.stringToPaddedHex(n)).join("")}`);
    }
    _startAddress() {
      return BigInt(`0b${this.mask() + "0".repeat(constants.BITS - this.subnetMask)}`);
    }
    startAddress() {
      return Address4.fromBigInt(this._startAddress());
    }
    startAddressExclusive() {
      const adjust = BigInt("1");
      return Address4.fromBigInt(this._startAddress() + adjust);
    }
    _endAddress() {
      return BigInt(`0b${this.mask() + "1".repeat(constants.BITS - this.subnetMask)}`);
    }
    endAddress() {
      return Address4.fromBigInt(this._endAddress());
    }
    endAddressExclusive() {
      const adjust = BigInt("1");
      return Address4.fromBigInt(this._endAddress() - adjust);
    }
    static fromBigInt(bigInt) {
      return Address4.fromHex(bigInt.toString(16));
    }
    static fromByteArray(bytes) {
      if (bytes.length !== 4) {
        throw new address_error_1.AddressError("IPv4 addresses require exactly 4 bytes");
      }
      for (let i = 0;i < bytes.length; i++) {
        if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {
          throw new address_error_1.AddressError("All bytes must be integers between 0 and 255");
        }
      }
      return this.fromUnsignedByteArray(bytes);
    }
    static fromUnsignedByteArray(bytes) {
      if (bytes.length !== 4) {
        throw new address_error_1.AddressError("IPv4 addresses require exactly 4 bytes");
      }
      const address = bytes.join(".");
      return new Address4(address);
    }
    mask(mask) {
      if (mask === undefined) {
        mask = this.subnetMask;
      }
      return this.getBitsBase2(0, mask);
    }
    getBitsBase2(start, end) {
      return this.binaryZeroPad().slice(start, end);
    }
    reverseForm(options) {
      if (!options) {
        options = {};
      }
      const reversed = this.correctForm().split(".").reverse().join(".");
      if (options.omitSuffix) {
        return reversed;
      }
      return `${reversed}.in-addr.arpa.`;
    }
    isMulticast() {
      return this.isInSubnet(new Address4("224.0.0.0/4"));
    }
    binaryZeroPad() {
      return this.bigInt().toString(2).padStart(constants.BITS, "0");
    }
    groupForV6() {
      const segments = this.parsedAddress;
      return this.address.replace(constants.RE_ADDRESS, `<span class="hover-group group-v4 group-6">${segments.slice(0, 2).join(".")}</span>.<span class="hover-group group-v4 group-7">${segments.slice(2, 4).join(".")}</span>`);
    }
  }
  exports.Address4 = Address4;
});

// node_modules/socks/node_modules/ip-address/dist/v6/constants.js
var require_constants5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RE_URL_WITH_PORT = exports.RE_URL = exports.RE_ZONE_STRING = exports.RE_SUBNET_STRING = exports.RE_BAD_ADDRESS = exports.RE_BAD_CHARACTERS = exports.TYPES = exports.SCOPES = exports.GROUPS = exports.BITS = undefined;
  exports.BITS = 128;
  exports.GROUPS = 8;
  exports.SCOPES = {
    0: "Reserved",
    1: "Interface local",
    2: "Link local",
    4: "Admin local",
    5: "Site local",
    8: "Organization local",
    14: "Global",
    15: "Reserved"
  };
  exports.TYPES = {
    "ff01::1/128": "Multicast (All nodes on this interface)",
    "ff01::2/128": "Multicast (All routers on this interface)",
    "ff02::1/128": "Multicast (All nodes on this link)",
    "ff02::2/128": "Multicast (All routers on this link)",
    "ff05::2/128": "Multicast (All routers in this site)",
    "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
    "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
    "ff02::9/128": "Multicast (RIP routers)",
    "ff02::a/128": "Multicast (EIGRP routers)",
    "ff02::d/128": "Multicast (PIM routers)",
    "ff02::16/128": "Multicast (MLDv2 reports)",
    "ff01::fb/128": "Multicast (mDNSv6)",
    "ff02::fb/128": "Multicast (mDNSv6)",
    "ff05::fb/128": "Multicast (mDNSv6)",
    "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
    "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
    "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
    "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
    "::/128": "Unspecified",
    "::1/128": "Loopback",
    "ff00::/8": "Multicast",
    "fe80::/10": "Link-local unicast"
  };
  exports.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
  exports.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
  exports.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
  exports.RE_ZONE_STRING = /%.*$/;
  exports.RE_URL = /^\[{0,1}([0-9a-f:]+)\]{0,1}/;
  exports.RE_URL_WITH_PORT = /\[([0-9a-f:]+)\]:([0-9]{1,5})/;
});

// node_modules/socks/node_modules/ip-address/dist/v6/helpers.js
var require_helpers3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.spanAllZeroes = spanAllZeroes;
  exports.spanAll = spanAll;
  exports.spanLeadingZeroes = spanLeadingZeroes;
  exports.simpleGroup = simpleGroup;
  function spanAllZeroes(s) {
    return s.replace(/(0+)/g, '<span class="zero">$1</span>');
  }
  function spanAll(s, offset2 = 0) {
    const letters = s.split("");
    return letters.map((n, i) => `<span class="digit value-${n} position-${i + offset2}">${spanAllZeroes(n)}</span>`).join("");
  }
  function spanLeadingZeroesSimple(group) {
    return group.replace(/^(0+)/, '<span class="zero">$1</span>');
  }
  function spanLeadingZeroes(address) {
    const groups = address.split(":");
    return groups.map((g) => spanLeadingZeroesSimple(g)).join(":");
  }
  function simpleGroup(addressString, offset2 = 0) {
    const groups = addressString.split(":");
    return groups.map((g, i) => {
      if (/group-v4/.test(g)) {
        return g;
      }
      return `<span class="hover-group group-${i + offset2}">${spanLeadingZeroesSimple(g)}</span>`;
    });
  }
});

// node_modules/socks/node_modules/ip-address/dist/v6/regular-expressions.js
var require_regular_expressions = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ADDRESS_BOUNDARY = undefined;
  exports.groupPossibilities = groupPossibilities;
  exports.padGroup = padGroup;
  exports.simpleRegularExpression = simpleRegularExpression;
  exports.possibleElisions = possibleElisions;
  var v6 = __importStar(require_constants5());
  function groupPossibilities(possibilities) {
    return `(${possibilities.join("|")})`;
  }
  function padGroup(group) {
    if (group.length < 4) {
      return `0{0,${4 - group.length}}${group}`;
    }
    return group;
  }
  exports.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
  function simpleRegularExpression(groups) {
    const zeroIndexes = [];
    groups.forEach((group, i) => {
      const groupInteger = parseInt(group, 16);
      if (groupInteger === 0) {
        zeroIndexes.push(i);
      }
    });
    const possibilities = zeroIndexes.map((zeroIndex) => groups.map((group, i) => {
      if (i === zeroIndex) {
        const elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
        return groupPossibilities([padGroup(group), elision]);
      }
      return padGroup(group);
    }).join(":"));
    possibilities.push(groups.map(padGroup).join(":"));
    return groupPossibilities(possibilities);
  }
  function possibleElisions(elidedGroups, moreLeft, moreRight) {
    const left = moreLeft ? "" : ":";
    const right = moreRight ? "" : ":";
    const possibilities = [];
    if (!moreLeft && !moreRight) {
      possibilities.push("::");
    }
    if (moreLeft && moreRight) {
      possibilities.push("");
    }
    if (moreRight && !moreLeft || !moreRight && moreLeft) {
      possibilities.push(":");
    }
    possibilities.push(`${left}(:0{1,4}){1,${elidedGroups - 1}}`);
    possibilities.push(`(0{1,4}:){1,${elidedGroups - 1}}${right}`);
    possibilities.push(`(0{1,4}:){${elidedGroups - 1}}0{1,4}`);
    for (let groups = 1;groups < elidedGroups - 1; groups++) {
      for (let position = 1;position < elidedGroups - groups; position++) {
        possibilities.push(`(0{1,4}:){${position}}:(0{1,4}:){${elidedGroups - position - groups - 1}}0{1,4}`);
      }
    }
    return groupPossibilities(possibilities);
  }
});

// node_modules/socks/node_modules/ip-address/dist/ipv6.js
var require_ipv6 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Address6 = undefined;
  var common = __importStar(require_common4());
  var constants4 = __importStar(require_constants4());
  var constants6 = __importStar(require_constants5());
  var helpers = __importStar(require_helpers3());
  var ipv4_1 = require_ipv4();
  var regular_expressions_1 = require_regular_expressions();
  var address_error_1 = require_address_error();
  var common_1 = require_common4();
  function assert(condition) {
    if (!condition) {
      throw new Error("Assertion failed.");
    }
  }
  function addCommas(number) {
    const r = /(\d+)(\d{3})/;
    while (r.test(number)) {
      number = number.replace(r, "$1,$2");
    }
    return number;
  }
  function spanLeadingZeroes4(n) {
    n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
    n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
    return n;
  }
  function compact(address, slice) {
    const s1 = [];
    const s2 = [];
    let i;
    for (i = 0;i < address.length; i++) {
      if (i < slice[0]) {
        s1.push(address[i]);
      } else if (i > slice[1]) {
        s2.push(address[i]);
      }
    }
    return s1.concat(["compact"]).concat(s2);
  }
  function paddedHex(octet) {
    return parseInt(octet, 16).toString(16).padStart(4, "0");
  }
  function unsignByte(b) {
    return b & 255;
  }

  class Address6 {
    constructor(address, optionalGroups) {
      this.addressMinusSuffix = "";
      this.parsedSubnet = "";
      this.subnet = "/128";
      this.subnetMask = 128;
      this.v4 = false;
      this.zone = "";
      this.isInSubnet = common.isInSubnet;
      this.isCorrect = common.isCorrect(constants6.BITS);
      if (optionalGroups === undefined) {
        this.groups = constants6.GROUPS;
      } else {
        this.groups = optionalGroups;
      }
      this.address = address;
      const subnet = constants6.RE_SUBNET_STRING.exec(address);
      if (subnet) {
        this.parsedSubnet = subnet[0].replace("/", "");
        this.subnetMask = parseInt(this.parsedSubnet, 10);
        this.subnet = `/${this.subnetMask}`;
        if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
          throw new address_error_1.AddressError("Invalid subnet mask.");
        }
        address = address.replace(constants6.RE_SUBNET_STRING, "");
      } else if (/\//.test(address)) {
        throw new address_error_1.AddressError("Invalid subnet mask.");
      }
      const zone = constants6.RE_ZONE_STRING.exec(address);
      if (zone) {
        this.zone = zone[0];
        address = address.replace(constants6.RE_ZONE_STRING, "");
      }
      this.addressMinusSuffix = address;
      this.parsedAddress = this.parse(this.addressMinusSuffix);
    }
    static isValid(address) {
      try {
        new Address6(address);
        return true;
      } catch (e) {
        return false;
      }
    }
    static fromBigInt(bigInt) {
      const hex = bigInt.toString(16).padStart(32, "0");
      const groups = [];
      let i;
      for (i = 0;i < constants6.GROUPS; i++) {
        groups.push(hex.slice(i * 4, (i + 1) * 4));
      }
      return new Address6(groups.join(":"));
    }
    static fromURL(url) {
      let host;
      let port = null;
      let result;
      if (url.indexOf("[") !== -1 && url.indexOf("]:") !== -1) {
        result = constants6.RE_URL_WITH_PORT.exec(url);
        if (result === null) {
          return {
            error: "failed to parse address with port",
            address: null,
            port: null
          };
        }
        host = result[1];
        port = result[2];
      } else if (url.indexOf("/") !== -1) {
        url = url.replace(/^[a-z0-9]+:\/\//, "");
        result = constants6.RE_URL.exec(url);
        if (result === null) {
          return {
            error: "failed to parse address from URL",
            address: null,
            port: null
          };
        }
        host = result[1];
      } else {
        host = url;
      }
      if (port) {
        port = parseInt(port, 10);
        if (port < 0 || port > 65536) {
          port = null;
        }
      } else {
        port = null;
      }
      return {
        address: new Address6(host),
        port
      };
    }
    static fromAddress4(address) {
      const address4 = new ipv4_1.Address4(address);
      const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
      return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);
    }
    static fromArpa(arpaFormAddress) {
      let address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
      const semicolonAmount = 7;
      if (address.length !== 63) {
        throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
      }
      const parts = address.split(".").reverse();
      for (let i = semicolonAmount;i > 0; i--) {
        const insertIndex = i * 4;
        parts.splice(insertIndex, 0, ":");
      }
      address = parts.join("");
      return new Address6(address);
    }
    microsoftTranscription() {
      return `${this.correctForm().replace(/:/g, "-")}.ipv6-literal.net`;
    }
    mask(mask = this.subnetMask) {
      return this.getBitsBase2(0, mask);
    }
    possibleSubnets(subnetSize = 128) {
      const availableBits = constants6.BITS - this.subnetMask;
      const subnetBits = Math.abs(subnetSize - constants6.BITS);
      const subnetPowers = availableBits - subnetBits;
      if (subnetPowers < 0) {
        return "0";
      }
      return addCommas((BigInt("2") ** BigInt(subnetPowers)).toString(10));
    }
    _startAddress() {
      return BigInt(`0b${this.mask() + "0".repeat(constants6.BITS - this.subnetMask)}`);
    }
    startAddress() {
      return Address6.fromBigInt(this._startAddress());
    }
    startAddressExclusive() {
      const adjust = BigInt("1");
      return Address6.fromBigInt(this._startAddress() + adjust);
    }
    _endAddress() {
      return BigInt(`0b${this.mask() + "1".repeat(constants6.BITS - this.subnetMask)}`);
    }
    endAddress() {
      return Address6.fromBigInt(this._endAddress());
    }
    endAddressExclusive() {
      const adjust = BigInt("1");
      return Address6.fromBigInt(this._endAddress() - adjust);
    }
    getScope() {
      let scope = constants6.SCOPES[parseInt(this.getBits(12, 16).toString(10), 10)];
      if (this.getType() === "Global unicast" && scope !== "Link local") {
        scope = "Global";
      }
      return scope || "Unknown";
    }
    getType() {
      for (const subnet of Object.keys(constants6.TYPES)) {
        if (this.isInSubnet(new Address6(subnet))) {
          return constants6.TYPES[subnet];
        }
      }
      return "Global unicast";
    }
    getBits(start, end) {
      return BigInt(`0b${this.getBitsBase2(start, end)}`);
    }
    getBitsBase2(start, end) {
      return this.binaryZeroPad().slice(start, end);
    }
    getBitsBase16(start, end) {
      const length = end - start;
      if (length % 4 !== 0) {
        throw new Error("Length of bits to retrieve must be divisible by four");
      }
      return this.getBits(start, end).toString(16).padStart(length / 4, "0");
    }
    getBitsPastSubnet() {
      return this.getBitsBase2(this.subnetMask, constants6.BITS);
    }
    reverseForm(options) {
      if (!options) {
        options = {};
      }
      const characters = Math.floor(this.subnetMask / 4);
      const reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
      if (characters > 0) {
        if (options.omitSuffix) {
          return reversed;
        }
        return `${reversed}.ip6.arpa.`;
      }
      if (options.omitSuffix) {
        return "";
      }
      return "ip6.arpa.";
    }
    correctForm() {
      let i;
      let groups = [];
      let zeroCounter = 0;
      const zeroes = [];
      for (i = 0;i < this.parsedAddress.length; i++) {
        const value = parseInt(this.parsedAddress[i], 16);
        if (value === 0) {
          zeroCounter++;
        }
        if (value !== 0 && zeroCounter > 0) {
          if (zeroCounter > 1) {
            zeroes.push([i - zeroCounter, i - 1]);
          }
          zeroCounter = 0;
        }
      }
      if (zeroCounter > 1) {
        zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
      }
      const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);
      if (zeroes.length > 0) {
        const index = zeroLengths.indexOf(Math.max(...zeroLengths));
        groups = compact(this.parsedAddress, zeroes[index]);
      } else {
        groups = this.parsedAddress;
      }
      for (i = 0;i < groups.length; i++) {
        if (groups[i] !== "compact") {
          groups[i] = parseInt(groups[i], 16).toString(16);
        }
      }
      let correct = groups.join(":");
      correct = correct.replace(/^compact$/, "::");
      correct = correct.replace(/(^compact)|(compact$)/, ":");
      correct = correct.replace(/compact/, "");
      return correct;
    }
    binaryZeroPad() {
      return this.bigInt().toString(2).padStart(constants6.BITS, "0");
    }
    parse4in6(address) {
      const groups = address.split(":");
      const lastGroup = groups.slice(-1)[0];
      const address4 = lastGroup.match(constants4.RE_ADDRESS);
      if (address4) {
        this.parsedAddress4 = address4[0];
        this.address4 = new ipv4_1.Address4(this.parsedAddress4);
        for (let i = 0;i < this.address4.groups; i++) {
          if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
            throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join(".")));
          }
        }
        this.v4 = true;
        groups[groups.length - 1] = this.address4.toGroup6();
        address = groups.join(":");
      }
      return address;
    }
    parse(address) {
      address = this.parse4in6(address);
      const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
      if (badCharacters) {
        throw new address_error_1.AddressError(`Bad character${badCharacters.length > 1 ? "s" : ""} detected in address: ${badCharacters.join("")}`, address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
      }
      const badAddress = address.match(constants6.RE_BAD_ADDRESS);
      if (badAddress) {
        throw new address_error_1.AddressError(`Address failed regex: ${badAddress.join("")}`, address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
      }
      let groups = [];
      const halves = address.split("::");
      if (halves.length === 2) {
        let first = halves[0].split(":");
        let last = halves[1].split(":");
        if (first.length === 1 && first[0] === "") {
          first = [];
        }
        if (last.length === 1 && last[0] === "") {
          last = [];
        }
        const remaining = this.groups - (first.length + last.length);
        if (!remaining) {
          throw new address_error_1.AddressError("Error parsing groups");
        }
        this.elidedGroups = remaining;
        this.elisionBegin = first.length;
        this.elisionEnd = first.length + this.elidedGroups;
        groups = groups.concat(first);
        for (let i = 0;i < remaining; i++) {
          groups.push("0");
        }
        groups = groups.concat(last);
      } else if (halves.length === 1) {
        groups = address.split(":");
        this.elidedGroups = 0;
      } else {
        throw new address_error_1.AddressError("Too many :: groups found");
      }
      groups = groups.map((group) => parseInt(group, 16).toString(16));
      if (groups.length !== this.groups) {
        throw new address_error_1.AddressError("Incorrect number of groups found");
      }
      return groups;
    }
    canonicalForm() {
      return this.parsedAddress.map(paddedHex).join(":");
    }
    decimal() {
      return this.parsedAddress.map((n) => parseInt(n, 16).toString(10).padStart(5, "0")).join(":");
    }
    bigInt() {
      return BigInt(`0x${this.parsedAddress.map(paddedHex).join("")}`);
    }
    to4() {
      const binary = this.binaryZeroPad().split("");
      return ipv4_1.Address4.fromHex(BigInt(`0b${binary.slice(96, 128).join("")}`).toString(16));
    }
    to4in6() {
      const address4 = this.to4();
      const address6 = new Address6(this.parsedAddress.slice(0, 6).join(":"), 6);
      const correct = address6.correctForm();
      let infix = "";
      if (!/:$/.test(correct)) {
        infix = ":";
      }
      return correct + infix + address4.address;
    }
    inspectTeredo() {
      const prefix = this.getBitsBase16(0, 32);
      const bitsForUdpPort = this.getBits(80, 96);
      const udpPort = (bitsForUdpPort ^ BigInt("0xffff")).toString();
      const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
      const bitsForClient4 = this.getBits(96, 128);
      const client4 = ipv4_1.Address4.fromHex((bitsForClient4 ^ BigInt("0xffffffff")).toString(16));
      const flagsBase2 = this.getBitsBase2(64, 80);
      const coneNat = (0, common_1.testBit)(flagsBase2, 15);
      const reserved = (0, common_1.testBit)(flagsBase2, 14);
      const groupIndividual = (0, common_1.testBit)(flagsBase2, 8);
      const universalLocal = (0, common_1.testBit)(flagsBase2, 9);
      const nonce = BigInt(`0b${flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16)}`).toString(10);
      return {
        prefix: `${prefix.slice(0, 4)}:${prefix.slice(4, 8)}`,
        server4: server4.address,
        client4: client4.address,
        flags: flagsBase2,
        coneNat,
        microsoft: {
          reserved,
          universalLocal,
          groupIndividual,
          nonce
        },
        udpPort
      };
    }
    inspect6to4() {
      const prefix = this.getBitsBase16(0, 16);
      const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
      return {
        prefix: prefix.slice(0, 4),
        gateway: gateway.address
      };
    }
    to6to4() {
      if (!this.is4()) {
        return null;
      }
      const addr6to4 = [
        "2002",
        this.getBitsBase16(96, 112),
        this.getBitsBase16(112, 128),
        "",
        "/16"
      ].join(":");
      return new Address6(addr6to4);
    }
    toByteArray() {
      const valueWithoutPadding = this.bigInt().toString(16);
      const leadingPad = "0".repeat(valueWithoutPadding.length % 2);
      const value = `${leadingPad}${valueWithoutPadding}`;
      const bytes = [];
      for (let i = 0, length = value.length;i < length; i += 2) {
        bytes.push(parseInt(value.substring(i, i + 2), 16));
      }
      return bytes;
    }
    toUnsignedByteArray() {
      return this.toByteArray().map(unsignByte);
    }
    static fromByteArray(bytes) {
      return this.fromUnsignedByteArray(bytes.map(unsignByte));
    }
    static fromUnsignedByteArray(bytes) {
      const BYTE_MAX = BigInt("256");
      let result = BigInt("0");
      let multiplier = BigInt("1");
      for (let i = bytes.length - 1;i >= 0; i--) {
        result += multiplier * BigInt(bytes[i].toString(10));
        multiplier *= BYTE_MAX;
      }
      return Address6.fromBigInt(result);
    }
    isCanonical() {
      return this.addressMinusSuffix === this.canonicalForm();
    }
    isLinkLocal() {
      if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
        return true;
      }
      return false;
    }
    isMulticast() {
      return this.getType() === "Multicast";
    }
    is4() {
      return this.v4;
    }
    isTeredo() {
      return this.isInSubnet(new Address6("2001::/32"));
    }
    is6to4() {
      return this.isInSubnet(new Address6("2002::/16"));
    }
    isLoopback() {
      return this.getType() === "Loopback";
    }
    href(optionalPort) {
      if (optionalPort === undefined) {
        optionalPort = "";
      } else {
        optionalPort = `:${optionalPort}`;
      }
      return `http://[${this.correctForm()}]${optionalPort}/`;
    }
    link(options) {
      if (!options) {
        options = {};
      }
      if (options.className === undefined) {
        options.className = "";
      }
      if (options.prefix === undefined) {
        options.prefix = "/#address=";
      }
      if (options.v4 === undefined) {
        options.v4 = false;
      }
      let formFunction = this.correctForm;
      if (options.v4) {
        formFunction = this.to4in6;
      }
      const form = formFunction.call(this);
      if (options.className) {
        return `<a href="${options.prefix}${form}" class="${options.className}">${form}</a>`;
      }
      return `<a href="${options.prefix}${form}">${form}</a>`;
    }
    group() {
      if (this.elidedGroups === 0) {
        return helpers.simpleGroup(this.address).join(":");
      }
      assert(typeof this.elidedGroups === "number");
      assert(typeof this.elisionBegin === "number");
      const output = [];
      const [left, right] = this.address.split("::");
      if (left.length) {
        output.push(...helpers.simpleGroup(left));
      } else {
        output.push("");
      }
      const classes = ["hover-group"];
      for (let i = this.elisionBegin;i < this.elisionBegin + this.elidedGroups; i++) {
        classes.push(`group-${i}`);
      }
      output.push(`<span class="${classes.join(" ")}"></span>`);
      if (right.length) {
        output.push(...helpers.simpleGroup(right, this.elisionEnd));
      } else {
        output.push("");
      }
      if (this.is4()) {
        assert(this.address4 instanceof ipv4_1.Address4);
        output.pop();
        output.push(this.address4.groupForV6());
      }
      return output.join(":");
    }
    regularExpressionString(substringSearch = false) {
      let output = [];
      const address6 = new Address6(this.correctForm());
      if (address6.elidedGroups === 0) {
        output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));
      } else if (address6.elidedGroups === constants6.GROUPS) {
        output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));
      } else {
        const halves = address6.address.split("::");
        if (halves[0].length) {
          output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(":")));
        }
        assert(typeof address6.elidedGroups === "number");
        output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
        if (halves[1].length) {
          output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(":")));
        }
        output = [output.join(":")];
      }
      if (!substringSearch) {
        output = [
          "(?=^|",
          regular_expressions_1.ADDRESS_BOUNDARY,
          "|[^\\w\\:])(",
          ...output,
          ")(?=[^\\w\\:]|",
          regular_expressions_1.ADDRESS_BOUNDARY,
          "|$)"
        ];
      }
      return output.join("");
    }
    regularExpression(substringSearch = false) {
      return new RegExp(this.regularExpressionString(substringSearch), "i");
    }
  }
  exports.Address6 = Address6;
});

// node_modules/socks/node_modules/ip-address/dist/ip-address.js
var require_ip_address = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.v6 = exports.AddressError = exports.Address6 = exports.Address4 = undefined;
  var ipv4_1 = require_ipv4();
  Object.defineProperty(exports, "Address4", { enumerable: true, get: function() {
    return ipv4_1.Address4;
  } });
  var ipv6_1 = require_ipv6();
  Object.defineProperty(exports, "Address6", { enumerable: true, get: function() {
    return ipv6_1.Address6;
  } });
  var address_error_1 = require_address_error();
  Object.defineProperty(exports, "AddressError", { enumerable: true, get: function() {
    return address_error_1.AddressError;
  } });
  var helpers = __importStar(require_helpers3());
  exports.v6 = { helpers };
});

// node_modules/socks/build/common/helpers.js
var require_helpers4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ipToBuffer = exports.int32ToIpv4 = exports.ipv4ToInt32 = exports.validateSocksClientChainOptions = exports.validateSocksClientOptions = undefined;
  var util_1 = require_util2();
  var constants_1 = require_constants3();
  var stream3 = __require("stream");
  var ip_address_1 = require_ip_address();
  var net = __require("net");
  function validateSocksClientOptions(options, acceptedCommands = ["connect", "bind", "associate"]) {
    if (!constants_1.SocksCommand[options.command]) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);
    }
    if (acceptedCommands.indexOf(options.command) === -1) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);
    }
    if (!isValidSocksRemoteHost(options.destination)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
    }
    if (!isValidSocksProxy(options.proxy)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
    }
    validateCustomProxyAuth(options.proxy, options);
    if (options.timeout && !isValidTimeoutValue(options.timeout)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
    }
    if (options.existing_socket && !(options.existing_socket instanceof stream3.Duplex)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);
    }
  }
  exports.validateSocksClientOptions = validateSocksClientOptions;
  function validateSocksClientChainOptions(options) {
    if (options.command !== "connect") {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);
    }
    if (!isValidSocksRemoteHost(options.destination)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
    }
    if (!(options.proxies && Array.isArray(options.proxies) && options.proxies.length >= 2)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);
    }
    options.proxies.forEach((proxy) => {
      if (!isValidSocksProxy(proxy)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
      }
      validateCustomProxyAuth(proxy, options);
    });
    if (options.timeout && !isValidTimeoutValue(options.timeout)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
    }
  }
  exports.validateSocksClientChainOptions = validateSocksClientChainOptions;
  function validateCustomProxyAuth(proxy, options) {
    if (proxy.custom_auth_method !== undefined) {
      if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);
      }
      if (proxy.custom_auth_request_handler === undefined || typeof proxy.custom_auth_request_handler !== "function") {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
      }
      if (proxy.custom_auth_response_size === undefined) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
      }
      if (proxy.custom_auth_response_handler === undefined || typeof proxy.custom_auth_response_handler !== "function") {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
      }
    }
  }
  function isValidSocksRemoteHost(remoteHost) {
    return remoteHost && typeof remoteHost.host === "string" && Buffer.byteLength(remoteHost.host) < 256 && typeof remoteHost.port === "number" && remoteHost.port >= 0 && remoteHost.port <= 65535;
  }
  function isValidSocksProxy(proxy) {
    return proxy && (typeof proxy.host === "string" || typeof proxy.ipaddress === "string") && typeof proxy.port === "number" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);
  }
  function isValidTimeoutValue(value) {
    return typeof value === "number" && value > 0;
  }
  function ipv4ToInt32(ip) {
    const address = new ip_address_1.Address4(ip);
    return address.toArray().reduce((acc, part) => (acc << 8) + part, 0) >>> 0;
  }
  exports.ipv4ToInt32 = ipv4ToInt32;
  function int32ToIpv4(int32) {
    const octet1 = int32 >>> 24 & 255;
    const octet2 = int32 >>> 16 & 255;
    const octet3 = int32 >>> 8 & 255;
    const octet4 = int32 & 255;
    return [octet1, octet2, octet3, octet4].join(".");
  }
  exports.int32ToIpv4 = int32ToIpv4;
  function ipToBuffer(ip) {
    if (net.isIPv4(ip)) {
      const address = new ip_address_1.Address4(ip);
      return Buffer.from(address.toArray());
    } else if (net.isIPv6(ip)) {
      const address = new ip_address_1.Address6(ip);
      return Buffer.from(address.canonicalForm().split(":").map((segment) => segment.padStart(4, "0")).join(""), "hex");
    } else {
      throw new Error("Invalid IP address format");
    }
  }
  exports.ipToBuffer = ipToBuffer;
});

// node_modules/socks/build/common/receivebuffer.js
var require_receivebuffer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReceiveBuffer = undefined;

  class ReceiveBuffer {
    constructor(size = 4096) {
      this.buffer = Buffer.allocUnsafe(size);
      this.offset = 0;
      this.originalSize = size;
    }
    get length() {
      return this.offset;
    }
    append(data) {
      if (!Buffer.isBuffer(data)) {
        throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
      }
      if (this.offset + data.length >= this.buffer.length) {
        const tmp = this.buffer;
        this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));
        tmp.copy(this.buffer);
      }
      data.copy(this.buffer, this.offset);
      return this.offset += data.length;
    }
    peek(length) {
      if (length > this.offset) {
        throw new Error("Attempted to read beyond the bounds of the managed internal data.");
      }
      return this.buffer.slice(0, length);
    }
    get(length) {
      if (length > this.offset) {
        throw new Error("Attempted to read beyond the bounds of the managed internal data.");
      }
      const value = Buffer.allocUnsafe(length);
      this.buffer.slice(0, length).copy(value);
      this.buffer.copyWithin(0, length, length + this.offset - length);
      this.offset -= length;
      return value;
    }
  }
  exports.ReceiveBuffer = ReceiveBuffer;
});

// node_modules/socks/build/client/socksclient.js
var require_socksclient = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SocksClientError = exports.SocksClient = undefined;
  var events_1 = __require("events");
  var net = __require("net");
  var smart_buffer_1 = require_smartbuffer();
  var constants_1 = require_constants3();
  var helpers_1 = require_helpers4();
  var receivebuffer_1 = require_receivebuffer();
  var util_1 = require_util2();
  Object.defineProperty(exports, "SocksClientError", { enumerable: true, get: function() {
    return util_1.SocksClientError;
  } });
  var ip_address_1 = require_ip_address();

  class SocksClient extends events_1.EventEmitter {
    constructor(options) {
      super();
      this.options = Object.assign({}, options);
      (0, helpers_1.validateSocksClientOptions)(options);
      this.setState(constants_1.SocksClientState.Created);
    }
    static createConnection(options, callback) {
      return new Promise((resolve, reject) => {
        try {
          (0, helpers_1.validateSocksClientOptions)(options, ["connect"]);
        } catch (err) {
          if (typeof callback === "function") {
            callback(err);
            return resolve(err);
          } else {
            return reject(err);
          }
        }
        const client3 = new SocksClient(options);
        client3.connect(options.existing_socket);
        client3.once("established", (info) => {
          client3.removeAllListeners();
          if (typeof callback === "function") {
            callback(null, info);
            resolve(info);
          } else {
            resolve(info);
          }
        });
        client3.once("error", (err) => {
          client3.removeAllListeners();
          if (typeof callback === "function") {
            callback(err);
            resolve(err);
          } else {
            reject(err);
          }
        });
      });
    }
    static createConnectionChain(options, callback) {
      return new Promise((resolve, reject) => __awaiter(this, undefined, undefined, function* () {
        try {
          (0, helpers_1.validateSocksClientChainOptions)(options);
        } catch (err) {
          if (typeof callback === "function") {
            callback(err);
            return resolve(err);
          } else {
            return reject(err);
          }
        }
        if (options.randomizeChain) {
          (0, util_1.shuffleArray)(options.proxies);
        }
        try {
          let sock;
          for (let i = 0;i < options.proxies.length; i++) {
            const nextProxy = options.proxies[i];
            const nextDestination = i === options.proxies.length - 1 ? options.destination : {
              host: options.proxies[i + 1].host || options.proxies[i + 1].ipaddress,
              port: options.proxies[i + 1].port
            };
            const result = yield SocksClient.createConnection({
              command: "connect",
              proxy: nextProxy,
              destination: nextDestination,
              existing_socket: sock
            });
            sock = sock || result.socket;
          }
          if (typeof callback === "function") {
            callback(null, { socket: sock });
            resolve({ socket: sock });
          } else {
            resolve({ socket: sock });
          }
        } catch (err) {
          if (typeof callback === "function") {
            callback(err);
            resolve(err);
          } else {
            reject(err);
          }
        }
      }));
    }
    static createUDPFrame(options) {
      const buff = new smart_buffer_1.SmartBuffer;
      buff.writeUInt16BE(0);
      buff.writeUInt8(options.frameNumber || 0);
      if (net.isIPv4(options.remoteHost.host)) {
        buff.writeUInt8(constants_1.Socks5HostType.IPv4);
        buff.writeUInt32BE((0, helpers_1.ipv4ToInt32)(options.remoteHost.host));
      } else if (net.isIPv6(options.remoteHost.host)) {
        buff.writeUInt8(constants_1.Socks5HostType.IPv6);
        buff.writeBuffer((0, helpers_1.ipToBuffer)(options.remoteHost.host));
      } else {
        buff.writeUInt8(constants_1.Socks5HostType.Hostname);
        buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
        buff.writeString(options.remoteHost.host);
      }
      buff.writeUInt16BE(options.remoteHost.port);
      buff.writeBuffer(options.data);
      return buff.toBuffer();
    }
    static parseUDPFrame(data) {
      const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
      buff.readOffset = 2;
      const frameNumber = buff.readUInt8();
      const hostType = buff.readUInt8();
      let remoteHost;
      if (hostType === constants_1.Socks5HostType.IPv4) {
        remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());
      } else if (hostType === constants_1.Socks5HostType.IPv6) {
        remoteHost = ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm();
      } else {
        remoteHost = buff.readString(buff.readUInt8());
      }
      const remotePort = buff.readUInt16BE();
      return {
        frameNumber,
        remoteHost: {
          host: remoteHost,
          port: remotePort
        },
        data: buff.readBuffer()
      };
    }
    setState(newState) {
      if (this.state !== constants_1.SocksClientState.Error) {
        this.state = newState;
      }
    }
    connect(existingSocket) {
      this.onDataReceived = (data) => this.onDataReceivedHandler(data);
      this.onClose = () => this.onCloseHandler();
      this.onError = (err) => this.onErrorHandler(err);
      this.onConnect = () => this.onConnectHandler();
      const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);
      if (timer.unref && typeof timer.unref === "function") {
        timer.unref();
      }
      if (existingSocket) {
        this.socket = existingSocket;
      } else {
        this.socket = new net.Socket;
      }
      this.socket.once("close", this.onClose);
      this.socket.once("error", this.onError);
      this.socket.once("connect", this.onConnect);
      this.socket.on("data", this.onDataReceived);
      this.setState(constants_1.SocksClientState.Connecting);
      this.receiveBuffer = new receivebuffer_1.ReceiveBuffer;
      if (existingSocket) {
        this.socket.emit("connect");
      } else {
        this.socket.connect(this.getSocketOptions());
        if (this.options.set_tcp_nodelay !== undefined && this.options.set_tcp_nodelay !== null) {
          this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
        }
      }
      this.prependOnceListener("established", (info) => {
        setImmediate(() => {
          if (this.receiveBuffer.length > 0) {
            const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
            info.socket.emit("data", excessData);
          }
          info.socket.resume();
        });
      });
    }
    getSocketOptions() {
      return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
    }
    onEstablishedTimeout() {
      if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {
        this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
      }
    }
    onConnectHandler() {
      this.setState(constants_1.SocksClientState.Connected);
      if (this.options.proxy.type === 4) {
        this.sendSocks4InitialHandshake();
      } else {
        this.sendSocks5InitialHandshake();
      }
      this.setState(constants_1.SocksClientState.SentInitialHandshake);
    }
    onDataReceivedHandler(data) {
      this.receiveBuffer.append(data);
      this.processData();
    }
    processData() {
      while (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
        if (this.state === constants_1.SocksClientState.SentInitialHandshake) {
          if (this.options.proxy.type === 4) {
            this.handleSocks4FinalHandshakeResponse();
          } else {
            this.handleInitialSocks5HandshakeResponse();
          }
        } else if (this.state === constants_1.SocksClientState.SentAuthentication) {
          this.handleInitialSocks5AuthenticationHandshakeResponse();
        } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {
          this.handleSocks5FinalHandshakeResponse();
        } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {
          if (this.options.proxy.type === 4) {
            this.handleSocks4IncomingConnectionResponse();
          } else {
            this.handleSocks5IncomingConnectionResponse();
          }
        } else {
          this.closeSocket(constants_1.ERRORS.InternalError);
          break;
        }
      }
    }
    onCloseHandler() {
      this.closeSocket(constants_1.ERRORS.SocketClosed);
    }
    onErrorHandler(err) {
      this.closeSocket(err.message);
    }
    removeInternalSocketHandlers() {
      this.socket.pause();
      this.socket.removeListener("data", this.onDataReceived);
      this.socket.removeListener("close", this.onClose);
      this.socket.removeListener("error", this.onError);
      this.socket.removeListener("connect", this.onConnect);
    }
    closeSocket(err) {
      if (this.state !== constants_1.SocksClientState.Error) {
        this.setState(constants_1.SocksClientState.Error);
        this.socket.destroy();
        this.removeInternalSocketHandlers();
        this.emit("error", new util_1.SocksClientError(err, this.options));
      }
    }
    sendSocks4InitialHandshake() {
      const userId = this.options.proxy.userId || "";
      const buff = new smart_buffer_1.SmartBuffer;
      buff.writeUInt8(4);
      buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
      buff.writeUInt16BE(this.options.destination.port);
      if (net.isIPv4(this.options.destination.host)) {
        buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        buff.writeStringNT(userId);
      } else {
        buff.writeUInt8(0);
        buff.writeUInt8(0);
        buff.writeUInt8(0);
        buff.writeUInt8(1);
        buff.writeStringNT(userId);
        buff.writeStringNT(this.options.destination.host);
      }
      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
      this.socket.write(buff.toBuffer());
    }
    handleSocks4FinalHandshakeResponse() {
      const data = this.receiveBuffer.get(8);
      if (data[1] !== constants_1.Socks4Response.Granted) {
        this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);
      } else {
        if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
          buff.readOffset = 2;
          const remoteHost = {
            port: buff.readUInt16BE(),
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
          };
          if (remoteHost.host === "0.0.0.0") {
            remoteHost.host = this.options.proxy.ipaddress;
          }
          this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
          this.emit("bound", { remoteHost, socket: this.socket });
        } else {
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { socket: this.socket });
        }
      }
    }
    handleSocks4IncomingConnectionResponse() {
      const data = this.receiveBuffer.get(8);
      if (data[1] !== constants_1.Socks4Response.Granted) {
        this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);
      } else {
        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
        buff.readOffset = 2;
        const remoteHost = {
          port: buff.readUInt16BE(),
          host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
        };
        this.setState(constants_1.SocksClientState.Established);
        this.removeInternalSocketHandlers();
        this.emit("established", { remoteHost, socket: this.socket });
      }
    }
    sendSocks5InitialHandshake() {
      const buff = new smart_buffer_1.SmartBuffer;
      const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
      if (this.options.proxy.userId || this.options.proxy.password) {
        supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
      }
      if (this.options.proxy.custom_auth_method !== undefined) {
        supportedAuthMethods.push(this.options.proxy.custom_auth_method);
      }
      buff.writeUInt8(5);
      buff.writeUInt8(supportedAuthMethods.length);
      for (const authMethod of supportedAuthMethods) {
        buff.writeUInt8(authMethod);
      }
      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
      this.socket.write(buff.toBuffer());
      this.setState(constants_1.SocksClientState.SentInitialHandshake);
    }
    handleInitialSocks5HandshakeResponse() {
      const data = this.receiveBuffer.get(2);
      if (data[0] !== 5) {
        this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
      } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
        this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
      } else {
        if (data[1] === constants_1.Socks5Auth.NoAuth) {
          this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
          this.sendSocks5CommandRequest();
        } else if (data[1] === constants_1.Socks5Auth.UserPass) {
          this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
          this.sendSocks5UserPassAuthentication();
        } else if (data[1] === this.options.proxy.custom_auth_method) {
          this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
          this.sendSocks5CustomAuthentication();
        } else {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
        }
      }
    }
    sendSocks5UserPassAuthentication() {
      const userId = this.options.proxy.userId || "";
      const password = this.options.proxy.password || "";
      const buff = new smart_buffer_1.SmartBuffer;
      buff.writeUInt8(1);
      buff.writeUInt8(Buffer.byteLength(userId));
      buff.writeString(userId);
      buff.writeUInt8(Buffer.byteLength(password));
      buff.writeString(password);
      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
      this.socket.write(buff.toBuffer());
      this.setState(constants_1.SocksClientState.SentAuthentication);
    }
    sendSocks5CustomAuthentication() {
      return __awaiter(this, undefined, undefined, function* () {
        this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
        this.socket.write(yield this.options.proxy.custom_auth_request_handler());
        this.setState(constants_1.SocksClientState.SentAuthentication);
      });
    }
    handleSocks5CustomAuthHandshakeResponse(data) {
      return __awaiter(this, undefined, undefined, function* () {
        return yield this.options.proxy.custom_auth_response_handler(data);
      });
    }
    handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
      return __awaiter(this, undefined, undefined, function* () {
        return data[1] === 0;
      });
    }
    handleSocks5AuthenticationUserPassHandshakeResponse(data) {
      return __awaiter(this, undefined, undefined, function* () {
        return data[1] === 0;
      });
    }
    handleInitialSocks5AuthenticationHandshakeResponse() {
      return __awaiter(this, undefined, undefined, function* () {
        this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);
        let authResult = false;
        if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
          authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
        } else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {
          authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
        } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
          authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
        }
        if (!authResult) {
          this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
        } else {
          this.sendSocks5CommandRequest();
        }
      });
    }
    sendSocks5CommandRequest() {
      const buff = new smart_buffer_1.SmartBuffer;
      buff.writeUInt8(5);
      buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
      buff.writeUInt8(0);
      if (net.isIPv4(this.options.destination.host)) {
        buff.writeUInt8(constants_1.Socks5HostType.IPv4);
        buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
      } else if (net.isIPv6(this.options.destination.host)) {
        buff.writeUInt8(constants_1.Socks5HostType.IPv6);
        buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
      } else {
        buff.writeUInt8(constants_1.Socks5HostType.Hostname);
        buff.writeUInt8(this.options.destination.host.length);
        buff.writeString(this.options.destination.host);
      }
      buff.writeUInt16BE(this.options.destination.port);
      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
      this.socket.write(buff.toBuffer());
      this.setState(constants_1.SocksClientState.SentFinalHandshake);
    }
    handleSocks5FinalHandshakeResponse() {
      const header = this.receiveBuffer.peek(5);
      if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
        this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);
      } else {
        const addressType = header[3];
        let remoteHost;
        let buff;
        if (addressType === constants_1.Socks5HostType.IPv4) {
          const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
            port: buff.readUInt16BE()
          };
          if (remoteHost.host === "0.0.0.0") {
            remoteHost.host = this.options.proxy.ipaddress;
          }
        } else if (addressType === constants_1.Socks5HostType.Hostname) {
          const hostLength = header[4];
          const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
          remoteHost = {
            host: buff.readString(hostLength),
            port: buff.readUInt16BE()
          };
        } else if (addressType === constants_1.Socks5HostType.IPv6) {
          const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
            port: buff.readUInt16BE()
          };
        }
        this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
        if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
          this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
          this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
          this.emit("bound", { remoteHost, socket: this.socket });
        } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", {
            remoteHost,
            socket: this.socket
          });
        }
      }
    }
    handleSocks5IncomingConnectionResponse() {
      const header = this.receiveBuffer.peek(5);
      if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
        this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);
      } else {
        const addressType = header[3];
        let remoteHost;
        let buff;
        if (addressType === constants_1.Socks5HostType.IPv4) {
          const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
            port: buff.readUInt16BE()
          };
          if (remoteHost.host === "0.0.0.0") {
            remoteHost.host = this.options.proxy.ipaddress;
          }
        } else if (addressType === constants_1.Socks5HostType.Hostname) {
          const hostLength = header[4];
          const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
          remoteHost = {
            host: buff.readString(hostLength),
            port: buff.readUInt16BE()
          };
        } else if (addressType === constants_1.Socks5HostType.IPv6) {
          const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
            port: buff.readUInt16BE()
          };
        }
        this.setState(constants_1.SocksClientState.Established);
        this.removeInternalSocketHandlers();
        this.emit("established", { remoteHost, socket: this.socket });
      }
    }
    get socksClientOptions() {
      return Object.assign({}, this.options);
    }
  }
  exports.SocksClient = SocksClient;
});

// node_modules/socks/build/index.js
var require_build = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_socksclient(), exports);
});

// node_modules/socks-proxy-agent/node_modules/debug/src/common.js
var require_common5 = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug3(...args) {
        if (!debug3.enabled) {
          return;
        }
        const self2 = debug3;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug3.namespace = namespace;
      debug3.useColors = createDebug.useColors();
      debug3.color = createDebug.selectColor(namespace);
      debug3.extend = extend;
      debug3.destroy = createDebug.destroy;
      Object.defineProperty(debug3, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug3);
      }
      return debug3;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/socks-proxy-agent/node_modules/debug/src/browser.js
var require_browser4 = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common5()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/socks-proxy-agent/node_modules/debug/src/node.js
var require_node5 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug3) {
    debug3.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug3.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common5()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/socks-proxy-agent/node_modules/debug/src/index.js
var require_src4 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser4();
  } else {
    module.exports = require_node5();
  }
});

// node_modules/socks-proxy-agent/dist/index.js
var require_dist4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SocksProxyAgent = undefined;
  var socks_1 = require_build();
  var agent_base_1 = require_dist();
  var debug_1 = __importDefault(require_src4());
  var dns = __importStar(__require("dns"));
  var net = __importStar(__require("net"));
  var tls = __importStar(__require("tls"));
  var url_1 = __require("url");
  var debug3 = (0, debug_1.default)("socks-proxy-agent");
  var setServernameFromNonIpHost = (options) => {
    if (options.servername === undefined && options.host && !net.isIP(options.host)) {
      return {
        ...options,
        servername: options.host
      };
    }
    return options;
  };
  function parseSocksURL(url) {
    let lookup = false;
    let type = 5;
    const host = url.hostname;
    const port = parseInt(url.port, 10) || 1080;
    switch (url.protocol.replace(":", "")) {
      case "socks4":
        lookup = true;
        type = 4;
        break;
      case "socks4a":
        type = 4;
        break;
      case "socks5":
        lookup = true;
        type = 5;
        break;
      case "socks":
        type = 5;
        break;
      case "socks5h":
        type = 5;
        break;
      default:
        throw new TypeError(`A "socks" protocol must be specified! Got: ${String(url.protocol)}`);
    }
    const proxy = {
      host,
      port,
      type
    };
    if (url.username) {
      Object.defineProperty(proxy, "userId", {
        value: decodeURIComponent(url.username),
        enumerable: false
      });
    }
    if (url.password != null) {
      Object.defineProperty(proxy, "password", {
        value: decodeURIComponent(url.password),
        enumerable: false
      });
    }
    return { lookup, proxy };
  }

  class SocksProxyAgent extends agent_base_1.Agent {
    constructor(uri, opts) {
      super(opts);
      const url = typeof uri === "string" ? new url_1.URL(uri) : uri;
      const { proxy, lookup } = parseSocksURL(url);
      this.shouldLookup = lookup;
      this.proxy = proxy;
      this.timeout = opts?.timeout ?? null;
      this.socketOptions = opts?.socketOptions ?? null;
    }
    async connect(req, opts) {
      const { shouldLookup, proxy, timeout } = this;
      if (!opts.host) {
        throw new Error("No `host` defined!");
      }
      let { host } = opts;
      const { port, lookup: lookupFn = dns.lookup } = opts;
      if (shouldLookup) {
        host = await new Promise((resolve, reject) => {
          lookupFn(host, {}, (err, res) => {
            if (err) {
              reject(err);
            } else {
              resolve(res);
            }
          });
        });
      }
      const socksOpts = {
        proxy,
        destination: {
          host,
          port: typeof port === "number" ? port : parseInt(port, 10)
        },
        command: "connect",
        timeout: timeout ?? undefined,
        socket_options: this.socketOptions ?? undefined
      };
      const cleanup = (tlsSocket) => {
        req.destroy();
        socket.destroy();
        if (tlsSocket)
          tlsSocket.destroy();
      };
      debug3("Creating socks proxy connection: %o", socksOpts);
      const { socket } = await socks_1.SocksClient.createConnection(socksOpts);
      debug3("Successfully created socks proxy connection");
      if (timeout !== null) {
        socket.setTimeout(timeout);
        socket.on("timeout", () => cleanup());
      }
      if (opts.secureEndpoint) {
        debug3("Upgrading socket connection to TLS");
        const tlsSocket = tls.connect({
          ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
          socket
        });
        tlsSocket.once("error", (error) => {
          debug3("Socket TLS error", error.message);
          cleanup(tlsSocket);
        });
        return tlsSocket;
      }
      return socket;
    }
  }
  SocksProxyAgent.protocols = [
    "socks",
    "socks4",
    "socks4a",
    "socks5",
    "socks5h"
  ];
  exports.SocksProxyAgent = SocksProxyAgent;
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
});

// node_modules/@npmcli/agent/lib/errors.js
var require_errors4 = __commonJS((exports, module) => {
  class InvalidProxyProtocolError extends Error {
    constructor(url) {
      super(`Invalid protocol \`${url.protocol}\` connecting to proxy \`${url.host}\``);
      this.code = "EINVALIDPROXY";
      this.proxy = url;
    }
  }

  class ConnectionTimeoutError extends Error {
    constructor(host) {
      super(`Timeout connecting to host \`${host}\``);
      this.code = "ECONNECTIONTIMEOUT";
      this.host = host;
    }
  }

  class IdleTimeoutError extends Error {
    constructor(host) {
      super(`Idle timeout reached for host \`${host}\``);
      this.code = "EIDLETIMEOUT";
      this.host = host;
    }
  }

  class ResponseTimeoutError extends Error {
    constructor(request, proxy) {
      let msg = "Response timeout ";
      if (proxy) {
        msg += `from proxy \`${proxy.host}\` `;
      }
      msg += `connecting to host \`${request.host}\``;
      super(msg);
      this.code = "ERESPONSETIMEOUT";
      this.proxy = proxy;
      this.request = request;
    }
  }

  class TransferTimeoutError extends Error {
    constructor(request, proxy) {
      let msg = "Transfer timeout ";
      if (proxy) {
        msg += `from proxy \`${proxy.host}\` `;
      }
      msg += `for \`${request.host}\``;
      super(msg);
      this.code = "ETRANSFERTIMEOUT";
      this.proxy = proxy;
      this.request = request;
    }
  }
  module.exports = {
    InvalidProxyProtocolError,
    ConnectionTimeoutError,
    IdleTimeoutError,
    ResponseTimeoutError,
    TransferTimeoutError
  };
});

// node_modules/@npmcli/agent/lib/proxy.js
var require_proxy = __commonJS((exports, module) => {
  var { HttpProxyAgent } = require_dist2();
  var { HttpsProxyAgent } = require_dist3();
  var { SocksProxyAgent } = require_dist4();
  var { LRUCache } = require_index_min();
  var { InvalidProxyProtocolError } = require_errors4();
  var PROXY_CACHE = new LRUCache({ max: 20 });
  var SOCKS_PROTOCOLS = new Set(SocksProxyAgent.protocols);
  var PROXY_ENV_KEYS = new Set(["https_proxy", "http_proxy", "proxy", "no_proxy"]);
  var PROXY_ENV = Object.entries(process.env).reduce((acc, [key, value]) => {
    key = key.toLowerCase();
    if (PROXY_ENV_KEYS.has(key)) {
      acc[key] = value;
    }
    return acc;
  }, {});
  var getProxyAgent = (url) => {
    url = new URL(url);
    const protocol = url.protocol.slice(0, -1);
    if (SOCKS_PROTOCOLS.has(protocol)) {
      return SocksProxyAgent;
    }
    if (protocol === "https" || protocol === "http") {
      return [HttpProxyAgent, HttpsProxyAgent];
    }
    throw new InvalidProxyProtocolError(url);
  };
  var isNoProxy = (url, noProxy) => {
    if (typeof noProxy === "string") {
      noProxy = noProxy.split(",").map((p) => p.trim()).filter(Boolean);
    }
    if (!noProxy || !noProxy.length) {
      return false;
    }
    const hostSegments = url.hostname.split(".").reverse();
    return noProxy.some((no) => {
      const noSegments = no.split(".").filter(Boolean).reverse();
      if (!noSegments.length) {
        return false;
      }
      for (let i = 0;i < noSegments.length; i++) {
        if (hostSegments[i] !== noSegments[i]) {
          return false;
        }
      }
      return true;
    });
  };
  var getProxy = (url, { proxy, noProxy }) => {
    url = new URL(url);
    if (!proxy) {
      proxy = url.protocol === "https:" ? PROXY_ENV.https_proxy : PROXY_ENV.https_proxy || PROXY_ENV.http_proxy || PROXY_ENV.proxy;
    }
    if (!noProxy) {
      noProxy = PROXY_ENV.no_proxy;
    }
    if (!proxy || isNoProxy(url, noProxy)) {
      return null;
    }
    return new URL(proxy);
  };
  module.exports = {
    getProxyAgent,
    getProxy,
    proxyCache: PROXY_CACHE
  };
});

// node_modules/@npmcli/agent/lib/agents.js
var require_agents = __commonJS((exports, module) => {
  var net = __require("net");
  var tls = __require("tls");
  var { once } = __require("events");
  var timers = __require("timers/promises");
  var { normalizeOptions, cacheOptions } = require_options2();
  var { getProxy, getProxyAgent, proxyCache } = require_proxy();
  var Errors = require_errors4();
  var { Agent: AgentBase } = require_dist();
  module.exports = class Agent extends AgentBase {
    #options;
    #timeouts;
    #proxy;
    #noProxy;
    #ProxyAgent;
    constructor(options = {}) {
      const { timeouts, proxy, noProxy, ...normalizedOptions } = normalizeOptions(options);
      super(normalizedOptions);
      this.#options = normalizedOptions;
      this.#timeouts = timeouts;
      if (proxy) {
        this.#proxy = new URL(proxy);
        this.#noProxy = noProxy;
        this.#ProxyAgent = getProxyAgent(proxy);
      }
    }
    get proxy() {
      return this.#proxy ? { url: this.#proxy } : {};
    }
    #getProxy(options) {
      if (!this.#proxy) {
        return;
      }
      const proxy = getProxy(`${options.protocol}//${options.host}:${options.port}`, {
        proxy: this.#proxy,
        noProxy: this.#noProxy
      });
      if (!proxy) {
        return;
      }
      const cacheKey = cacheOptions({
        ...options,
        ...this.#options,
        timeouts: this.#timeouts,
        proxy
      });
      if (proxyCache.has(cacheKey)) {
        return proxyCache.get(cacheKey);
      }
      let ProxyAgent = this.#ProxyAgent;
      if (Array.isArray(ProxyAgent)) {
        ProxyAgent = this.isSecureEndpoint(options) ? ProxyAgent[1] : ProxyAgent[0];
      }
      const proxyAgent = new ProxyAgent(proxy, {
        ...this.#options,
        socketOptions: { family: this.#options.family }
      });
      proxyCache.set(cacheKey, proxyAgent);
      return proxyAgent;
    }
    async#timeoutConnection({ promises, options, timeout }, ac = new AbortController) {
      if (timeout) {
        const connectionTimeout = timers.setTimeout(timeout, null, { signal: ac.signal }).then(() => {
          throw new Errors.ConnectionTimeoutError(`${options.host}:${options.port}`);
        }).catch((err) => {
          if (err.name === "AbortError") {
            return;
          }
          throw err;
        });
        promises.push(connectionTimeout);
      }
      let result;
      try {
        result = await Promise.race(promises);
        ac.abort();
      } catch (err) {
        ac.abort();
        throw err;
      }
      return result;
    }
    async connect(request, options) {
      options.lookup ??= this.#options.lookup;
      let socket;
      let timeout = this.#timeouts.connection;
      const isSecureEndpoint = this.isSecureEndpoint(options);
      const proxy = this.#getProxy(options);
      if (proxy) {
        const start = Date.now();
        socket = await this.#timeoutConnection({
          options,
          timeout,
          promises: [proxy.connect(request, options)]
        });
        if (timeout) {
          timeout = timeout - (Date.now() - start);
        }
      } else {
        socket = (isSecureEndpoint ? tls : net).connect(options);
      }
      socket.setKeepAlive(this.keepAlive, this.keepAliveMsecs);
      socket.setNoDelay(this.keepAlive);
      const abortController = new AbortController;
      const { signal } = abortController;
      const connectPromise = socket[isSecureEndpoint ? "secureConnecting" : "connecting"] ? once(socket, isSecureEndpoint ? "secureConnect" : "connect", { signal }) : Promise.resolve();
      await this.#timeoutConnection({
        options,
        timeout,
        promises: [
          connectPromise,
          once(socket, "error", { signal }).then((err) => {
            throw err[0];
          })
        ]
      }, abortController);
      if (this.#timeouts.idle) {
        socket.setTimeout(this.#timeouts.idle, () => {
          socket.destroy(new Errors.IdleTimeoutError(`${options.host}:${options.port}`));
        });
      }
      return socket;
    }
    addRequest(request, options) {
      const proxy = this.#getProxy(options);
      if (proxy?.setRequestProps) {
        proxy.setRequestProps(request, options);
      }
      request.setHeader("connection", this.keepAlive ? "keep-alive" : "close");
      if (this.#timeouts.response) {
        let responseTimeout;
        request.once("finish", () => {
          setTimeout(() => {
            request.destroy(new Errors.ResponseTimeoutError(request, this.#proxy));
          }, this.#timeouts.response);
        });
        request.once("response", () => {
          clearTimeout(responseTimeout);
        });
      }
      if (this.#timeouts.transfer) {
        let transferTimeout;
        request.once("response", (res) => {
          setTimeout(() => {
            res.destroy(new Errors.TransferTimeoutError(request, this.#proxy));
          }, this.#timeouts.transfer);
          res.once("close", () => {
            clearTimeout(transferTimeout);
          });
        });
      }
      return super.addRequest(request, options);
    }
  };
});

// node_modules/@npmcli/agent/lib/index.js
var require_lib11 = __commonJS((exports, module) => {
  var { LRUCache } = require_index_min();
  var { normalizeOptions, cacheOptions } = require_options2();
  var { getProxy, proxyCache } = require_proxy();
  var dns = require_dns();
  var Agent = require_agents();
  var agentCache = new LRUCache({ max: 20 });
  var getAgent = (url, { agent, proxy, noProxy, ...options } = {}) => {
    if (agent != null) {
      return agent;
    }
    url = new URL(url);
    const proxyForUrl = getProxy(url, { proxy, noProxy });
    const normalizedOptions = {
      ...normalizeOptions(options),
      proxy: proxyForUrl
    };
    const cacheKey = cacheOptions({
      ...normalizedOptions,
      secureEndpoint: url.protocol === "https:"
    });
    if (agentCache.has(cacheKey)) {
      return agentCache.get(cacheKey);
    }
    const newAgent = new Agent(normalizedOptions);
    agentCache.set(cacheKey, newAgent);
    return newAgent;
  };
  module.exports = {
    getAgent,
    Agent,
    HttpAgent: Agent,
    HttpsAgent: Agent,
    cache: {
      proxy: proxyCache,
      agent: agentCache,
      dns: dns.cache,
      clear: () => {
        proxyCache.clear();
        agentCache.clear();
        dns.cache.clear();
      }
    }
  };
});

// node_modules/make-fetch-happen/package.json
var require_package3 = __commonJS((exports, module) => {
  module.exports = {
    name: "make-fetch-happen",
    version: "15.0.4",
    description: "Opinionated, caching, retrying fetch client",
    main: "lib/index.js",
    files: [
      "bin/",
      "lib/"
    ],
    scripts: {
      test: "tap",
      posttest: "npm run lint",
      eslint: 'eslint "**/*.{js,cjs,ts,mjs,jsx,tsx}"',
      lint: "npm run eslint",
      lintfix: "npm run eslint -- --fix",
      postlint: "template-oss-check",
      snap: "tap",
      "template-oss-apply": "template-oss-apply --force"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/npm/make-fetch-happen.git"
    },
    keywords: [
      "http",
      "request",
      "fetch",
      "mean girls",
      "caching",
      "cache",
      "subresource integrity"
    ],
    author: "GitHub Inc.",
    license: "ISC",
    dependencies: {
      "@gar/promise-retry": "^1.0.0",
      "@npmcli/agent": "^4.0.0",
      cacache: "^20.0.1",
      "http-cache-semantics": "^4.1.1",
      minipass: "^7.0.2",
      "minipass-fetch": "^5.0.0",
      "minipass-flush": "^1.0.5",
      "minipass-pipeline": "^1.2.4",
      negotiator: "^1.0.0",
      "proc-log": "^6.0.0",
      ssri: "^13.0.0"
    },
    devDependencies: {
      "@npmcli/eslint-config": "^5.0.0",
      "@npmcli/template-oss": "4.25.0",
      nock: "^13.2.4",
      "safe-buffer": "^5.2.1",
      "standard-version": "^9.3.2",
      tap: "^16.0.0"
    },
    engines: {
      node: "^20.17.0 || >=22.9.0"
    },
    tap: {
      color: 1,
      files: "test/*.js",
      "check-coverage": true,
      timeout: 60,
      "nyc-arg": [
        "--exclude",
        "tap-snapshots/**"
      ]
    },
    templateOSS: {
      "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
      version: "4.25.0",
      publish: "true"
    }
  };
});

// node_modules/make-fetch-happen/lib/remote.js
var require_remote = __commonJS((exports, module) => {
  var { Minipass } = require_commonjs();
  var fetch2 = require_lib2();
  var { promiseRetry } = require_lib9();
  var ssri = require_lib3();
  var { log: log2 } = require_lib10();
  var CachingMinipassPipeline = require_pipeline();
  var { getAgent } = require_lib11();
  var pkg = require_package3();
  var USER_AGENT2 = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`;
  var RETRY_ERRORS = [
    "ECONNRESET",
    "ECONNREFUSED",
    "EADDRINUSE",
    "ETIMEDOUT",
    "ECONNECTIONTIMEOUT",
    "EIDLETIMEOUT",
    "ERESPONSETIMEOUT",
    "ETRANSFERTIMEOUT"
  ];
  var RETRY_TYPES = [
    "request-timeout"
  ];
  var remoteFetch = (request, options) => {
    const agent = getAgent(request.url, { ...options, signal: undefined });
    if (!request.headers.has("connection")) {
      request.headers.set("connection", agent ? "keep-alive" : "close");
    }
    if (!request.headers.has("user-agent")) {
      request.headers.set("user-agent", USER_AGENT2);
    }
    const _opts = {
      ...options,
      agent,
      redirect: "manual"
    };
    return promiseRetry(async (retryHandler, attemptNum) => {
      const req = new fetch2.Request(request, _opts);
      try {
        let res = await fetch2(req, _opts);
        if (_opts.integrity && res.status === 200) {
          const integrityStream = ssri.integrityStream({
            algorithms: _opts.algorithms,
            integrity: _opts.integrity,
            size: _opts.size
          });
          const pipeline2 = new CachingMinipassPipeline({
            events: ["integrity", "size"]
          }, res.body, integrityStream);
          integrityStream.on("integrity", (i) => pipeline2.emit("integrity", i));
          integrityStream.on("size", (s) => pipeline2.emit("size", s));
          res = new fetch2.Response(pipeline2, res);
          res.body.hasIntegrityEmitter = true;
        }
        res.headers.set("x-fetch-attempts", attemptNum);
        const isStream = Minipass.isStream(req.body);
        const isRetriable = req.method !== "POST" && !isStream && ([408, 420, 429].includes(res.status) || res.status >= 500);
        if (isRetriable) {
          if (typeof options.onRetry === "function") {
            options.onRetry(res);
          }
          log2.http("fetch", `${req.method} ${req.url} attempt ${attemptNum} failed with ${res.status}`);
          return retryHandler(res);
        }
        return res;
      } catch (err) {
        const code = err.code === "EPROMISERETRY" ? err.retried.code : err.code;
        const isRetryError = err.retried instanceof fetch2.Response || RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type);
        if (req.method === "POST" || isRetryError) {
          throw err;
        }
        if (typeof options.onRetry === "function") {
          options.onRetry(err);
        }
        log2.http("fetch", `${req.method} ${req.url} attempt ${attemptNum} failed with ${err.code}`);
        return retryHandler(err);
      }
    }, options.retry).catch((err) => {
      if (err.status >= 400 && err.type !== "system") {
        return err;
      }
      throw err;
    });
  };
  module.exports = remoteFetch;
});

// node_modules/make-fetch-happen/lib/cache/entry.js
var require_entry = __commonJS((exports, module) => {
  var { Request: Request2, Response } = require_lib2();
  var { Minipass } = require_commonjs();
  var MinipassFlush = require_minipass_flush();
  var cacache = require_lib8();
  var url = __require("url");
  var CachingMinipassPipeline = require_pipeline();
  var CachePolicy = require_policy();
  var cacheKey = require_key();
  var remote = require_remote();
  var hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
  var KEEP_REQUEST_HEADERS = [
    "accept-charset",
    "accept-encoding",
    "accept-language",
    "accept",
    "cache-control"
  ];
  var KEEP_RESPONSE_HEADERS = [
    "cache-control",
    "content-encoding",
    "content-language",
    "content-type",
    "date",
    "etag",
    "expires",
    "last-modified",
    "link",
    "location",
    "pragma",
    "vary"
  ];
  var getMetadata = (request, response, options) => {
    const metadata = {
      time: Date.now(),
      url: request.url,
      reqHeaders: {},
      resHeaders: {},
      options: {
        compress: options.compress != null ? options.compress : request.compress
      }
    };
    if (response.status !== 200 && response.status !== 304) {
      metadata.status = response.status;
    }
    for (const name of KEEP_REQUEST_HEADERS) {
      if (request.headers.has(name)) {
        metadata.reqHeaders[name] = request.headers.get(name);
      }
    }
    const host = request.headers.get("host");
    const parsedUrl = new url.URL(request.url);
    if (host && parsedUrl.host !== host) {
      metadata.reqHeaders.host = host;
    }
    if (response.headers.has("vary")) {
      const vary = response.headers.get("vary");
      if (vary !== "*") {
        const varyHeaders = vary.trim().toLowerCase().split(/\s*,\s*/);
        for (const name of varyHeaders) {
          if (request.headers.has(name)) {
            metadata.reqHeaders[name] = request.headers.get(name);
          }
        }
      }
    }
    for (const name of KEEP_RESPONSE_HEADERS) {
      if (response.headers.has(name)) {
        metadata.resHeaders[name] = response.headers.get(name);
      }
    }
    for (const name of options.cacheAdditionalHeaders) {
      if (response.headers.has(name)) {
        metadata.resHeaders[name] = response.headers.get(name);
      }
    }
    return metadata;
  };
  var _request = Symbol("request");
  var _response = Symbol("response");
  var _policy = Symbol("policy");

  class CacheEntry {
    constructor({ entry, request, response, options }) {
      if (entry) {
        this.key = entry.key;
        this.entry = entry;
        this.entry.metadata.time = this.entry.metadata.time || this.entry.time;
      } else {
        this.key = cacheKey(request);
      }
      this.options = options;
      this[_request] = request;
      this[_response] = response;
      this[_policy] = null;
    }
    static async find(request, options) {
      try {
        var matches = await cacache.index.compact(options.cachePath, cacheKey(request), (A, B) => {
          const entryA = new CacheEntry({ entry: A, options });
          const entryB = new CacheEntry({ entry: B, options });
          return entryA.policy.satisfies(entryB.request);
        }, {
          validateEntry: (entry) => {
            if (entry.metadata && entry.metadata.resHeaders && entry.metadata.resHeaders["content-encoding"] === null) {
              return false;
            }
            if (entry.integrity === null) {
              return !!(entry.metadata && entry.metadata.status);
            }
            return true;
          }
        });
      } catch (err) {
        return;
      }
      if (options.cache === "reload") {
        return;
      }
      let match;
      for (const entry of matches) {
        const _entry = new CacheEntry({
          entry,
          options
        });
        if (_entry.policy.satisfies(request)) {
          match = _entry;
          break;
        }
      }
      return match;
    }
    static async invalidate(request, options) {
      const key = cacheKey(request);
      try {
        await cacache.rm.entry(options.cachePath, key, { removeFully: true });
      } catch (err) {}
    }
    get request() {
      if (!this[_request]) {
        this[_request] = new Request2(this.entry.metadata.url, {
          method: "GET",
          headers: this.entry.metadata.reqHeaders,
          ...this.entry.metadata.options
        });
      }
      return this[_request];
    }
    get response() {
      if (!this[_response]) {
        this[_response] = new Response(null, {
          url: this.entry.metadata.url,
          counter: this.options.counter,
          status: this.entry.metadata.status || 200,
          headers: {
            ...this.entry.metadata.resHeaders,
            "content-length": this.entry.size
          }
        });
      }
      return this[_response];
    }
    get policy() {
      if (!this[_policy]) {
        this[_policy] = new CachePolicy({
          entry: this.entry,
          request: this.request,
          response: this.response,
          options: this.options
        });
      }
      return this[_policy];
    }
    async store(status) {
      if (this.request.method !== "GET" || ![200, 301, 308].includes(this.response.status) || !this.policy.storable()) {
        this.response.headers.set("x-local-cache-status", "skip");
        return this.response;
      }
      const size = this.response.headers.get("content-length");
      const cacheOpts = {
        algorithms: this.options.algorithms,
        metadata: getMetadata(this.request, this.response, this.options),
        size,
        integrity: this.options.integrity,
        integrityEmitter: this.response.body.hasIntegrityEmitter && this.response.body
      };
      let body = null;
      if (this.response.status === 200) {
        let cacheWriteResolve, cacheWriteReject;
        const cacheWritePromise = new Promise((resolve, reject) => {
          cacheWriteResolve = resolve;
          cacheWriteReject = reject;
        }).catch((err) => {
          body.emit("error", err);
        });
        body = new CachingMinipassPipeline({ events: ["integrity", "size"] }, new MinipassFlush({
          flush() {
            return cacheWritePromise;
          }
        }));
        body.hasIntegrityEmitter = true;
        const onResume = () => {
          const tee = new Minipass;
          const cacheStream = cacache.put.stream(this.options.cachePath, this.key, cacheOpts);
          cacheStream.on("integrity", (i) => body.emit("integrity", i));
          cacheStream.on("size", (s) => body.emit("size", s));
          tee.pipe(cacheStream);
          cacheStream.promise().then(cacheWriteResolve, cacheWriteReject);
          body.unshift(tee);
          body.unshift(this.response.body);
        };
        body.once("resume", onResume);
        body.once("end", () => body.removeListener("resume", onResume));
      } else {
        await cacache.index.insert(this.options.cachePath, this.key, null, cacheOpts);
      }
      this.response.headers.set("x-local-cache", encodeURIComponent(this.options.cachePath));
      this.response.headers.set("x-local-cache-key", encodeURIComponent(this.key));
      this.response.headers.set("x-local-cache-mode", "stream");
      this.response.headers.set("x-local-cache-status", status);
      this.response.headers.set("x-local-cache-time", new Date().toISOString());
      const newResponse = new Response(body, {
        url: this.response.url,
        status: this.response.status,
        headers: this.response.headers,
        counter: this.options.counter
      });
      return newResponse;
    }
    async respond(method, options, status) {
      let response;
      if (method === "HEAD" || [301, 308].includes(this.response.status)) {
        response = this.response;
      } else {
        const body = new Minipass;
        const headers = { ...this.policy.responseHeaders() };
        const onResume = () => {
          const cacheStream = cacache.get.stream.byDigest(this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize });
          cacheStream.on("error", async (err) => {
            cacheStream.pause();
            if (err.code === "EINTEGRITY") {
              await cacache.rm.content(this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize });
            }
            if (err.code === "ENOENT" || err.code === "EINTEGRITY") {
              await CacheEntry.invalidate(this.request, this.options);
            }
            body.emit("error", err);
            cacheStream.resume();
          });
          body.emit("integrity", this.entry.integrity);
          body.emit("size", Number(headers["content-length"]));
          cacheStream.pipe(body);
        };
        body.once("resume", onResume);
        body.once("end", () => body.removeListener("resume", onResume));
        response = new Response(body, {
          url: this.entry.metadata.url,
          counter: options.counter,
          status: 200,
          headers
        });
      }
      response.headers.set("x-local-cache", encodeURIComponent(this.options.cachePath));
      response.headers.set("x-local-cache-hash", encodeURIComponent(this.entry.integrity));
      response.headers.set("x-local-cache-key", encodeURIComponent(this.key));
      response.headers.set("x-local-cache-mode", "stream");
      response.headers.set("x-local-cache-status", status);
      response.headers.set("x-local-cache-time", new Date(this.entry.metadata.time).toUTCString());
      return response;
    }
    async revalidate(request, options) {
      const revalidateRequest = new Request2(request, {
        headers: this.policy.revalidationHeaders(request)
      });
      try {
        var response = await remote(revalidateRequest, {
          ...options,
          headers: undefined
        });
      } catch (err) {
        if (!this.policy.mustRevalidate) {
          return this.respond(request.method, options, "stale");
        }
        throw err;
      }
      if (this.policy.revalidated(revalidateRequest, response)) {
        const metadata = getMetadata(request, response, options);
        for (const name of KEEP_RESPONSE_HEADERS) {
          if (!hasOwnProperty(metadata.resHeaders, name) && hasOwnProperty(this.entry.metadata.resHeaders, name)) {
            metadata.resHeaders[name] = this.entry.metadata.resHeaders[name];
          }
        }
        for (const name of options.cacheAdditionalHeaders) {
          const inMeta = hasOwnProperty(metadata.resHeaders, name);
          const inEntry = hasOwnProperty(this.entry.metadata.resHeaders, name);
          const inPolicy = hasOwnProperty(this.policy.response.headers, name);
          if (!inMeta && inEntry) {
            metadata.resHeaders[name] = this.entry.metadata.resHeaders[name];
          }
          if (!inPolicy && inMeta) {
            this.policy.response.headers[name] = metadata.resHeaders[name];
          }
        }
        try {
          await cacache.index.insert(options.cachePath, this.key, this.entry.integrity, {
            size: this.entry.size,
            metadata
          });
        } catch (err) {}
        return this.respond(request.method, options, "revalidated");
      }
      const newEntry = new CacheEntry({
        request,
        response,
        options
      });
      return newEntry.store("updated");
    }
  }
  module.exports = CacheEntry;
});

// node_modules/make-fetch-happen/lib/cache/index.js
var require_cache = __commonJS((exports, module) => {
  var { NotCachedError } = require_errors2();
  var CacheEntry = require_entry();
  var remote = require_remote();
  var cacheFetch = async (request, options) => {
    const entry = await CacheEntry.find(request, options);
    if (!entry) {
      if (options.cache === "only-if-cached") {
        throw new NotCachedError(request.url);
      }
      const response = await remote(request, options);
      const newEntry = new CacheEntry({ request, response, options });
      return newEntry.store("miss");
    }
    if (options.cache === "no-cache") {
      return entry.revalidate(request, options);
    }
    const _needsRevalidation = entry.policy.needsRevalidation(request);
    if (options.cache === "force-cache" || options.cache === "only-if-cached" || !_needsRevalidation) {
      return entry.respond(request.method, options, _needsRevalidation ? "stale" : "hit");
    }
    return entry.revalidate(request, options);
  };
  cacheFetch.invalidate = async (request, options) => {
    if (!options.cachePath) {
      return;
    }
    return CacheEntry.invalidate(request, options);
  };
  module.exports = cacheFetch;
});

// node_modules/make-fetch-happen/lib/fetch.js
var require_fetch = __commonJS((exports, module) => {
  var { FetchError, Request: Request2, isRedirect } = require_lib2();
  var url = __require("url");
  var CachePolicy = require_policy();
  var cache2 = require_cache();
  var remote = require_remote();
  var canFollowRedirect = (request, response, options) => {
    if (!isRedirect(response.status)) {
      return false;
    }
    if (options.redirect === "manual") {
      return false;
    }
    if (options.redirect === "error") {
      throw new FetchError(`redirect mode is set to error: ${request.url}`, "no-redirect", { code: "ENOREDIRECT" });
    }
    if (!response.headers.has("location")) {
      throw new FetchError(`redirect location header missing for: ${request.url}`, "no-location", { code: "EINVALIDREDIRECT" });
    }
    if (request.counter >= request.follow) {
      throw new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect", { code: "EMAXREDIRECT" });
    }
    return true;
  };
  var getRedirect = (request, response, options) => {
    const _opts = { ...options };
    const location = response.headers.get("location");
    const redirectUrl = new url.URL(location, /^https?:/.test(location) ? undefined : request.url);
    if (new url.URL(request.url).hostname !== redirectUrl.hostname) {
      request.headers.delete("authorization");
      request.headers.delete("cookie");
    }
    if (response.status === 303 || request.method === "POST" && [301, 302].includes(response.status)) {
      _opts.method = "GET";
      _opts.body = null;
      request.headers.delete("content-length");
    }
    _opts.headers = {};
    request.headers.forEach((value, key) => {
      _opts.headers[key] = value;
    });
    _opts.counter = ++request.counter;
    const redirectReq = new Request2(url.format(redirectUrl), _opts);
    return {
      request: redirectReq,
      options: _opts
    };
  };
  var fetch2 = async (request, options) => {
    const response = CachePolicy.storable(request, options) ? await cache2(request, options) : await remote(request, options);
    if (!["GET", "HEAD"].includes(request.method) && response.status >= 200 && response.status <= 399) {
      await cache2.invalidate(request, options);
    }
    if (!canFollowRedirect(request, response, options)) {
      return response;
    }
    const redirect = getRedirect(request, response, options);
    return fetch2(redirect.request, redirect.options);
  };
  module.exports = fetch2;
});

// node_modules/make-fetch-happen/lib/index.js
var require_lib12 = __commonJS((exports, module) => {
  var { FetchError, Headers: Headers2, Request: Request2, Response } = require_lib2();
  var configureOptions = require_options();
  var fetch2 = require_fetch();
  var makeFetchHappen = (url, opts) => {
    const options = configureOptions(opts);
    const request = new Request2(url, options);
    return fetch2(request, options);
  };
  makeFetchHappen.defaults = (defaultUrl, defaultOptions = {}, wrappedFetch = makeFetchHappen) => {
    if (typeof defaultUrl === "object") {
      defaultOptions = defaultUrl;
      defaultUrl = null;
    }
    const defaultedFetch = (url, options = {}) => {
      const finalUrl = url || defaultUrl;
      const finalOptions = {
        ...defaultOptions,
        ...options,
        headers: {
          ...defaultOptions.headers,
          ...options.headers
        }
      };
      return wrappedFetch(finalUrl, finalOptions);
    };
    defaultedFetch.defaults = (defaultUrl1, defaultOptions1 = {}) => makeFetchHappen.defaults(defaultUrl1, defaultOptions1, defaultedFetch);
    return defaultedFetch;
  };
  module.exports = makeFetchHappen;
  module.exports.FetchError = FetchError;
  module.exports.Headers = Headers2;
  module.exports.Request = Request2;
  module.exports.Response = Response;
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS((exports) => {
  var parseUrl = __require("url").parse;
  var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
  };
  function getProxyForUrl(url) {
    var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
    var proto = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
      return "";
    }
    proto = proto.split(":", 1)[0];
    hostname = hostname.replace(/:\d*$/, "");
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname, port)) {
      return "";
    }
    var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
    if (proxy && proxy.indexOf("://") === -1) {
      proxy = proto + "://" + proxy;
    }
    return proxy;
  }
  function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
    if (!NO_PROXY) {
      return true;
    }
    if (NO_PROXY === "*") {
      return false;
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
      if (!proxy) {
        return true;
      }
      var parsedProxy = proxy.match(/^(.+):(\d+)$/);
      var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
      var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
      if (parsedProxyPort && parsedProxyPort !== port) {
        return true;
      }
      if (!/^[.*]/.test(parsedProxyHostname)) {
        return hostname !== parsedProxyHostname;
      }
      if (parsedProxyHostname.charAt(0) === "*") {
        parsedProxyHostname = parsedProxyHostname.slice(1);
      }
      return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
  }
  function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
  }
  exports.getProxyForUrl = getProxyForUrl;
});

// node_modules/unleash-client/lib/request.js
var require_request2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.get = exports.post = exports.buildHeaders = exports.getDefaultAgent = undefined;
  var node_http_1 = __importDefault(__require("node:http"));
  var node_https_1 = __importDefault(__require("node:https"));
  var http_proxy_agent_1 = require_dist2();
  var https_proxy_agent_1 = require_dist3();
  var make_fetch_happen_1 = __importDefault(require_lib12());
  var proxy_from_env_1 = require_proxy_from_env();
  var details_json_1 = __importDefault(require_details());
  var httpAgentOptions = {
    keepAlive: true,
    keepAliveMsecs: 30 * 1000,
    timeout: 10 * 1000
  };
  var httpNoProxyAgent = new node_http_1.default.Agent(httpAgentOptions);
  var httpsNoProxyAgent = new node_https_1.default.Agent(httpAgentOptions);
  var getDefaultAgent = (url) => {
    const proxy = (0, proxy_from_env_1.getProxyForUrl)(url.href);
    const isHttps = url.protocol === "https:";
    if (!proxy || proxy === "") {
      return isHttps ? httpsNoProxyAgent : httpNoProxyAgent;
    }
    return isHttps ? new https_proxy_agent_1.HttpsProxyAgent(proxy, httpAgentOptions) : new http_proxy_agent_1.HttpProxyAgent(proxy, httpAgentOptions);
  };
  exports.getDefaultAgent = getDefaultAgent;
  var buildHeaders = ({ appName, instanceId, etag, contentType, custom, specVersionSupported, connectionId, interval }) => {
    const head = {};
    if (appName) {
      head["User-Agent"] = appName;
      head["unleash-appname"] = appName;
    }
    if (instanceId) {
      head["UNLEASH-INSTANCEID"] = instanceId;
    }
    if (etag) {
      head["If-None-Match"] = etag;
    }
    if (contentType) {
      head["Content-Type"] = contentType;
    }
    if (specVersionSupported) {
      head["Unleash-Client-Spec"] = specVersionSupported;
    }
    const version = details_json_1.default.version;
    head["unleash-sdk"] = `unleash-node-sdk:${version}`;
    if (custom) {
      Object.assign(head, custom);
    }
    if (connectionId) {
      head["unleash-connection-id"] = connectionId;
    }
    head["unleash-interval"] = String(interval);
    return head;
  };
  exports.buildHeaders = buildHeaders;
  var post = ({ url, appName, timeout, instanceId, connectionId, interval, headers, json, httpOptions }) => (0, make_fetch_happen_1.default)(url, {
    timeout: timeout || 1e4,
    method: "POST",
    agent: httpOptions?.agent || exports.getDefaultAgent,
    headers: (0, exports.buildHeaders)({
      appName,
      instanceId,
      connectionId,
      interval,
      etag: undefined,
      contentType: "application/json",
      custom: headers
    }),
    body: JSON.stringify(json),
    strictSSL: httpOptions?.rejectUnauthorized
  });
  exports.post = post;
  var get = ({ url, etag, appName, timeout, instanceId, connectionId, interval, headers, httpOptions, supportedSpecVersion }) => (0, make_fetch_happen_1.default)(url, {
    method: "GET",
    timeout: timeout || 1e4,
    agent: httpOptions?.agent || exports.getDefaultAgent,
    headers: (0, exports.buildHeaders)({
      appName,
      instanceId,
      interval,
      etag,
      contentType: undefined,
      custom: headers,
      specVersionSupported: supportedSpecVersion,
      connectionId
    }),
    retry: {
      retries: 2,
      maxTimeout: timeout || 1e4
    },
    strictSSL: httpOptions?.rejectUnauthorized
  });
  exports.get = get;
});

// node_modules/unleash-client/lib/url-utils.js
var require_url_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.suffixSlash = undefined;
  exports.resolveUrl = resolveUrl;
  function resolveUrl(from, to) {
    const resolvedUrl = new URL(to, new URL(from, "resolve://"));
    if (resolvedUrl.protocol === "resolve:") {
      const { pathname, search, hash } = resolvedUrl;
      return pathname + search + hash;
    }
    return resolvedUrl.toString();
  }
  var getUrl = (base, projectName, namePrefix, tags, mode) => {
    const isDeltaPolling = mode && mode.type === "polling" && mode.format === "delta";
    const url = resolveUrl(base, isDeltaPolling ? "./client/delta" : "./client/features");
    const params = new URLSearchParams;
    if (projectName) {
      params.append("project", projectName);
    }
    if (namePrefix) {
      params.append("namePrefix", namePrefix);
    }
    if (tags) {
      tags.forEach((tag2) => {
        params.append("tag", tag2);
      });
    }
    if (params.toString().length > 0) {
      return `${url}?${params.toString()}`;
    }
    return url;
  };
  var suffixSlash = (url) => url.endsWith("/") ? url : `${url}/`;
  exports.suffixSlash = suffixSlash;
  exports.default = getUrl;
});

// node_modules/unleash-client/lib/repository/polling-fetcher.js
var require_polling_fetcher = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PollingFetcher = undefined;
  var node_events_1 = __require("node:events");
  var events_1 = require_events();
  var feature_1 = require_feature();
  var request_1 = require_request2();
  var url_utils_1 = __importDefault(require_url_utils());

  class PollingFetcher extends node_events_1.EventEmitter {
    timer;
    stopped = false;
    failures = 0;
    etag;
    options;
    constructor(options) {
      super();
      this.options = options;
      this.etag = options.etag;
    }
    timedFetch(interval) {
      if (interval > 0) {
        this.timer = setTimeout(() => this.fetch(), interval);
        if (typeof this.timer.unref === "function") {
          this.timer.unref();
        }
      }
    }
    async start() {
      this.stopped = false;
      await this.fetch();
    }
    nextFetch() {
      return this.options.refreshInterval + this.failures * this.options.refreshInterval;
    }
    getFailures() {
      return this.failures;
    }
    getEtag() {
      return this.etag;
    }
    setEtag(value) {
      this.etag = value;
    }
    backoff() {
      this.failures = Math.min(this.failures + 1, 10);
      return this.nextFetch();
    }
    countSuccess() {
      this.failures = Math.max(this.failures - 1, 0);
      return this.nextFetch();
    }
    configurationError(url, statusCode) {
      this.failures += 1;
      if (statusCode === 401 || statusCode === 403) {
        this.emit(events_1.UnleashEvents.Error, new Error(`${url} responded ${statusCode} which means your API key is not allowed to connect. Stopping refresh of toggles`));
      }
      return 0;
    }
    recoverableError(url, statusCode) {
      const nextFetch = this.backoff();
      if (statusCode === 429) {
        this.emit(events_1.UnleashEvents.Warn, `${url} responded TOO_MANY_CONNECTIONS (429). Backing off`);
      } else if (statusCode === 404) {
        this.emit(events_1.UnleashEvents.Warn, `${url} responded FILE_NOT_FOUND (404). Backing off`);
      } else if (statusCode === 500 || statusCode === 502 || statusCode === 503 || statusCode === 504) {
        this.emit(events_1.UnleashEvents.Warn, `${url} responded ${statusCode}. Backing off`);
      }
      return nextFetch;
    }
    handleErrorCases(url, statusCode) {
      if (statusCode === 401 || statusCode === 403) {
        return this.configurationError(url, statusCode);
      } else if (statusCode === 404 || statusCode === 429 || statusCode === 500 || statusCode === 502 || statusCode === 503 || statusCode === 504) {
        return this.recoverableError(url, statusCode);
      } else {
        const error = new Error(`Response was not statusCode 2XX, but was ${statusCode}`);
        this.emit(events_1.UnleashEvents.Error, error);
        return this.options.refreshInterval;
      }
    }
    async fetch() {
      if (this.stopped || !(this.options.refreshInterval > 0)) {
        return;
      }
      let nextFetch = this.options.refreshInterval;
      try {
        let mergedTags;
        if (this.options.tags) {
          mergedTags = this.mergeTagsToStringArray(this.options.tags);
        }
        const url = (0, url_utils_1.default)(this.options.url, this.options.projectName, this.options.namePrefix, mergedTags, this.options.mode);
        const headers = this.options.customHeadersFunction ? await this.options.customHeadersFunction() : this.options.headers;
        const res = await (0, request_1.get)({
          url,
          etag: this.etag,
          appName: this.options.appName,
          timeout: this.options.timeout,
          instanceId: this.options.instanceId,
          connectionId: this.options.connectionId,
          interval: this.options.refreshInterval,
          headers,
          httpOptions: this.options.httpOptions,
          supportedSpecVersion: "5.2.0"
        });
        if (res.status === 304) {
          this.emit(events_1.UnleashEvents.Unchanged);
          nextFetch = this.countSuccess();
        } else if (res.ok) {
          nextFetch = this.countSuccess();
          try {
            const data = await res.json();
            if (res.headers.get("etag") !== null) {
              this.etag = res.headers.get("etag");
            } else {
              this.etag = undefined;
            }
            const fetchingModeHeader = res.headers.get("fetch-mode");
            if (fetchingModeHeader === "streaming" && this.options.onModeChange) {
              await this.options.onModeChange("streaming");
              return;
            }
            await this.options.onSave((0, feature_1.parseApiResponse)(data), true);
          } catch (err) {
            this.emit(events_1.UnleashEvents.Error, err);
          }
        } else {
          nextFetch = this.handleErrorCases(url, res.status);
        }
      } catch (err) {
        const e = err;
        if (e.code === "ECONNRESET") {
          nextFetch = Math.max(Math.floor(this.options.refreshInterval / 2), 1000);
          this.emit(events_1.UnleashEvents.Warn, `Socket keep alive error, retrying in ${nextFetch}ms`);
        } else {
          this.emit(events_1.UnleashEvents.Error, err);
        }
      } finally {
        this.timedFetch(nextFetch);
      }
    }
    mergeTagsToStringArray(tags) {
      return tags.map((tag2) => `${tag2.name}:${tag2.value}`);
    }
    stop() {
      this.stopped = true;
      if (this.timer) {
        clearTimeout(this.timer);
      }
    }
  }
  exports.PollingFetcher = PollingFetcher;
});

// node_modules/launchdarkly-eventsource/lib/retry-delay.js
var require_retry_delay = __commonJS((exports, module) => {
  function RetryDelayStrategy(baseDelayMillis, resetIntervalMillis, backoff, jitter) {
    var currentBaseDelay = baseDelayMillis;
    var retryCount = 0;
    var goodSince;
    return {
      nextRetryDelay: function(currentTimeMillis) {
        if (goodSince && resetIntervalMillis && currentTimeMillis - goodSince >= resetIntervalMillis) {
          retryCount = 0;
        }
        goodSince = null;
        var delay = backoff ? backoff(currentBaseDelay, retryCount) : currentBaseDelay;
        retryCount++;
        return jitter ? jitter(delay) : delay;
      },
      setGoodSince: function(goodSinceTimeMillis) {
        goodSince = goodSinceTimeMillis;
      },
      setBaseDelay: function(baseDelay) {
        currentBaseDelay = baseDelay;
        retryCount = 0;
      }
    };
  }
  function defaultBackoff(maxDelayMillis) {
    return function(baseDelayMillis, retryCount) {
      var d = baseDelayMillis * Math.pow(2, retryCount);
      return d > maxDelayMillis ? maxDelayMillis : d;
    };
  }
  function defaultJitter(ratio) {
    return function(computedDelayMillis) {
      return computedDelayMillis - Math.trunc(Math.random() * ratio * computedDelayMillis);
    };
  }
  module.exports = {
    RetryDelayStrategy,
    defaultBackoff,
    defaultJitter
  };
});

// node_modules/launchdarkly-eventsource/lib/capacity.js
var require_capacity = __commonJS((exports, module) => {
  function CalculateCapacity(currentCapacity, requiredCapacity, maxOverAllocation) {
    if (requiredCapacity > currentCapacity) {
      let newCapacity = requiredCapacity;
      if (newCapacity < Buffer.poolSize) {
        newCapacity = Buffer.poolSize;
      }
      let doubleCapacity = currentCapacity * 2;
      if (newCapacity < doubleCapacity) {
        newCapacity = doubleCapacity;
      }
      const overAllocation = newCapacity - requiredCapacity;
      if (overAllocation > maxOverAllocation) {
        newCapacity = requiredCapacity + maxOverAllocation;
      }
      return [true, newCapacity];
    }
    return [false, 0];
  }
  module.exports = CalculateCapacity;
});

// node_modules/launchdarkly-eventsource/lib/eventsource.js
var require_eventsource = __commonJS((exports, module) => {
  var retryDelay = require_retry_delay();
  var CalculateCapacity = require_capacity();
  var parse2 = __require("url").parse;
  var URL2 = __require("url").URL;
  var events = __require("events");
  var https = __require("https");
  var http = __require("http");
  var util = __require("util");
  var httpsOptions = [
    "pfx",
    "key",
    "passphrase",
    "cert",
    "ca",
    "ciphers",
    "rejectUnauthorized",
    "secureProtocol",
    "servername",
    "checkServerIdentity"
  ];
  var bom = [239, 187, 191];
  var colon = 58;
  var space = 32;
  var lineFeed = 10;
  var carriageReturn = 13;
  var MAX_OVER_ALLOCATION = 1024 * 1024;
  function hasBom(buf) {
    return bom.every(function(charCode, index) {
      return buf[index] === charCode;
    });
  }
  function once(cb) {
    let called = false;
    return (...params) => {
      if (!called) {
        called = true;
        cb(...params);
      }
    };
  }
  function EventSource(url, eventSourceInitDict) {
    var readyState = EventSource.CONNECTING;
    var config = eventSourceInitDict || {};
    Object.defineProperty(this, "readyState", {
      get: function() {
        return readyState;
      }
    });
    Object.defineProperty(this, "url", {
      get: function() {
        return url;
      }
    });
    var self2 = this;
    self2.reconnectInterval = 1000;
    var req;
    var lastEventId = "";
    if (config.headers && config.headers["Last-Event-ID"]) {
      lastEventId = config.headers["Last-Event-ID"];
    }
    var discardTrailingNewline = false;
    var data, eventName, eventId;
    var reconnectUrl = null;
    var retryDelayStrategy = new retryDelay.RetryDelayStrategy(config.initialRetryDelayMillis !== null && config.initialRetryDelayMillis !== undefined ? config.initialRetryDelayMillis : 1000, config.retryResetIntervalMillis, config.maxBackoffMillis ? retryDelay.defaultBackoff(config.maxBackoffMillis) : null, config.jitterRatio ? retryDelay.defaultJitter(config.jitterRatio) : null);
    var streamOriginUrl = new URL2(url).origin;
    let reconnectTimer;
    function makeRequestUrlAndOptions() {
      var actualUrl = url;
      var options = { headers: {} };
      if (!config.skipDefaultHeaders) {
        options.headers["Cache-Control"] = "no-cache";
        options.headers["Accept"] = "text/event-stream";
      }
      if (lastEventId)
        options.headers["Last-Event-ID"] = lastEventId;
      if (config.headers) {
        for (var key in config.headers) {
          if (config.headers.hasOwnProperty(key)) {
            options.headers[key] = config.headers[key];
          }
        }
      }
      options.rejectUnauthorized = !!config.rejectUnauthorized;
      if (config.proxy) {
        actualUrl = null;
        var parsedUrl = parse2(url);
        var proxy = parse2(config.proxy);
        options.protocol = proxy.protocol === "https:" ? "https:" : "http:";
        options.path = url;
        options.headers.Host = parsedUrl.host;
        options.hostname = proxy.hostname;
        options.host = proxy.host;
        options.port = proxy.port;
        if (proxy.username) {
          options.auth = proxy.username + ":" + proxy.password;
        }
      }
      if (config.agent) {
        options.agent = config.agent;
      }
      if (config.https) {
        for (var optName in config.https) {
          if (httpsOptions.indexOf(optName) === -1) {
            continue;
          }
          var option = config.https[optName];
          if (option !== undefined) {
            options[optName] = option;
          }
        }
      }
      if (config.withCredentials !== undefined) {
        options.withCredentials = config.withCredentials;
      }
      if (config.method) {
        options.method = config.method;
      }
      return { url: actualUrl, options };
    }
    function defaultErrorFilter(error) {
      if (error.status) {
        var s = error.status;
        return s === 500 || s === 502 || s === 503 || s === 504;
      }
      return true;
    }
    function failed(error) {
      if (readyState === EventSource.CLOSED) {
        return;
      }
      var errorEvent = error ? new Event("error", error) : new Event("end", { message: "the request completed unexpectedly" });
      var shouldRetry = (config.errorFilter || defaultErrorFilter)(errorEvent);
      if (shouldRetry) {
        readyState = EventSource.CONNECTING;
        _emit(errorEvent);
        scheduleReconnect();
      } else {
        _emit(errorEvent);
        readyState = EventSource.CLOSED;
        _emit(new Event("closed"));
      }
    }
    function scheduleReconnect() {
      if (readyState !== EventSource.CONNECTING)
        return;
      var delay = retryDelayStrategy.nextRetryDelay(new Date().getTime());
      if (reconnectUrl) {
        url = reconnectUrl;
        reconnectUrl = null;
      }
      var event = new Event("retrying");
      event.delayMillis = delay;
      _emit(event);
      clearTimeout(reconnectTimer);
      reconnectTimer = setTimeout(function() {
        if (readyState !== EventSource.CONNECTING)
          return;
        connect2();
      }, delay);
    }
    function destroyRequest() {
      if (req.destroy)
        req.destroy();
      if (req.xhr && req.xhr.abort)
        req.xhr.abort();
    }
    function connect2() {
      var urlAndOptions = makeRequestUrlAndOptions();
      var isSecure = urlAndOptions.options.protocol === "https:" || urlAndOptions.url && urlAndOptions.url.startsWith("https:");
      const failOnce = once(failed);
      var callback = function(res) {
        if (res.statusCode === 301 || res.statusCode === 307) {
          if (!res.headers.location) {
            failOnce({ status: res.statusCode, headers: res.headers, message: res.statusMessage });
            return;
          }
          if (res.statusCode === 307)
            reconnectUrl = url;
          url = res.headers.location;
          process.nextTick(connect2);
          return;
        }
        if (res.statusCode !== 200) {
          failOnce({ status: res.statusCode, headers: res.headers, message: res.statusMessage });
          return;
        }
        data = "";
        eventName = "";
        eventId = undefined;
        readyState = EventSource.OPEN;
        res.on("close", function() {
          res.removeAllListeners("close");
          res.removeAllListeners("end");
          failOnce();
        });
        res.on("end", function() {
          res.removeAllListeners("close");
          res.removeAllListeners("end");
          failOnce();
        });
        _emit(new Event("open", { headers: res.headers }));
        var isFirst = true;
        var buf;
        var startingPos = 0;
        var startingFieldLength = -1;
        let sizeUsed = 0;
        res.on("data", function(chunk) {
          if (!buf) {
            buf = chunk;
            if (isFirst && hasBom(buf)) {
              buf = buf.slice(bom.length);
              sizeUsed -= bom.length;
            }
          } else {
            const [resize, newCapacity] = CalculateCapacity(buf.length, chunk.length + sizeUsed, MAX_OVER_ALLOCATION);
            if (resize) {
              let newBuffer = Buffer.alloc(newCapacity);
              buf.copy(newBuffer, 0, 0, sizeUsed);
              buf = newBuffer;
            }
            chunk.copy(buf, sizeUsed);
          }
          sizeUsed += chunk.length;
          isFirst = false;
          let pos = 0;
          const length = sizeUsed;
          while (pos < length) {
            if (discardTrailingNewline) {
              if (buf[pos] === lineFeed) {
                ++pos;
              }
              discardTrailingNewline = false;
            }
            var lineLength = -1;
            var fieldLength = startingFieldLength;
            var c;
            for (var i2 = startingPos;lineLength < 0 && i2 < length; ++i2) {
              c = buf[i2];
              if (c === colon) {
                if (fieldLength < 0) {
                  fieldLength = i2 - pos;
                }
              } else if (c === carriageReturn) {
                discardTrailingNewline = true;
                lineLength = i2 - pos;
              } else if (c === lineFeed) {
                lineLength = i2 - pos;
              }
            }
            if (lineLength < 0) {
              startingPos = length - pos;
              startingFieldLength = fieldLength;
              break;
            } else {
              startingPos = 0;
              startingFieldLength = -1;
            }
            parseEventStreamLine(buf, pos, fieldLength, lineLength);
            pos += lineLength + 1;
          }
          if (pos === length) {
            buf = undefined;
            sizeUsed = 0;
          } else if (pos > 0) {
            buf = buf.slice(pos);
            sizeUsed = sizeUsed - pos;
          }
        });
      };
      var api = isSecure ? https : http;
      req = urlAndOptions.url ? api.request(urlAndOptions.url, urlAndOptions.options, callback) : api.request(urlAndOptions.options, callback);
      if (config.readTimeoutMillis) {
        req.setTimeout(config.readTimeoutMillis);
      }
      if (config.body) {
        req.write(config.body);
      }
      req.on("error", function(err) {
        failOnce({ message: err.message });
      });
      req.on("timeout", function() {
        failOnce({ message: "Read timeout, received no data in " + config.readTimeoutMillis + "ms, assuming connection is dead" });
        destroyRequest();
      });
      if (req.setNoDelay)
        req.setNoDelay(true);
      req.end();
    }
    connect2();
    function _emit(event) {
      if (event) {
        self2.emit(event.type, event);
      }
    }
    this._close = function() {
      clearTimeout(reconnectTimer);
      if (readyState === EventSource.CLOSED)
        return;
      readyState = EventSource.CLOSED;
      destroyRequest();
      _emit(new Event("closed"));
    };
    function receivedEvent(event) {
      retryDelayStrategy.setGoodSince(new Date().getTime());
      _emit(event);
    }
    function parseEventStreamLine(buf, pos, fieldLength, lineLength) {
      if (lineLength === 0) {
        if (data.length > 0) {
          var type = eventName || "message";
          if (eventId !== undefined) {
            lastEventId = eventId;
          }
          var event = new MessageEvent(type, {
            data: data.slice(0, -1),
            lastEventId,
            origin: streamOriginUrl
          });
          data = "";
          eventId = undefined;
          receivedEvent(event);
        }
        eventName = undefined;
      } else {
        var noValue = fieldLength < 0;
        var step = 0;
        var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();
        if (noValue) {
          step = lineLength;
        } else if (buf[pos + fieldLength + 1] !== space) {
          step = fieldLength + 1;
        } else {
          step = fieldLength + 2;
        }
        pos += step;
        var valueLength = lineLength - step;
        var value = buf.slice(pos, pos + valueLength).toString();
        if (field === "data") {
          data += value + `
`;
        } else if (field === "event") {
          eventName = value;
        } else if (field === "id") {
          if (!value.includes("\x00")) {
            eventId = value;
          }
        } else if (field === "retry") {
          var retry = parseInt(value, 10);
          if (!Number.isNaN(retry)) {
            self2.reconnectInterval = retry;
            retryDelayStrategy.setBaseDelay(retry);
          }
        }
      }
    }
  }
  module.exports = {
    EventSource
  };
  util.inherits(EventSource, events.EventEmitter);
  EventSource.prototype.constructor = EventSource;
  ["open", "end", "error", "message", "retrying", "closed"].forEach(function(method) {
    Object.defineProperty(EventSource.prototype, "on" + method, {
      get: function get() {
        var listener = this.listeners(method)[0];
        return listener ? listener._listener ? listener._listener : listener : undefined;
      },
      set: function set(listener) {
        this.removeAllListeners(method);
        this.addEventListener(method, listener);
      }
    });
  });
  Object.defineProperty(EventSource, "CONNECTING", { enumerable: true, value: 0 });
  Object.defineProperty(EventSource, "OPEN", { enumerable: true, value: 1 });
  Object.defineProperty(EventSource, "CLOSED", { enumerable: true, value: 2 });
  EventSource.prototype.CONNECTING = 0;
  EventSource.prototype.OPEN = 1;
  EventSource.prototype.CLOSED = 2;
  var supportedOptions = [
    "errorFilter",
    "headers",
    "https",
    "initialRetryDelayMillis",
    "jitterRatio",
    "maxBackoffMillis",
    "method",
    "proxy",
    "retryResetIntervalMillis",
    "skipDefaultHeaders",
    "withCredentials"
  ];
  var supportedOptionsObject = {};
  for (i in supportedOptions) {
    Object.defineProperty(supportedOptionsObject, supportedOptions[i], { enumerable: true, value: true });
  }
  var i;
  Object.defineProperty(EventSource, "supportedOptions", { enumerable: true, value: supportedOptionsObject });
  EventSource.prototype.close = function() {
    this._close();
  };
  EventSource.prototype.addEventListener = function addEventListener(type, listener) {
    if (typeof listener === "function") {
      listener._listener = listener;
      this.on(type, listener);
    }
  };
  EventSource.prototype.dispatchEvent = function dispatchEvent(event) {
    if (!event.type) {
      throw new Error("UNSPECIFIED_EVENT_TYPE_ERR");
    }
    this.emit(event.type, event.detail);
  };
  EventSource.prototype.removeEventListener = function removeEventListener(type, listener) {
    if (typeof listener === "function") {
      listener._listener = undefined;
      this.removeListener(type, listener);
    }
  };
  function Event(type, optionalProperties) {
    Object.defineProperty(this, "type", { writable: false, value: type, enumerable: true });
    if (optionalProperties) {
      for (var f in optionalProperties) {
        if (optionalProperties.hasOwnProperty(f)) {
          Object.defineProperty(this, f, { writable: false, value: optionalProperties[f], enumerable: true });
        }
      }
    }
  }
  function MessageEvent(type, eventInitDict) {
    Object.defineProperty(this, "type", { writable: false, value: type, enumerable: true });
    for (var f in eventInitDict) {
      if (eventInitDict.hasOwnProperty(f)) {
        Object.defineProperty(this, f, { writable: false, value: eventInitDict[f], enumerable: true });
      }
    }
  }
});

// node_modules/unleash-client/lib/event-source.js
var require_event_source = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventSource = undefined;
  var launchdarkly_eventsource_1 = require_eventsource();
  exports.EventSource = launchdarkly_eventsource_1.EventSource;
});

// node_modules/unleash-client/lib/repository/streaming-fail-over.js
var require_streaming_fail_over = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FailoverStrategy = undefined;
  var FAILOVER_SERVER_HINTS = ["polling"];
  var HARD_FAILOVER_STATUS_CODES = [401, 403, 404, 429, 501];
  var SOFT_FAILOVER_STATUS_CODES = [408, 500, 502, 503, 504];

  class FailoverStrategy {
    maxFails;
    relaxTimeMs;
    failures = [];
    constructor(maxFails, relaxTimeMs) {
      this.maxFails = maxFails;
      this.relaxTimeMs = relaxTimeMs;
    }
    shouldFailover(event, now = new Date) {
      const nowMs = now.getTime();
      this.pruneOldFailures(nowMs);
      switch (event.type) {
        case "http-status-error":
          return this.handleHttpStatus(event);
        case "server-hint":
          return this.handleServerEvent(event);
        case "network-error":
          return this.handleNetwork(event);
      }
    }
    handleServerEvent(event) {
      if (FAILOVER_SERVER_HINTS.includes(event.event)) {
        return true;
      }
      return false;
    }
    handleNetwork(event) {
      return this.hasTooManyFails(event);
    }
    handleHttpStatus(event) {
      if (HARD_FAILOVER_STATUS_CODES.includes(event.statusCode)) {
        return true;
      } else if (SOFT_FAILOVER_STATUS_CODES.includes(event.statusCode)) {
        return this.hasTooManyFails(event);
      }
      return false;
    }
    hasTooManyFails(event) {
      this.failures.push(event);
      return this.failures.length >= this.maxFails;
    }
    pruneOldFailures(nowMs) {
      const cutoff = nowMs - this.relaxTimeMs;
      let write = 0;
      for (let read = 0;read < this.failures.length; read++) {
        if (this.failures[read].occurredAt.getTime() >= cutoff) {
          this.failures[write++] = this.failures[read];
        }
      }
      this.failures.length = write;
    }
  }
  exports.FailoverStrategy = FailoverStrategy;
});

// node_modules/unleash-client/lib/repository/streaming-fetcher.js
var require_streaming_fetcher = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamingFetcher = undefined;
  var node_events_1 = __require("node:events");
  var event_source_1 = require_event_source();
  var events_1 = require_events();
  var feature_1 = require_feature();
  var request_1 = require_request2();
  var url_utils_1 = require_url_utils();
  var streaming_fail_over_1 = require_streaming_fail_over();

  class StreamingFetcher extends node_events_1.EventEmitter {
    eventSource;
    url;
    appName;
    instanceId;
    headers;
    connectionId;
    onSave;
    onModeChange;
    failoverStrategy;
    constructor({ url, appName, instanceId, headers, connectionId, eventSource, maxFailuresUntilFailover = 5, failureWindowMs = 60000, onSave, onModeChange }) {
      super();
      this.url = url;
      this.appName = appName;
      this.instanceId = instanceId;
      this.headers = headers;
      this.connectionId = connectionId;
      this.onSave = onSave;
      this.onModeChange = onModeChange;
      this.eventSource = eventSource;
      this.failoverStrategy = new streaming_fail_over_1.FailoverStrategy(maxFailuresUntilFailover, failureWindowMs);
    }
    setupEventSource() {
      if (this.eventSource) {
        this.eventSource.addEventListener("unleash-connected", async (event) => {
          await this.handleFlagsFromStream(event);
        });
        this.eventSource.addEventListener("unleash-updated", this.handleFlagsFromStream.bind(this));
        this.eventSource.addEventListener("error", this.handleErrorEvent.bind(this));
        this.eventSource.addEventListener("end", this.handleServerDisconnect.bind(this));
        this.eventSource.addEventListener("fetch-mode", this.handleModeChange.bind(this));
      }
    }
    async handleErrorEvent(error) {
      const now = new Date;
      const statusCode = typeof error === "object" && error !== null && typeof error.status === "number" ? error.status : undefined;
      const message3 = typeof error === "string" ? error : typeof error === "object" && error !== null && typeof error.message === "string" ? error.message : undefined;
      const failEvent = typeof statusCode === "number" ? {
        type: "http-status-error",
        message: message3 ?? `Stream failed with http status code ${statusCode}`,
        statusCode,
        occurredAt: now
      } : {
        type: "network-error",
        message: message3 ?? "Network error occurred in streaming",
        occurredAt: now
      };
      await this.handleFailoverDecision(failEvent);
    }
    async handleServerDisconnect() {
      const failEvent = {
        type: "network-error",
        message: "Server closed the streaming connection",
        occurredAt: new Date
      };
      await this.handleFailoverDecision(failEvent);
    }
    async handleFailoverDecision(event) {
      const now = new Date;
      const shouldFailover = this.failoverStrategy.shouldFailover(event, now);
      if (!shouldFailover) {
        return;
      }
      this.emit(events_1.UnleashEvents.Warn, event.message);
      if (this.onModeChange) {
        await this.onModeChange("polling");
      }
    }
    async handleFlagsFromStream(event) {
      try {
        const data = (0, feature_1.parseApiResponse)(JSON.parse(event.data));
        await this.onSave(data, true);
      } catch (err) {
        const errorMessage = err instanceof Error && typeof err.message === "string" ? err.message : String(err);
        this.emit(events_1.UnleashEvents.Warn, `Requesting full re-hydration to prevent data loss because of a failed event process: ${errorMessage}`);
        this.forceRehydration();
      }
    }
    async handleModeChange(event) {
      const newMode = event.data;
      if (newMode === "polling") {
        await this.handleFailoverDecision({
          type: "server-hint",
          event: `polling`,
          message: "Server has explicitly requested switching to polling mode",
          occurredAt: new Date
        });
      }
    }
    forceRehydration() {
      if (!this.eventSource) {
        return;
      }
      const currentEventSource = this.eventSource;
      this.eventSource = undefined;
      currentEventSource?.close();
      this.eventSource = this.createEventSource();
      this.setupEventSource();
    }
    createEventSource() {
      return new event_source_1.EventSource((0, url_utils_1.resolveUrl)(this.url, "./client/streaming"), {
        headers: (0, request_1.buildHeaders)({
          appName: this.appName,
          instanceId: this.instanceId,
          etag: undefined,
          contentType: undefined,
          custom: this.headers,
          specVersionSupported: "5.2.0",
          connectionId: this.connectionId
        }),
        readTimeoutMillis: 60000,
        initialRetryDelayMillis: 2000,
        maxBackoffMillis: 30000,
        retryResetIntervalMillis: 60000,
        jitterRatio: 0.5,
        errorFilter: () => true
      });
    }
    async start() {
      if (!this.eventSource) {
        this.eventSource = this.createEventSource();
      }
      this.setupEventSource();
    }
    stop() {
      if (this.eventSource) {
        this.eventSource.close();
        this.eventSource = undefined;
      }
    }
  }
  exports.StreamingFetcher = StreamingFetcher;
});

// node_modules/unleash-client/lib/repository/adaptive-fetcher.js
var require_adaptive_fetcher = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AdaptiveFetcher = undefined;
  var node_events_1 = __require("node:events");
  var events_1 = require_events();
  var polling_fetcher_1 = require_polling_fetcher();
  var streaming_fetcher_1 = require_streaming_fetcher();

  class AdaptiveFetcher extends node_events_1.EventEmitter {
    currentFetcher;
    pollingFetcher;
    streamingFetcher;
    options;
    stopped = false;
    constructor(options) {
      super();
      this.options = { ...options, onModeChange: this.handleModeChange.bind(this) };
      this.pollingFetcher = new polling_fetcher_1.PollingFetcher(this.options);
      this.streamingFetcher = new streaming_fetcher_1.StreamingFetcher(this.options);
      this.setupFetcherEventForwarding(this.pollingFetcher);
      this.setupFetcherEventForwarding(this.streamingFetcher);
      this.currentFetcher = this.options.mode.type === "streaming" ? this.streamingFetcher : this.pollingFetcher;
    }
    setupFetcherEventForwarding(fetcher) {
      fetcher.on(events_1.UnleashEvents.Error, (err) => this.emit(events_1.UnleashEvents.Error, err));
      fetcher.on(events_1.UnleashEvents.Warn, (msg) => this.emit(events_1.UnleashEvents.Warn, msg));
      fetcher.on(events_1.UnleashEvents.Unchanged, () => this.emit(events_1.UnleashEvents.Unchanged));
    }
    async handleModeChange(newMode) {
      if (this.stopped) {
        return;
      }
      if (newMode === "polling") {
        await this.switchToPolling();
      } else if (newMode === "streaming") {
        await this.switchToStreaming();
      }
    }
    async switchToPolling() {
      if (this.currentFetcher === this.pollingFetcher) {
        return;
      }
      this.currentFetcher.stop();
      this.currentFetcher = this.pollingFetcher;
      await this.currentFetcher.start();
      this.emit(events_1.UnleashEvents.Mode, { from: "streaming", to: "polling" });
    }
    async switchToStreaming() {
      if (this.currentFetcher === this.streamingFetcher) {
        return;
      }
      this.currentFetcher.stop();
      this.currentFetcher = this.streamingFetcher;
      await this.currentFetcher.start();
      this.emit(events_1.UnleashEvents.Mode, { from: "polling", to: "streaming" });
    }
    async start() {
      await this.currentFetcher.start();
    }
    async setMode(mode) {
      await this.handleModeChange(mode);
    }
    stop() {
      this.stopped = true;
      this.currentFetcher.stop();
      this.pollingFetcher.stop();
      this.streamingFetcher.stop();
    }
    getMode() {
      if (this.currentFetcher === this.streamingFetcher) {
        return "streaming";
      }
      return "polling";
    }
    getFailures() {
      return this.pollingFetcher.getFailures();
    }
    nextFetch() {
      return this.pollingFetcher.nextFetch();
    }
    async fetch() {
      if (this.currentFetcher === this.pollingFetcher) {
        return this.pollingFetcher.fetch();
      }
    }
    getEtag() {
      return this.pollingFetcher.getEtag();
    }
    setEtag(value) {
      this.pollingFetcher.setEtag(value);
    }
  }
  exports.AdaptiveFetcher = AdaptiveFetcher;
});

// node_modules/unleash-client/lib/repository/index.js
var require_repository = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SUPPORTED_SPEC_VERSION = undefined;
  var node_events_1 = __require("node:events");
  var events_1 = require_events();
  var feature_1 = require_feature();
  var adaptive_fetcher_1 = require_adaptive_fetcher();
  exports.SUPPORTED_SPEC_VERSION = "5.2.0";

  class Repository extends node_events_1.EventEmitter {
    appName;
    bootstrapProvider;
    bootstrapOverride;
    storageProvider;
    ready = false;
    connected = false;
    stopped = false;
    data = {};
    segments;
    fetcher;
    url;
    projectName;
    get etag() {
      return this.fetcher.getEtag?.() || undefined;
    }
    set etag(value) {
      this.fetcher.setEtag?.(value);
    }
    constructor({ url, appName, instanceId, connectionId, projectName, refreshInterval = 15000, timeout, headers, customHeadersFunction, httpOptions, namePrefix, tags, bootstrapProvider, bootstrapOverride = true, storageProvider, eventSource, mode }) {
      super();
      this.appName = appName;
      this.url = url;
      this.projectName = projectName;
      this.bootstrapProvider = bootstrapProvider;
      this.bootstrapOverride = bootstrapOverride;
      this.storageProvider = storageProvider;
      this.segments = new Map;
      this.fetcher = new adaptive_fetcher_1.AdaptiveFetcher({
        url,
        appName,
        instanceId,
        connectionId,
        refreshInterval,
        timeout,
        headers,
        customHeadersFunction,
        httpOptions,
        namePrefix,
        tags,
        projectName,
        mode,
        eventSource,
        onSave: this.save.bind(this)
      });
      this.setupFetchingStrategyEvents();
    }
    setupFetchingStrategyEvents() {
      this.fetcher.on(events_1.UnleashEvents.Error, (err) => this.emit(events_1.UnleashEvents.Error, err));
      this.fetcher.on(events_1.UnleashEvents.Warn, (msg) => this.emit(events_1.UnleashEvents.Warn, msg));
      this.fetcher.on(events_1.UnleashEvents.Unchanged, () => this.emit(events_1.UnleashEvents.Unchanged));
      this.fetcher.on(events_1.UnleashEvents.Mode, (data) => this.emit(events_1.UnleashEvents.Mode, data));
    }
    validateFeature(feature) {
      const errors = [];
      if (!Array.isArray(feature.strategies)) {
        errors.push(`feature.strategies should be an array, but was ${typeof feature.strategies}`);
      }
      if (feature.variants && !Array.isArray(feature.variants)) {
        errors.push(`feature.variants should be an array, but was ${typeof feature.variants}`);
      }
      if (typeof feature.enabled !== "boolean") {
        errors.push(`feature.enabled should be an boolean, but was ${typeof feature.enabled}`);
      }
      if (errors.length > 0) {
        const err = new Error(errors.join(", "));
        this.emit(events_1.UnleashEvents.Error, err);
      }
    }
    async start() {
      await Promise.all([this.fetcher.start(), this.loadBackup(), this.loadBootstrap()]);
    }
    async loadBackup() {
      try {
        const content = await this.storageProvider.get(this.appName);
        if (this.ready) {
          return;
        }
        if (content && this.notEmpty(content)) {
          this.data = this.convertToMap(content.features);
          this.segments = this.createSegmentLookup(content.segments);
          this.setReady();
        }
      } catch (err) {
        this.emit(events_1.UnleashEvents.Warn, err);
      }
    }
    setReady() {
      const doEmitReady = this.ready === false;
      this.ready = true;
      if (doEmitReady) {
        process.nextTick(() => {
          this.emit(events_1.UnleashEvents.Ready);
        });
      }
    }
    createSegmentLookup(segments) {
      if (!segments) {
        return new Map;
      }
      return new Map(segments.map((segment) => [segment.id, segment]));
    }
    async save(response, fromApi) {
      if (this.stopped) {
        return;
      }
      if (fromApi) {
        this.connected = true;
        this.applyFeatureResponse(response);
      } else if (!this.connected) {
        this.applyFeatureResponse(response);
      }
      this.setReady();
      const newFeatures = Object.values(this.data);
      this.emit(events_1.UnleashEvents.Changed, newFeatures);
      const clientFeatureResponse = {
        version: "version" in response ? response.version : 2,
        features: newFeatures,
        segments: [...this.segments.values()]
      };
      await this.storageProvider.set(this.appName, clientFeatureResponse);
    }
    applyFeatureResponse(response) {
      switch (response.type) {
        case "delta": {
          response.events.forEach((event) => {
            switch (event.type) {
              case "feature-updated": {
                this.data[event.feature.name] = event.feature;
                break;
              }
              case "feature-removed": {
                delete this.data[event.featureName];
                break;
              }
              case "segment-updated": {
                this.segments.set(event.segment.id, event.segment);
                break;
              }
              case "segment-removed": {
                this.segments.delete(event.segmentId);
                break;
              }
              case "hydration": {
                this.data = this.convertToMap(event.features);
                this.segments = this.createSegmentLookup(event.segments);
                break;
              }
              default: {
                this.emit(events_1.UnleashEvents.Warn, `Unknown event type received, this may or may not cause features to evaluate incorrectly: ${JSON.stringify(event)}`);
                break;
              }
            }
          });
          break;
        }
        case "full": {
          this.data = this.convertToMap(response.features);
          this.segments = this.createSegmentLookup(response.segments);
          break;
        }
        default: {
          assertNever(response);
        }
      }
    }
    notEmpty(content) {
      return content.features.length > 0;
    }
    async loadBootstrap() {
      try {
        const content = await this.bootstrapProvider.readBootstrap();
        if (!this.bootstrapOverride && this.ready) {
          return;
        }
        if (content && this.notEmpty(content)) {
          await this.save((0, feature_1.parseApiResponse)(content), false);
        }
      } catch (err) {
        const message3 = err instanceof Error ? err.message : "Unknown error";
        this.emit(events_1.UnleashEvents.Warn, `Unleash SDK was unable to load bootstrap.
Message: ${message3}`);
      }
    }
    convertToMap(features) {
      const result = {};
      if (!features?.length)
        return {};
      for (const feature of features) {
        this.validateFeature(feature);
        result[feature.name] = feature;
      }
      return result;
    }
    stop() {
      this.stopped = true;
      this.fetcher.stop();
      this.removeAllListeners();
    }
    getSegment(segmentId) {
      return this.segments.get(segmentId);
    }
    getToggle(name) {
      return this.data[name];
    }
    getToggles() {
      return Object.keys(this.data).map((key) => this.data[key]);
    }
    getTogglesWithSegmentData() {
      const toggles = this.getToggles();
      return toggles.map((toggle) => {
        const { strategies, ...restOfToggle } = toggle;
        return { ...restOfToggle, strategies: this.enhanceStrategies(strategies) };
      });
    }
    getMode() {
      return this.fetcher.getMode();
    }
    async setMode(mode) {
      await this.fetcher.setMode(mode);
    }
    getFailures() {
      return this.fetcher.getFailures();
    }
    nextFetch() {
      return this.fetcher.nextFetch();
    }
    async fetch() {
      return this.fetcher.fetch();
    }
    enhanceStrategies = (strategies) => {
      return strategies?.map((strategy) => {
        const { segments, ...restOfStrategy } = strategy;
        const enhancedSegments = segments?.map((segment) => this.getSegment(segment));
        return { ...restOfStrategy, segments: enhancedSegments };
      });
    };
  }
  exports.default = Repository;
  var assertNever = (value) => {
    throw new Error(`Unexpected value: ${JSON.stringify(value)}`);
  };
});

// node_modules/unleash-client/lib/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var node_events_1 = __require("node:events");
  var details_json_1 = require_details();
  var events_1 = require_events();
  var helpers_1 = require_helpers();
  var repository_1 = require_repository();
  var request_1 = require_request2();
  var url_utils_1 = require_url_utils();

  class Metrics extends node_events_1.EventEmitter {
    bucket;
    appName;
    instanceId;
    connectionId;
    sdkVersion;
    strategies;
    metricsInterval;
    metricsJitter;
    failures = 0;
    disabled;
    url;
    timer;
    started;
    headers;
    customHeadersFunction;
    timeout;
    httpOptions;
    platformData;
    metricRegistry;
    constructor({ appName, instanceId, connectionId, strategies, metricsInterval = 0, metricsJitter = 0, disableMetrics = false, url, headers, customHeadersFunction, timeout, httpOptions, metricRegistry }) {
      super();
      this.disabled = disableMetrics;
      this.metricsInterval = metricsInterval;
      this.metricsJitter = metricsJitter;
      this.appName = appName;
      this.instanceId = instanceId;
      this.connectionId = connectionId;
      this.sdkVersion = details_json_1.sdkVersion;
      this.strategies = strategies;
      this.url = url;
      this.headers = headers;
      this.customHeadersFunction = customHeadersFunction;
      this.started = new Date;
      this.timeout = timeout;
      this.bucket = this.createBucket();
      this.httpOptions = httpOptions;
      this.platformData = this.getPlatformData();
      this.metricRegistry = metricRegistry;
    }
    getAppliedJitter() {
      return (0, helpers_1.getAppliedJitter)(this.metricsJitter);
    }
    getFailures() {
      return this.failures;
    }
    getInterval() {
      if (this.metricsInterval === 0) {
        return 0;
      } else {
        return this.metricsInterval + this.failures * this.metricsInterval + this.getAppliedJitter();
      }
    }
    startTimer() {
      if (this.disabled || this.getInterval() === 0) {
        return;
      }
      this.timer = setTimeout(() => {
        this.sendMetrics();
      }, this.getInterval());
      if (typeof this.timer.unref === "function") {
        this.timer.unref();
      }
    }
    start() {
      if (this.metricsInterval > 0) {
        this.startTimer();
        this.registerInstance();
      }
    }
    stop() {
      if (this.timer) {
        clearInterval(this.timer);
        delete this.timer;
      }
      this.disabled = true;
    }
    async registerInstance() {
      if (this.disabled) {
        return false;
      }
      const url = (0, url_utils_1.resolveUrl)((0, url_utils_1.suffixSlash)(this.url), "./client/register");
      const payload = this.getClientData();
      const headers = this.customHeadersFunction ? await this.customHeadersFunction() : this.headers;
      try {
        const res = await (0, request_1.post)({
          url,
          json: payload,
          appName: this.appName,
          instanceId: this.instanceId,
          connectionId: this.connectionId,
          headers,
          timeout: this.timeout,
          httpOptions: this.httpOptions
        });
        if (!res.ok) {
          this.emit(events_1.UnleashEvents.Warn, `${url} returning ${res.status}`, await res.text());
        } else {
          this.emit(events_1.UnleashEvents.Registered, payload);
        }
      } catch (err) {
        this.emit(events_1.UnleashEvents.Warn, err);
      }
      return true;
    }
    configurationError(url, statusCode) {
      this.emit(events_1.UnleashEvents.Warn, `${url} returning ${statusCode}, stopping metrics`);
      this.metricsInterval = 0;
      this.stop();
    }
    backoff(url, statusCode) {
      this.failures = Math.min(10, this.failures + 1);
      this.emit(events_1.UnleashEvents.Warn, `${url} returning ${statusCode}. Backing off to ${this.failures} times normal interval`);
      this.startTimer();
    }
    async sendMetrics() {
      if (this.disabled) {
        return;
      }
      const impactMetrics = this.metricRegistry?.collect() || [];
      if (this.bucketIsEmpty() && impactMetrics.length === 0) {
        this.resetBucket();
        this.startTimer();
        this.metricRegistry?.restore(impactMetrics);
        return;
      }
      const url = (0, url_utils_1.resolveUrl)((0, url_utils_1.suffixSlash)(this.url), "./client/metrics");
      const payload = this.createMetricsData(impactMetrics);
      const headers = this.customHeadersFunction ? await this.customHeadersFunction() : this.headers;
      try {
        const res = await (0, request_1.post)({
          url,
          json: payload,
          appName: this.appName,
          instanceId: this.instanceId,
          connectionId: this.connectionId,
          interval: this.metricsInterval,
          headers,
          timeout: this.timeout,
          httpOptions: this.httpOptions
        });
        if (!res.ok) {
          if (res.status === 403 || res.status === 401) {
            this.configurationError(url, res.status);
          } else if (res.status === 404 || res.status === 429 || res.status === 500 || res.status === 502 || res.status === 503 || res.status === 504) {
            this.backoff(url, res.status);
          }
          this.restoreBucket(payload.bucket);
          this.metricRegistry?.restore(impactMetrics);
        } else {
          this.emit(events_1.UnleashEvents.Sent, payload);
          this.reduceBackoff();
        }
      } catch (err) {
        this.restoreBucket(payload.bucket);
        this.metricRegistry?.restore(impactMetrics);
        this.emit(events_1.UnleashEvents.Warn, err);
        this.startTimer();
      }
    }
    reduceBackoff() {
      this.failures = Math.max(0, this.failures - 1);
      this.startTimer();
    }
    assertBucket(name) {
      if (this.disabled) {
        return;
      }
      if (!this.bucket.toggles[name]) {
        this.bucket.toggles[name] = {
          yes: 0,
          no: 0,
          variants: {}
        };
      }
    }
    count(name, enabled) {
      if (this.disabled) {
        return;
      }
      this.increaseCounter(name, enabled, 1);
      this.emit(events_1.UnleashEvents.Count, name, enabled);
    }
    countVariant(name, variantName) {
      if (this.disabled) {
        return;
      }
      this.increaseVariantCounter(name, variantName, 1);
      this.emit(events_1.UnleashEvents.CountVariant, name, variantName);
    }
    increaseCounter(name, enabled, inc = 1) {
      if (inc === 0) {
        return;
      }
      this.assertBucket(name);
      this.bucket.toggles[name][enabled ? "yes" : "no"] += inc;
    }
    increaseVariantCounter(name, variantName, inc = 1) {
      this.assertBucket(name);
      if (this.bucket.toggles[name].variants[variantName]) {
        this.bucket.toggles[name].variants[variantName] += inc;
      } else {
        this.bucket.toggles[name].variants[variantName] = inc;
      }
    }
    bucketIsEmpty() {
      return Object.keys(this.bucket.toggles).length === 0;
    }
    createBucket() {
      return {
        start: new Date,
        stop: undefined,
        toggles: {}
      };
    }
    resetBucket() {
      this.bucket = this.createBucket();
    }
    createMetricsData(impactMetrics) {
      const bucket = { ...this.bucket, stop: new Date };
      this.resetBucket();
      const base = {
        appName: this.appName,
        instanceId: this.instanceId,
        connectionId: this.connectionId,
        bucket,
        platformName: this.platformData.name,
        platformVersion: this.platformData.version,
        yggdrasilVersion: null,
        specVersion: repository_1.SUPPORTED_SPEC_VERSION
      };
      if (impactMetrics.length > 0) {
        base.impactMetrics = impactMetrics;
      }
      return base;
    }
    restoreBucket(bucket) {
      if (this.disabled) {
        return;
      }
      this.bucket.start = bucket.start;
      const { toggles } = bucket;
      Object.keys(toggles).forEach((toggleName) => {
        const toggle = toggles[toggleName];
        this.increaseCounter(toggleName, true, toggle.yes);
        this.increaseCounter(toggleName, false, toggle.no);
        Object.keys(toggle.variants).forEach((variant) => {
          this.increaseVariantCounter(toggleName, variant, toggle.variants[variant]);
        });
      });
    }
    getClientData() {
      return {
        appName: this.appName,
        instanceId: this.instanceId,
        sdkVersion: this.sdkVersion,
        strategies: this.strategies,
        started: this.started,
        interval: this.metricsInterval,
        connectionId: this.connectionId,
        platformName: this.platformData.name,
        platformVersion: this.platformData.version,
        yggdrasilVersion: null,
        specVersion: repository_1.SUPPORTED_SPEC_VERSION
      };
    }
    getPlatformData() {
      if (typeof Bun !== "undefined") {
        return { name: "bun", version: Bun.version };
      } else if (typeof Deno !== "undefined") {
        return { name: "deno", version: Deno.version.deno };
      } else if (typeof process !== "undefined" && process.versions && process.versions.node) {
        return { name: "node", version: process.versions.node };
      } else {
        return { name: "unknown", version: "unknown" };
      }
    }
  }
  exports.default = Metrics;
});

// node_modules/unleash-client/lib/repository/bootstrap-provider.js
var require_bootstrap_provider = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultBootstrapProvider = undefined;
  exports.resolveBootstrapProvider = resolveBootstrapProvider;
  var node_fs_1 = __require("node:fs");
  var make_fetch_happen_1 = __importDefault(require_lib12());
  var request_1 = require_request2();

  class DefaultBootstrapProvider {
    url;
    urlHeaders;
    filePath;
    data;
    segments;
    appName;
    instanceId;
    constructor(options, appName, instanceId) {
      this.url = options.url;
      this.urlHeaders = options.urlHeaders;
      this.filePath = options.filePath;
      this.data = options.data;
      this.segments = options.segments;
      this.appName = appName;
      this.instanceId = instanceId;
    }
    async loadFromUrl(bootstrapUrl) {
      const response = await (0, make_fetch_happen_1.default)(bootstrapUrl, {
        method: "GET",
        timeout: 1e4,
        headers: (0, request_1.buildHeaders)({
          appName: this.appName,
          instanceId: this.instanceId,
          etag: undefined,
          contentType: undefined,
          custom: this.urlHeaders
        }),
        retry: {
          retries: 2,
          maxTimeout: 1e4
        }
      });
      if (response.ok) {
        return response.json();
      }
      return;
    }
    async loadFromFile(filePath) {
      const fileContent = await node_fs_1.promises.readFile(filePath, "utf8");
      return JSON.parse(fileContent);
    }
    async readBootstrap() {
      if (this.data) {
        return { version: 2, segments: this.segments, features: [...this.data] };
      }
      if (this.url) {
        return this.loadFromUrl(this.url);
      }
      if (this.filePath) {
        return this.loadFromFile(this.filePath);
      }
      return;
    }
  }
  exports.DefaultBootstrapProvider = DefaultBootstrapProvider;
  function resolveBootstrapProvider(options, appName, instanceId) {
    return options.bootstrapProvider || new DefaultBootstrapProvider(options, appName, instanceId);
  }
});

// node_modules/unleash-client/lib/repository/storage-provider-file.js
var require_storage_provider_file = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var node_fs_1 = __require("node:fs");
  var node_path_1 = __require("node:path");
  var helpers_1 = require_helpers();
  var { writeFile, readFile } = node_fs_1.promises;

  class FileStorageProvider {
    backupPath;
    constructor(backupPath) {
      if (!backupPath) {
        throw new Error("backup Path is required");
      }
      this.backupPath = backupPath;
    }
    getPath(key) {
      return (0, node_path_1.join)(this.backupPath, `/unleash-backup-${(0, helpers_1.safeName)(key)}.json`);
    }
    async set(key, data) {
      return writeFile(this.getPath(key), JSON.stringify(data));
    }
    async get(key) {
      const path = this.getPath(key);
      let data;
      try {
        data = await readFile(path, "utf8");
      } catch (error) {
        if (typeof error === "object" && error && "code" in error && error.code === "ENOENT") {
          return;
        }
        throw error;
      }
      if (!data || data.trim().length === 0) {
        return;
      }
      try {
        return JSON.parse(data);
      } catch (error) {
        if (error instanceof Error) {
          error.message = `Unleash storage failed parsing file ${path}: ${error.message}`;
        }
        throw error;
      }
    }
  }
  exports.default = FileStorageProvider;
});

// node_modules/unleash-client/lib/strategy/strategy.js
var require_strategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Strategy = exports.Operator = undefined;
  var semver_1 = require_semver2();
  var helpers_1 = require_helpers();
  var variant_1 = require_variant();
  var Operator;
  (function(Operator2) {
    Operator2["IN"] = "IN";
    Operator2["NOT_IN"] = "NOT_IN";
    Operator2["STR_ENDS_WITH"] = "STR_ENDS_WITH";
    Operator2["STR_STARTS_WITH"] = "STR_STARTS_WITH";
    Operator2["STR_CONTAINS"] = "STR_CONTAINS";
    Operator2["NUM_EQ"] = "NUM_EQ";
    Operator2["NUM_GT"] = "NUM_GT";
    Operator2["NUM_GTE"] = "NUM_GTE";
    Operator2["NUM_LT"] = "NUM_LT";
    Operator2["NUM_LTE"] = "NUM_LTE";
    Operator2["DATE_AFTER"] = "DATE_AFTER";
    Operator2["DATE_BEFORE"] = "DATE_BEFORE";
    Operator2["SEMVER_EQ"] = "SEMVER_EQ";
    Operator2["SEMVER_GT"] = "SEMVER_GT";
    Operator2["SEMVER_LT"] = "SEMVER_LT";
  })(Operator || (exports.Operator = Operator = {}));
  var cleanValues = (values) => values.filter((v) => !!v).map((v) => v.trim());
  var isValidSemver = (version) => Boolean((0, semver_1.valid)(version)) && !version.startsWith("v");
  var InOperator = (constraint, context) => {
    const field = constraint.contextName;
    const values = cleanValues(constraint.values);
    const contextValue = (0, helpers_1.resolveContextValue)(context, field);
    const isIn = values.some((val) => val === contextValue);
    return constraint.operator === Operator.IN ? isIn : !isIn;
  };
  var StringOperator = (constraint, context) => {
    const { contextName, operator, caseInsensitive } = constraint;
    let values = cleanValues(constraint.values);
    let contextValue = (0, helpers_1.resolveContextValue)(context, contextName);
    if (caseInsensitive) {
      values = values.map((v) => v.toLocaleLowerCase());
      contextValue = contextValue?.toLocaleLowerCase();
    }
    if (typeof contextValue !== "string") {
      return false;
    }
    if (operator === Operator.STR_STARTS_WITH) {
      return values.some((val) => contextValue?.startsWith(val));
    }
    if (operator === Operator.STR_ENDS_WITH) {
      return values.some((val) => contextValue?.endsWith(val));
    }
    if (operator === Operator.STR_CONTAINS) {
      return values.some((val) => contextValue?.includes(val));
    }
    return false;
  };
  var SemverOperator = (constraint, context) => {
    const { contextName, operator } = constraint;
    const value = constraint.value;
    const contextValue = (0, helpers_1.resolveContextValue)(context, contextName);
    if (!contextValue) {
      return false;
    }
    try {
      if (!isValidSemver(contextValue)) {
        return false;
      }
      if (operator === Operator.SEMVER_EQ) {
        return (0, semver_1.eq)(contextValue, value);
      }
      if (operator === Operator.SEMVER_LT) {
        return (0, semver_1.lt)(contextValue, value);
      }
      if (operator === Operator.SEMVER_GT) {
        return (0, semver_1.gt)(contextValue, value);
      }
    } catch (_e) {
      return false;
    }
    return false;
  };
  var DateOperator = (constraint, context) => {
    const { operator } = constraint;
    const value = new Date(constraint.value);
    const currentTime = context.currentTime ? new Date(context.currentTime) : new Date;
    if (operator === Operator.DATE_AFTER) {
      return currentTime > value;
    }
    if (operator === Operator.DATE_BEFORE) {
      return currentTime < value;
    }
    return false;
  };
  var NumberOperator = (constraint, context) => {
    const field = constraint.contextName;
    const { operator } = constraint;
    const value = Number(constraint.value);
    const contextValue = Number((0, helpers_1.resolveContextValue)(context, field));
    if (Number.isNaN(value) || Number.isNaN(contextValue)) {
      return false;
    }
    if (operator === Operator.NUM_EQ) {
      return contextValue === value;
    }
    if (operator === Operator.NUM_GT) {
      return contextValue > value;
    }
    if (operator === Operator.NUM_GTE) {
      return contextValue >= value;
    }
    if (operator === Operator.NUM_LT) {
      return contextValue < value;
    }
    if (operator === Operator.NUM_LTE) {
      return contextValue <= value;
    }
    return false;
  };
  var operators = new Map;
  operators.set(Operator.IN, InOperator);
  operators.set(Operator.NOT_IN, InOperator);
  operators.set(Operator.STR_STARTS_WITH, StringOperator);
  operators.set(Operator.STR_ENDS_WITH, StringOperator);
  operators.set(Operator.STR_CONTAINS, StringOperator);
  operators.set(Operator.NUM_EQ, NumberOperator);
  operators.set(Operator.NUM_LT, NumberOperator);
  operators.set(Operator.NUM_LTE, NumberOperator);
  operators.set(Operator.NUM_GT, NumberOperator);
  operators.set(Operator.NUM_GTE, NumberOperator);
  operators.set(Operator.DATE_AFTER, DateOperator);
  operators.set(Operator.DATE_BEFORE, DateOperator);
  operators.set(Operator.SEMVER_EQ, SemverOperator);
  operators.set(Operator.SEMVER_GT, SemverOperator);
  operators.set(Operator.SEMVER_LT, SemverOperator);

  class Strategy {
    name;
    returnValue;
    constructor(name, returnValue = false) {
      this.name = name || "unknown";
      this.returnValue = returnValue;
    }
    checkConstraint(constraint, context) {
      const evaluator = operators.get(constraint.operator);
      if (!evaluator) {
        return false;
      }
      if (constraint.inverted) {
        return !evaluator(constraint, context);
      }
      return evaluator(constraint, context);
    }
    checkConstraints(context, constraints) {
      if (!constraints) {
        return true;
      }
      for (const constraint of constraints) {
        if (!constraint || !this.checkConstraint(constraint, context)) {
          return false;
        }
      }
      return true;
    }
    isEnabled(_parameters, _context) {
      return this.returnValue;
    }
    isEnabledWithConstraints(parameters, context, constraints) {
      return this.checkConstraints(context, constraints) && this.isEnabled(parameters, context);
    }
    getResult(parameters, context, constraints, variants) {
      const enabled = this.isEnabledWithConstraints(parameters, context, constraints);
      if (enabled && Array.isArray(variants) && variants.length > 0) {
        const stickiness = variants[0].stickiness || parameters.stickiness;
        const variantDefinition = (0, variant_1.selectVariantDefinition)(parameters.groupId, stickiness, variants, context);
        return variantDefinition ? {
          enabled: true,
          variant: {
            name: variantDefinition.name,
            enabled: true,
            payload: variantDefinition.payload
          }
        } : { enabled: true };
      }
      if (enabled) {
        return { enabled: true };
      }
      return { enabled: false };
    }
  }
  exports.Strategy = Strategy;
});

// node_modules/unleash-client/lib/strategy/application-hostname-strategy.js
var require_application_hostname_strategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var node_os_1 = __require("node:os");
  var strategy_1 = require_strategy();

  class ApplicationHostnameStrategy extends strategy_1.Strategy {
    hostname;
    constructor() {
      super("applicationHostname");
      this.hostname = (process.env.HOSTNAME || (0, node_os_1.hostname)() || "undefined").toLowerCase();
    }
    isEnabled(parameters) {
      if (!parameters.hostNames) {
        return false;
      }
      return parameters.hostNames.toLowerCase().split(/\s*,\s*/).includes(this.hostname);
    }
  }
  exports.default = ApplicationHostnameStrategy;
});

// node_modules/unleash-client/lib/strategy/default-strategy.js
var require_default_strategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var strategy_1 = require_strategy();

  class DefaultStrategy extends strategy_1.Strategy {
    constructor() {
      super("default");
    }
    isEnabled() {
      return true;
    }
  }
  exports.default = DefaultStrategy;
});

// node_modules/unleash-client/lib/strategy/flexible-rollout-strategy.js
var require_flexible_rollout_strategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers();
  var strategy_1 = require_strategy();
  var util_1 = require_util();
  var STICKINESS = {
    default: "default",
    random: "random"
  };

  class FlexibleRolloutStrategy extends strategy_1.Strategy {
    randomGenerator = () => `${Math.round(Math.random() * 1e4) + 1}`;
    constructor(randomGenerator) {
      super("flexibleRollout");
      if (randomGenerator) {
        this.randomGenerator = randomGenerator;
      }
    }
    resolveStickiness(stickiness, context) {
      switch (stickiness) {
        case STICKINESS.default:
          return context.userId || context.sessionId || this.randomGenerator();
        case STICKINESS.random:
          return this.randomGenerator();
        default:
          return (0, helpers_1.resolveContextValue)(context, stickiness);
      }
    }
    isEnabled(parameters, context) {
      const groupId = parameters.groupId || context.featureToggle || "";
      const percentage = Number(parameters.rollout);
      const stickiness = parameters.stickiness || STICKINESS.default;
      const stickinessId = this.resolveStickiness(stickiness, context);
      if (!stickinessId) {
        return false;
      }
      const normalizedUserId = (0, util_1.normalizedStrategyValue)(stickinessId, groupId);
      return percentage > 0 && normalizedUserId <= percentage;
    }
  }
  exports.default = FlexibleRolloutStrategy;
});

// node_modules/unleash-client/lib/strategy/gradual-rollout-random.js
var require_gradual_rollout_random = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var strategy_1 = require_strategy();

  class GradualRolloutRandomStrategy extends strategy_1.Strategy {
    randomGenerator = () => Math.floor(Math.random() * 100) + 1;
    constructor(randomGenerator) {
      super("gradualRolloutRandom");
      this.randomGenerator = randomGenerator || this.randomGenerator;
    }
    isEnabled(parameters, _context) {
      const percentage = Number(parameters.percentage);
      const random = this.randomGenerator();
      return percentage >= random;
    }
  }
  exports.default = GradualRolloutRandomStrategy;
});

// node_modules/unleash-client/lib/strategy/gradual-rollout-session-id.js
var require_gradual_rollout_session_id = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var strategy_1 = require_strategy();
  var util_1 = require_util();

  class GradualRolloutSessionIdStrategy extends strategy_1.Strategy {
    constructor() {
      super("gradualRolloutSessionId");
    }
    isEnabled(parameters, context) {
      const { sessionId } = context;
      if (!sessionId) {
        return false;
      }
      const percentage = Number(parameters.percentage);
      const groupId = parameters.groupId || "";
      const normalizedId = (0, util_1.normalizedStrategyValue)(sessionId, groupId);
      return percentage > 0 && normalizedId <= percentage;
    }
  }
  exports.default = GradualRolloutSessionIdStrategy;
});

// node_modules/unleash-client/lib/strategy/gradual-rollout-user-id.js
var require_gradual_rollout_user_id = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var strategy_1 = require_strategy();
  var util_1 = require_util();

  class GradualRolloutUserIdStrategy extends strategy_1.Strategy {
    constructor() {
      super("gradualRolloutUserId");
    }
    isEnabled(parameters, context) {
      const { userId } = context;
      if (!userId) {
        return false;
      }
      const percentage = Number(parameters.percentage);
      const groupId = parameters.groupId || "";
      const normalizedUserId = (0, util_1.normalizedStrategyValue)(userId, groupId);
      return percentage > 0 && normalizedUserId <= percentage;
    }
  }
  exports.default = GradualRolloutUserIdStrategy;
});

// node_modules/ip-address/dist/common.js
var require_common6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCorrect = exports.isInSubnet = undefined;
  function isInSubnet(address) {
    if (this.subnetMask < address.subnetMask) {
      return false;
    }
    if (this.mask(address.subnetMask) === address.mask()) {
      return true;
    }
    return false;
  }
  exports.isInSubnet = isInSubnet;
  function isCorrect(defaultBits) {
    return function() {
      if (this.addressMinusSuffix !== this.correctForm()) {
        return false;
      }
      if (this.subnetMask === defaultBits && !this.parsedSubnet) {
        return true;
      }
      return this.parsedSubnet === String(this.subnetMask);
    };
  }
  exports.isCorrect = isCorrect;
});

// node_modules/ip-address/dist/v4/constants.js
var require_constants6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RE_SUBNET_STRING = exports.RE_ADDRESS = exports.GROUPS = exports.BITS = undefined;
  exports.BITS = 32;
  exports.GROUPS = 4;
  exports.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
  exports.RE_SUBNET_STRING = /\/\d{1,2}$/;
});

// node_modules/ip-address/dist/address-error.js
var require_address_error2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AddressError = undefined;

  class AddressError extends Error {
    constructor(message3, parseMessage) {
      super(message3);
      this.name = "AddressError";
      if (parseMessage !== null) {
        this.parseMessage = parseMessage;
      }
    }
  }
  exports.AddressError = AddressError;
});

// node_modules/jsbn/index.js
var require_jsbn = __commonJS((exports, module) => {
  (function() {
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b, c) {
      if (a != null)
        if (typeof a == "number")
          this.fromNumber(a, b, c);
        else if (b == null && typeof a != "string")
          this.fromString(a, 256);
        else
          this.fromString(a, b);
    }
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this[i++] + w[j] + c;
        c = Math.floor(v / 67108864);
        w[j++] = v & 67108863;
      }
      return c;
    }
    function am2(i, x, w, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this[i] & 32767;
        var h = this[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w[j++] = l & 1073741823;
      }
      return c;
    }
    function am3(i, x, w, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this[i] & 16383;
        var h = this[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w[j++] = l & 268435455;
      }
      return c;
    }
    var inBrowser = typeof navigator !== "undefined";
    if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array;
    var rr, vv;
    rr = 48;
    for (vv = 0;vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = 97;
    for (vv = 10;vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = 65;
    for (vv = 10;vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i = this.t - 1;i >= 0; --i)
        r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0)
        this[0] = x;
      else if (x < -1)
        this[0] = x + this.DV;
      else
        this.t = 0;
    }
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s[i] & 255 : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this[this.t++] = x;
        else if (sh + k > this.DB) {
          this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this[this.t++] = x >> this.DB - sh;
        } else
          this[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
      var p = this.DB - i * this.DB % k;
      if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (this[i] & (1 << p) - 1) << k - p;
            d |= this[--i] >> (p += this.DB - k);
          } else {
            d = this[i] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0)
        return this.s < 0 ? -r : r;
      while (--i >= 0)
        if ((r = this[i] - a[i]) != 0)
          return r;
      return 0;
    }
    function nbits(x) {
      var r = 1, t2;
      if ((t2 = x >>> 16) != 0) {
        x = t2;
        r += 16;
      }
      if ((t2 = x >> 8) != 0) {
        x = t2;
        r += 8;
      }
      if ((t2 = x >> 4) != 0) {
        x = t2;
        r += 4;
      }
      if ((t2 = x >> 2) != 0) {
        x = t2;
        r += 2;
      }
      if ((t2 = x >> 1) != 0) {
        x = t2;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1;i >= 0; --i)
        r[i + n] = this[i];
      for (i = n - 1;i >= 0; --i)
        r[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i = n;i < this.t; ++i)
        r[i - n] = this[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
      for (i = this.t - 1;i >= 0; --i) {
        r[i + ds + 1] = this[i] >> cbs | c;
        c = (this[i] & bm) << bs;
      }
      for (i = ds - 1;i >= 0; --i)
        r[i] = 0;
      r[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r[0] = this[ds] >> bs;
      for (var i = ds + 1;i < this.t; ++i) {
        r[i - ds - 1] |= (this[i] & bm) << cbs;
        r[i - ds] = this[i] >> bs;
      }
      if (bs > 0)
        r[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this[i] - a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1)
        r[i++] = this.DV + c;
      else if (c > 0)
        r[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0)
        r[i] = 0;
      for (i = 0;i < y.t; ++i)
        r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0)
        r[i] = 0;
      for (i = 0;i < x.t - 1; ++i) {
        var c = x.am(i, x[i], r, 2 * i, 0, 1);
        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r[i + x.t] -= x.DV;
          r[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q, r) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null)
          q.fromInt(0);
        if (r != null)
          this.copyTo(r);
        return;
      }
      if (r == null)
        r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB - nbits(pm[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i = r.t, j = i - ys, t2 = q == null ? nbi() : q;
      y.dlShiftTo(j, t2);
      if (r.compareTo(t2) >= 0) {
        r[r.t++] = 1;
        r.subTo(t2, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t2);
      t2.subTo(y, y);
      while (y.t < ys)
        y[y.t++] = 0;
      while (--j >= 0) {
        var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
        if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t2);
          r.subTo(t2, r);
          while (r[i] < --qd)
            r.subTo(t2, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms)
          BigInteger.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this[0];
      if ((x & 1) == 0)
        return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x[x.t++] = 0;
      for (var i = 0;i < this.m.t; ++i) {
        var j = x[i] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i + this.m.t;
        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x[j] >= x.DV) {
          x[j] -= x.DV;
          x[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z2) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z2.sqrTo(r, r2);
        if ((e & 1 << i) > 0)
          z2.mulTo(r2, g, r);
        else {
          var t2 = r;
          r = r2;
          r2 = t2;
        }
      }
      return z2.revert(r);
    }
    function bnModPowInt(e, m) {
      var z2;
      if (e < 256 || m.isEven())
        z2 = new Classic(m);
      else
        z2 = new Montgomery(m);
      return this.exp(e, z2);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this[0];
      else if (this.t == 0)
        return 0;
      return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this[0] << 16 >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
      this.divRemTo(d, y, z2);
      while (y.signum() > 0) {
        r = (a + z2.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z2);
      }
      return z2.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i = 0;i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if (typeof b == "number") {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array, t2 = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t2 > 0)
          x[0] &= (1 << t2) - 1;
        else
          x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i = this.t, r = new Array;
      r[0] = this.s;
      var p = this.DB - i * this.DB % 8, d, k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | this.s << this.DB - p;
        while (i >= 0) {
          if (p < 8) {
            d = (this[i] & (1 << p) - 1) << 8 - p;
            d |= this[--i] >> (p += this.DB - 8);
          } else {
            d = this[i] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d & 128) != 0)
            d |= -256;
          if (k == 0 && (this.s & 128) != (d & 128))
            ++k;
          if (k > 0 || d != this.s)
            r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i, f, m = Math.min(a.t, this.t);
      for (i = 0;i < m; ++i)
        r[i] = op(this[i], a[i]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m;i < this.t; ++i)
          r[i] = op(this[i], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i = m;i < a.t; ++i)
          r[i] = op(f, a[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i = 0;i < this.t; ++i)
        r[i] = this.DM & ~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0)
        return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0)
        ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i = 0;i < this.t; ++i)
        if (this[i] != 0)
          return i * this.DB + lbit(this[i]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i = 0;i < this.t; ++i)
        r += cbit(this[i] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return this.s != 0;
      return (this[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this[i] + a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0)
        r[i++] = c;
      else if (c < -1)
        r[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnSquare() {
      var r = nbi();
      this.squareTo(r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a, q, r);
      return new Array(q, r);
    }
    function bnpDMultiply(n) {
      this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0)
        return;
      while (this.t <= w)
        this[this.t++] = 0;
      this[w] += n;
      while (this[w] >= this.DV) {
        this[w] -= this.DV;
        if (++w >= this.t)
          this[this.t++] = 0;
        ++this[w];
      }
    }
    function NullExp() {}
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp);
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0)
        r[--i] = 0;
      var j;
      for (j = r.t - this.t;i < j; ++i)
        r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n);i < j; ++i)
        this.am(0, a[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0)
        r[i] = 0;
      for (i = Math.max(n - this.t, 0);i < a.t; ++i)
        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(), k, r = nbv(1), z2;
      if (i <= 0)
        return r;
      else if (i < 18)
        k = 1;
      else if (i < 48)
        k = 3;
      else if (i < 144)
        k = 4;
      else if (i < 768)
        k = 5;
      else
        k = 6;
      if (i < 8)
        z2 = new Classic(m);
      else if (m.isEven())
        z2 = new Barrett(m);
      else
        z2 = new Montgomery(m);
      var g = new Array, n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z2.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z2.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z2.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
      i = nbits(e[j]) - 1;
      while (j >= 0) {
        if (i >= k1)
          w = e[j] >> i - k1 & km;
        else {
          w = (e[j] & (1 << i + 1) - 1) << k1 - i;
          if (j > 0)
            w |= e[j - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z2.sqrTo(r, r2);
            z2.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z2.sqrTo(r, r2);
          else {
            t2 = r;
            r = r2;
            r2 = t2;
          }
          z2.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e[j] & 1 << i) == 0) {
          z2.sqrTo(r, r2);
          t2 = r;
          r = r2;
          r2 = t2;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z2.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t2 = x;
        x = y;
        y = t2;
      }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i < g)
        g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0)
          x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0)
          y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r = this[0] % n;
        else
          for (var i = this.t - 1;i >= 0; --i)
            r = (d * r + this[i]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.isEven() && ac || m.signum() == 0)
        return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t2) {
      var i, x = this.abs();
      if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0;i < lowprimes.length; ++i)
          if (x[0] == lowprimes[i])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j)
          if (m % lowprimes[i++] == 0)
            return false;
      }
      return x.millerRabin(t2);
    }
    function bnpMillerRabin(t2) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      t2 = t2 + 1 >> 1;
      if (t2 > lowprimes.length)
        t2 = lowprimes.length;
      var a = nbi();
      for (var i = 0;i < t2; ++i) {
        a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    BigInteger.prototype.square = bnSquare;
    BigInteger.prototype.Barrett = Barrett;
    var rng_state;
    var rng_pool;
    var rng_pptr;
    function rng_seed_int(x) {
      rng_pool[rng_pptr++] ^= x & 255;
      rng_pool[rng_pptr++] ^= x >> 8 & 255;
      rng_pool[rng_pptr++] ^= x >> 16 & 255;
      rng_pool[rng_pptr++] ^= x >> 24 & 255;
      if (rng_pptr >= rng_psize)
        rng_pptr -= rng_psize;
    }
    function rng_seed_time() {
      rng_seed_int(new Date().getTime());
    }
    if (rng_pool == null) {
      rng_pool = new Array;
      rng_pptr = 0;
      var t;
      if (typeof window !== "undefined" && window.crypto) {
        if (window.crypto.getRandomValues) {
          var ua = new Uint8Array(32);
          window.crypto.getRandomValues(ua);
          for (t = 0;t < 32; ++t)
            rng_pool[rng_pptr++] = ua[t];
        } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
          var z = window.crypto.random(32);
          for (t = 0;t < z.length; ++t)
            rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
        }
      }
      while (rng_pptr < rng_psize) {
        t = Math.floor(65536 * Math.random());
        rng_pool[rng_pptr++] = t >>> 8;
        rng_pool[rng_pptr++] = t & 255;
      }
      rng_pptr = 0;
      rng_seed_time();
    }
    function rng_get_byte() {
      if (rng_state == null) {
        rng_seed_time();
        rng_state = prng_newstate();
        rng_state.init(rng_pool);
        for (rng_pptr = 0;rng_pptr < rng_pool.length; ++rng_pptr)
          rng_pool[rng_pptr] = 0;
        rng_pptr = 0;
      }
      return rng_state.next();
    }
    function rng_get_bytes(ba) {
      var i;
      for (i = 0;i < ba.length; ++i)
        ba[i] = rng_get_byte();
    }
    function SecureRandom() {}
    SecureRandom.prototype.nextBytes = rng_get_bytes;
    function Arcfour() {
      this.i = 0;
      this.j = 0;
      this.S = new Array;
    }
    function ARC4init(key) {
      var i, j, t2;
      for (i = 0;i < 256; ++i)
        this.S[i] = i;
      j = 0;
      for (i = 0;i < 256; ++i) {
        j = j + this.S[i] + key[i % key.length] & 255;
        t2 = this.S[i];
        this.S[i] = this.S[j];
        this.S[j] = t2;
      }
      this.i = 0;
      this.j = 0;
    }
    function ARC4next() {
      var t2;
      this.i = this.i + 1 & 255;
      this.j = this.j + this.S[this.i] & 255;
      t2 = this.S[this.i];
      this.S[this.i] = this.S[this.j];
      this.S[this.j] = t2;
      return this.S[t2 + this.S[this.i] & 255];
    }
    Arcfour.prototype.init = ARC4init;
    Arcfour.prototype.next = ARC4next;
    function prng_newstate() {
      return new Arcfour;
    }
    var rng_psize = 256;
    if (typeof exports !== "undefined") {
      exports = module.exports = {
        default: BigInteger,
        BigInteger,
        SecureRandom
      };
    } else {
      this.jsbn = {
        BigInteger,
        SecureRandom
      };
    }
  }).call(exports);
});

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS((exports) => {
  (function() {
    var re = {
      not_string: /[^s]/,
      not_bool: /[^t]/,
      not_type: /[^T]/,
      not_primitive: /[^v]/,
      number: /[diefg]/,
      numeric_arg: /[bcdiefguxX]/,
      json: /[j]/,
      not_json: /[^j]/,
      text: /^[^\x25]+/,
      modulo: /^\x25{2}/,
      placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
      key: /^([a-z_][a-z_\d]*)/i,
      key_access: /^\.([a-z_][a-z_\d]*)/i,
      index_access: /^\[(\d+)\]/,
      sign: /^[+-]/
    };
    function sprintf(key) {
      return sprintf_format(sprintf_parse(key), arguments);
    }
    function vsprintf(fmt, argv) {
      return sprintf.apply(null, [fmt].concat(argv || []));
    }
    function sprintf_format(parse_tree, argv) {
      var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign;
      for (i = 0;i < tree_length; i++) {
        if (typeof parse_tree[i] === "string") {
          output += parse_tree[i];
        } else if (typeof parse_tree[i] === "object") {
          ph = parse_tree[i];
          if (ph.keys) {
            arg = argv[cursor];
            for (k = 0;k < ph.keys.length; k++) {
              if (arg == undefined) {
                throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
              }
              arg = arg[ph.keys[k]];
            }
          } else if (ph.param_no) {
            arg = argv[ph.param_no];
          } else {
            arg = argv[cursor++];
          }
          if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
            arg = arg();
          }
          if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
            throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
          }
          if (re.number.test(ph.type)) {
            is_positive = arg >= 0;
          }
          switch (ph.type) {
            case "b":
              arg = parseInt(arg, 10).toString(2);
              break;
            case "c":
              arg = String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
            case "i":
              arg = parseInt(arg, 10);
              break;
            case "j":
              arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
              break;
            case "e":
              arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
              break;
            case "f":
              arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
              break;
            case "g":
              arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
              break;
            case "o":
              arg = (parseInt(arg, 10) >>> 0).toString(8);
              break;
            case "s":
              arg = String(arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "t":
              arg = String(!!arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "T":
              arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "u":
              arg = parseInt(arg, 10) >>> 0;
              break;
            case "v":
              arg = arg.valueOf();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "x":
              arg = (parseInt(arg, 10) >>> 0).toString(16);
              break;
            case "X":
              arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
              break;
          }
          if (re.json.test(ph.type)) {
            output += arg;
          } else {
            if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
              sign = is_positive ? "+" : "-";
              arg = arg.toString().replace(re.sign, "");
            } else {
              sign = "";
            }
            pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
            pad_length = ph.width - (sign + arg).length;
            pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
            output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
          }
        }
      }
      return output;
    }
    var sprintf_cache = Object.create(null);
    function sprintf_parse(fmt) {
      if (sprintf_cache[fmt]) {
        return sprintf_cache[fmt];
      }
      var _fmt = fmt, match, parse_tree = [], arg_names = 0;
      while (_fmt) {
        if ((match = re.text.exec(_fmt)) !== null) {
          parse_tree.push(match[0]);
        } else if ((match = re.modulo.exec(_fmt)) !== null) {
          parse_tree.push("%");
        } else if ((match = re.placeholder.exec(_fmt)) !== null) {
          if (match[2]) {
            arg_names |= 1;
            var field_list = [], replacement_field = match[2], field_match = [];
            if ((field_match = re.key.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else {
                  throw new SyntaxError("[sprintf] failed to parse named argument key");
                }
              }
            } else {
              throw new SyntaxError("[sprintf] failed to parse named argument key");
            }
            match[2] = field_list;
          } else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
          }
          parse_tree.push({
            placeholder: match[0],
            param_no: match[1],
            keys: match[2],
            sign: match[3],
            pad_char: match[4],
            align: match[5],
            width: match[6],
            precision: match[7],
            type: match[8]
          });
        } else {
          throw new SyntaxError("[sprintf] unexpected placeholder");
        }
        _fmt = _fmt.substring(match[0].length);
      }
      return sprintf_cache[fmt] = parse_tree;
    }
    if (typeof exports !== "undefined") {
      exports.sprintf = sprintf;
      exports.vsprintf = vsprintf;
    }
    if (typeof window !== "undefined") {
      window["sprintf"] = sprintf;
      window["vsprintf"] = vsprintf;
      if (typeof define === "function" && define["amd"]) {
        define(function() {
          return {
            sprintf,
            vsprintf
          };
        });
      }
    }
  })();
});

// node_modules/ip-address/dist/ipv4.js
var require_ipv42 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Address4 = undefined;
  var common = __importStar(require_common6());
  var constants = __importStar(require_constants6());
  var address_error_1 = require_address_error2();
  var jsbn_1 = require_jsbn();
  var sprintf_js_1 = require_sprintf();

  class Address4 {
    constructor(address) {
      this.groups = constants.GROUPS;
      this.parsedAddress = [];
      this.parsedSubnet = "";
      this.subnet = "/32";
      this.subnetMask = 32;
      this.v4 = true;
      this.isCorrect = common.isCorrect(constants.BITS);
      this.isInSubnet = common.isInSubnet;
      this.address = address;
      const subnet = constants.RE_SUBNET_STRING.exec(address);
      if (subnet) {
        this.parsedSubnet = subnet[0].replace("/", "");
        this.subnetMask = parseInt(this.parsedSubnet, 10);
        this.subnet = `/${this.subnetMask}`;
        if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
          throw new address_error_1.AddressError("Invalid subnet mask.");
        }
        address = address.replace(constants.RE_SUBNET_STRING, "");
      }
      this.addressMinusSuffix = address;
      this.parsedAddress = this.parse(address);
    }
    static isValid(address) {
      try {
        new Address4(address);
        return true;
      } catch (e) {
        return false;
      }
    }
    parse(address) {
      const groups = address.split(".");
      if (!address.match(constants.RE_ADDRESS)) {
        throw new address_error_1.AddressError("Invalid IPv4 address.");
      }
      return groups;
    }
    correctForm() {
      return this.parsedAddress.map((part) => parseInt(part, 10)).join(".");
    }
    static fromHex(hex) {
      const padded = hex.replace(/:/g, "").padStart(8, "0");
      const groups = [];
      let i;
      for (i = 0;i < 8; i += 2) {
        const h = padded.slice(i, i + 2);
        groups.push(parseInt(h, 16));
      }
      return new Address4(groups.join("."));
    }
    static fromInteger(integer) {
      return Address4.fromHex(integer.toString(16));
    }
    static fromArpa(arpaFormAddress) {
      const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
      const address = leader.split(".").reverse().join(".");
      return new Address4(address);
    }
    toHex() {
      return this.parsedAddress.map((part) => (0, sprintf_js_1.sprintf)("%02x", parseInt(part, 10))).join(":");
    }
    toArray() {
      return this.parsedAddress.map((part) => parseInt(part, 10));
    }
    toGroup6() {
      const output = [];
      let i;
      for (i = 0;i < constants.GROUPS; i += 2) {
        const hex = (0, sprintf_js_1.sprintf)("%02x%02x", parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));
        output.push((0, sprintf_js_1.sprintf)("%x", parseInt(hex, 16)));
      }
      return output.join(":");
    }
    bigInteger() {
      return new jsbn_1.BigInteger(this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)("%02x", parseInt(n, 10))).join(""), 16);
    }
    _startAddress() {
      return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants.BITS - this.subnetMask), 2);
    }
    startAddress() {
      return Address4.fromBigInteger(this._startAddress());
    }
    startAddressExclusive() {
      const adjust = new jsbn_1.BigInteger("1");
      return Address4.fromBigInteger(this._startAddress().add(adjust));
    }
    _endAddress() {
      return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants.BITS - this.subnetMask), 2);
    }
    endAddress() {
      return Address4.fromBigInteger(this._endAddress());
    }
    endAddressExclusive() {
      const adjust = new jsbn_1.BigInteger("1");
      return Address4.fromBigInteger(this._endAddress().subtract(adjust));
    }
    static fromBigInteger(bigInteger) {
      return Address4.fromInteger(parseInt(bigInteger.toString(), 10));
    }
    mask(mask) {
      if (mask === undefined) {
        mask = this.subnetMask;
      }
      return this.getBitsBase2(0, mask);
    }
    getBitsBase2(start, end) {
      return this.binaryZeroPad().slice(start, end);
    }
    reverseForm(options) {
      if (!options) {
        options = {};
      }
      const reversed = this.correctForm().split(".").reverse().join(".");
      if (options.omitSuffix) {
        return reversed;
      }
      return (0, sprintf_js_1.sprintf)("%s.in-addr.arpa.", reversed);
    }
    isMulticast() {
      return this.isInSubnet(new Address4("224.0.0.0/4"));
    }
    binaryZeroPad() {
      return this.bigInteger().toString(2).padStart(constants.BITS, "0");
    }
    groupForV6() {
      const segments = this.parsedAddress;
      return this.address.replace(constants.RE_ADDRESS, (0, sprintf_js_1.sprintf)('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join("."), segments.slice(2, 4).join(".")));
    }
  }
  exports.Address4 = Address4;
});

// node_modules/ip-address/dist/v6/constants.js
var require_constants7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RE_URL_WITH_PORT = exports.RE_URL = exports.RE_ZONE_STRING = exports.RE_SUBNET_STRING = exports.RE_BAD_ADDRESS = exports.RE_BAD_CHARACTERS = exports.TYPES = exports.SCOPES = exports.GROUPS = exports.BITS = undefined;
  exports.BITS = 128;
  exports.GROUPS = 8;
  exports.SCOPES = {
    0: "Reserved",
    1: "Interface local",
    2: "Link local",
    4: "Admin local",
    5: "Site local",
    8: "Organization local",
    14: "Global",
    15: "Reserved"
  };
  exports.TYPES = {
    "ff01::1/128": "Multicast (All nodes on this interface)",
    "ff01::2/128": "Multicast (All routers on this interface)",
    "ff02::1/128": "Multicast (All nodes on this link)",
    "ff02::2/128": "Multicast (All routers on this link)",
    "ff05::2/128": "Multicast (All routers in this site)",
    "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
    "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
    "ff02::9/128": "Multicast (RIP routers)",
    "ff02::a/128": "Multicast (EIGRP routers)",
    "ff02::d/128": "Multicast (PIM routers)",
    "ff02::16/128": "Multicast (MLDv2 reports)",
    "ff01::fb/128": "Multicast (mDNSv6)",
    "ff02::fb/128": "Multicast (mDNSv6)",
    "ff05::fb/128": "Multicast (mDNSv6)",
    "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
    "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
    "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
    "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
    "::/128": "Unspecified",
    "::1/128": "Loopback",
    "ff00::/8": "Multicast",
    "fe80::/10": "Link-local unicast"
  };
  exports.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
  exports.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
  exports.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
  exports.RE_ZONE_STRING = /%.*$/;
  exports.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
  exports.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
});

// node_modules/ip-address/dist/v6/helpers.js
var require_helpers5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.simpleGroup = exports.spanLeadingZeroes = exports.spanAll = exports.spanAllZeroes = undefined;
  var sprintf_js_1 = require_sprintf();
  function spanAllZeroes(s) {
    return s.replace(/(0+)/g, '<span class="zero">$1</span>');
  }
  exports.spanAllZeroes = spanAllZeroes;
  function spanAll(s, offset2 = 0) {
    const letters = s.split("");
    return letters.map((n, i) => (0, sprintf_js_1.sprintf)('<span class="digit value-%s position-%d">%s</span>', n, i + offset2, spanAllZeroes(n))).join("");
  }
  exports.spanAll = spanAll;
  function spanLeadingZeroesSimple(group) {
    return group.replace(/^(0+)/, '<span class="zero">$1</span>');
  }
  function spanLeadingZeroes(address) {
    const groups = address.split(":");
    return groups.map((g) => spanLeadingZeroesSimple(g)).join(":");
  }
  exports.spanLeadingZeroes = spanLeadingZeroes;
  function simpleGroup(addressString, offset2 = 0) {
    const groups = addressString.split(":");
    return groups.map((g, i) => {
      if (/group-v4/.test(g)) {
        return g;
      }
      return (0, sprintf_js_1.sprintf)('<span class="hover-group group-%d">%s</span>', i + offset2, spanLeadingZeroesSimple(g));
    });
  }
  exports.simpleGroup = simpleGroup;
});

// node_modules/ip-address/dist/v6/regular-expressions.js
var require_regular_expressions2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.possibleElisions = exports.simpleRegularExpression = exports.ADDRESS_BOUNDARY = exports.padGroup = exports.groupPossibilities = undefined;
  var v6 = __importStar(require_constants7());
  var sprintf_js_1 = require_sprintf();
  function groupPossibilities(possibilities) {
    return (0, sprintf_js_1.sprintf)("(%s)", possibilities.join("|"));
  }
  exports.groupPossibilities = groupPossibilities;
  function padGroup(group) {
    if (group.length < 4) {
      return (0, sprintf_js_1.sprintf)("0{0,%d}%s", 4 - group.length, group);
    }
    return group;
  }
  exports.padGroup = padGroup;
  exports.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
  function simpleRegularExpression(groups) {
    const zeroIndexes = [];
    groups.forEach((group, i) => {
      const groupInteger = parseInt(group, 16);
      if (groupInteger === 0) {
        zeroIndexes.push(i);
      }
    });
    const possibilities = zeroIndexes.map((zeroIndex) => groups.map((group, i) => {
      if (i === zeroIndex) {
        const elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
        return groupPossibilities([padGroup(group), elision]);
      }
      return padGroup(group);
    }).join(":"));
    possibilities.push(groups.map(padGroup).join(":"));
    return groupPossibilities(possibilities);
  }
  exports.simpleRegularExpression = simpleRegularExpression;
  function possibleElisions(elidedGroups, moreLeft, moreRight) {
    const left = moreLeft ? "" : ":";
    const right = moreRight ? "" : ":";
    const possibilities = [];
    if (!moreLeft && !moreRight) {
      possibilities.push("::");
    }
    if (moreLeft && moreRight) {
      possibilities.push("");
    }
    if (moreRight && !moreLeft || !moreRight && moreLeft) {
      possibilities.push(":");
    }
    possibilities.push((0, sprintf_js_1.sprintf)("%s(:0{1,4}){1,%d}", left, elidedGroups - 1));
    possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){1,%d}%s", elidedGroups - 1, right));
    possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){%d}0{1,4}", elidedGroups - 1));
    for (let groups = 1;groups < elidedGroups - 1; groups++) {
      for (let position = 1;position < elidedGroups - groups; position++) {
        possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", position, elidedGroups - position - groups - 1));
      }
    }
    return groupPossibilities(possibilities);
  }
  exports.possibleElisions = possibleElisions;
});

// node_modules/ip-address/dist/ipv6.js
var require_ipv62 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Address6 = undefined;
  var common = __importStar(require_common6());
  var constants4 = __importStar(require_constants6());
  var constants6 = __importStar(require_constants7());
  var helpers = __importStar(require_helpers5());
  var ipv4_1 = require_ipv42();
  var regular_expressions_1 = require_regular_expressions2();
  var address_error_1 = require_address_error2();
  var jsbn_1 = require_jsbn();
  var sprintf_js_1 = require_sprintf();
  function assert(condition) {
    if (!condition) {
      throw new Error("Assertion failed.");
    }
  }
  function addCommas(number) {
    const r = /(\d+)(\d{3})/;
    while (r.test(number)) {
      number = number.replace(r, "$1,$2");
    }
    return number;
  }
  function spanLeadingZeroes4(n) {
    n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
    n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
    return n;
  }
  function compact(address, slice) {
    const s1 = [];
    const s2 = [];
    let i;
    for (i = 0;i < address.length; i++) {
      if (i < slice[0]) {
        s1.push(address[i]);
      } else if (i > slice[1]) {
        s2.push(address[i]);
      }
    }
    return s1.concat(["compact"]).concat(s2);
  }
  function paddedHex(octet) {
    return (0, sprintf_js_1.sprintf)("%04x", parseInt(octet, 16));
  }
  function unsignByte(b) {
    return b & 255;
  }

  class Address6 {
    constructor(address, optionalGroups) {
      this.addressMinusSuffix = "";
      this.parsedSubnet = "";
      this.subnet = "/128";
      this.subnetMask = 128;
      this.v4 = false;
      this.zone = "";
      this.isInSubnet = common.isInSubnet;
      this.isCorrect = common.isCorrect(constants6.BITS);
      if (optionalGroups === undefined) {
        this.groups = constants6.GROUPS;
      } else {
        this.groups = optionalGroups;
      }
      this.address = address;
      const subnet = constants6.RE_SUBNET_STRING.exec(address);
      if (subnet) {
        this.parsedSubnet = subnet[0].replace("/", "");
        this.subnetMask = parseInt(this.parsedSubnet, 10);
        this.subnet = `/${this.subnetMask}`;
        if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
          throw new address_error_1.AddressError("Invalid subnet mask.");
        }
        address = address.replace(constants6.RE_SUBNET_STRING, "");
      } else if (/\//.test(address)) {
        throw new address_error_1.AddressError("Invalid subnet mask.");
      }
      const zone = constants6.RE_ZONE_STRING.exec(address);
      if (zone) {
        this.zone = zone[0];
        address = address.replace(constants6.RE_ZONE_STRING, "");
      }
      this.addressMinusSuffix = address;
      this.parsedAddress = this.parse(this.addressMinusSuffix);
    }
    static isValid(address) {
      try {
        new Address6(address);
        return true;
      } catch (e) {
        return false;
      }
    }
    static fromBigInteger(bigInteger) {
      const hex = bigInteger.toString(16).padStart(32, "0");
      const groups = [];
      let i;
      for (i = 0;i < constants6.GROUPS; i++) {
        groups.push(hex.slice(i * 4, (i + 1) * 4));
      }
      return new Address6(groups.join(":"));
    }
    static fromURL(url) {
      let host;
      let port = null;
      let result;
      if (url.indexOf("[") !== -1 && url.indexOf("]:") !== -1) {
        result = constants6.RE_URL_WITH_PORT.exec(url);
        if (result === null) {
          return {
            error: "failed to parse address with port",
            address: null,
            port: null
          };
        }
        host = result[1];
        port = result[2];
      } else if (url.indexOf("/") !== -1) {
        url = url.replace(/^[a-z0-9]+:\/\//, "");
        result = constants6.RE_URL.exec(url);
        if (result === null) {
          return {
            error: "failed to parse address from URL",
            address: null,
            port: null
          };
        }
        host = result[1];
      } else {
        host = url;
      }
      if (port) {
        port = parseInt(port, 10);
        if (port < 0 || port > 65536) {
          port = null;
        }
      } else {
        port = null;
      }
      return {
        address: new Address6(host),
        port
      };
    }
    static fromAddress4(address) {
      const address4 = new ipv4_1.Address4(address);
      const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
      return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);
    }
    static fromArpa(arpaFormAddress) {
      let address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
      const semicolonAmount = 7;
      if (address.length !== 63) {
        throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
      }
      const parts = address.split(".").reverse();
      for (let i = semicolonAmount;i > 0; i--) {
        const insertIndex = i * 4;
        parts.splice(insertIndex, 0, ":");
      }
      address = parts.join("");
      return new Address6(address);
    }
    microsoftTranscription() {
      return (0, sprintf_js_1.sprintf)("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-"));
    }
    mask(mask = this.subnetMask) {
      return this.getBitsBase2(0, mask);
    }
    possibleSubnets(subnetSize = 128) {
      const availableBits = constants6.BITS - this.subnetMask;
      const subnetBits = Math.abs(subnetSize - constants6.BITS);
      const subnetPowers = availableBits - subnetBits;
      if (subnetPowers < 0) {
        return "0";
      }
      return addCommas(new jsbn_1.BigInteger("2", 10).pow(subnetPowers).toString(10));
    }
    _startAddress() {
      return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants6.BITS - this.subnetMask), 2);
    }
    startAddress() {
      return Address6.fromBigInteger(this._startAddress());
    }
    startAddressExclusive() {
      const adjust = new jsbn_1.BigInteger("1");
      return Address6.fromBigInteger(this._startAddress().add(adjust));
    }
    _endAddress() {
      return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants6.BITS - this.subnetMask), 2);
    }
    endAddress() {
      return Address6.fromBigInteger(this._endAddress());
    }
    endAddressExclusive() {
      const adjust = new jsbn_1.BigInteger("1");
      return Address6.fromBigInteger(this._endAddress().subtract(adjust));
    }
    getScope() {
      let scope = constants6.SCOPES[this.getBits(12, 16).intValue()];
      if (this.getType() === "Global unicast" && scope !== "Link local") {
        scope = "Global";
      }
      return scope || "Unknown";
    }
    getType() {
      for (const subnet of Object.keys(constants6.TYPES)) {
        if (this.isInSubnet(new Address6(subnet))) {
          return constants6.TYPES[subnet];
        }
      }
      return "Global unicast";
    }
    getBits(start, end) {
      return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);
    }
    getBitsBase2(start, end) {
      return this.binaryZeroPad().slice(start, end);
    }
    getBitsBase16(start, end) {
      const length = end - start;
      if (length % 4 !== 0) {
        throw new Error("Length of bits to retrieve must be divisible by four");
      }
      return this.getBits(start, end).toString(16).padStart(length / 4, "0");
    }
    getBitsPastSubnet() {
      return this.getBitsBase2(this.subnetMask, constants6.BITS);
    }
    reverseForm(options) {
      if (!options) {
        options = {};
      }
      const characters = Math.floor(this.subnetMask / 4);
      const reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
      if (characters > 0) {
        if (options.omitSuffix) {
          return reversed;
        }
        return (0, sprintf_js_1.sprintf)("%s.ip6.arpa.", reversed);
      }
      if (options.omitSuffix) {
        return "";
      }
      return "ip6.arpa.";
    }
    correctForm() {
      let i;
      let groups = [];
      let zeroCounter = 0;
      const zeroes = [];
      for (i = 0;i < this.parsedAddress.length; i++) {
        const value = parseInt(this.parsedAddress[i], 16);
        if (value === 0) {
          zeroCounter++;
        }
        if (value !== 0 && zeroCounter > 0) {
          if (zeroCounter > 1) {
            zeroes.push([i - zeroCounter, i - 1]);
          }
          zeroCounter = 0;
        }
      }
      if (zeroCounter > 1) {
        zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
      }
      const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);
      if (zeroes.length > 0) {
        const index = zeroLengths.indexOf(Math.max(...zeroLengths));
        groups = compact(this.parsedAddress, zeroes[index]);
      } else {
        groups = this.parsedAddress;
      }
      for (i = 0;i < groups.length; i++) {
        if (groups[i] !== "compact") {
          groups[i] = parseInt(groups[i], 16).toString(16);
        }
      }
      let correct = groups.join(":");
      correct = correct.replace(/^compact$/, "::");
      correct = correct.replace(/^compact|compact$/, ":");
      correct = correct.replace(/compact/, "");
      return correct;
    }
    binaryZeroPad() {
      return this.bigInteger().toString(2).padStart(constants6.BITS, "0");
    }
    parse4in6(address) {
      const groups = address.split(":");
      const lastGroup = groups.slice(-1)[0];
      const address4 = lastGroup.match(constants4.RE_ADDRESS);
      if (address4) {
        this.parsedAddress4 = address4[0];
        this.address4 = new ipv4_1.Address4(this.parsedAddress4);
        for (let i = 0;i < this.address4.groups; i++) {
          if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
            throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join(".")));
          }
        }
        this.v4 = true;
        groups[groups.length - 1] = this.address4.toGroup6();
        address = groups.join(":");
      }
      return address;
    }
    parse(address) {
      address = this.parse4in6(address);
      const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
      if (badCharacters) {
        throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Bad character%s detected in address: %s", badCharacters.length > 1 ? "s" : "", badCharacters.join("")), address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
      }
      const badAddress = address.match(constants6.RE_BAD_ADDRESS);
      if (badAddress) {
        throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Address failed regex: %s", badAddress.join("")), address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
      }
      let groups = [];
      const halves = address.split("::");
      if (halves.length === 2) {
        let first = halves[0].split(":");
        let last = halves[1].split(":");
        if (first.length === 1 && first[0] === "") {
          first = [];
        }
        if (last.length === 1 && last[0] === "") {
          last = [];
        }
        const remaining = this.groups - (first.length + last.length);
        if (!remaining) {
          throw new address_error_1.AddressError("Error parsing groups");
        }
        this.elidedGroups = remaining;
        this.elisionBegin = first.length;
        this.elisionEnd = first.length + this.elidedGroups;
        groups = groups.concat(first);
        for (let i = 0;i < remaining; i++) {
          groups.push("0");
        }
        groups = groups.concat(last);
      } else if (halves.length === 1) {
        groups = address.split(":");
        this.elidedGroups = 0;
      } else {
        throw new address_error_1.AddressError("Too many :: groups found");
      }
      groups = groups.map((group) => (0, sprintf_js_1.sprintf)("%x", parseInt(group, 16)));
      if (groups.length !== this.groups) {
        throw new address_error_1.AddressError("Incorrect number of groups found");
      }
      return groups;
    }
    canonicalForm() {
      return this.parsedAddress.map(paddedHex).join(":");
    }
    decimal() {
      return this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)("%05d", parseInt(n, 16))).join(":");
    }
    bigInteger() {
      return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(""), 16);
    }
    to4() {
      const binary = this.binaryZeroPad().split("");
      return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary.slice(96, 128).join(""), 2).toString(16));
    }
    to4in6() {
      const address4 = this.to4();
      const address6 = new Address6(this.parsedAddress.slice(0, 6).join(":"), 6);
      const correct = address6.correctForm();
      let infix = "";
      if (!/:$/.test(correct)) {
        infix = ":";
      }
      return correct + infix + address4.address;
    }
    inspectTeredo() {
      const prefix = this.getBitsBase16(0, 32);
      const udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger("ffff", 16)).toString();
      const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
      const client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger("ffffffff", 16)).toString(16));
      const flags = this.getBits(64, 80);
      const flagsBase2 = this.getBitsBase2(64, 80);
      const coneNat = flags.testBit(15);
      const reserved = flags.testBit(14);
      const groupIndividual = flags.testBit(8);
      const universalLocal = flags.testBit(9);
      const nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
      return {
        prefix: (0, sprintf_js_1.sprintf)("%s:%s", prefix.slice(0, 4), prefix.slice(4, 8)),
        server4: server4.address,
        client4: client4.address,
        flags: flagsBase2,
        coneNat,
        microsoft: {
          reserved,
          universalLocal,
          groupIndividual,
          nonce
        },
        udpPort
      };
    }
    inspect6to4() {
      const prefix = this.getBitsBase16(0, 16);
      const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
      return {
        prefix: (0, sprintf_js_1.sprintf)("%s", prefix.slice(0, 4)),
        gateway: gateway.address
      };
    }
    to6to4() {
      if (!this.is4()) {
        return null;
      }
      const addr6to4 = [
        "2002",
        this.getBitsBase16(96, 112),
        this.getBitsBase16(112, 128),
        "",
        "/16"
      ].join(":");
      return new Address6(addr6to4);
    }
    toByteArray() {
      const byteArray = this.bigInteger().toByteArray();
      if (byteArray.length === 17 && byteArray[0] === 0) {
        return byteArray.slice(1);
      }
      return byteArray;
    }
    toUnsignedByteArray() {
      return this.toByteArray().map(unsignByte);
    }
    static fromByteArray(bytes) {
      return this.fromUnsignedByteArray(bytes.map(unsignByte));
    }
    static fromUnsignedByteArray(bytes) {
      const BYTE_MAX = new jsbn_1.BigInteger("256", 10);
      let result = new jsbn_1.BigInteger("0", 10);
      let multiplier = new jsbn_1.BigInteger("1", 10);
      for (let i = bytes.length - 1;i >= 0; i--) {
        result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes[i].toString(10), 10)));
        multiplier = multiplier.multiply(BYTE_MAX);
      }
      return Address6.fromBigInteger(result);
    }
    isCanonical() {
      return this.addressMinusSuffix === this.canonicalForm();
    }
    isLinkLocal() {
      if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
        return true;
      }
      return false;
    }
    isMulticast() {
      return this.getType() === "Multicast";
    }
    is4() {
      return this.v4;
    }
    isTeredo() {
      return this.isInSubnet(new Address6("2001::/32"));
    }
    is6to4() {
      return this.isInSubnet(new Address6("2002::/16"));
    }
    isLoopback() {
      return this.getType() === "Loopback";
    }
    href(optionalPort) {
      if (optionalPort === undefined) {
        optionalPort = "";
      } else {
        optionalPort = (0, sprintf_js_1.sprintf)(":%s", optionalPort);
      }
      return (0, sprintf_js_1.sprintf)("http://[%s]%s/", this.correctForm(), optionalPort);
    }
    link(options) {
      if (!options) {
        options = {};
      }
      if (options.className === undefined) {
        options.className = "";
      }
      if (options.prefix === undefined) {
        options.prefix = "/#address=";
      }
      if (options.v4 === undefined) {
        options.v4 = false;
      }
      let formFunction = this.correctForm;
      if (options.v4) {
        formFunction = this.to4in6;
      }
      if (options.className) {
        return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s" class="%3$s">%2$s</a>', options.prefix, formFunction.call(this), options.className);
      }
      return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s">%2$s</a>', options.prefix, formFunction.call(this));
    }
    group() {
      if (this.elidedGroups === 0) {
        return helpers.simpleGroup(this.address).join(":");
      }
      assert(typeof this.elidedGroups === "number");
      assert(typeof this.elisionBegin === "number");
      const output = [];
      const [left, right] = this.address.split("::");
      if (left.length) {
        output.push(...helpers.simpleGroup(left));
      } else {
        output.push("");
      }
      const classes = ["hover-group"];
      for (let i = this.elisionBegin;i < this.elisionBegin + this.elidedGroups; i++) {
        classes.push((0, sprintf_js_1.sprintf)("group-%d", i));
      }
      output.push((0, sprintf_js_1.sprintf)('<span class="%s"></span>', classes.join(" ")));
      if (right.length) {
        output.push(...helpers.simpleGroup(right, this.elisionEnd));
      } else {
        output.push("");
      }
      if (this.is4()) {
        assert(this.address4 instanceof ipv4_1.Address4);
        output.pop();
        output.push(this.address4.groupForV6());
      }
      return output.join(":");
    }
    regularExpressionString(substringSearch = false) {
      let output = [];
      const address6 = new Address6(this.correctForm());
      if (address6.elidedGroups === 0) {
        output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));
      } else if (address6.elidedGroups === constants6.GROUPS) {
        output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));
      } else {
        const halves = address6.address.split("::");
        if (halves[0].length) {
          output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(":")));
        }
        assert(typeof address6.elidedGroups === "number");
        output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
        if (halves[1].length) {
          output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(":")));
        }
        output = [output.join(":")];
      }
      if (!substringSearch) {
        output = [
          "(?=^|",
          regular_expressions_1.ADDRESS_BOUNDARY,
          "|[^\\w\\:])(",
          ...output,
          ")(?=[^\\w\\:]|",
          regular_expressions_1.ADDRESS_BOUNDARY,
          "|$)"
        ];
      }
      return output.join("");
    }
    regularExpression(substringSearch = false) {
      return new RegExp(this.regularExpressionString(substringSearch), "i");
    }
  }
  exports.Address6 = Address6;
});

// node_modules/ip-address/dist/ip-address.js
var require_ip_address2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.v6 = exports.AddressError = exports.Address6 = exports.Address4 = undefined;
  var ipv4_1 = require_ipv42();
  Object.defineProperty(exports, "Address4", { enumerable: true, get: function() {
    return ipv4_1.Address4;
  } });
  var ipv6_1 = require_ipv62();
  Object.defineProperty(exports, "Address6", { enumerable: true, get: function() {
    return ipv6_1.Address6;
  } });
  var address_error_1 = require_address_error2();
  Object.defineProperty(exports, "AddressError", { enumerable: true, get: function() {
    return address_error_1.AddressError;
  } });
  var helpers = __importStar(require_helpers5());
  exports.v6 = { helpers };
});

// node_modules/unleash-client/lib/strategy/remote-addresss-strategy.js
var require_remote_addresss_strategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ip_address_1 = require_ip_address2();
  var strategy_1 = require_strategy();

  class RemoteAddressStrategy extends strategy_1.Strategy {
    constructor() {
      super("remoteAddress");
    }
    isEnabled(parameters, context) {
      if (!parameters.IPs) {
        return false;
      }
      return parameters.IPs.split(/\s*,\s*/).some((range) => {
        if (range === context.remoteAddress) {
          return true;
        }
        try {
          const subnetRange = new ip_address_1.Address4(range);
          const remoteAddress = new ip_address_1.Address4(context.remoteAddress || "");
          return remoteAddress.isInSubnet(subnetRange);
        } catch (_err) {
          return false;
        }
      });
    }
  }
  exports.default = RemoteAddressStrategy;
});

// node_modules/unleash-client/lib/strategy/user-with-id-strategy.js
var require_user_with_id_strategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var strategy_1 = require_strategy();

  class UserWithIdStrategy extends strategy_1.Strategy {
    constructor() {
      super("userWithId");
    }
    isEnabled(parameters, context) {
      const userIdList = parameters.userIds ? parameters.userIds.split(/\s*,\s*/) : [];
      return context.userId !== undefined && userIdList.includes(context.userId);
    }
  }
  exports.default = UserWithIdStrategy;
});

// node_modules/unleash-client/lib/strategy/index.js
var require_strategy2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultStrategies = exports.Strategy = undefined;
  var application_hostname_strategy_1 = __importDefault(require_application_hostname_strategy());
  var default_strategy_1 = __importDefault(require_default_strategy());
  var flexible_rollout_strategy_1 = __importDefault(require_flexible_rollout_strategy());
  var gradual_rollout_random_1 = __importDefault(require_gradual_rollout_random());
  var gradual_rollout_session_id_1 = __importDefault(require_gradual_rollout_session_id());
  var gradual_rollout_user_id_1 = __importDefault(require_gradual_rollout_user_id());
  var remote_addresss_strategy_1 = __importDefault(require_remote_addresss_strategy());
  var user_with_id_strategy_1 = __importDefault(require_user_with_id_strategy());
  var strategy_1 = require_strategy();
  Object.defineProperty(exports, "Strategy", { enumerable: true, get: function() {
    return strategy_1.Strategy;
  } });
  exports.defaultStrategies = [
    new default_strategy_1.default,
    new application_hostname_strategy_1.default,
    new gradual_rollout_random_1.default,
    new gradual_rollout_user_id_1.default,
    new gradual_rollout_session_id_1.default,
    new user_with_id_strategy_1.default,
    new remote_addresss_strategy_1.default,
    new flexible_rollout_strategy_1.default
  ];
});

// node_modules/unleash-client/lib/uuidv4.js
var require_uuidv4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uuidv4 = undefined;
  var uuidv4 = () => {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  };
  exports.uuidv4 = uuidv4;
});

// node_modules/unleash-client/lib/unleash.js
var require_unleash = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Unleash = exports.UnleashEvents = exports.Strategy = undefined;
  var node_events_1 = __require("node:events");
  var node_os_1 = __require("node:os");
  var client_1 = __importDefault(require_client());
  var events_1 = require_events();
  Object.defineProperty(exports, "UnleashEvents", { enumerable: true, get: function() {
    return events_1.UnleashEvents;
  } });
  var helpers_1 = require_helpers();
  var context_1 = require_context();
  var metric_api_1 = require_metric_api();
  var metric_types_1 = require_metric_types();
  var metrics_1 = __importDefault(require_metrics());
  var repository_1 = __importDefault(require_repository());
  var bootstrap_provider_1 = require_bootstrap_provider();
  var storage_provider_file_1 = __importDefault(require_storage_provider_file());
  var strategy_1 = require_strategy2();
  Object.defineProperty(exports, "Strategy", { enumerable: true, get: function() {
    return strategy_1.Strategy;
  } });
  var uuidv4_1 = require_uuidv4();
  var variant_1 = require_variant();
  var BACKUP_PATH = (0, node_os_1.tmpdir)();

  class Unleash extends node_events_1.EventEmitter {
    static configSignature;
    static instance;
    static instanceCount = 0;
    repository;
    client;
    metrics;
    staticContext;
    synchronized = false;
    ready = false;
    started = false;
    metricRegistry = new metric_types_1.InMemoryMetricRegistry;
    impactMetrics;
    constructor({ appName, environment = "default", projectName, instanceId, url, refreshInterval = 15 * 1000, metricsInterval = 60 * 1000, metricsJitter = 0, disableMetrics = false, backupPath = BACKUP_PATH, strategies = [], repository, namePrefix, customHeaders, customHeadersFunction, timeout, httpOptions, tags, bootstrap = {}, bootstrapOverride, storageProvider, disableAutoStart = false, skipInstanceCountWarning = false, experimentalMode = { type: "polling", format: "full" } }) {
      super();
      Unleash.instanceCount++;
      this.on(events_1.UnleashEvents.Error, (error) => {
        if (this.listenerCount(events_1.UnleashEvents.Error) === 1) {
          console.error(error);
        }
      });
      if (!skipInstanceCountWarning && Unleash.instanceCount > 10) {
        process.nextTick(() => {
          const error = new Error("The unleash SDK has been initialized more than 10 times");
          this.emit(events_1.UnleashEvents.Error, error);
        });
      }
      if (!url) {
        throw new Error('Unleash API "url" is required');
      }
      if (!appName) {
        throw new Error('Unleash client "appName" is required');
      }
      const unleashUrl = this.cleanUnleashUrl(url);
      const unleashInstanceId = (0, helpers_1.generateInstanceId)(instanceId);
      const unleashConnectionId = (0, uuidv4_1.uuidv4)();
      this.staticContext = { appName, environment };
      const bootstrapProvider = (0, bootstrap_provider_1.resolveBootstrapProvider)(bootstrap, appName, unleashInstanceId);
      this.repository = repository || new repository_1.default({
        projectName,
        url: unleashUrl,
        appName,
        instanceId: unleashInstanceId,
        connectionId: unleashConnectionId,
        refreshInterval,
        headers: customHeaders,
        customHeadersFunction,
        timeout,
        httpOptions,
        namePrefix,
        tags,
        bootstrapProvider,
        bootstrapOverride,
        mode: experimentalMode,
        storageProvider: storageProvider || new storage_provider_file_1.default(backupPath)
      });
      this.repository.on(events_1.UnleashEvents.Ready, () => {
        this.ready = true;
        process.nextTick(() => {
          this.emit(events_1.UnleashEvents.Ready);
        });
      });
      this.repository.on(events_1.UnleashEvents.Error, (err) => {
        err.message = `Unleash Repository error: ${err.message}`;
        this.emit(events_1.UnleashEvents.Error, err);
      });
      this.repository.on(events_1.UnleashEvents.Warn, (msg) => this.emit(events_1.UnleashEvents.Warn, msg));
      this.repository.on(events_1.UnleashEvents.Unchanged, (msg) => this.emit(events_1.UnleashEvents.Unchanged, msg));
      this.repository.on(events_1.UnleashEvents.Changed, (data) => {
        this.emit(events_1.UnleashEvents.Changed, data);
        if (!this.synchronized) {
          this.synchronized = true;
          process.nextTick(() => this.emit(events_1.UnleashEvents.Synchronized));
        }
      });
      const supportedStrategies = strategies.concat(strategy_1.defaultStrategies);
      this.client = new client_1.default(this.repository, supportedStrategies);
      this.client.on(events_1.UnleashEvents.Error, (err) => this.emit(events_1.UnleashEvents.Error, err));
      this.client.on(events_1.UnleashEvents.Impression, (e) => this.emit(events_1.UnleashEvents.Impression, e));
      this.metrics = new metrics_1.default({
        disableMetrics,
        appName,
        instanceId: unleashInstanceId,
        connectionId: unleashConnectionId,
        strategies: supportedStrategies.map((strategy) => strategy.name),
        metricsInterval,
        metricsJitter,
        url: unleashUrl,
        headers: customHeaders,
        customHeadersFunction,
        timeout,
        httpOptions,
        metricRegistry: this.metricRegistry
      });
      this.impactMetrics = new metric_api_1.MetricsAPI(this.metricRegistry, this.client, (0, context_1.buildImpactMetricContext)(customHeaders, this.staticContext));
      this.metrics.on(events_1.UnleashEvents.Error, (err) => {
        err.message = `Unleash Metrics error: ${err.message}`;
        this.emit(events_1.UnleashEvents.Error, err);
      });
      this.metrics.on(events_1.UnleashEvents.Warn, (msg) => this.emit(events_1.UnleashEvents.Warn, msg));
      this.metrics.on(events_1.UnleashEvents.Sent, (payload) => this.emit(events_1.UnleashEvents.Sent, payload));
      this.metrics.on(events_1.UnleashEvents.Count, (name, enabled) => {
        this.emit(events_1.UnleashEvents.Count, name, enabled);
      });
      this.metrics.on(events_1.UnleashEvents.Registered, (payload) => {
        this.emit(events_1.UnleashEvents.Registered, payload);
      });
      if (!disableAutoStart) {
        process.nextTick(async () => this.start());
      }
    }
    static getInstance(config) {
      const cleanConfig = {
        ...config,
        repository: undefined,
        customHeadersFunction: undefined,
        storageProvider: undefined
      };
      const configSignature = (0, helpers_1.generateHashOfConfig)(cleanConfig);
      if (Unleash.instance) {
        if (configSignature !== Unleash.configSignature) {
          throw new Error("You already have an Unleash instance with a different configuration.");
        }
        return Unleash.instance;
      }
      const instance = new Unleash(config);
      Unleash.instance = instance;
      Unleash.configSignature = configSignature;
      return instance;
    }
    cleanUnleashUrl(url) {
      let unleashUrl = url;
      if (unleashUrl.endsWith("/features")) {
        const oldUrl = unleashUrl;
        process.nextTick(() => this.emit(events_1.UnleashEvents.Warn, `Unleash server URL "${oldUrl}" should no longer link directly to /features`));
        unleashUrl = unleashUrl.replace(/\/features$/, "");
      }
      if (!unleashUrl.endsWith("/")) {
        unleashUrl += "/";
      }
      return unleashUrl;
    }
    isSynchronized() {
      return this.synchronized;
    }
    async start() {
      if (this.started)
        return;
      this.started = true;
      await Promise.all([this.repository.start(), this.metrics.start()]);
    }
    destroy() {
      this.repository.stop();
      this.metrics.stop();
      Unleash.instance = undefined;
      Unleash.configSignature = undefined;
      Unleash.instanceCount--;
    }
    isEnabled(name, context = {}, fallback) {
      const enhancedContext = { ...this.staticContext, ...context };
      const fallbackFunc = (0, helpers_1.createFallbackFunction)(name, enhancedContext, fallback);
      let result;
      if (this.ready) {
        result = this.client.isEnabled(name, enhancedContext, fallbackFunc);
      } else {
        result = fallbackFunc();
        this.emit(events_1.UnleashEvents.Warn, `Unleash has not been initialized yet. isEnabled(${name}) defaulted to ${result}`);
      }
      this.count(name, result);
      return result;
    }
    getVariant(name, context = {}, fallbackVariant) {
      const enhancedContext = { ...this.staticContext, ...context };
      let variant;
      if (this.ready) {
        variant = this.client.getVariant(name, enhancedContext, fallbackVariant);
      } else {
        variant = typeof fallbackVariant !== "undefined" ? { ...fallbackVariant, feature_enabled: false, featureEnabled: false } : { ...variant_1.defaultVariant, featureEnabled: variant_1.defaultVariant.feature_enabled ?? false };
        this.emit(events_1.UnleashEvents.Warn, `Unleash has not been initialized yet. isEnabled(${name}) defaulted to ${variant}`);
      }
      if (variant.name) {
        this.countVariant(name, variant.name);
      }
      this.count(name, Boolean(variant.feature_enabled));
      return variant;
    }
    forceGetVariant(name, context = {}, fallbackVariant) {
      const enhancedContext = { ...this.staticContext, ...context };
      let variant;
      if (this.ready) {
        variant = this.client.forceGetVariant(name, enhancedContext, fallbackVariant);
      } else {
        variant = typeof fallbackVariant !== "undefined" ? { ...fallbackVariant, feature_enabled: false } : variant_1.defaultVariant;
        this.emit(events_1.UnleashEvents.Warn, `Unleash has not been initialized yet. isEnabled(${name}) defaulted to ${variant}`);
      }
      if (variant.name) {
        this.countVariant(name, variant.name);
      }
      this.count(name, variant.feature_enabled || false);
      return variant;
    }
    getFeatureToggleDefinition(toggleName) {
      return this.repository.getToggle(toggleName);
    }
    getFeatureToggleDefinitions(withFullSegments) {
      if (withFullSegments === true) {
        return this.repository.getTogglesWithSegmentData();
      }
      return this.repository.getToggles();
    }
    count(toggleName, enabled) {
      this.metrics.count(toggleName, enabled);
    }
    countVariant(toggleName, variantName) {
      this.metrics.countVariant(toggleName, variantName);
    }
    flushMetrics() {
      return this.metrics.sendMetrics();
    }
    async destroyWithFlush() {
      await this.flushMetrics();
      this.destroy();
    }
    async setExperimentalMode(mode) {
      if (this.repository.setMode) {
        return this.repository.setMode(mode);
      }
      throw new Error("setMode is not supported by this repository implementation");
    }
  }
  exports.Unleash = Unleash;
});

// node_modules/unleash-client/lib/impact-metrics/metric-client.js
var require_metric_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnleashMetricClient = undefined;
  var unleash_1 = require_unleash();

  class UnleashMetricClient extends unleash_1.Unleash {
    constructor(...args) {
      super(...args);
      console.warn("UnleashMetricClient is deprecated. " + "This functionality now lives in UnleashClient. " + "This class will be removed in the next major release.");
    }
  }
  exports.UnleashMetricClient = UnleashMetricClient;
});

// node_modules/unleash-client/lib/index.js
var require_lib13 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnleashMetricClient = exports.UnleashEvents = exports.InMemStorageProvider = exports.Unleash = exports.PayloadType = exports.Strategy = undefined;
  exports.initialize = initialize;
  exports.startUnleash = startUnleash;
  exports.isEnabled = isEnabled;
  exports.destroy = destroy;
  exports.getFeatureToggleDefinition = getFeatureToggleDefinition;
  exports.getFeatureToggleDefinitions = getFeatureToggleDefinitions;
  exports.getVariant = getVariant;
  exports.forceGetVariant = forceGetVariant;
  exports.count = count;
  exports.countVariant = countVariant;
  exports.flushMetrics = flushMetrics;
  exports.destroyWithFlush = destroyWithFlush;
  var node_events_1 = __require("node:events");
  var events_1 = require_events();
  Object.defineProperty(exports, "UnleashEvents", { enumerable: true, get: function() {
    return events_1.UnleashEvents;
  } });
  var storage_provider_in_mem_1 = __importDefault(require_storage_provider_in_mem());
  exports.InMemStorageProvider = storage_provider_in_mem_1.default;
  var unleash_1 = require_unleash();
  Object.defineProperty(exports, "Unleash", { enumerable: true, get: function() {
    return unleash_1.Unleash;
  } });
  var variant_1 = require_variant();
  Object.defineProperty(exports, "PayloadType", { enumerable: true, get: function() {
    return variant_1.PayloadType;
  } });
  var index_1 = require_strategy2();
  Object.defineProperty(exports, "Strategy", { enumerable: true, get: function() {
    return index_1.Strategy;
  } });
  var metric_client_1 = require_metric_client();
  Object.defineProperty(exports, "UnleashMetricClient", { enumerable: true, get: function() {
    return metric_client_1.UnleashMetricClient;
  } });
  var instance;
  function initialize(options) {
    instance = unleash_1.Unleash.getInstance(options);
    return instance;
  }
  async function startUnleash(options) {
    const unleash = initialize(options);
    if (!unleash.isSynchronized()) {
      await (0, node_events_1.once)(unleash, "synchronized");
    }
    return unleash;
  }
  function isEnabled(name, context = {}, fallbackValue) {
    return instance ? instance.isEnabled(name, context, fallbackValue) : !!fallbackValue;
  }
  function destroy() {
    if (instance) {
      instance.destroy();
    }
    instance = undefined;
  }
  function getFeatureToggleDefinition(toggleName) {
    return instance?.getFeatureToggleDefinition(toggleName);
  }
  function getFeatureToggleDefinitions(withFullSegments = false) {
    return instance?.getFeatureToggleDefinitions(withFullSegments);
  }
  function getVariant(name, context = {}, fallbackVariant) {
    const variant = fallbackVariant || variant_1.defaultVariant;
    return instance ? instance.getVariant(name, context, variant) : variant;
  }
  function forceGetVariant(name, context = {}, fallbackVariant) {
    const variant = fallbackVariant || variant_1.defaultVariant;
    return instance ? instance.forceGetVariant(name, context, variant) : variant;
  }
  function count(toggleName, enabled) {
    return instance?.count(toggleName, enabled);
  }
  function countVariant(toggleName, variantName) {
    return instance?.countVariant(toggleName, variantName);
  }
  async function flushMetrics() {
    return instance?.flushMetrics();
  }
  async function destroyWithFlush() {
    return instance?.destroyWithFlush();
  }
});

// node_modules/postal-mime/src/decode-strings.js
function decodeBase642(base64) {
  let bufferLength = Math.ceil(base64.length / 4) * 3;
  const len = base64.length;
  let p = 0;
  if (base64.length % 4 === 3) {
    bufferLength--;
  } else if (base64.length % 4 === 2) {
    bufferLength -= 2;
  } else if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arrayBuffer = new ArrayBuffer(bufferLength);
  const bytes = new Uint8Array(arrayBuffer);
  for (let i2 = 0;i2 < len; i2 += 4) {
    let encoded1 = base64Lookup[base64.charCodeAt(i2)];
    let encoded2 = base64Lookup[base64.charCodeAt(i2 + 1)];
    let encoded3 = base64Lookup[base64.charCodeAt(i2 + 2)];
    let encoded4 = base64Lookup[base64.charCodeAt(i2 + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arrayBuffer;
}
function getDecoder(charset) {
  charset = charset || "utf8";
  let decoder2;
  try {
    decoder2 = new TextDecoder(charset);
  } catch (err) {
    decoder2 = new TextDecoder("windows-1252");
  }
  return decoder2;
}
async function blobToArrayBuffer(blob) {
  if ("arrayBuffer" in blob) {
    return await blob.arrayBuffer();
  }
  const fr = new FileReader;
  return new Promise((resolve, reject) => {
    fr.onload = function(e) {
      resolve(e.target.result);
    };
    fr.onerror = function(e) {
      reject(fr.error);
    };
    fr.readAsArrayBuffer(blob);
  });
}
function getHex(c) {
  if (c >= 48 && c <= 57 || c >= 97 && c <= 102 || c >= 65 && c <= 70) {
    return String.fromCharCode(c);
  }
  return false;
}
function decodeWord(charset, encoding, str) {
  let splitPos = charset.indexOf("*");
  if (splitPos >= 0) {
    charset = charset.substr(0, splitPos);
  }
  encoding = encoding.toUpperCase();
  let byteStr;
  if (encoding === "Q") {
    str = str.replace(/=\s+([0-9a-fA-F])/g, "=$1").replace(/[_\s]/g, " ");
    let buf = textEncoder.encode(str);
    let encodedBytes = [];
    for (let i2 = 0, len = buf.length;i2 < len; i2++) {
      let c = buf[i2];
      if (i2 <= len - 2 && c === 61) {
        let c1 = getHex(buf[i2 + 1]);
        let c2 = getHex(buf[i2 + 2]);
        if (c1 && c2) {
          let c3 = parseInt(c1 + c2, 16);
          encodedBytes.push(c3);
          i2 += 2;
          continue;
        }
      }
      encodedBytes.push(c);
    }
    byteStr = new ArrayBuffer(encodedBytes.length);
    let dataView = new DataView(byteStr);
    for (let i2 = 0, len = encodedBytes.length;i2 < len; i2++) {
      dataView.setUint8(i2, encodedBytes[i2]);
    }
  } else if (encoding === "B") {
    byteStr = decodeBase642(str.replace(/[^a-zA-Z0-9\+\/=]+/g, ""));
  } else {
    byteStr = textEncoder.encode(str);
  }
  return getDecoder(charset).decode(byteStr);
}
function decodeWords(str) {
  let joinString = true;
  let done = false;
  while (!done) {
    let result = (str || "").toString().replace(/(=\?([^?]+)\?[Bb]\?([^?]*)\?=)\s*(?==\?([^?]+)\?[Bb]\?[^?]*\?=)/g, (match, left, chLeft, encodedLeftStr, chRight) => {
      if (!joinString) {
        return match;
      }
      if (chLeft === chRight && encodedLeftStr.length % 4 === 0 && !/=$/.test(encodedLeftStr)) {
        return left + "__\x00JOIN\x00__";
      }
      return match;
    }).replace(/(=\?([^?]+)\?[Qq]\?[^?]*\?=)\s*(?==\?([^?]+)\?[Qq]\?[^?]*\?=)/g, (match, left, chLeft, chRight) => {
      if (!joinString) {
        return match;
      }
      if (chLeft === chRight) {
        return left + "__\x00JOIN\x00__";
      }
      return match;
    }).replace(/(\?=)?__\x00JOIN\x00__(=\?([^?]+)\?[QqBb]\?)?/g, "").replace(/(=\?[^?]+\?[QqBb]\?[^?]*\?=)\s+(?==\?[^?]+\?[QqBb]\?[^?]*\?=)/g, "$1").replace(/=\?([\w_\-*]+)\?([QqBb])\?([^?]*)\?=/g, (m, charset, encoding, text) => decodeWord(charset, encoding, text));
    if (joinString && result.indexOf("") >= 0) {
      joinString = false;
    } else {
      return result;
    }
  }
}
function decodeURIComponentWithCharset(encodedStr, charset) {
  charset = charset || "utf-8";
  let encodedBytes = [];
  for (let i2 = 0;i2 < encodedStr.length; i2++) {
    let c = encodedStr.charAt(i2);
    if (c === "%" && /^[a-f0-9]{2}/i.test(encodedStr.substr(i2 + 1, 2))) {
      let byte = encodedStr.substr(i2 + 1, 2);
      i2 += 2;
      encodedBytes.push(parseInt(byte, 16));
    } else if (c.charCodeAt(0) > 126) {
      c = textEncoder.encode(c);
      for (let j = 0;j < c.length; j++) {
        encodedBytes.push(c[j]);
      }
    } else {
      encodedBytes.push(c.charCodeAt(0));
    }
  }
  const byteStr = new ArrayBuffer(encodedBytes.length);
  const dataView = new DataView(byteStr);
  for (let i2 = 0, len = encodedBytes.length;i2 < len; i2++) {
    dataView.setUint8(i2, encodedBytes[i2]);
  }
  return getDecoder(charset).decode(byteStr);
}
function decodeParameterValueContinuations(header) {
  let paramKeys = new Map;
  Object.keys(header.params).forEach((key) => {
    let match = key.match(/\*((\d+)\*?)?$/);
    if (!match) {
      return;
    }
    let actualKey = key.substr(0, match.index).toLowerCase();
    let nr = Number(match[2]) || 0;
    let paramVal;
    if (!paramKeys.has(actualKey)) {
      paramVal = {
        charset: false,
        values: []
      };
      paramKeys.set(actualKey, paramVal);
    } else {
      paramVal = paramKeys.get(actualKey);
    }
    let value = header.params[key];
    if (nr === 0 && match[0].charAt(match[0].length - 1) === "*" && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {
      paramVal.charset = match[1] || "utf-8";
      value = match[2];
    }
    paramVal.values.push({ nr, value });
    delete header.params[key];
  });
  paramKeys.forEach((paramVal, key) => {
    header.params[key] = decodeURIComponentWithCharset(paramVal.values.sort((a, b) => a.nr - b.nr).map((a) => a.value).join(""), paramVal.charset);
  });
}
var textEncoder, base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", base64Lookup, i;
var init_decode_strings = __esm(() => {
  textEncoder = new TextEncoder;
  base64Lookup = new Uint8Array(256);
  for (i = 0;i < base64Chars.length; i++) {
    base64Lookup[base64Chars.charCodeAt(i)] = i;
  }
});

// node_modules/postal-mime/src/pass-through-decoder.js
class PassThroughDecoder {
  constructor() {
    this.chunks = [];
  }
  update(line) {
    this.chunks.push(line);
    this.chunks.push(`
`);
  }
  finalize() {
    return blobToArrayBuffer(new Blob(this.chunks, { type: "application/octet-stream" }));
  }
}
var init_pass_through_decoder = __esm(() => {
  init_decode_strings();
});

// node_modules/postal-mime/src/base64-decoder.js
class Base64Decoder {
  constructor(opts) {
    opts = opts || {};
    this.decoder = opts.decoder || new TextDecoder;
    this.maxChunkSize = 100 * 1024;
    this.chunks = [];
    this.remainder = "";
  }
  update(buffer) {
    let str = this.decoder.decode(buffer);
    if (/[^a-zA-Z0-9+\/]/.test(str)) {
      str = str.replace(/[^a-zA-Z0-9+\/]+/g, "");
    }
    this.remainder += str;
    if (this.remainder.length >= this.maxChunkSize) {
      let allowedBytes = Math.floor(this.remainder.length / 4) * 4;
      let base64Str;
      if (allowedBytes === this.remainder.length) {
        base64Str = this.remainder;
        this.remainder = "";
      } else {
        base64Str = this.remainder.substr(0, allowedBytes);
        this.remainder = this.remainder.substr(allowedBytes);
      }
      if (base64Str.length) {
        this.chunks.push(decodeBase642(base64Str));
      }
    }
  }
  finalize() {
    if (this.remainder && !/^=+$/.test(this.remainder)) {
      this.chunks.push(decodeBase642(this.remainder));
    }
    return blobToArrayBuffer(new Blob(this.chunks, { type: "application/octet-stream" }));
  }
}
var init_base64_decoder = __esm(() => {
  init_decode_strings();
});

// node_modules/postal-mime/src/qp-decoder.js
class QPDecoder {
  constructor(opts) {
    opts = opts || {};
    this.decoder = opts.decoder || new TextDecoder;
    this.maxChunkSize = 100 * 1024;
    this.remainder = "";
    this.chunks = [];
  }
  decodeQPBytes(encodedBytes) {
    let buf = new ArrayBuffer(encodedBytes.length);
    let dataView = new DataView(buf);
    for (let i2 = 0, len = encodedBytes.length;i2 < len; i2++) {
      dataView.setUint8(i2, parseInt(encodedBytes[i2], 16));
    }
    return buf;
  }
  decodeChunks(str) {
    str = str.replace(SOFT_LINE_BREAK_REGEX, "");
    let list = str.split(QP_SPLIT_REGEX);
    let encodedBytes = [];
    for (let part of list) {
      if (part.charAt(0) !== "=") {
        if (encodedBytes.length) {
          this.chunks.push(this.decodeQPBytes(encodedBytes));
          encodedBytes = [];
        }
        this.chunks.push(part);
        continue;
      }
      if (part.length === 3) {
        if (VALID_QP_REGEX.test(part)) {
          encodedBytes.push(part.substr(1));
        } else {
          if (encodedBytes.length) {
            this.chunks.push(this.decodeQPBytes(encodedBytes));
            encodedBytes = [];
          }
          this.chunks.push(part);
        }
        continue;
      }
      if (part.length > 3) {
        const firstThree = part.substr(0, 3);
        if (VALID_QP_REGEX.test(firstThree)) {
          encodedBytes.push(part.substr(1, 2));
          this.chunks.push(this.decodeQPBytes(encodedBytes));
          encodedBytes = [];
          part = part.substr(3);
          this.chunks.push(part);
        } else {
          if (encodedBytes.length) {
            this.chunks.push(this.decodeQPBytes(encodedBytes));
            encodedBytes = [];
          }
          this.chunks.push(part);
        }
      }
    }
    if (encodedBytes.length) {
      this.chunks.push(this.decodeQPBytes(encodedBytes));
      encodedBytes = [];
    }
  }
  update(buffer) {
    let str = this.decoder.decode(buffer) + `
`;
    str = this.remainder + str;
    if (str.length < this.maxChunkSize) {
      this.remainder = str;
      return;
    }
    this.remainder = "";
    let partialEnding = str.match(PARTIAL_QP_ENDING_REGEX);
    if (partialEnding) {
      if (partialEnding.index === 0) {
        this.remainder = str;
        return;
      }
      this.remainder = str.substr(partialEnding.index);
      str = str.substr(0, partialEnding.index);
    }
    this.decodeChunks(str);
  }
  finalize() {
    if (this.remainder.length) {
      this.decodeChunks(this.remainder);
      this.remainder = "";
    }
    return blobToArrayBuffer(new Blob(this.chunks, { type: "application/octet-stream" }));
  }
}
var VALID_QP_REGEX, QP_SPLIT_REGEX, SOFT_LINE_BREAK_REGEX, PARTIAL_QP_ENDING_REGEX;
var init_qp_decoder = __esm(() => {
  init_decode_strings();
  VALID_QP_REGEX = /^=[a-f0-9]{2}$/i;
  QP_SPLIT_REGEX = /(?==[a-f0-9]{2})/i;
  SOFT_LINE_BREAK_REGEX = /=\r?\n/g;
  PARTIAL_QP_ENDING_REGEX = /=[a-fA-F0-9]?$/;
});

// node_modules/postal-mime/src/mime-node.js
class MimeNode {
  constructor(options) {
    this.options = options || {};
    this.postalMime = this.options.postalMime;
    this.root = !!this.options.parentNode;
    this.childNodes = [];
    if (this.options.parentNode) {
      this.parentNode = this.options.parentNode;
      this.depth = this.parentNode.depth + 1;
      if (this.depth > this.options.maxNestingDepth) {
        throw new Error(`Maximum MIME nesting depth of ${this.options.maxNestingDepth} levels exceeded`);
      }
      this.options.parentNode.childNodes.push(this);
    } else {
      this.depth = 0;
    }
    this.state = "header";
    this.headerLines = [];
    this.headerSize = 0;
    const parentMultipartType = this.options.parentMultipartType || null;
    const defaultContentType = parentMultipartType === "digest" ? "message/rfc822" : "text/plain";
    this.contentType = {
      value: defaultContentType,
      default: true
    };
    this.contentTransferEncoding = {
      value: "8bit"
    };
    this.contentDisposition = {
      value: ""
    };
    this.headers = [];
    this.contentDecoder = false;
  }
  setupContentDecoder(transferEncoding) {
    if (/base64/i.test(transferEncoding)) {
      this.contentDecoder = new Base64Decoder;
    } else if (/quoted-printable/i.test(transferEncoding)) {
      this.contentDecoder = new QPDecoder({ decoder: getDecoder(this.contentType.parsed.params.charset) });
    } else {
      this.contentDecoder = new PassThroughDecoder;
    }
  }
  async finalize() {
    if (this.state === "finished") {
      return;
    }
    if (this.state === "header") {
      this.processHeaders();
    }
    let boundaries = this.postalMime.boundaries;
    for (let i2 = boundaries.length - 1;i2 >= 0; i2--) {
      let boundary = boundaries[i2];
      if (boundary.node === this) {
        boundaries.splice(i2, 1);
        break;
      }
    }
    await this.finalizeChildNodes();
    this.content = this.contentDecoder ? await this.contentDecoder.finalize() : null;
    this.state = "finished";
  }
  async finalizeChildNodes() {
    for (let childNode of this.childNodes) {
      await childNode.finalize();
    }
  }
  stripComments(str) {
    let result = "";
    let depth = 0;
    let escaped = false;
    let inQuote = false;
    for (let i2 = 0;i2 < str.length; i2++) {
      const chr = str.charAt(i2);
      if (escaped) {
        if (depth === 0) {
          result += chr;
        }
        escaped = false;
        continue;
      }
      if (chr === "\\") {
        escaped = true;
        if (depth === 0) {
          result += chr;
        }
        continue;
      }
      if (chr === '"' && depth === 0) {
        inQuote = !inQuote;
        result += chr;
        continue;
      }
      if (!inQuote) {
        if (chr === "(") {
          depth++;
          continue;
        }
        if (chr === ")" && depth > 0) {
          depth--;
          continue;
        }
      }
      if (depth === 0) {
        result += chr;
      }
    }
    return result;
  }
  parseStructuredHeader(str) {
    str = this.stripComments(str);
    let response = {
      value: false,
      params: {}
    };
    let key = false;
    let value = "";
    let stage = "value";
    let quote = false;
    let escaped = false;
    let chr;
    for (let i2 = 0, len = str.length;i2 < len; i2++) {
      chr = str.charAt(i2);
      switch (stage) {
        case "key":
          if (chr === "=") {
            key = value.trim().toLowerCase();
            stage = "value";
            value = "";
            break;
          }
          value += chr;
          break;
        case "value":
          if (escaped) {
            value += chr;
          } else if (chr === "\\") {
            escaped = true;
            continue;
          } else if (quote && chr === quote) {
            quote = false;
          } else if (!quote && chr === '"') {
            quote = chr;
          } else if (!quote && chr === ";") {
            if (key === false) {
              response.value = value.trim();
            } else {
              response.params[key] = value.trim();
            }
            stage = "key";
            value = "";
          } else {
            value += chr;
          }
          escaped = false;
          break;
      }
    }
    value = value.trim();
    if (stage === "value") {
      if (key === false) {
        response.value = value;
      } else {
        response.params[key] = value;
      }
    } else if (value) {
      response.params[value.toLowerCase()] = "";
    }
    if (response.value) {
      response.value = response.value.toLowerCase();
    }
    decodeParameterValueContinuations(response);
    return response;
  }
  decodeFlowedText(str, delSp) {
    return str.split(/\r?\n/).reduce((previousValue, currentValue) => {
      if (/ $/.test(previousValue) && !/(^|\n)-- $/.test(previousValue)) {
        if (delSp) {
          return previousValue.slice(0, -1) + currentValue;
        } else {
          return previousValue + currentValue;
        }
      } else {
        return previousValue + `
` + currentValue;
      }
    }).replace(/^ /gm, "");
  }
  getTextContent() {
    if (!this.content) {
      return "";
    }
    let str = getDecoder(this.contentType.parsed.params.charset).decode(this.content);
    if (/^flowed$/i.test(this.contentType.parsed.params.format)) {
      str = this.decodeFlowedText(str, /^yes$/i.test(this.contentType.parsed.params.delsp));
    }
    return str;
  }
  processHeaders() {
    for (let i2 = this.headerLines.length - 1;i2 >= 0; i2--) {
      let line = this.headerLines[i2];
      if (i2 && /^\s/.test(line)) {
        this.headerLines[i2 - 1] += `
` + line;
        this.headerLines.splice(i2, 1);
      }
    }
    this.rawHeaderLines = [];
    for (let i2 = this.headerLines.length - 1;i2 >= 0; i2--) {
      let rawLine = this.headerLines[i2];
      let sep = rawLine.indexOf(":");
      let rawKey = sep < 0 ? rawLine.trim() : rawLine.substr(0, sep).trim();
      this.rawHeaderLines.push({
        key: rawKey.toLowerCase(),
        line: rawLine
      });
      let normalizedLine = rawLine.replace(/\s+/g, " ");
      sep = normalizedLine.indexOf(":");
      let key = sep < 0 ? normalizedLine.trim() : normalizedLine.substr(0, sep).trim();
      let value = sep < 0 ? "" : normalizedLine.substr(sep + 1).trim();
      this.headers.push({ key: key.toLowerCase(), originalKey: key, value });
      switch (key.toLowerCase()) {
        case "content-type":
          if (this.contentType.default) {
            this.contentType = { value, parsed: {} };
          }
          break;
        case "content-transfer-encoding":
          this.contentTransferEncoding = { value, parsed: {} };
          break;
        case "content-disposition":
          this.contentDisposition = { value, parsed: {} };
          break;
        case "content-id":
          this.contentId = value;
          break;
        case "content-description":
          this.contentDescription = value;
          break;
      }
    }
    this.contentType.parsed = this.parseStructuredHeader(this.contentType.value);
    this.contentType.multipart = /^multipart\//i.test(this.contentType.parsed.value) ? this.contentType.parsed.value.substr(this.contentType.parsed.value.indexOf("/") + 1) : false;
    if (this.contentType.multipart && this.contentType.parsed.params.boundary) {
      this.postalMime.boundaries.push({
        value: textEncoder.encode(this.contentType.parsed.params.boundary),
        node: this
      });
    }
    this.contentDisposition.parsed = this.parseStructuredHeader(this.contentDisposition.value);
    this.contentTransferEncoding.encoding = this.contentTransferEncoding.value.toLowerCase().split(/[^\w-]/).shift();
    this.setupContentDecoder(this.contentTransferEncoding.encoding);
  }
  feed(line) {
    switch (this.state) {
      case "header":
        if (!line.length) {
          this.state = "body";
          return this.processHeaders();
        }
        this.headerSize += line.length;
        if (this.headerSize > this.options.maxHeadersSize) {
          let error = new Error(`Maximum header size of ${this.options.maxHeadersSize} bytes exceeded`);
          throw error;
        }
        this.headerLines.push(getDecoder().decode(line));
        break;
      case "body": {
        this.contentDecoder.update(line);
      }
    }
  }
}
var init_mime_node = __esm(() => {
  init_decode_strings();
  init_pass_through_decoder();
  init_base64_decoder();
  init_qp_decoder();
});

// node_modules/postal-mime/src/html-entities.js
var htmlEntities, html_entities_default;
var init_html_entities = __esm(() => {
  htmlEntities = {
    "&AElig": "",
    "&AElig;": "",
    "&AMP": "&",
    "&AMP;": "&",
    "&Aacute": "",
    "&Aacute;": "",
    "&Abreve;": "",
    "&Acirc": "",
    "&Acirc;": "",
    "&Acy;": "",
    "&Afr;": "\uD835\uDD04",
    "&Agrave": "",
    "&Agrave;": "",
    "&Alpha;": "",
    "&Amacr;": "",
    "&And;": "",
    "&Aogon;": "",
    "&Aopf;": "\uD835\uDD38",
    "&ApplyFunction;": "",
    "&Aring": "",
    "&Aring;": "",
    "&Ascr;": "\uD835\uDC9C",
    "&Assign;": "",
    "&Atilde": "",
    "&Atilde;": "",
    "&Auml": "",
    "&Auml;": "",
    "&Backslash;": "",
    "&Barv;": "",
    "&Barwed;": "",
    "&Bcy;": "",
    "&Because;": "",
    "&Bernoullis;": "",
    "&Beta;": "",
    "&Bfr;": "\uD835\uDD05",
    "&Bopf;": "\uD835\uDD39",
    "&Breve;": "",
    "&Bscr;": "",
    "&Bumpeq;": "",
    "&CHcy;": "",
    "&COPY": "",
    "&COPY;": "",
    "&Cacute;": "",
    "&Cap;": "",
    "&CapitalDifferentialD;": "",
    "&Cayleys;": "",
    "&Ccaron;": "",
    "&Ccedil": "",
    "&Ccedil;": "",
    "&Ccirc;": "",
    "&Cconint;": "",
    "&Cdot;": "",
    "&Cedilla;": "",
    "&CenterDot;": "",
    "&Cfr;": "",
    "&Chi;": "",
    "&CircleDot;": "",
    "&CircleMinus;": "",
    "&CirclePlus;": "",
    "&CircleTimes;": "",
    "&ClockwiseContourIntegral;": "",
    "&CloseCurlyDoubleQuote;": "",
    "&CloseCurlyQuote;": "",
    "&Colon;": "",
    "&Colone;": "",
    "&Congruent;": "",
    "&Conint;": "",
    "&ContourIntegral;": "",
    "&Copf;": "",
    "&Coproduct;": "",
    "&CounterClockwiseContourIntegral;": "",
    "&Cross;": "",
    "&Cscr;": "\uD835\uDC9E",
    "&Cup;": "",
    "&CupCap;": "",
    "&DD;": "",
    "&DDotrahd;": "",
    "&DJcy;": "",
    "&DScy;": "",
    "&DZcy;": "",
    "&Dagger;": "",
    "&Darr;": "",
    "&Dashv;": "",
    "&Dcaron;": "",
    "&Dcy;": "",
    "&Del;": "",
    "&Delta;": "",
    "&Dfr;": "\uD835\uDD07",
    "&DiacriticalAcute;": "",
    "&DiacriticalDot;": "",
    "&DiacriticalDoubleAcute;": "",
    "&DiacriticalGrave;": "`",
    "&DiacriticalTilde;": "",
    "&Diamond;": "",
    "&DifferentialD;": "",
    "&Dopf;": "\uD835\uDD3B",
    "&Dot;": "",
    "&DotDot;": "",
    "&DotEqual;": "",
    "&DoubleContourIntegral;": "",
    "&DoubleDot;": "",
    "&DoubleDownArrow;": "",
    "&DoubleLeftArrow;": "",
    "&DoubleLeftRightArrow;": "",
    "&DoubleLeftTee;": "",
    "&DoubleLongLeftArrow;": "",
    "&DoubleLongLeftRightArrow;": "",
    "&DoubleLongRightArrow;": "",
    "&DoubleRightArrow;": "",
    "&DoubleRightTee;": "",
    "&DoubleUpArrow;": "",
    "&DoubleUpDownArrow;": "",
    "&DoubleVerticalBar;": "",
    "&DownArrow;": "",
    "&DownArrowBar;": "",
    "&DownArrowUpArrow;": "",
    "&DownBreve;": "",
    "&DownLeftRightVector;": "",
    "&DownLeftTeeVector;": "",
    "&DownLeftVector;": "",
    "&DownLeftVectorBar;": "",
    "&DownRightTeeVector;": "",
    "&DownRightVector;": "",
    "&DownRightVectorBar;": "",
    "&DownTee;": "",
    "&DownTeeArrow;": "",
    "&Downarrow;": "",
    "&Dscr;": "\uD835\uDC9F",
    "&Dstrok;": "",
    "&ENG;": "",
    "&ETH": "",
    "&ETH;": "",
    "&Eacute": "",
    "&Eacute;": "",
    "&Ecaron;": "",
    "&Ecirc": "",
    "&Ecirc;": "",
    "&Ecy;": "",
    "&Edot;": "",
    "&Efr;": "\uD835\uDD08",
    "&Egrave": "",
    "&Egrave;": "",
    "&Element;": "",
    "&Emacr;": "",
    "&EmptySmallSquare;": "",
    "&EmptyVerySmallSquare;": "",
    "&Eogon;": "",
    "&Eopf;": "\uD835\uDD3C",
    "&Epsilon;": "",
    "&Equal;": "",
    "&EqualTilde;": "",
    "&Equilibrium;": "",
    "&Escr;": "",
    "&Esim;": "",
    "&Eta;": "",
    "&Euml": "",
    "&Euml;": "",
    "&Exists;": "",
    "&ExponentialE;": "",
    "&Fcy;": "",
    "&Ffr;": "\uD835\uDD09",
    "&FilledSmallSquare;": "",
    "&FilledVerySmallSquare;": "",
    "&Fopf;": "\uD835\uDD3D",
    "&ForAll;": "",
    "&Fouriertrf;": "",
    "&Fscr;": "",
    "&GJcy;": "",
    "&GT": ">",
    "&GT;": ">",
    "&Gamma;": "",
    "&Gammad;": "",
    "&Gbreve;": "",
    "&Gcedil;": "",
    "&Gcirc;": "",
    "&Gcy;": "",
    "&Gdot;": "",
    "&Gfr;": "\uD835\uDD0A",
    "&Gg;": "",
    "&Gopf;": "\uD835\uDD3E",
    "&GreaterEqual;": "",
    "&GreaterEqualLess;": "",
    "&GreaterFullEqual;": "",
    "&GreaterGreater;": "",
    "&GreaterLess;": "",
    "&GreaterSlantEqual;": "",
    "&GreaterTilde;": "",
    "&Gscr;": "\uD835\uDCA2",
    "&Gt;": "",
    "&HARDcy;": "",
    "&Hacek;": "",
    "&Hat;": "^",
    "&Hcirc;": "",
    "&Hfr;": "",
    "&HilbertSpace;": "",
    "&Hopf;": "",
    "&HorizontalLine;": "",
    "&Hscr;": "",
    "&Hstrok;": "",
    "&HumpDownHump;": "",
    "&HumpEqual;": "",
    "&IEcy;": "",
    "&IJlig;": "",
    "&IOcy;": "",
    "&Iacute": "",
    "&Iacute;": "",
    "&Icirc": "",
    "&Icirc;": "",
    "&Icy;": "",
    "&Idot;": "",
    "&Ifr;": "",
    "&Igrave": "",
    "&Igrave;": "",
    "&Im;": "",
    "&Imacr;": "",
    "&ImaginaryI;": "",
    "&Implies;": "",
    "&Int;": "",
    "&Integral;": "",
    "&Intersection;": "",
    "&InvisibleComma;": "",
    "&InvisibleTimes;": "",
    "&Iogon;": "",
    "&Iopf;": "\uD835\uDD40",
    "&Iota;": "",
    "&Iscr;": "",
    "&Itilde;": "",
    "&Iukcy;": "",
    "&Iuml": "",
    "&Iuml;": "",
    "&Jcirc;": "",
    "&Jcy;": "",
    "&Jfr;": "\uD835\uDD0D",
    "&Jopf;": "\uD835\uDD41",
    "&Jscr;": "\uD835\uDCA5",
    "&Jsercy;": "",
    "&Jukcy;": "",
    "&KHcy;": "",
    "&KJcy;": "",
    "&Kappa;": "",
    "&Kcedil;": "",
    "&Kcy;": "",
    "&Kfr;": "\uD835\uDD0E",
    "&Kopf;": "\uD835\uDD42",
    "&Kscr;": "\uD835\uDCA6",
    "&LJcy;": "",
    "&LT": "<",
    "&LT;": "<",
    "&Lacute;": "",
    "&Lambda;": "",
    "&Lang;": "",
    "&Laplacetrf;": "",
    "&Larr;": "",
    "&Lcaron;": "",
    "&Lcedil;": "",
    "&Lcy;": "",
    "&LeftAngleBracket;": "",
    "&LeftArrow;": "",
    "&LeftArrowBar;": "",
    "&LeftArrowRightArrow;": "",
    "&LeftCeiling;": "",
    "&LeftDoubleBracket;": "",
    "&LeftDownTeeVector;": "",
    "&LeftDownVector;": "",
    "&LeftDownVectorBar;": "",
    "&LeftFloor;": "",
    "&LeftRightArrow;": "",
    "&LeftRightVector;": "",
    "&LeftTee;": "",
    "&LeftTeeArrow;": "",
    "&LeftTeeVector;": "",
    "&LeftTriangle;": "",
    "&LeftTriangleBar;": "",
    "&LeftTriangleEqual;": "",
    "&LeftUpDownVector;": "",
    "&LeftUpTeeVector;": "",
    "&LeftUpVector;": "",
    "&LeftUpVectorBar;": "",
    "&LeftVector;": "",
    "&LeftVectorBar;": "",
    "&Leftarrow;": "",
    "&Leftrightarrow;": "",
    "&LessEqualGreater;": "",
    "&LessFullEqual;": "",
    "&LessGreater;": "",
    "&LessLess;": "",
    "&LessSlantEqual;": "",
    "&LessTilde;": "",
    "&Lfr;": "\uD835\uDD0F",
    "&Ll;": "",
    "&Lleftarrow;": "",
    "&Lmidot;": "",
    "&LongLeftArrow;": "",
    "&LongLeftRightArrow;": "",
    "&LongRightArrow;": "",
    "&Longleftarrow;": "",
    "&Longleftrightarrow;": "",
    "&Longrightarrow;": "",
    "&Lopf;": "\uD835\uDD43",
    "&LowerLeftArrow;": "",
    "&LowerRightArrow;": "",
    "&Lscr;": "",
    "&Lsh;": "",
    "&Lstrok;": "",
    "&Lt;": "",
    "&Map;": "",
    "&Mcy;": "",
    "&MediumSpace;": "",
    "&Mellintrf;": "",
    "&Mfr;": "\uD835\uDD10",
    "&MinusPlus;": "",
    "&Mopf;": "\uD835\uDD44",
    "&Mscr;": "",
    "&Mu;": "",
    "&NJcy;": "",
    "&Nacute;": "",
    "&Ncaron;": "",
    "&Ncedil;": "",
    "&Ncy;": "",
    "&NegativeMediumSpace;": "",
    "&NegativeThickSpace;": "",
    "&NegativeThinSpace;": "",
    "&NegativeVeryThinSpace;": "",
    "&NestedGreaterGreater;": "",
    "&NestedLessLess;": "",
    "&NewLine;": `
`,
    "&Nfr;": "\uD835\uDD11",
    "&NoBreak;": "",
    "&NonBreakingSpace;": "",
    "&Nopf;": "",
    "&Not;": "",
    "&NotCongruent;": "",
    "&NotCupCap;": "",
    "&NotDoubleVerticalBar;": "",
    "&NotElement;": "",
    "&NotEqual;": "",
    "&NotEqualTilde;": "",
    "&NotExists;": "",
    "&NotGreater;": "",
    "&NotGreaterEqual;": "",
    "&NotGreaterFullEqual;": "",
    "&NotGreaterGreater;": "",
    "&NotGreaterLess;": "",
    "&NotGreaterSlantEqual;": "",
    "&NotGreaterTilde;": "",
    "&NotHumpDownHump;": "",
    "&NotHumpEqual;": "",
    "&NotLeftTriangle;": "",
    "&NotLeftTriangleBar;": "",
    "&NotLeftTriangleEqual;": "",
    "&NotLess;": "",
    "&NotLessEqual;": "",
    "&NotLessGreater;": "",
    "&NotLessLess;": "",
    "&NotLessSlantEqual;": "",
    "&NotLessTilde;": "",
    "&NotNestedGreaterGreater;": "",
    "&NotNestedLessLess;": "",
    "&NotPrecedes;": "",
    "&NotPrecedesEqual;": "",
    "&NotPrecedesSlantEqual;": "",
    "&NotReverseElement;": "",
    "&NotRightTriangle;": "",
    "&NotRightTriangleBar;": "",
    "&NotRightTriangleEqual;": "",
    "&NotSquareSubset;": "",
    "&NotSquareSubsetEqual;": "",
    "&NotSquareSuperset;": "",
    "&NotSquareSupersetEqual;": "",
    "&NotSubset;": "",
    "&NotSubsetEqual;": "",
    "&NotSucceeds;": "",
    "&NotSucceedsEqual;": "",
    "&NotSucceedsSlantEqual;": "",
    "&NotSucceedsTilde;": "",
    "&NotSuperset;": "",
    "&NotSupersetEqual;": "",
    "&NotTilde;": "",
    "&NotTildeEqual;": "",
    "&NotTildeFullEqual;": "",
    "&NotTildeTilde;": "",
    "&NotVerticalBar;": "",
    "&Nscr;": "\uD835\uDCA9",
    "&Ntilde": "",
    "&Ntilde;": "",
    "&Nu;": "",
    "&OElig;": "",
    "&Oacute": "",
    "&Oacute;": "",
    "&Ocirc": "",
    "&Ocirc;": "",
    "&Ocy;": "",
    "&Odblac;": "",
    "&Ofr;": "\uD835\uDD12",
    "&Ograve": "",
    "&Ograve;": "",
    "&Omacr;": "",
    "&Omega;": "",
    "&Omicron;": "",
    "&Oopf;": "\uD835\uDD46",
    "&OpenCurlyDoubleQuote;": "",
    "&OpenCurlyQuote;": "",
    "&Or;": "",
    "&Oscr;": "\uD835\uDCAA",
    "&Oslash": "",
    "&Oslash;": "",
    "&Otilde": "",
    "&Otilde;": "",
    "&Otimes;": "",
    "&Ouml": "",
    "&Ouml;": "",
    "&OverBar;": "",
    "&OverBrace;": "",
    "&OverBracket;": "",
    "&OverParenthesis;": "",
    "&PartialD;": "",
    "&Pcy;": "",
    "&Pfr;": "\uD835\uDD13",
    "&Phi;": "",
    "&Pi;": "",
    "&PlusMinus;": "",
    "&Poincareplane;": "",
    "&Popf;": "",
    "&Pr;": "",
    "&Precedes;": "",
    "&PrecedesEqual;": "",
    "&PrecedesSlantEqual;": "",
    "&PrecedesTilde;": "",
    "&Prime;": "",
    "&Product;": "",
    "&Proportion;": "",
    "&Proportional;": "",
    "&Pscr;": "\uD835\uDCAB",
    "&Psi;": "",
    "&QUOT": '"',
    "&QUOT;": '"',
    "&Qfr;": "\uD835\uDD14",
    "&Qopf;": "",
    "&Qscr;": "\uD835\uDCAC",
    "&RBarr;": "",
    "&REG": "",
    "&REG;": "",
    "&Racute;": "",
    "&Rang;": "",
    "&Rarr;": "",
    "&Rarrtl;": "",
    "&Rcaron;": "",
    "&Rcedil;": "",
    "&Rcy;": "",
    "&Re;": "",
    "&ReverseElement;": "",
    "&ReverseEquilibrium;": "",
    "&ReverseUpEquilibrium;": "",
    "&Rfr;": "",
    "&Rho;": "",
    "&RightAngleBracket;": "",
    "&RightArrow;": "",
    "&RightArrowBar;": "",
    "&RightArrowLeftArrow;": "",
    "&RightCeiling;": "",
    "&RightDoubleBracket;": "",
    "&RightDownTeeVector;": "",
    "&RightDownVector;": "",
    "&RightDownVectorBar;": "",
    "&RightFloor;": "",
    "&RightTee;": "",
    "&RightTeeArrow;": "",
    "&RightTeeVector;": "",
    "&RightTriangle;": "",
    "&RightTriangleBar;": "",
    "&RightTriangleEqual;": "",
    "&RightUpDownVector;": "",
    "&RightUpTeeVector;": "",
    "&RightUpVector;": "",
    "&RightUpVectorBar;": "",
    "&RightVector;": "",
    "&RightVectorBar;": "",
    "&Rightarrow;": "",
    "&Ropf;": "",
    "&RoundImplies;": "",
    "&Rrightarrow;": "",
    "&Rscr;": "",
    "&Rsh;": "",
    "&RuleDelayed;": "",
    "&SHCHcy;": "",
    "&SHcy;": "",
    "&SOFTcy;": "",
    "&Sacute;": "",
    "&Sc;": "",
    "&Scaron;": "",
    "&Scedil;": "",
    "&Scirc;": "",
    "&Scy;": "",
    "&Sfr;": "\uD835\uDD16",
    "&ShortDownArrow;": "",
    "&ShortLeftArrow;": "",
    "&ShortRightArrow;": "",
    "&ShortUpArrow;": "",
    "&Sigma;": "",
    "&SmallCircle;": "",
    "&Sopf;": "\uD835\uDD4A",
    "&Sqrt;": "",
    "&Square;": "",
    "&SquareIntersection;": "",
    "&SquareSubset;": "",
    "&SquareSubsetEqual;": "",
    "&SquareSuperset;": "",
    "&SquareSupersetEqual;": "",
    "&SquareUnion;": "",
    "&Sscr;": "\uD835\uDCAE",
    "&Star;": "",
    "&Sub;": "",
    "&Subset;": "",
    "&SubsetEqual;": "",
    "&Succeeds;": "",
    "&SucceedsEqual;": "",
    "&SucceedsSlantEqual;": "",
    "&SucceedsTilde;": "",
    "&SuchThat;": "",
    "&Sum;": "",
    "&Sup;": "",
    "&Superset;": "",
    "&SupersetEqual;": "",
    "&Supset;": "",
    "&THORN": "",
    "&THORN;": "",
    "&TRADE;": "",
    "&TSHcy;": "",
    "&TScy;": "",
    "&Tab;": "\t",
    "&Tau;": "",
    "&Tcaron;": "",
    "&Tcedil;": "",
    "&Tcy;": "",
    "&Tfr;": "\uD835\uDD17",
    "&Therefore;": "",
    "&Theta;": "",
    "&ThickSpace;": "",
    "&ThinSpace;": "",
    "&Tilde;": "",
    "&TildeEqual;": "",
    "&TildeFullEqual;": "",
    "&TildeTilde;": "",
    "&Topf;": "\uD835\uDD4B",
    "&TripleDot;": "",
    "&Tscr;": "\uD835\uDCAF",
    "&Tstrok;": "",
    "&Uacute": "",
    "&Uacute;": "",
    "&Uarr;": "",
    "&Uarrocir;": "",
    "&Ubrcy;": "",
    "&Ubreve;": "",
    "&Ucirc": "",
    "&Ucirc;": "",
    "&Ucy;": "",
    "&Udblac;": "",
    "&Ufr;": "\uD835\uDD18",
    "&Ugrave": "",
    "&Ugrave;": "",
    "&Umacr;": "",
    "&UnderBar;": "_",
    "&UnderBrace;": "",
    "&UnderBracket;": "",
    "&UnderParenthesis;": "",
    "&Union;": "",
    "&UnionPlus;": "",
    "&Uogon;": "",
    "&Uopf;": "\uD835\uDD4C",
    "&UpArrow;": "",
    "&UpArrowBar;": "",
    "&UpArrowDownArrow;": "",
    "&UpDownArrow;": "",
    "&UpEquilibrium;": "",
    "&UpTee;": "",
    "&UpTeeArrow;": "",
    "&Uparrow;": "",
    "&Updownarrow;": "",
    "&UpperLeftArrow;": "",
    "&UpperRightArrow;": "",
    "&Upsi;": "",
    "&Upsilon;": "",
    "&Uring;": "",
    "&Uscr;": "\uD835\uDCB0",
    "&Utilde;": "",
    "&Uuml": "",
    "&Uuml;": "",
    "&VDash;": "",
    "&Vbar;": "",
    "&Vcy;": "",
    "&Vdash;": "",
    "&Vdashl;": "",
    "&Vee;": "",
    "&Verbar;": "",
    "&Vert;": "",
    "&VerticalBar;": "",
    "&VerticalLine;": "|",
    "&VerticalSeparator;": "",
    "&VerticalTilde;": "",
    "&VeryThinSpace;": "",
    "&Vfr;": "\uD835\uDD19",
    "&Vopf;": "\uD835\uDD4D",
    "&Vscr;": "\uD835\uDCB1",
    "&Vvdash;": "",
    "&Wcirc;": "",
    "&Wedge;": "",
    "&Wfr;": "\uD835\uDD1A",
    "&Wopf;": "\uD835\uDD4E",
    "&Wscr;": "\uD835\uDCB2",
    "&Xfr;": "\uD835\uDD1B",
    "&Xi;": "",
    "&Xopf;": "\uD835\uDD4F",
    "&Xscr;": "\uD835\uDCB3",
    "&YAcy;": "",
    "&YIcy;": "",
    "&YUcy;": "",
    "&Yacute": "",
    "&Yacute;": "",
    "&Ycirc;": "",
    "&Ycy;": "",
    "&Yfr;": "\uD835\uDD1C",
    "&Yopf;": "\uD835\uDD50",
    "&Yscr;": "\uD835\uDCB4",
    "&Yuml;": "",
    "&ZHcy;": "",
    "&Zacute;": "",
    "&Zcaron;": "",
    "&Zcy;": "",
    "&Zdot;": "",
    "&ZeroWidthSpace;": "",
    "&Zeta;": "",
    "&Zfr;": "",
    "&Zopf;": "",
    "&Zscr;": "\uD835\uDCB5",
    "&aacute": "",
    "&aacute;": "",
    "&abreve;": "",
    "&ac;": "",
    "&acE;": "",
    "&acd;": "",
    "&acirc": "",
    "&acirc;": "",
    "&acute": "",
    "&acute;": "",
    "&acy;": "",
    "&aelig": "",
    "&aelig;": "",
    "&af;": "",
    "&afr;": "\uD835\uDD1E",
    "&agrave": "",
    "&agrave;": "",
    "&alefsym;": "",
    "&aleph;": "",
    "&alpha;": "",
    "&amacr;": "",
    "&amalg;": "",
    "&amp": "&",
    "&amp;": "&",
    "&and;": "",
    "&andand;": "",
    "&andd;": "",
    "&andslope;": "",
    "&andv;": "",
    "&ang;": "",
    "&ange;": "",
    "&angle;": "",
    "&angmsd;": "",
    "&angmsdaa;": "",
    "&angmsdab;": "",
    "&angmsdac;": "",
    "&angmsdad;": "",
    "&angmsdae;": "",
    "&angmsdaf;": "",
    "&angmsdag;": "",
    "&angmsdah;": "",
    "&angrt;": "",
    "&angrtvb;": "",
    "&angrtvbd;": "",
    "&angsph;": "",
    "&angst;": "",
    "&angzarr;": "",
    "&aogon;": "",
    "&aopf;": "\uD835\uDD52",
    "&ap;": "",
    "&apE;": "",
    "&apacir;": "",
    "&ape;": "",
    "&apid;": "",
    "&apos;": "'",
    "&approx;": "",
    "&approxeq;": "",
    "&aring": "",
    "&aring;": "",
    "&ascr;": "\uD835\uDCB6",
    "&ast;": "*",
    "&asymp;": "",
    "&asympeq;": "",
    "&atilde": "",
    "&atilde;": "",
    "&auml": "",
    "&auml;": "",
    "&awconint;": "",
    "&awint;": "",
    "&bNot;": "",
    "&backcong;": "",
    "&backepsilon;": "",
    "&backprime;": "",
    "&backsim;": "",
    "&backsimeq;": "",
    "&barvee;": "",
    "&barwed;": "",
    "&barwedge;": "",
    "&bbrk;": "",
    "&bbrktbrk;": "",
    "&bcong;": "",
    "&bcy;": "",
    "&bdquo;": "",
    "&becaus;": "",
    "&because;": "",
    "&bemptyv;": "",
    "&bepsi;": "",
    "&bernou;": "",
    "&beta;": "",
    "&beth;": "",
    "&between;": "",
    "&bfr;": "\uD835\uDD1F",
    "&bigcap;": "",
    "&bigcirc;": "",
    "&bigcup;": "",
    "&bigodot;": "",
    "&bigoplus;": "",
    "&bigotimes;": "",
    "&bigsqcup;": "",
    "&bigstar;": "",
    "&bigtriangledown;": "",
    "&bigtriangleup;": "",
    "&biguplus;": "",
    "&bigvee;": "",
    "&bigwedge;": "",
    "&bkarow;": "",
    "&blacklozenge;": "",
    "&blacksquare;": "",
    "&blacktriangle;": "",
    "&blacktriangledown;": "",
    "&blacktriangleleft;": "",
    "&blacktriangleright;": "",
    "&blank;": "",
    "&blk12;": "",
    "&blk14;": "",
    "&blk34;": "",
    "&block;": "",
    "&bne;": "=",
    "&bnequiv;": "",
    "&bnot;": "",
    "&bopf;": "\uD835\uDD53",
    "&bot;": "",
    "&bottom;": "",
    "&bowtie;": "",
    "&boxDL;": "",
    "&boxDR;": "",
    "&boxDl;": "",
    "&boxDr;": "",
    "&boxH;": "",
    "&boxHD;": "",
    "&boxHU;": "",
    "&boxHd;": "",
    "&boxHu;": "",
    "&boxUL;": "",
    "&boxUR;": "",
    "&boxUl;": "",
    "&boxUr;": "",
    "&boxV;": "",
    "&boxVH;": "",
    "&boxVL;": "",
    "&boxVR;": "",
    "&boxVh;": "",
    "&boxVl;": "",
    "&boxVr;": "",
    "&boxbox;": "",
    "&boxdL;": "",
    "&boxdR;": "",
    "&boxdl;": "",
    "&boxdr;": "",
    "&boxh;": "",
    "&boxhD;": "",
    "&boxhU;": "",
    "&boxhd;": "",
    "&boxhu;": "",
    "&boxminus;": "",
    "&boxplus;": "",
    "&boxtimes;": "",
    "&boxuL;": "",
    "&boxuR;": "",
    "&boxul;": "",
    "&boxur;": "",
    "&boxv;": "",
    "&boxvH;": "",
    "&boxvL;": "",
    "&boxvR;": "",
    "&boxvh;": "",
    "&boxvl;": "",
    "&boxvr;": "",
    "&bprime;": "",
    "&breve;": "",
    "&brvbar": "",
    "&brvbar;": "",
    "&bscr;": "\uD835\uDCB7",
    "&bsemi;": "",
    "&bsim;": "",
    "&bsime;": "",
    "&bsol;": "\\",
    "&bsolb;": "",
    "&bsolhsub;": "",
    "&bull;": "",
    "&bullet;": "",
    "&bump;": "",
    "&bumpE;": "",
    "&bumpe;": "",
    "&bumpeq;": "",
    "&cacute;": "",
    "&cap;": "",
    "&capand;": "",
    "&capbrcup;": "",
    "&capcap;": "",
    "&capcup;": "",
    "&capdot;": "",
    "&caps;": "",
    "&caret;": "",
    "&caron;": "",
    "&ccaps;": "",
    "&ccaron;": "",
    "&ccedil": "",
    "&ccedil;": "",
    "&ccirc;": "",
    "&ccups;": "",
    "&ccupssm;": "",
    "&cdot;": "",
    "&cedil": "",
    "&cedil;": "",
    "&cemptyv;": "",
    "&cent": "",
    "&cent;": "",
    "&centerdot;": "",
    "&cfr;": "\uD835\uDD20",
    "&chcy;": "",
    "&check;": "",
    "&checkmark;": "",
    "&chi;": "",
    "&cir;": "",
    "&cirE;": "",
    "&circ;": "",
    "&circeq;": "",
    "&circlearrowleft;": "",
    "&circlearrowright;": "",
    "&circledR;": "",
    "&circledS;": "",
    "&circledast;": "",
    "&circledcirc;": "",
    "&circleddash;": "",
    "&cire;": "",
    "&cirfnint;": "",
    "&cirmid;": "",
    "&cirscir;": "",
    "&clubs;": "",
    "&clubsuit;": "",
    "&colon;": ":",
    "&colone;": "",
    "&coloneq;": "",
    "&comma;": ",",
    "&commat;": "@",
    "&comp;": "",
    "&compfn;": "",
    "&complement;": "",
    "&complexes;": "",
    "&cong;": "",
    "&congdot;": "",
    "&conint;": "",
    "&copf;": "\uD835\uDD54",
    "&coprod;": "",
    "&copy": "",
    "&copy;": "",
    "&copysr;": "",
    "&crarr;": "",
    "&cross;": "",
    "&cscr;": "\uD835\uDCB8",
    "&csub;": "",
    "&csube;": "",
    "&csup;": "",
    "&csupe;": "",
    "&ctdot;": "",
    "&cudarrl;": "",
    "&cudarrr;": "",
    "&cuepr;": "",
    "&cuesc;": "",
    "&cularr;": "",
    "&cularrp;": "",
    "&cup;": "",
    "&cupbrcap;": "",
    "&cupcap;": "",
    "&cupcup;": "",
    "&cupdot;": "",
    "&cupor;": "",
    "&cups;": "",
    "&curarr;": "",
    "&curarrm;": "",
    "&curlyeqprec;": "",
    "&curlyeqsucc;": "",
    "&curlyvee;": "",
    "&curlywedge;": "",
    "&curren": "",
    "&curren;": "",
    "&curvearrowleft;": "",
    "&curvearrowright;": "",
    "&cuvee;": "",
    "&cuwed;": "",
    "&cwconint;": "",
    "&cwint;": "",
    "&cylcty;": "",
    "&dArr;": "",
    "&dHar;": "",
    "&dagger;": "",
    "&daleth;": "",
    "&darr;": "",
    "&dash;": "",
    "&dashv;": "",
    "&dbkarow;": "",
    "&dblac;": "",
    "&dcaron;": "",
    "&dcy;": "",
    "&dd;": "",
    "&ddagger;": "",
    "&ddarr;": "",
    "&ddotseq;": "",
    "&deg": "",
    "&deg;": "",
    "&delta;": "",
    "&demptyv;": "",
    "&dfisht;": "",
    "&dfr;": "\uD835\uDD21",
    "&dharl;": "",
    "&dharr;": "",
    "&diam;": "",
    "&diamond;": "",
    "&diamondsuit;": "",
    "&diams;": "",
    "&die;": "",
    "&digamma;": "",
    "&disin;": "",
    "&div;": "",
    "&divide": "",
    "&divide;": "",
    "&divideontimes;": "",
    "&divonx;": "",
    "&djcy;": "",
    "&dlcorn;": "",
    "&dlcrop;": "",
    "&dollar;": "$",
    "&dopf;": "\uD835\uDD55",
    "&dot;": "",
    "&doteq;": "",
    "&doteqdot;": "",
    "&dotminus;": "",
    "&dotplus;": "",
    "&dotsquare;": "",
    "&doublebarwedge;": "",
    "&downarrow;": "",
    "&downdownarrows;": "",
    "&downharpoonleft;": "",
    "&downharpoonright;": "",
    "&drbkarow;": "",
    "&drcorn;": "",
    "&drcrop;": "",
    "&dscr;": "\uD835\uDCB9",
    "&dscy;": "",
    "&dsol;": "",
    "&dstrok;": "",
    "&dtdot;": "",
    "&dtri;": "",
    "&dtrif;": "",
    "&duarr;": "",
    "&duhar;": "",
    "&dwangle;": "",
    "&dzcy;": "",
    "&dzigrarr;": "",
    "&eDDot;": "",
    "&eDot;": "",
    "&eacute": "",
    "&eacute;": "",
    "&easter;": "",
    "&ecaron;": "",
    "&ecir;": "",
    "&ecirc": "",
    "&ecirc;": "",
    "&ecolon;": "",
    "&ecy;": "",
    "&edot;": "",
    "&ee;": "",
    "&efDot;": "",
    "&efr;": "\uD835\uDD22",
    "&eg;": "",
    "&egrave": "",
    "&egrave;": "",
    "&egs;": "",
    "&egsdot;": "",
    "&el;": "",
    "&elinters;": "",
    "&ell;": "",
    "&els;": "",
    "&elsdot;": "",
    "&emacr;": "",
    "&empty;": "",
    "&emptyset;": "",
    "&emptyv;": "",
    "&emsp13;": "",
    "&emsp14;": "",
    "&emsp;": "",
    "&eng;": "",
    "&ensp;": "",
    "&eogon;": "",
    "&eopf;": "\uD835\uDD56",
    "&epar;": "",
    "&eparsl;": "",
    "&eplus;": "",
    "&epsi;": "",
    "&epsilon;": "",
    "&epsiv;": "",
    "&eqcirc;": "",
    "&eqcolon;": "",
    "&eqsim;": "",
    "&eqslantgtr;": "",
    "&eqslantless;": "",
    "&equals;": "=",
    "&equest;": "",
    "&equiv;": "",
    "&equivDD;": "",
    "&eqvparsl;": "",
    "&erDot;": "",
    "&erarr;": "",
    "&escr;": "",
    "&esdot;": "",
    "&esim;": "",
    "&eta;": "",
    "&eth": "",
    "&eth;": "",
    "&euml": "",
    "&euml;": "",
    "&euro;": "",
    "&excl;": "!",
    "&exist;": "",
    "&expectation;": "",
    "&exponentiale;": "",
    "&fallingdotseq;": "",
    "&fcy;": "",
    "&female;": "",
    "&ffilig;": "",
    "&fflig;": "",
    "&ffllig;": "",
    "&ffr;": "\uD835\uDD23",
    "&filig;": "",
    "&fjlig;": "fj",
    "&flat;": "",
    "&fllig;": "",
    "&fltns;": "",
    "&fnof;": "",
    "&fopf;": "\uD835\uDD57",
    "&forall;": "",
    "&fork;": "",
    "&forkv;": "",
    "&fpartint;": "",
    "&frac12": "",
    "&frac12;": "",
    "&frac13;": "",
    "&frac14": "",
    "&frac14;": "",
    "&frac15;": "",
    "&frac16;": "",
    "&frac18;": "",
    "&frac23;": "",
    "&frac25;": "",
    "&frac34": "",
    "&frac34;": "",
    "&frac35;": "",
    "&frac38;": "",
    "&frac45;": "",
    "&frac56;": "",
    "&frac58;": "",
    "&frac78;": "",
    "&frasl;": "",
    "&frown;": "",
    "&fscr;": "\uD835\uDCBB",
    "&gE;": "",
    "&gEl;": "",
    "&gacute;": "",
    "&gamma;": "",
    "&gammad;": "",
    "&gap;": "",
    "&gbreve;": "",
    "&gcirc;": "",
    "&gcy;": "",
    "&gdot;": "",
    "&ge;": "",
    "&gel;": "",
    "&geq;": "",
    "&geqq;": "",
    "&geqslant;": "",
    "&ges;": "",
    "&gescc;": "",
    "&gesdot;": "",
    "&gesdoto;": "",
    "&gesdotol;": "",
    "&gesl;": "",
    "&gesles;": "",
    "&gfr;": "\uD835\uDD24",
    "&gg;": "",
    "&ggg;": "",
    "&gimel;": "",
    "&gjcy;": "",
    "&gl;": "",
    "&glE;": "",
    "&gla;": "",
    "&glj;": "",
    "&gnE;": "",
    "&gnap;": "",
    "&gnapprox;": "",
    "&gne;": "",
    "&gneq;": "",
    "&gneqq;": "",
    "&gnsim;": "",
    "&gopf;": "\uD835\uDD58",
    "&grave;": "`",
    "&gscr;": "",
    "&gsim;": "",
    "&gsime;": "",
    "&gsiml;": "",
    "&gt": ">",
    "&gt;": ">",
    "&gtcc;": "",
    "&gtcir;": "",
    "&gtdot;": "",
    "&gtlPar;": "",
    "&gtquest;": "",
    "&gtrapprox;": "",
    "&gtrarr;": "",
    "&gtrdot;": "",
    "&gtreqless;": "",
    "&gtreqqless;": "",
    "&gtrless;": "",
    "&gtrsim;": "",
    "&gvertneqq;": "",
    "&gvnE;": "",
    "&hArr;": "",
    "&hairsp;": "",
    "&half;": "",
    "&hamilt;": "",
    "&hardcy;": "",
    "&harr;": "",
    "&harrcir;": "",
    "&harrw;": "",
    "&hbar;": "",
    "&hcirc;": "",
    "&hearts;": "",
    "&heartsuit;": "",
    "&hellip;": "",
    "&hercon;": "",
    "&hfr;": "\uD835\uDD25",
    "&hksearow;": "",
    "&hkswarow;": "",
    "&hoarr;": "",
    "&homtht;": "",
    "&hookleftarrow;": "",
    "&hookrightarrow;": "",
    "&hopf;": "\uD835\uDD59",
    "&horbar;": "",
    "&hscr;": "\uD835\uDCBD",
    "&hslash;": "",
    "&hstrok;": "",
    "&hybull;": "",
    "&hyphen;": "",
    "&iacute": "",
    "&iacute;": "",
    "&ic;": "",
    "&icirc": "",
    "&icirc;": "",
    "&icy;": "",
    "&iecy;": "",
    "&iexcl": "",
    "&iexcl;": "",
    "&iff;": "",
    "&ifr;": "\uD835\uDD26",
    "&igrave": "",
    "&igrave;": "",
    "&ii;": "",
    "&iiiint;": "",
    "&iiint;": "",
    "&iinfin;": "",
    "&iiota;": "",
    "&ijlig;": "",
    "&imacr;": "",
    "&image;": "",
    "&imagline;": "",
    "&imagpart;": "",
    "&imath;": "",
    "&imof;": "",
    "&imped;": "",
    "&in;": "",
    "&incare;": "",
    "&infin;": "",
    "&infintie;": "",
    "&inodot;": "",
    "&int;": "",
    "&intcal;": "",
    "&integers;": "",
    "&intercal;": "",
    "&intlarhk;": "",
    "&intprod;": "",
    "&iocy;": "",
    "&iogon;": "",
    "&iopf;": "\uD835\uDD5A",
    "&iota;": "",
    "&iprod;": "",
    "&iquest": "",
    "&iquest;": "",
    "&iscr;": "\uD835\uDCBE",
    "&isin;": "",
    "&isinE;": "",
    "&isindot;": "",
    "&isins;": "",
    "&isinsv;": "",
    "&isinv;": "",
    "&it;": "",
    "&itilde;": "",
    "&iukcy;": "",
    "&iuml": "",
    "&iuml;": "",
    "&jcirc;": "",
    "&jcy;": "",
    "&jfr;": "\uD835\uDD27",
    "&jmath;": "",
    "&jopf;": "\uD835\uDD5B",
    "&jscr;": "\uD835\uDCBF",
    "&jsercy;": "",
    "&jukcy;": "",
    "&kappa;": "",
    "&kappav;": "",
    "&kcedil;": "",
    "&kcy;": "",
    "&kfr;": "\uD835\uDD28",
    "&kgreen;": "",
    "&khcy;": "",
    "&kjcy;": "",
    "&kopf;": "\uD835\uDD5C",
    "&kscr;": "\uD835\uDCC0",
    "&lAarr;": "",
    "&lArr;": "",
    "&lAtail;": "",
    "&lBarr;": "",
    "&lE;": "",
    "&lEg;": "",
    "&lHar;": "",
    "&lacute;": "",
    "&laemptyv;": "",
    "&lagran;": "",
    "&lambda;": "",
    "&lang;": "",
    "&langd;": "",
    "&langle;": "",
    "&lap;": "",
    "&laquo": "",
    "&laquo;": "",
    "&larr;": "",
    "&larrb;": "",
    "&larrbfs;": "",
    "&larrfs;": "",
    "&larrhk;": "",
    "&larrlp;": "",
    "&larrpl;": "",
    "&larrsim;": "",
    "&larrtl;": "",
    "&lat;": "",
    "&latail;": "",
    "&late;": "",
    "&lates;": "",
    "&lbarr;": "",
    "&lbbrk;": "",
    "&lbrace;": "{",
    "&lbrack;": "[",
    "&lbrke;": "",
    "&lbrksld;": "",
    "&lbrkslu;": "",
    "&lcaron;": "",
    "&lcedil;": "",
    "&lceil;": "",
    "&lcub;": "{",
    "&lcy;": "",
    "&ldca;": "",
    "&ldquo;": "",
    "&ldquor;": "",
    "&ldrdhar;": "",
    "&ldrushar;": "",
    "&ldsh;": "",
    "&le;": "",
    "&leftarrow;": "",
    "&leftarrowtail;": "",
    "&leftharpoondown;": "",
    "&leftharpoonup;": "",
    "&leftleftarrows;": "",
    "&leftrightarrow;": "",
    "&leftrightarrows;": "",
    "&leftrightharpoons;": "",
    "&leftrightsquigarrow;": "",
    "&leftthreetimes;": "",
    "&leg;": "",
    "&leq;": "",
    "&leqq;": "",
    "&leqslant;": "",
    "&les;": "",
    "&lescc;": "",
    "&lesdot;": "",
    "&lesdoto;": "",
    "&lesdotor;": "",
    "&lesg;": "",
    "&lesges;": "",
    "&lessapprox;": "",
    "&lessdot;": "",
    "&lesseqgtr;": "",
    "&lesseqqgtr;": "",
    "&lessgtr;": "",
    "&lesssim;": "",
    "&lfisht;": "",
    "&lfloor;": "",
    "&lfr;": "\uD835\uDD29",
    "&lg;": "",
    "&lgE;": "",
    "&lhard;": "",
    "&lharu;": "",
    "&lharul;": "",
    "&lhblk;": "",
    "&ljcy;": "",
    "&ll;": "",
    "&llarr;": "",
    "&llcorner;": "",
    "&llhard;": "",
    "&lltri;": "",
    "&lmidot;": "",
    "&lmoust;": "",
    "&lmoustache;": "",
    "&lnE;": "",
    "&lnap;": "",
    "&lnapprox;": "",
    "&lne;": "",
    "&lneq;": "",
    "&lneqq;": "",
    "&lnsim;": "",
    "&loang;": "",
    "&loarr;": "",
    "&lobrk;": "",
    "&longleftarrow;": "",
    "&longleftrightarrow;": "",
    "&longmapsto;": "",
    "&longrightarrow;": "",
    "&looparrowleft;": "",
    "&looparrowright;": "",
    "&lopar;": "",
    "&lopf;": "\uD835\uDD5D",
    "&loplus;": "",
    "&lotimes;": "",
    "&lowast;": "",
    "&lowbar;": "_",
    "&loz;": "",
    "&lozenge;": "",
    "&lozf;": "",
    "&lpar;": "(",
    "&lparlt;": "",
    "&lrarr;": "",
    "&lrcorner;": "",
    "&lrhar;": "",
    "&lrhard;": "",
    "&lrm;": "",
    "&lrtri;": "",
    "&lsaquo;": "",
    "&lscr;": "\uD835\uDCC1",
    "&lsh;": "",
    "&lsim;": "",
    "&lsime;": "",
    "&lsimg;": "",
    "&lsqb;": "[",
    "&lsquo;": "",
    "&lsquor;": "",
    "&lstrok;": "",
    "&lt": "<",
    "&lt;": "<",
    "&ltcc;": "",
    "&ltcir;": "",
    "&ltdot;": "",
    "&lthree;": "",
    "&ltimes;": "",
    "&ltlarr;": "",
    "&ltquest;": "",
    "&ltrPar;": "",
    "&ltri;": "",
    "&ltrie;": "",
    "&ltrif;": "",
    "&lurdshar;": "",
    "&luruhar;": "",
    "&lvertneqq;": "",
    "&lvnE;": "",
    "&mDDot;": "",
    "&macr": "",
    "&macr;": "",
    "&male;": "",
    "&malt;": "",
    "&maltese;": "",
    "&map;": "",
    "&mapsto;": "",
    "&mapstodown;": "",
    "&mapstoleft;": "",
    "&mapstoup;": "",
    "&marker;": "",
    "&mcomma;": "",
    "&mcy;": "",
    "&mdash;": "",
    "&measuredangle;": "",
    "&mfr;": "\uD835\uDD2A",
    "&mho;": "",
    "&micro": "",
    "&micro;": "",
    "&mid;": "",
    "&midast;": "*",
    "&midcir;": "",
    "&middot": "",
    "&middot;": "",
    "&minus;": "",
    "&minusb;": "",
    "&minusd;": "",
    "&minusdu;": "",
    "&mlcp;": "",
    "&mldr;": "",
    "&mnplus;": "",
    "&models;": "",
    "&mopf;": "\uD835\uDD5E",
    "&mp;": "",
    "&mscr;": "\uD835\uDCC2",
    "&mstpos;": "",
    "&mu;": "",
    "&multimap;": "",
    "&mumap;": "",
    "&nGg;": "",
    "&nGt;": "",
    "&nGtv;": "",
    "&nLeftarrow;": "",
    "&nLeftrightarrow;": "",
    "&nLl;": "",
    "&nLt;": "",
    "&nLtv;": "",
    "&nRightarrow;": "",
    "&nVDash;": "",
    "&nVdash;": "",
    "&nabla;": "",
    "&nacute;": "",
    "&nang;": "",
    "&nap;": "",
    "&napE;": "",
    "&napid;": "",
    "&napos;": "",
    "&napprox;": "",
    "&natur;": "",
    "&natural;": "",
    "&naturals;": "",
    "&nbsp": "",
    "&nbsp;": "",
    "&nbump;": "",
    "&nbumpe;": "",
    "&ncap;": "",
    "&ncaron;": "",
    "&ncedil;": "",
    "&ncong;": "",
    "&ncongdot;": "",
    "&ncup;": "",
    "&ncy;": "",
    "&ndash;": "",
    "&ne;": "",
    "&neArr;": "",
    "&nearhk;": "",
    "&nearr;": "",
    "&nearrow;": "",
    "&nedot;": "",
    "&nequiv;": "",
    "&nesear;": "",
    "&nesim;": "",
    "&nexist;": "",
    "&nexists;": "",
    "&nfr;": "\uD835\uDD2B",
    "&ngE;": "",
    "&nge;": "",
    "&ngeq;": "",
    "&ngeqq;": "",
    "&ngeqslant;": "",
    "&nges;": "",
    "&ngsim;": "",
    "&ngt;": "",
    "&ngtr;": "",
    "&nhArr;": "",
    "&nharr;": "",
    "&nhpar;": "",
    "&ni;": "",
    "&nis;": "",
    "&nisd;": "",
    "&niv;": "",
    "&njcy;": "",
    "&nlArr;": "",
    "&nlE;": "",
    "&nlarr;": "",
    "&nldr;": "",
    "&nle;": "",
    "&nleftarrow;": "",
    "&nleftrightarrow;": "",
    "&nleq;": "",
    "&nleqq;": "",
    "&nleqslant;": "",
    "&nles;": "",
    "&nless;": "",
    "&nlsim;": "",
    "&nlt;": "",
    "&nltri;": "",
    "&nltrie;": "",
    "&nmid;": "",
    "&nopf;": "\uD835\uDD5F",
    "&not": "",
    "&not;": "",
    "&notin;": "",
    "&notinE;": "",
    "&notindot;": "",
    "&notinva;": "",
    "&notinvb;": "",
    "&notinvc;": "",
    "&notni;": "",
    "&notniva;": "",
    "&notnivb;": "",
    "&notnivc;": "",
    "&npar;": "",
    "&nparallel;": "",
    "&nparsl;": "",
    "&npart;": "",
    "&npolint;": "",
    "&npr;": "",
    "&nprcue;": "",
    "&npre;": "",
    "&nprec;": "",
    "&npreceq;": "",
    "&nrArr;": "",
    "&nrarr;": "",
    "&nrarrc;": "",
    "&nrarrw;": "",
    "&nrightarrow;": "",
    "&nrtri;": "",
    "&nrtrie;": "",
    "&nsc;": "",
    "&nsccue;": "",
    "&nsce;": "",
    "&nscr;": "\uD835\uDCC3",
    "&nshortmid;": "",
    "&nshortparallel;": "",
    "&nsim;": "",
    "&nsime;": "",
    "&nsimeq;": "",
    "&nsmid;": "",
    "&nspar;": "",
    "&nsqsube;": "",
    "&nsqsupe;": "",
    "&nsub;": "",
    "&nsubE;": "",
    "&nsube;": "",
    "&nsubset;": "",
    "&nsubseteq;": "",
    "&nsubseteqq;": "",
    "&nsucc;": "",
    "&nsucceq;": "",
    "&nsup;": "",
    "&nsupE;": "",
    "&nsupe;": "",
    "&nsupset;": "",
    "&nsupseteq;": "",
    "&nsupseteqq;": "",
    "&ntgl;": "",
    "&ntilde": "",
    "&ntilde;": "",
    "&ntlg;": "",
    "&ntriangleleft;": "",
    "&ntrianglelefteq;": "",
    "&ntriangleright;": "",
    "&ntrianglerighteq;": "",
    "&nu;": "",
    "&num;": "#",
    "&numero;": "",
    "&numsp;": "",
    "&nvDash;": "",
    "&nvHarr;": "",
    "&nvap;": "",
    "&nvdash;": "",
    "&nvge;": "",
    "&nvgt;": ">",
    "&nvinfin;": "",
    "&nvlArr;": "",
    "&nvle;": "",
    "&nvlt;": "<",
    "&nvltrie;": "",
    "&nvrArr;": "",
    "&nvrtrie;": "",
    "&nvsim;": "",
    "&nwArr;": "",
    "&nwarhk;": "",
    "&nwarr;": "",
    "&nwarrow;": "",
    "&nwnear;": "",
    "&oS;": "",
    "&oacute": "",
    "&oacute;": "",
    "&oast;": "",
    "&ocir;": "",
    "&ocirc": "",
    "&ocirc;": "",
    "&ocy;": "",
    "&odash;": "",
    "&odblac;": "",
    "&odiv;": "",
    "&odot;": "",
    "&odsold;": "",
    "&oelig;": "",
    "&ofcir;": "",
    "&ofr;": "\uD835\uDD2C",
    "&ogon;": "",
    "&ograve": "",
    "&ograve;": "",
    "&ogt;": "",
    "&ohbar;": "",
    "&ohm;": "",
    "&oint;": "",
    "&olarr;": "",
    "&olcir;": "",
    "&olcross;": "",
    "&oline;": "",
    "&olt;": "",
    "&omacr;": "",
    "&omega;": "",
    "&omicron;": "",
    "&omid;": "",
    "&ominus;": "",
    "&oopf;": "\uD835\uDD60",
    "&opar;": "",
    "&operp;": "",
    "&oplus;": "",
    "&or;": "",
    "&orarr;": "",
    "&ord;": "",
    "&order;": "",
    "&orderof;": "",
    "&ordf": "",
    "&ordf;": "",
    "&ordm": "",
    "&ordm;": "",
    "&origof;": "",
    "&oror;": "",
    "&orslope;": "",
    "&orv;": "",
    "&oscr;": "",
    "&oslash": "",
    "&oslash;": "",
    "&osol;": "",
    "&otilde": "",
    "&otilde;": "",
    "&otimes;": "",
    "&otimesas;": "",
    "&ouml": "",
    "&ouml;": "",
    "&ovbar;": "",
    "&par;": "",
    "&para": "",
    "&para;": "",
    "&parallel;": "",
    "&parsim;": "",
    "&parsl;": "",
    "&part;": "",
    "&pcy;": "",
    "&percnt;": "%",
    "&period;": ".",
    "&permil;": "",
    "&perp;": "",
    "&pertenk;": "",
    "&pfr;": "\uD835\uDD2D",
    "&phi;": "",
    "&phiv;": "",
    "&phmmat;": "",
    "&phone;": "",
    "&pi;": "",
    "&pitchfork;": "",
    "&piv;": "",
    "&planck;": "",
    "&planckh;": "",
    "&plankv;": "",
    "&plus;": "+",
    "&plusacir;": "",
    "&plusb;": "",
    "&pluscir;": "",
    "&plusdo;": "",
    "&plusdu;": "",
    "&pluse;": "",
    "&plusmn": "",
    "&plusmn;": "",
    "&plussim;": "",
    "&plustwo;": "",
    "&pm;": "",
    "&pointint;": "",
    "&popf;": "\uD835\uDD61",
    "&pound": "",
    "&pound;": "",
    "&pr;": "",
    "&prE;": "",
    "&prap;": "",
    "&prcue;": "",
    "&pre;": "",
    "&prec;": "",
    "&precapprox;": "",
    "&preccurlyeq;": "",
    "&preceq;": "",
    "&precnapprox;": "",
    "&precneqq;": "",
    "&precnsim;": "",
    "&precsim;": "",
    "&prime;": "",
    "&primes;": "",
    "&prnE;": "",
    "&prnap;": "",
    "&prnsim;": "",
    "&prod;": "",
    "&profalar;": "",
    "&profline;": "",
    "&profsurf;": "",
    "&prop;": "",
    "&propto;": "",
    "&prsim;": "",
    "&prurel;": "",
    "&pscr;": "\uD835\uDCC5",
    "&psi;": "",
    "&puncsp;": "",
    "&qfr;": "\uD835\uDD2E",
    "&qint;": "",
    "&qopf;": "\uD835\uDD62",
    "&qprime;": "",
    "&qscr;": "\uD835\uDCC6",
    "&quaternions;": "",
    "&quatint;": "",
    "&quest;": "?",
    "&questeq;": "",
    "&quot": '"',
    "&quot;": '"',
    "&rAarr;": "",
    "&rArr;": "",
    "&rAtail;": "",
    "&rBarr;": "",
    "&rHar;": "",
    "&race;": "",
    "&racute;": "",
    "&radic;": "",
    "&raemptyv;": "",
    "&rang;": "",
    "&rangd;": "",
    "&range;": "",
    "&rangle;": "",
    "&raquo": "",
    "&raquo;": "",
    "&rarr;": "",
    "&rarrap;": "",
    "&rarrb;": "",
    "&rarrbfs;": "",
    "&rarrc;": "",
    "&rarrfs;": "",
    "&rarrhk;": "",
    "&rarrlp;": "",
    "&rarrpl;": "",
    "&rarrsim;": "",
    "&rarrtl;": "",
    "&rarrw;": "",
    "&ratail;": "",
    "&ratio;": "",
    "&rationals;": "",
    "&rbarr;": "",
    "&rbbrk;": "",
    "&rbrace;": "}",
    "&rbrack;": "]",
    "&rbrke;": "",
    "&rbrksld;": "",
    "&rbrkslu;": "",
    "&rcaron;": "",
    "&rcedil;": "",
    "&rceil;": "",
    "&rcub;": "}",
    "&rcy;": "",
    "&rdca;": "",
    "&rdldhar;": "",
    "&rdquo;": "",
    "&rdquor;": "",
    "&rdsh;": "",
    "&real;": "",
    "&realine;": "",
    "&realpart;": "",
    "&reals;": "",
    "&rect;": "",
    "&reg": "",
    "&reg;": "",
    "&rfisht;": "",
    "&rfloor;": "",
    "&rfr;": "\uD835\uDD2F",
    "&rhard;": "",
    "&rharu;": "",
    "&rharul;": "",
    "&rho;": "",
    "&rhov;": "",
    "&rightarrow;": "",
    "&rightarrowtail;": "",
    "&rightharpoondown;": "",
    "&rightharpoonup;": "",
    "&rightleftarrows;": "",
    "&rightleftharpoons;": "",
    "&rightrightarrows;": "",
    "&rightsquigarrow;": "",
    "&rightthreetimes;": "",
    "&ring;": "",
    "&risingdotseq;": "",
    "&rlarr;": "",
    "&rlhar;": "",
    "&rlm;": "",
    "&rmoust;": "",
    "&rmoustache;": "",
    "&rnmid;": "",
    "&roang;": "",
    "&roarr;": "",
    "&robrk;": "",
    "&ropar;": "",
    "&ropf;": "\uD835\uDD63",
    "&roplus;": "",
    "&rotimes;": "",
    "&rpar;": ")",
    "&rpargt;": "",
    "&rppolint;": "",
    "&rrarr;": "",
    "&rsaquo;": "",
    "&rscr;": "\uD835\uDCC7",
    "&rsh;": "",
    "&rsqb;": "]",
    "&rsquo;": "",
    "&rsquor;": "",
    "&rthree;": "",
    "&rtimes;": "",
    "&rtri;": "",
    "&rtrie;": "",
    "&rtrif;": "",
    "&rtriltri;": "",
    "&ruluhar;": "",
    "&rx;": "",
    "&sacute;": "",
    "&sbquo;": "",
    "&sc;": "",
    "&scE;": "",
    "&scap;": "",
    "&scaron;": "",
    "&sccue;": "",
    "&sce;": "",
    "&scedil;": "",
    "&scirc;": "",
    "&scnE;": "",
    "&scnap;": "",
    "&scnsim;": "",
    "&scpolint;": "",
    "&scsim;": "",
    "&scy;": "",
    "&sdot;": "",
    "&sdotb;": "",
    "&sdote;": "",
    "&seArr;": "",
    "&searhk;": "",
    "&searr;": "",
    "&searrow;": "",
    "&sect": "",
    "&sect;": "",
    "&semi;": ";",
    "&seswar;": "",
    "&setminus;": "",
    "&setmn;": "",
    "&sext;": "",
    "&sfr;": "\uD835\uDD30",
    "&sfrown;": "",
    "&sharp;": "",
    "&shchcy;": "",
    "&shcy;": "",
    "&shortmid;": "",
    "&shortparallel;": "",
    "&shy": "",
    "&shy;": "",
    "&sigma;": "",
    "&sigmaf;": "",
    "&sigmav;": "",
    "&sim;": "",
    "&simdot;": "",
    "&sime;": "",
    "&simeq;": "",
    "&simg;": "",
    "&simgE;": "",
    "&siml;": "",
    "&simlE;": "",
    "&simne;": "",
    "&simplus;": "",
    "&simrarr;": "",
    "&slarr;": "",
    "&smallsetminus;": "",
    "&smashp;": "",
    "&smeparsl;": "",
    "&smid;": "",
    "&smile;": "",
    "&smt;": "",
    "&smte;": "",
    "&smtes;": "",
    "&softcy;": "",
    "&sol;": "/",
    "&solb;": "",
    "&solbar;": "",
    "&sopf;": "\uD835\uDD64",
    "&spades;": "",
    "&spadesuit;": "",
    "&spar;": "",
    "&sqcap;": "",
    "&sqcaps;": "",
    "&sqcup;": "",
    "&sqcups;": "",
    "&sqsub;": "",
    "&sqsube;": "",
    "&sqsubset;": "",
    "&sqsubseteq;": "",
    "&sqsup;": "",
    "&sqsupe;": "",
    "&sqsupset;": "",
    "&sqsupseteq;": "",
    "&squ;": "",
    "&square;": "",
    "&squarf;": "",
    "&squf;": "",
    "&srarr;": "",
    "&sscr;": "\uD835\uDCC8",
    "&ssetmn;": "",
    "&ssmile;": "",
    "&sstarf;": "",
    "&star;": "",
    "&starf;": "",
    "&straightepsilon;": "",
    "&straightphi;": "",
    "&strns;": "",
    "&sub;": "",
    "&subE;": "",
    "&subdot;": "",
    "&sube;": "",
    "&subedot;": "",
    "&submult;": "",
    "&subnE;": "",
    "&subne;": "",
    "&subplus;": "",
    "&subrarr;": "",
    "&subset;": "",
    "&subseteq;": "",
    "&subseteqq;": "",
    "&subsetneq;": "",
    "&subsetneqq;": "",
    "&subsim;": "",
    "&subsub;": "",
    "&subsup;": "",
    "&succ;": "",
    "&succapprox;": "",
    "&succcurlyeq;": "",
    "&succeq;": "",
    "&succnapprox;": "",
    "&succneqq;": "",
    "&succnsim;": "",
    "&succsim;": "",
    "&sum;": "",
    "&sung;": "",
    "&sup1": "",
    "&sup1;": "",
    "&sup2": "",
    "&sup2;": "",
    "&sup3": "",
    "&sup3;": "",
    "&sup;": "",
    "&supE;": "",
    "&supdot;": "",
    "&supdsub;": "",
    "&supe;": "",
    "&supedot;": "",
    "&suphsol;": "",
    "&suphsub;": "",
    "&suplarr;": "",
    "&supmult;": "",
    "&supnE;": "",
    "&supne;": "",
    "&supplus;": "",
    "&supset;": "",
    "&supseteq;": "",
    "&supseteqq;": "",
    "&supsetneq;": "",
    "&supsetneqq;": "",
    "&supsim;": "",
    "&supsub;": "",
    "&supsup;": "",
    "&swArr;": "",
    "&swarhk;": "",
    "&swarr;": "",
    "&swarrow;": "",
    "&swnwar;": "",
    "&szlig": "",
    "&szlig;": "",
    "&target;": "",
    "&tau;": "",
    "&tbrk;": "",
    "&tcaron;": "",
    "&tcedil;": "",
    "&tcy;": "",
    "&tdot;": "",
    "&telrec;": "",
    "&tfr;": "\uD835\uDD31",
    "&there4;": "",
    "&therefore;": "",
    "&theta;": "",
    "&thetasym;": "",
    "&thetav;": "",
    "&thickapprox;": "",
    "&thicksim;": "",
    "&thinsp;": "",
    "&thkap;": "",
    "&thksim;": "",
    "&thorn": "",
    "&thorn;": "",
    "&tilde;": "",
    "&times": "",
    "&times;": "",
    "&timesb;": "",
    "&timesbar;": "",
    "&timesd;": "",
    "&tint;": "",
    "&toea;": "",
    "&top;": "",
    "&topbot;": "",
    "&topcir;": "",
    "&topf;": "\uD835\uDD65",
    "&topfork;": "",
    "&tosa;": "",
    "&tprime;": "",
    "&trade;": "",
    "&triangle;": "",
    "&triangledown;": "",
    "&triangleleft;": "",
    "&trianglelefteq;": "",
    "&triangleq;": "",
    "&triangleright;": "",
    "&trianglerighteq;": "",
    "&tridot;": "",
    "&trie;": "",
    "&triminus;": "",
    "&triplus;": "",
    "&trisb;": "",
    "&tritime;": "",
    "&trpezium;": "",
    "&tscr;": "\uD835\uDCC9",
    "&tscy;": "",
    "&tshcy;": "",
    "&tstrok;": "",
    "&twixt;": "",
    "&twoheadleftarrow;": "",
    "&twoheadrightarrow;": "",
    "&uArr;": "",
    "&uHar;": "",
    "&uacute": "",
    "&uacute;": "",
    "&uarr;": "",
    "&ubrcy;": "",
    "&ubreve;": "",
    "&ucirc": "",
    "&ucirc;": "",
    "&ucy;": "",
    "&udarr;": "",
    "&udblac;": "",
    "&udhar;": "",
    "&ufisht;": "",
    "&ufr;": "\uD835\uDD32",
    "&ugrave": "",
    "&ugrave;": "",
    "&uharl;": "",
    "&uharr;": "",
    "&uhblk;": "",
    "&ulcorn;": "",
    "&ulcorner;": "",
    "&ulcrop;": "",
    "&ultri;": "",
    "&umacr;": "",
    "&uml": "",
    "&uml;": "",
    "&uogon;": "",
    "&uopf;": "\uD835\uDD66",
    "&uparrow;": "",
    "&updownarrow;": "",
    "&upharpoonleft;": "",
    "&upharpoonright;": "",
    "&uplus;": "",
    "&upsi;": "",
    "&upsih;": "",
    "&upsilon;": "",
    "&upuparrows;": "",
    "&urcorn;": "",
    "&urcorner;": "",
    "&urcrop;": "",
    "&uring;": "",
    "&urtri;": "",
    "&uscr;": "\uD835\uDCCA",
    "&utdot;": "",
    "&utilde;": "",
    "&utri;": "",
    "&utrif;": "",
    "&uuarr;": "",
    "&uuml": "",
    "&uuml;": "",
    "&uwangle;": "",
    "&vArr;": "",
    "&vBar;": "",
    "&vBarv;": "",
    "&vDash;": "",
    "&vangrt;": "",
    "&varepsilon;": "",
    "&varkappa;": "",
    "&varnothing;": "",
    "&varphi;": "",
    "&varpi;": "",
    "&varpropto;": "",
    "&varr;": "",
    "&varrho;": "",
    "&varsigma;": "",
    "&varsubsetneq;": "",
    "&varsubsetneqq;": "",
    "&varsupsetneq;": "",
    "&varsupsetneqq;": "",
    "&vartheta;": "",
    "&vartriangleleft;": "",
    "&vartriangleright;": "",
    "&vcy;": "",
    "&vdash;": "",
    "&vee;": "",
    "&veebar;": "",
    "&veeeq;": "",
    "&vellip;": "",
    "&verbar;": "|",
    "&vert;": "|",
    "&vfr;": "\uD835\uDD33",
    "&vltri;": "",
    "&vnsub;": "",
    "&vnsup;": "",
    "&vopf;": "\uD835\uDD67",
    "&vprop;": "",
    "&vrtri;": "",
    "&vscr;": "\uD835\uDCCB",
    "&vsubnE;": "",
    "&vsubne;": "",
    "&vsupnE;": "",
    "&vsupne;": "",
    "&vzigzag;": "",
    "&wcirc;": "",
    "&wedbar;": "",
    "&wedge;": "",
    "&wedgeq;": "",
    "&weierp;": "",
    "&wfr;": "\uD835\uDD34",
    "&wopf;": "\uD835\uDD68",
    "&wp;": "",
    "&wr;": "",
    "&wreath;": "",
    "&wscr;": "\uD835\uDCCC",
    "&xcap;": "",
    "&xcirc;": "",
    "&xcup;": "",
    "&xdtri;": "",
    "&xfr;": "\uD835\uDD35",
    "&xhArr;": "",
    "&xharr;": "",
    "&xi;": "",
    "&xlArr;": "",
    "&xlarr;": "",
    "&xmap;": "",
    "&xnis;": "",
    "&xodot;": "",
    "&xopf;": "\uD835\uDD69",
    "&xoplus;": "",
    "&xotime;": "",
    "&xrArr;": "",
    "&xrarr;": "",
    "&xscr;": "\uD835\uDCCD",
    "&xsqcup;": "",
    "&xuplus;": "",
    "&xutri;": "",
    "&xvee;": "",
    "&xwedge;": "",
    "&yacute": "",
    "&yacute;": "",
    "&yacy;": "",
    "&ycirc;": "",
    "&ycy;": "",
    "&yen": "",
    "&yen;": "",
    "&yfr;": "\uD835\uDD36",
    "&yicy;": "",
    "&yopf;": "\uD835\uDD6A",
    "&yscr;": "\uD835\uDCCE",
    "&yucy;": "",
    "&yuml": "",
    "&yuml;": "",
    "&zacute;": "",
    "&zcaron;": "",
    "&zcy;": "",
    "&zdot;": "",
    "&zeetrf;": "",
    "&zeta;": "",
    "&zfr;": "\uD835\uDD37",
    "&zhcy;": "",
    "&zigrarr;": "",
    "&zopf;": "\uD835\uDD6B",
    "&zscr;": "\uD835\uDCCF",
    "&zwj;": "",
    "&zwnj;": ""
  };
  html_entities_default = htmlEntities;
});

// node_modules/postal-mime/src/text-format.js
function decodeHTMLEntities(str) {
  return str.replace(/&(#\d+|#x[a-f0-9]+|[a-z]+\d*);?/gi, (match, entity) => {
    if (typeof html_entities_default[match] === "string") {
      return html_entities_default[match];
    }
    if (entity.charAt(0) !== "#" || match.charAt(match.length - 1) !== ";") {
      return match;
    }
    let codePoint;
    if (entity.charAt(1) === "x") {
      codePoint = parseInt(entity.substr(2), 16);
    } else {
      codePoint = parseInt(entity.substr(1), 10);
    }
    var output = "";
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return "";
    }
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  });
}
function escapeHtml(str) {
  return str.trim().replace(/[<>"'?&]/g, (c) => {
    let hex = c.charCodeAt(0).toString(16);
    if (hex.length < 2) {
      hex = "0" + hex;
    }
    return "&#x" + hex.toUpperCase() + ";";
  });
}
function textToHtml(str) {
  let html = escapeHtml(str).replace(/\n/g, "<br />");
  return "<div>" + html + "</div>";
}
function htmlToText(str) {
  str = str.replace(/\r?\n/g, "\x01").replace(/<\!\-\-.*?\-\->/gi, " ").replace(/<br\b[^>]*>/gi, `
`).replace(/<\/?(p|div|table|tr|td|th)\b[^>]*>/gi, `

`).replace(/<script\b[^>]*>.*?<\/script\b[^>]*>/gi, " ").replace(/^.*<body\b[^>]*>/i, "").replace(/^.*<\/head\b[^>]*>/i, "").replace(/^.*<\!doctype\b[^>]*>/i, "").replace(/<\/body\b[^>]*>.*$/i, "").replace(/<\/html\b[^>]*>.*$/i, "").replace(/<a\b[^>]*href\s*=\s*["']?([^\s"']+)[^>]*>/gi, " ($1) ").replace(/<\/?(span|em|i|strong|b|u|a)\b[^>]*>/gi, "").replace(/<li\b[^>]*>[\n\u0001\s]*/gi, "* ").replace(/<hr\b[^>]*>/g, `
-------------
`).replace(/<[^>]*>/g, " ").replace(/\u0001/g, `
`).replace(/[ \t]+/g, " ").replace(/^\s+$/gm, "").replace(/\n\n+/g, `

`).replace(/^\n+/, `
`).replace(/\n+$/, `
`);
  str = decodeHTMLEntities(str);
  return str;
}
function formatTextAddress(address) {
  return [].concat(address.name || []).concat(address.name ? `<${address.address}>` : address.address).join(" ");
}
function formatTextAddresses(addresses) {
  let parts = [];
  let processAddress = (address, partCounter) => {
    if (partCounter) {
      parts.push(", ");
    }
    if (address.group) {
      let groupStart = `${address.name}:`;
      let groupEnd = `;`;
      parts.push(groupStart);
      address.group.forEach(processAddress);
      parts.push(groupEnd);
    } else {
      parts.push(formatTextAddress(address));
    }
  };
  addresses.forEach(processAddress);
  return parts.join("");
}
function formatHtmlAddress(address) {
  return `<a href="mailto:${escapeHtml(address.address)}" class="postal-email-address">${escapeHtml(address.name || `<${address.address}>`)}</a>`;
}
function formatHtmlAddresses(addresses) {
  let parts = [];
  let processAddress = (address, partCounter) => {
    if (partCounter) {
      parts.push('<span class="postal-email-address-separator">, </span>');
    }
    if (address.group) {
      let groupStart = `<span class="postal-email-address-group">${escapeHtml(address.name)}:</span>`;
      let groupEnd = `<span class="postal-email-address-group">;</span>`;
      parts.push(groupStart);
      address.group.forEach(processAddress);
      parts.push(groupEnd);
    } else {
      parts.push(formatHtmlAddress(address));
    }
  };
  addresses.forEach(processAddress);
  return parts.join(" ");
}
function foldLines(str, lineLength, afterSpace) {
  str = (str || "").toString();
  lineLength = lineLength || 76;
  let pos = 0, len = str.length, result = "", line, match;
  while (pos < len) {
    line = str.substr(pos, lineLength);
    if (line.length < lineLength) {
      result += line;
      break;
    }
    if (match = line.match(/^[^\n\r]*(\r?\n|\r)/)) {
      line = match[0];
      result += line;
      pos += line.length;
      continue;
    } else if ((match = line.match(/(\s+)[^\s]*$/)) && match[0].length - (afterSpace ? (match[1] || "").length : 0) < line.length) {
      line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || "").length : 0)));
    } else if (match = str.substr(pos + line.length).match(/^[^\s]+(\s*)/)) {
      line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || "").length : 0));
    }
    result += line;
    pos += line.length;
    if (pos < len) {
      result += `\r
`;
    }
  }
  return result;
}
function formatTextHeader(message3) {
  let rows = [];
  if (message3.from) {
    rows.push({ key: "From", val: formatTextAddress(message3.from) });
  }
  if (message3.subject) {
    rows.push({ key: "Subject", val: message3.subject });
  }
  if (message3.date) {
    let dateOptions = {
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      hour12: false
    };
    let dateStr = typeof Intl === "undefined" ? message3.date : new Intl.DateTimeFormat("default", dateOptions).format(new Date(message3.date));
    rows.push({ key: "Date", val: dateStr });
  }
  if (message3.to && message3.to.length) {
    rows.push({ key: "To", val: formatTextAddresses(message3.to) });
  }
  if (message3.cc && message3.cc.length) {
    rows.push({ key: "Cc", val: formatTextAddresses(message3.cc) });
  }
  if (message3.bcc && message3.bcc.length) {
    rows.push({ key: "Bcc", val: formatTextAddresses(message3.bcc) });
  }
  let maxKeyLength = rows.map((r) => r.key.length).reduce((acc, cur) => {
    return cur > acc ? cur : acc;
  }, 0);
  rows = rows.flatMap((row) => {
    let sepLen = maxKeyLength - row.key.length;
    let prefix = `${row.key}: ${" ".repeat(sepLen)}`;
    let emptyPrefix = `${" ".repeat(row.key.length + 1)} ${" ".repeat(sepLen)}`;
    let foldedLines = foldLines(row.val, 80, true).split(/\r?\n/).map((line) => line.trim());
    return foldedLines.map((line, i2) => `${i2 ? emptyPrefix : prefix}${line}`);
  });
  let maxLineLength = rows.map((r) => r.length).reduce((acc, cur) => {
    return cur > acc ? cur : acc;
  }, 0);
  let lineMarker = "-".repeat(maxLineLength);
  let template = `
${lineMarker}
${rows.join(`
`)}
${lineMarker}
`;
  return template;
}
function formatHtmlHeader(message3) {
  let rows = [];
  if (message3.from) {
    rows.push(`<div class="postal-email-header-key">From</div><div class="postal-email-header-value">${formatHtmlAddress(message3.from)}</div>`);
  }
  if (message3.subject) {
    rows.push(`<div class="postal-email-header-key">Subject</div><div class="postal-email-header-value postal-email-header-subject">${escapeHtml(message3.subject)}</div>`);
  }
  if (message3.date) {
    let dateOptions = {
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      hour12: false
    };
    let dateStr = typeof Intl === "undefined" ? message3.date : new Intl.DateTimeFormat("default", dateOptions).format(new Date(message3.date));
    rows.push(`<div class="postal-email-header-key">Date</div><div class="postal-email-header-value postal-email-header-date" data-date="${escapeHtml(message3.date)}">${escapeHtml(dateStr)}</div>`);
  }
  if (message3.to && message3.to.length) {
    rows.push(`<div class="postal-email-header-key">To</div><div class="postal-email-header-value">${formatHtmlAddresses(message3.to)}</div>`);
  }
  if (message3.cc && message3.cc.length) {
    rows.push(`<div class="postal-email-header-key">Cc</div><div class="postal-email-header-value">${formatHtmlAddresses(message3.cc)}</div>`);
  }
  if (message3.bcc && message3.bcc.length) {
    rows.push(`<div class="postal-email-header-key">Bcc</div><div class="postal-email-header-value">${formatHtmlAddresses(message3.bcc)}</div>`);
  }
  let template = `<div class="postal-email-header">${rows.length ? '<div class="postal-email-header-row">' : ""}${rows.join(`</div>
<div class="postal-email-header-row">`)}${rows.length ? "</div>" : ""}</div>`;
  return template;
}
var init_text_format = __esm(() => {
  init_html_entities();
});

// node_modules/postal-mime/src/address-parser.js
function _handleAddress(tokens, depth) {
  let isGroup = false;
  let state = "text";
  let address;
  let addresses = [];
  let data = {
    address: [],
    comment: [],
    group: [],
    text: [],
    textWasQuoted: []
  };
  let i2;
  let len;
  let insideQuotes = false;
  for (i2 = 0, len = tokens.length;i2 < len; i2++) {
    let token2 = tokens[i2];
    let prevToken = i2 ? tokens[i2 - 1] : null;
    if (token2.type === "operator") {
      switch (token2.value) {
        case "<":
          state = "address";
          insideQuotes = false;
          break;
        case "(":
          state = "comment";
          insideQuotes = false;
          break;
        case ":":
          state = "group";
          isGroup = true;
          insideQuotes = false;
          break;
        case '"':
          insideQuotes = !insideQuotes;
          state = "text";
          break;
        default:
          state = "text";
          insideQuotes = false;
          break;
      }
    } else if (token2.value) {
      if (state === "address") {
        token2.value = token2.value.replace(/^[^<]*<\s*/, "");
      }
      if (prevToken && prevToken.noBreak && data[state].length) {
        data[state][data[state].length - 1] += token2.value;
        if (state === "text" && insideQuotes) {
          data.textWasQuoted[data.textWasQuoted.length - 1] = true;
        }
      } else {
        data[state].push(token2.value);
        if (state === "text") {
          data.textWasQuoted.push(insideQuotes);
        }
      }
    }
  }
  if (!data.text.length && data.comment.length) {
    data.text = data.comment;
    data.comment = [];
  }
  if (isGroup) {
    data.text = data.text.join(" ");
    let groupMembers = [];
    if (data.group.length) {
      let parsedGroup = addressParser(data.group.join(","), { _depth: depth + 1 });
      parsedGroup.forEach((member) => {
        if (member.group) {
          groupMembers = groupMembers.concat(member.group);
        } else {
          groupMembers.push(member);
        }
      });
    }
    addresses.push({
      name: decodeWords(data.text || address && address.name),
      group: groupMembers
    });
  } else {
    if (!data.address.length && data.text.length) {
      for (i2 = data.text.length - 1;i2 >= 0; i2--) {
        if (!data.textWasQuoted[i2] && data.text[i2].match(/^[^@\s]+@[^@\s]+$/)) {
          data.address = data.text.splice(i2, 1);
          data.textWasQuoted.splice(i2, 1);
          break;
        }
      }
      let _regexHandler = function(address2) {
        if (!data.address.length) {
          data.address = [address2.trim()];
          return " ";
        } else {
          return address2;
        }
      };
      if (!data.address.length) {
        for (i2 = data.text.length - 1;i2 >= 0; i2--) {
          if (!data.textWasQuoted[i2]) {
            data.text[i2] = data.text[i2].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
            if (data.address.length) {
              break;
            }
          }
        }
      }
    }
    if (!data.text.length && data.comment.length) {
      data.text = data.comment;
      data.comment = [];
    }
    if (data.address.length > 1) {
      data.text = data.text.concat(data.address.splice(1));
    }
    data.text = data.text.join(" ");
    data.address = data.address.join(" ");
    if (!data.address && /^=\?[^=]+?=$/.test(data.text.trim())) {
      const parsedSubAddresses = addressParser(decodeWords(data.text));
      if (parsedSubAddresses && parsedSubAddresses.length) {
        return parsedSubAddresses;
      }
    }
    if (!data.address && isGroup) {
      return [];
    } else {
      address = {
        address: data.address || data.text || "",
        name: decodeWords(data.text || data.address || "")
      };
      if (address.address === address.name) {
        if ((address.address || "").match(/@/)) {
          address.name = "";
        } else {
          address.address = "";
        }
      }
      addresses.push(address);
    }
  }
  return addresses;
}

class Tokenizer {
  constructor(str) {
    this.str = (str || "").toString();
    this.operatorCurrent = "";
    this.operatorExpecting = "";
    this.node = null;
    this.escaped = false;
    this.list = [];
    this.operators = {
      '"': '"',
      "(": ")",
      "<": ">",
      ",": "",
      ":": ";",
      ";": ""
    };
  }
  tokenize() {
    let list = [];
    for (let i2 = 0, len = this.str.length;i2 < len; i2++) {
      let chr = this.str.charAt(i2);
      let nextChr = i2 < len - 1 ? this.str.charAt(i2 + 1) : null;
      this.checkChar(chr, nextChr);
    }
    this.list.forEach((node) => {
      node.value = (node.value || "").toString().trim();
      if (node.value) {
        list.push(node);
      }
    });
    return list;
  }
  checkChar(chr, nextChr) {
    if (this.escaped) {} else if (chr === this.operatorExpecting) {
      this.node = {
        type: "operator",
        value: chr
      };
      if (nextChr && ![" ", "\t", "\r", `
`, ",", ";"].includes(nextChr)) {
        this.node.noBreak = true;
      }
      this.list.push(this.node);
      this.node = null;
      this.operatorExpecting = "";
      this.escaped = false;
      return;
    } else if (!this.operatorExpecting && chr in this.operators) {
      this.node = {
        type: "operator",
        value: chr
      };
      this.list.push(this.node);
      this.node = null;
      this.operatorExpecting = this.operators[chr];
      this.escaped = false;
      return;
    } else if (['"', "'"].includes(this.operatorExpecting) && chr === "\\") {
      this.escaped = true;
      return;
    }
    if (!this.node) {
      this.node = {
        type: "text",
        value: ""
      };
      this.list.push(this.node);
    }
    if (chr === `
`) {
      chr = " ";
    }
    if (chr.charCodeAt(0) >= 33 || [" ", "\t"].includes(chr)) {
      this.node.value += chr;
    }
    this.escaped = false;
  }
}
function addressParser(str, options) {
  options = options || {};
  let depth = options._depth || 0;
  if (depth > MAX_NESTED_GROUP_DEPTH) {
    return [];
  }
  let tokenizer = new Tokenizer(str);
  let tokens = tokenizer.tokenize();
  let addresses = [];
  let address = [];
  let parsedAddresses = [];
  tokens.forEach((token2) => {
    if (token2.type === "operator" && (token2.value === "," || token2.value === ";")) {
      if (address.length) {
        addresses.push(address);
      }
      address = [];
    } else {
      address.push(token2);
    }
  });
  if (address.length) {
    addresses.push(address);
  }
  addresses.forEach((address2) => {
    address2 = _handleAddress(address2, depth);
    if (address2.length) {
      parsedAddresses = parsedAddresses.concat(address2);
    }
  });
  if (options.flatten) {
    let addresses2 = [];
    let walkAddressList = (list) => {
      list.forEach((address2) => {
        if (address2.group) {
          return walkAddressList(address2.group);
        } else {
          addresses2.push(address2);
        }
      });
    };
    walkAddressList(parsedAddresses);
    return addresses2;
  }
  return parsedAddresses;
}
var MAX_NESTED_GROUP_DEPTH = 50, address_parser_default;
var init_address_parser = __esm(() => {
  init_decode_strings();
  address_parser_default = addressParser;
});

// node_modules/postal-mime/src/base64-encoder.js
function base64ArrayBuffer(arrayBuffer) {
  var base64 = "";
  var encodings = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var bytes = new Uint8Array(arrayBuffer);
  var byteLength = bytes.byteLength;
  var byteRemainder = byteLength % 3;
  var mainLength = byteLength - byteRemainder;
  var a, b, c, d;
  var chunk;
  for (var i2 = 0;i2 < mainLength; i2 = i2 + 3) {
    chunk = bytes[i2] << 16 | bytes[i2 + 1] << 8 | bytes[i2 + 2];
    a = (chunk & 16515072) >> 18;
    b = (chunk & 258048) >> 12;
    c = (chunk & 4032) >> 6;
    d = chunk & 63;
    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
  }
  if (byteRemainder == 1) {
    chunk = bytes[mainLength];
    a = (chunk & 252) >> 2;
    b = (chunk & 3) << 4;
    base64 += encodings[a] + encodings[b] + "==";
  } else if (byteRemainder == 2) {
    chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];
    a = (chunk & 64512) >> 10;
    b = (chunk & 1008) >> 4;
    c = (chunk & 15) << 2;
    base64 += encodings[a] + encodings[b] + encodings[c] + "=";
  }
  return base64;
}

// node_modules/postal-mime/src/postal-mime.js
class PostalMime {
  static parse(buf, options) {
    const parser = new PostalMime(options);
    return parser.parse(buf);
  }
  constructor(options) {
    this.options = options || {};
    this.mimeOptions = {
      maxNestingDepth: this.options.maxNestingDepth || MAX_NESTING_DEPTH,
      maxHeadersSize: this.options.maxHeadersSize || MAX_HEADERS_SIZE
    };
    this.root = this.currentNode = new MimeNode({
      postalMime: this,
      ...this.mimeOptions
    });
    this.boundaries = [];
    this.textContent = {};
    this.attachments = [];
    this.attachmentEncoding = (this.options.attachmentEncoding || "").toString().replace(/[-_\s]/g, "").trim().toLowerCase() || "arraybuffer";
    this.started = false;
  }
  async finalize() {
    await this.root.finalize();
  }
  async processLine(line, isFinal) {
    let boundaries = this.boundaries;
    if (boundaries.length && line.length > 2 && line[0] === 45 && line[1] === 45) {
      for (let i2 = boundaries.length - 1;i2 >= 0; i2--) {
        let boundary = boundaries[i2];
        if (line.length < boundary.value.length + 2) {
          continue;
        }
        let boundaryMatches = true;
        for (let j = 0;j < boundary.value.length; j++) {
          if (line[j + 2] !== boundary.value[j]) {
            boundaryMatches = false;
            break;
          }
        }
        if (!boundaryMatches) {
          continue;
        }
        let boundaryEnd = boundary.value.length + 2;
        let isTerminator = false;
        if (line.length >= boundary.value.length + 4 && line[boundary.value.length + 2] === 45 && line[boundary.value.length + 3] === 45) {
          isTerminator = true;
          boundaryEnd = boundary.value.length + 4;
        }
        let hasValidTrailing = true;
        for (let j = boundaryEnd;j < line.length; j++) {
          if (line[j] !== 32 && line[j] !== 9) {
            hasValidTrailing = false;
            break;
          }
        }
        if (!hasValidTrailing) {
          continue;
        }
        if (isTerminator) {
          await boundary.node.finalize();
          this.currentNode = boundary.node.parentNode || this.root;
        } else {
          await boundary.node.finalizeChildNodes();
          this.currentNode = new MimeNode({
            postalMime: this,
            parentNode: boundary.node,
            parentMultipartType: boundary.node.contentType.multipart,
            ...this.mimeOptions
          });
        }
        if (isFinal) {
          return this.finalize();
        }
        return;
      }
    }
    this.currentNode.feed(line);
    if (isFinal) {
      return this.finalize();
    }
  }
  readLine() {
    let startPos = this.readPos;
    let endPos = this.readPos;
    let res = () => {
      return {
        bytes: new Uint8Array(this.buf, startPos, endPos - startPos),
        done: this.readPos >= this.av.length
      };
    };
    while (this.readPos < this.av.length) {
      const c = this.av[this.readPos++];
      if (c !== 13 && c !== 10) {
        endPos = this.readPos;
      }
      if (c === 10) {
        return res();
      }
    }
    return res();
  }
  async processNodeTree() {
    let textContent = {};
    let textTypes = new Set;
    let textMap = this.textMap = new Map;
    let forceRfc822Attachments = this.forceRfc822Attachments();
    let walk = async (node, alternative, related) => {
      alternative = alternative || false;
      related = related || false;
      if (!node.contentType.multipart) {
        if (this.isInlineMessageRfc822(node) && !forceRfc822Attachments) {
          const subParser = new PostalMime;
          node.subMessage = await subParser.parse(node.content);
          if (!textMap.has(node)) {
            textMap.set(node, {});
          }
          let textEntry = textMap.get(node);
          if (node.subMessage.text || !node.subMessage.html) {
            textEntry.plain = textEntry.plain || [];
            textEntry.plain.push({ type: "subMessage", value: node.subMessage });
            textTypes.add("plain");
          }
          if (node.subMessage.html) {
            textEntry.html = textEntry.html || [];
            textEntry.html.push({ type: "subMessage", value: node.subMessage });
            textTypes.add("html");
          }
          if (subParser.textMap) {
            subParser.textMap.forEach((subTextEntry, subTextNode) => {
              textMap.set(subTextNode, subTextEntry);
            });
          }
          for (let attachment of node.subMessage.attachments || []) {
            this.attachments.push(attachment);
          }
        } else if (this.isInlineTextNode(node)) {
          let textType = node.contentType.parsed.value.substr(node.contentType.parsed.value.indexOf("/") + 1);
          let selectorNode = alternative || node;
          if (!textMap.has(selectorNode)) {
            textMap.set(selectorNode, {});
          }
          let textEntry = textMap.get(selectorNode);
          textEntry[textType] = textEntry[textType] || [];
          textEntry[textType].push({ type: "text", value: node.getTextContent() });
          textTypes.add(textType);
        } else if (node.content) {
          const filename = node.contentDisposition?.parsed?.params?.filename || node.contentType.parsed.params.name || null;
          const attachment = {
            filename: filename ? decodeWords(filename) : null,
            mimeType: node.contentType.parsed.value,
            disposition: node.contentDisposition?.parsed?.value || null
          };
          if (related && node.contentId) {
            attachment.related = true;
          }
          if (node.contentDescription) {
            attachment.description = node.contentDescription;
          }
          if (node.contentId) {
            attachment.contentId = node.contentId;
          }
          switch (node.contentType.parsed.value) {
            case "text/calendar":
            case "application/ics": {
              if (node.contentType.parsed.params.method) {
                attachment.method = node.contentType.parsed.params.method.toString().toUpperCase().trim();
              }
              const decodedText = node.getTextContent().replace(/\r?\n/g, `
`).replace(/\n*$/, `
`);
              attachment.content = textEncoder.encode(decodedText);
              break;
            }
            default:
              attachment.content = node.content;
          }
          this.attachments.push(attachment);
        }
      } else if (node.contentType.multipart === "alternative") {
        alternative = node;
      } else if (node.contentType.multipart === "related") {
        related = node;
      }
      for (let childNode of node.childNodes) {
        await walk(childNode, alternative, related);
      }
    };
    await walk(this.root, false, []);
    textMap.forEach((mapEntry) => {
      textTypes.forEach((textType) => {
        if (!textContent[textType]) {
          textContent[textType] = [];
        }
        if (mapEntry[textType]) {
          mapEntry[textType].forEach((textEntry) => {
            switch (textEntry.type) {
              case "text":
                textContent[textType].push(textEntry.value);
                break;
              case "subMessage":
                {
                  switch (textType) {
                    case "html":
                      textContent[textType].push(formatHtmlHeader(textEntry.value));
                      break;
                    case "plain":
                      textContent[textType].push(formatTextHeader(textEntry.value));
                      break;
                  }
                }
                break;
            }
          });
        } else {
          let alternativeType;
          switch (textType) {
            case "html":
              alternativeType = "plain";
              break;
            case "plain":
              alternativeType = "html";
              break;
          }
          (mapEntry[alternativeType] || []).forEach((textEntry) => {
            switch (textEntry.type) {
              case "text":
                switch (textType) {
                  case "html":
                    textContent[textType].push(textToHtml(textEntry.value));
                    break;
                  case "plain":
                    textContent[textType].push(htmlToText(textEntry.value));
                    break;
                }
                break;
              case "subMessage":
                {
                  switch (textType) {
                    case "html":
                      textContent[textType].push(formatHtmlHeader(textEntry.value));
                      break;
                    case "plain":
                      textContent[textType].push(formatTextHeader(textEntry.value));
                      break;
                  }
                }
                break;
            }
          });
        }
      });
    });
    Object.keys(textContent).forEach((textType) => {
      textContent[textType] = textContent[textType].join(`
`);
    });
    this.textContent = textContent;
  }
  isInlineTextNode(node) {
    if (node.contentDisposition?.parsed?.value === "attachment") {
      return false;
    }
    switch (node.contentType.parsed?.value) {
      case "text/html":
      case "text/plain":
        return true;
      case "text/calendar":
      case "text/csv":
      default:
        return false;
    }
  }
  isInlineMessageRfc822(node) {
    if (node.contentType.parsed?.value !== "message/rfc822") {
      return false;
    }
    let disposition = node.contentDisposition?.parsed?.value || (this.options.rfc822Attachments ? "attachment" : "inline");
    return disposition === "inline";
  }
  forceRfc822Attachments() {
    if (this.options.forceRfc822Attachments) {
      return true;
    }
    let forceRfc822Attachments = false;
    let walk = (node) => {
      if (!node.contentType.multipart) {
        if (node.contentType.parsed && ["message/delivery-status", "message/feedback-report"].includes(node.contentType.parsed.value)) {
          forceRfc822Attachments = true;
        }
      }
      for (let childNode of node.childNodes) {
        walk(childNode);
      }
    };
    walk(this.root);
    return forceRfc822Attachments;
  }
  async resolveStream(stream3) {
    let chunkLen = 0;
    let chunks = [];
    const reader = stream3.getReader();
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      chunks.push(value);
      chunkLen += value.length;
    }
    const result = new Uint8Array(chunkLen);
    let chunkPointer = 0;
    for (let chunk of chunks) {
      result.set(chunk, chunkPointer);
      chunkPointer += chunk.length;
    }
    return result;
  }
  async parse(buf) {
    if (this.started) {
      throw new Error("Can not reuse parser, create a new PostalMime object");
    }
    this.started = true;
    if (buf && typeof buf.getReader === "function") {
      buf = await this.resolveStream(buf);
    }
    buf = buf || new ArrayBuffer(0);
    if (typeof buf === "string") {
      buf = textEncoder.encode(buf);
    }
    if (buf instanceof Blob || Object.prototype.toString.call(buf) === "[object Blob]") {
      buf = await blobToArrayBuffer(buf);
    }
    if (buf.buffer instanceof ArrayBuffer) {
      buf = new Uint8Array(buf).buffer;
    }
    this.buf = buf;
    this.av = new Uint8Array(buf);
    this.readPos = 0;
    while (this.readPos < this.av.length) {
      const line = this.readLine();
      await this.processLine(line.bytes, line.done);
    }
    await this.processNodeTree();
    const message3 = {
      headers: this.root.headers.map((entry) => ({ key: entry.key, value: entry.value })).reverse()
    };
    for (const key of ["from", "sender"]) {
      const addressHeader = this.root.headers.find((line) => line.key === key);
      if (addressHeader && addressHeader.value) {
        const addresses = address_parser_default(addressHeader.value);
        if (addresses && addresses.length) {
          message3[key] = addresses[0];
        }
      }
    }
    for (const key of ["delivered-to", "return-path"]) {
      const addressHeader = this.root.headers.find((line) => line.key === key);
      if (addressHeader && addressHeader.value) {
        const addresses = address_parser_default(addressHeader.value);
        if (addresses && addresses.length && addresses[0].address) {
          const camelKey = key.replace(/\-(.)/g, (o, c) => c.toUpperCase());
          message3[camelKey] = addresses[0].address;
        }
      }
    }
    for (const key of ["to", "cc", "bcc", "reply-to"]) {
      const addressHeaders = this.root.headers.filter((line) => line.key === key);
      let addresses = [];
      addressHeaders.filter((entry) => entry && entry.value).map((entry) => address_parser_default(entry.value)).forEach((parsed) => addresses = addresses.concat(parsed || []));
      if (addresses && addresses.length) {
        const camelKey = key.replace(/\-(.)/g, (o, c) => c.toUpperCase());
        message3[camelKey] = addresses;
      }
    }
    for (const key of ["subject", "message-id", "in-reply-to", "references"]) {
      const header = this.root.headers.find((line) => line.key === key);
      if (header && header.value) {
        const camelKey = key.replace(/\-(.)/g, (o, c) => c.toUpperCase());
        message3[camelKey] = decodeWords(header.value);
      }
    }
    let dateHeader = this.root.headers.find((line) => line.key === "date");
    if (dateHeader) {
      let date = new Date(dateHeader.value);
      if (!date || date.toString() === "Invalid Date") {
        date = dateHeader.value;
      } else {
        date = date.toISOString();
      }
      message3.date = date;
    }
    if (this.textContent?.html) {
      message3.html = this.textContent.html;
    }
    if (this.textContent?.plain) {
      message3.text = this.textContent.plain;
    }
    message3.attachments = this.attachments;
    message3.headerLines = (this.root.rawHeaderLines || []).slice().reverse();
    switch (this.attachmentEncoding) {
      case "arraybuffer":
        break;
      case "base64":
        for (let attachment of message3.attachments || []) {
          if (attachment?.content) {
            attachment.content = base64ArrayBuffer(attachment.content);
            attachment.encoding = "base64";
          }
        }
        break;
      case "utf8":
        let attachmentDecoder = new TextDecoder("utf8");
        for (let attachment of message3.attachments || []) {
          if (attachment?.content) {
            attachment.content = attachmentDecoder.decode(attachment.content);
            attachment.encoding = "utf8";
          }
        }
        break;
      default:
        throw new Error("Unknwon attachment encoding");
    }
    return message3;
  }
}
var MAX_NESTING_DEPTH = 256, MAX_HEADERS_SIZE;
var init_postal_mime = __esm(() => {
  init_mime_node();
  init_text_format();
  init_address_parser();
  init_decode_strings();
  MAX_HEADERS_SIZE = 2 * 1024 * 1024;
});

// node_modules/svix/dist/models/applicationIn.js
var require_applicationIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationInSerializer = undefined;
  exports.ApplicationInSerializer = {
    _fromJsonObject(object) {
      return {
        metadata: object["metadata"],
        name: object["name"],
        rateLimit: object["rateLimit"],
        uid: object["uid"]
      };
    },
    _toJsonObject(self2) {
      return {
        metadata: self2.metadata,
        name: self2.name,
        rateLimit: self2.rateLimit,
        uid: self2.uid
      };
    }
  };
});

// node_modules/svix/dist/models/applicationOut.js
var require_applicationOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationOutSerializer = undefined;
  exports.ApplicationOutSerializer = {
    _fromJsonObject(object) {
      return {
        createdAt: new Date(object["createdAt"]),
        id: object["id"],
        metadata: object["metadata"],
        name: object["name"],
        rateLimit: object["rateLimit"],
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"])
      };
    },
    _toJsonObject(self2) {
      return {
        createdAt: self2.createdAt,
        id: self2.id,
        metadata: self2.metadata,
        name: self2.name,
        rateLimit: self2.rateLimit,
        uid: self2.uid,
        updatedAt: self2.updatedAt
      };
    }
  };
});

// node_modules/svix/dist/models/applicationPatch.js
var require_applicationPatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationPatchSerializer = undefined;
  exports.ApplicationPatchSerializer = {
    _fromJsonObject(object) {
      return {
        metadata: object["metadata"],
        name: object["name"],
        rateLimit: object["rateLimit"],
        uid: object["uid"]
      };
    },
    _toJsonObject(self2) {
      return {
        metadata: self2.metadata,
        name: self2.name,
        rateLimit: self2.rateLimit,
        uid: self2.uid
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseApplicationOut.js
var require_listResponseApplicationOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseApplicationOutSerializer = undefined;
  var applicationOut_1 = require_applicationOut();
  exports.ListResponseApplicationOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => applicationOut_1.ApplicationOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => applicationOut_1.ApplicationOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/util.js
var require_util3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApiException = undefined;

  class ApiException extends Error {
    constructor(code, body, headers) {
      super(`HTTP-Code: ${code}
Headers: ${JSON.stringify(headers)}`);
      this.code = code;
      this.body = body;
      this.headers = {};
      headers.forEach((value, name) => {
        this.headers[name] = value;
      });
    }
  }
  exports.ApiException = ApiException;
});

// node_modules/uuid/dist/max.js
var require_max = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = exports.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = exports.default = "00000000-0000-0000-0000-000000000000";
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function validate(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  }
  var _default = exports.default = validate;
});

// node_modules/uuid/dist/parse.js
var require_parse2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function parse2(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  }
  var _default = exports.default = parse2;
});

// node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var byteToHex = [];
  for (let i2 = 0;i2 < 256; ++i2) {
    byteToHex.push((i2 + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset2 = 0) {
    return (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  }
  function stringify(arr, offset2 = 0) {
    const uuid = unsafeStringify(arr, offset2);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var _default = exports.default = stringify;
});

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _nodeCrypto = _interopRequireDefault(__require("node:crypto"));
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      _nodeCrypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset2) {
    let i2 = buf && offset2 || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node;
    let clockseq = options.clockseq;
    if (!options._v6) {
      if (!node) {
        node = _nodeId;
      }
      if (clockseq == null) {
        clockseq = _clockseq;
      }
    }
    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node == null) {
        node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        if (!_nodeId && !options._v6) {
          node[0] |= 1;
          _nodeId = node;
        }
      }
      if (clockseq == null) {
        clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        if (_clockseq === undefined && !options._v6) {
          _clockseq = clockseq;
        }
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i2++] = tl >>> 24 & 255;
    b[i2++] = tl >>> 16 & 255;
    b[i2++] = tl >>> 8 & 255;
    b[i2++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i2++] = tmh >>> 8 & 255;
    b[i2++] = tmh & 255;
    b[i2++] = tmh >>> 24 & 15 | 16;
    b[i2++] = tmh >>> 16 & 255;
    b[i2++] = clockseq >>> 8 | 128;
    b[i2++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i2 + n] = node[n];
    }
    return buf || (0, _stringify.unsafeStringify)(b);
  }
  var _default = exports.default = v1;
});

// node_modules/uuid/dist/v1ToV6.js
var require_v1ToV6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v1ToV6;
  var _parse = _interopRequireDefault(require_parse2());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v1ToV6(uuid) {
    const v1Bytes = typeof uuid === "string" ? (0, _parse.default)(uuid) : uuid;
    const v6Bytes = _v1ToV6(v1Bytes);
    return typeof uuid === "string" ? (0, _stringify.unsafeStringify)(v6Bytes) : v6Bytes;
  }
  function _v1ToV6(v1Bytes, randomize = false) {
    return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
  }
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify();
  var _parse = _interopRequireDefault(require_parse2());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i2 = 0;i2 < str.length; ++i2) {
      bytes.push(str.charCodeAt(i2));
    }
    return bytes;
  }
  var DNS = exports.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  var URL2 = exports.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  function v35(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset2) {
      var _namespace;
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset2 = offset2 || 0;
        for (let i2 = 0;i2 < 16; ++i2) {
          buf[offset2 + i2] = bytes[i2];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {}
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  }
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(__require("node:crypto"));
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function md5(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _nodeCrypto.default.createHash("md5").update(bytes).digest();
  }
  var _default = exports.default = md5;
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = exports.default = v3;
});

// node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(__require("node:crypto"));
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var _default = exports.default = {
    randomUUID: _nodeCrypto.default.randomUUID
  };
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v4(options, buf, offset2) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset2 = offset2 || 0;
      for (let i2 = 0;i2 < 16; ++i2) {
        buf[offset2 + i2] = rnds[i2];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  }
  var _default = exports.default = v4;
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(__require("node:crypto"));
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function sha1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _nodeCrypto.default.createHash("sha1").update(bytes).digest();
  }
  var _default = exports.default = sha1;
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = exports.default = v5;
});

// node_modules/uuid/dist/v6.js
var require_v6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v6;
  var _stringify = require_stringify();
  var _v = _interopRequireDefault(require_v1());
  var _v1ToV = _interopRequireDefault(require_v1ToV6());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v6(options = {}, buf, offset2 = 0) {
    let bytes = (0, _v.default)({
      ...options,
      _v6: true
    }, new Uint8Array(16));
    bytes = (0, _v1ToV.default)(bytes);
    if (buf) {
      for (let i2 = 0;i2 < 16; i2++) {
        buf[offset2 + i2] = bytes[i2];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(bytes);
  }
});

// node_modules/uuid/dist/v6ToV1.js
var require_v6ToV1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v6ToV1;
  var _parse = _interopRequireDefault(require_parse2());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v6ToV1(uuid) {
    const v6Bytes = typeof uuid === "string" ? (0, _parse.default)(uuid) : uuid;
    const v1Bytes = _v6ToV1(v6Bytes);
    return typeof uuid === "string" ? (0, _stringify.unsafeStringify)(v1Bytes) : v1Bytes;
  }
  function _v6ToV1(v6Bytes) {
    return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
  }
});

// node_modules/uuid/dist/v7.js
var require_v7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var _seqLow = null;
  var _seqHigh = null;
  var _msecs = 0;
  function v7(options, buf, offset2) {
    options = options || {};
    let i2 = buf && offset2 || 0;
    const b = buf || new Uint8Array(16);
    const rnds = options.random || (options.rng || _rng.default)();
    const msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let seq = options.seq !== undefined ? options.seq : null;
    let seqHigh = _seqHigh;
    let seqLow = _seqLow;
    if (msecs > _msecs && options.msecs === undefined) {
      _msecs = msecs;
      if (seq !== null) {
        seqHigh = null;
        seqLow = null;
      }
    }
    if (seq !== null) {
      if (seq > 2147483647) {
        seq = 2147483647;
      }
      seqHigh = seq >>> 19 & 4095;
      seqLow = seq & 524287;
    }
    if (seqHigh === null || seqLow === null) {
      seqHigh = rnds[6] & 127;
      seqHigh = seqHigh << 8 | rnds[7];
      seqLow = rnds[8] & 63;
      seqLow = seqLow << 8 | rnds[9];
      seqLow = seqLow << 5 | rnds[10] >>> 3;
    }
    if (msecs + 1e4 > _msecs && seq === null) {
      if (++seqLow > 524287) {
        seqLow = 0;
        if (++seqHigh > 4095) {
          seqHigh = 0;
          _msecs++;
        }
      }
    } else {
      _msecs = msecs;
    }
    _seqHigh = seqHigh;
    _seqLow = seqLow;
    b[i2++] = _msecs / 1099511627776 & 255;
    b[i2++] = _msecs / 4294967296 & 255;
    b[i2++] = _msecs / 16777216 & 255;
    b[i2++] = _msecs / 65536 & 255;
    b[i2++] = _msecs / 256 & 255;
    b[i2++] = _msecs & 255;
    b[i2++] = seqHigh >>> 4 & 15 | 112;
    b[i2++] = seqHigh & 255;
    b[i2++] = seqLow >>> 13 & 63 | 128;
    b[i2++] = seqLow >>> 5 & 255;
    b[i2++] = seqLow << 3 & 255 | rnds[10] & 7;
    b[i2++] = rnds[11];
    b[i2++] = rnds[12];
    b[i2++] = rnds[13];
    b[i2++] = rnds[14];
    b[i2++] = rnds[15];
    return buf || (0, _stringify.unsafeStringify)(b);
  }
  var _default = exports.default = v7;
});

// node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function version(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  }
  var _default = exports.default = version;
});

// node_modules/uuid/dist/index.js
var require_dist5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "MAX", {
    enumerable: true,
    get: function() {
      return _max.default;
    }
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v1ToV6", {
    enumerable: true,
    get: function() {
      return _v1ToV.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "v6", {
    enumerable: true,
    get: function() {
      return _v5.default;
    }
  });
  Object.defineProperty(exports, "v6ToV1", {
    enumerable: true,
    get: function() {
      return _v6ToV.default;
    }
  });
  Object.defineProperty(exports, "v7", {
    enumerable: true,
    get: function() {
      return _v6.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _max = _interopRequireDefault(require_max());
  var _nil = _interopRequireDefault(require_nil());
  var _parse = _interopRequireDefault(require_parse2());
  var _stringify = _interopRequireDefault(require_stringify());
  var _v = _interopRequireDefault(require_v1());
  var _v1ToV = _interopRequireDefault(require_v1ToV6());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _v5 = _interopRequireDefault(require_v6());
  var _v6ToV = _interopRequireDefault(require_v6ToV1());
  var _v6 = _interopRequireDefault(require_v7());
  var _validate = _interopRequireDefault(require_validate());
  var _version = _interopRequireDefault(require_version());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
});

// node_modules/svix/dist/request.js
var require_request3 = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SvixRequest = exports.HttpMethod = exports.LIB_VERSION = undefined;
  var util_1 = require_util3();
  var uuid_1 = require_dist5();
  exports.LIB_VERSION = "1.84.1";
  var USER_AGENT2 = `svix-libs/${exports.LIB_VERSION}/javascript`;
  var HttpMethod;
  (function(HttpMethod2) {
    HttpMethod2["GET"] = "GET";
    HttpMethod2["HEAD"] = "HEAD";
    HttpMethod2["POST"] = "POST";
    HttpMethod2["PUT"] = "PUT";
    HttpMethod2["DELETE"] = "DELETE";
    HttpMethod2["CONNECT"] = "CONNECT";
    HttpMethod2["OPTIONS"] = "OPTIONS";
    HttpMethod2["TRACE"] = "TRACE";
    HttpMethod2["PATCH"] = "PATCH";
  })(HttpMethod = exports.HttpMethod || (exports.HttpMethod = {}));

  class SvixRequest {
    constructor(method, path) {
      this.method = method;
      this.path = path;
      this.queryParams = {};
      this.headerParams = {};
    }
    setPathParam(name, value) {
      const newPath = this.path.replace(`{${name}}`, encodeURIComponent(value));
      if (this.path === newPath) {
        throw new Error(`path parameter ${name} not found`);
      }
      this.path = newPath;
    }
    setQueryParams(params) {
      for (const [name, value] of Object.entries(params)) {
        this.setQueryParam(name, value);
      }
    }
    setQueryParam(name, value) {
      if (value === undefined || value === null) {
        return;
      }
      if (typeof value === "string") {
        this.queryParams[name] = value;
      } else if (typeof value === "boolean" || typeof value === "number") {
        this.queryParams[name] = value.toString();
      } else if (value instanceof Date) {
        this.queryParams[name] = value.toISOString();
      } else if (Array.isArray(value)) {
        if (value.length > 0) {
          this.queryParams[name] = value.join(",");
        }
      } else {
        const _assert_unreachable = value;
        throw new Error(`query parameter ${name} has unsupported type`);
      }
    }
    setHeaderParam(name, value) {
      if (value === undefined) {
        return;
      }
      this.headerParams[name] = value;
    }
    setBody(value) {
      this.body = JSON.stringify(value);
    }
    send(ctx, parseResponseBody) {
      return __awaiter(this, undefined, undefined, function* () {
        const response = yield this.sendInner(ctx);
        if (response.status === 204) {
          return null;
        }
        const responseBody = yield response.text();
        return parseResponseBody(JSON.parse(responseBody));
      });
    }
    sendNoResponseBody(ctx) {
      return __awaiter(this, undefined, undefined, function* () {
        yield this.sendInner(ctx);
      });
    }
    sendInner(ctx) {
      var _a, _b;
      return __awaiter(this, undefined, undefined, function* () {
        const url = new URL(ctx.baseUrl + this.path);
        for (const [name, value] of Object.entries(this.queryParams)) {
          url.searchParams.set(name, value);
        }
        if (this.headerParams["idempotency-key"] === undefined && this.method.toUpperCase() === "POST") {
          this.headerParams["idempotency-key"] = `auto_${(0, uuid_1.v4)()}`;
        }
        const randomId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
        if (this.body != null) {
          this.headerParams["content-type"] = "application/json";
        }
        const isCredentialsSupported = "credentials" in Request.prototype;
        const response = yield sendWithRetry(url, {
          method: this.method.toString(),
          body: this.body,
          headers: Object.assign({ accept: "application/json, */*;q=0.8", authorization: `Bearer ${ctx.token}`, "user-agent": USER_AGENT2, "svix-req-id": randomId.toString() }, this.headerParams),
          credentials: isCredentialsSupported ? "same-origin" : undefined,
          signal: ctx.timeout !== undefined ? AbortSignal.timeout(ctx.timeout) : undefined
        }, ctx.retryScheduleInMs, (_a = ctx.retryScheduleInMs) === null || _a === undefined ? undefined : _a[0], ((_b = ctx.retryScheduleInMs) === null || _b === undefined ? undefined : _b.length) || ctx.numRetries, ctx.fetch);
        return filterResponseForErrors(response);
      });
    }
  }
  exports.SvixRequest = SvixRequest;
  function filterResponseForErrors(response) {
    return __awaiter(this, undefined, undefined, function* () {
      if (response.status < 300) {
        return response;
      }
      const responseBody = yield response.text();
      if (response.status === 422) {
        throw new util_1.ApiException(response.status, JSON.parse(responseBody), response.headers);
      }
      if (response.status >= 400 && response.status <= 499) {
        throw new util_1.ApiException(response.status, JSON.parse(responseBody), response.headers);
      }
      throw new util_1.ApiException(response.status, responseBody, response.headers);
    });
  }
  function sendWithRetry(url, init, retryScheduleInMs, nextInterval = 50, triesLeft = 2, fetchImpl = fetch, retryCount = 1) {
    return __awaiter(this, undefined, undefined, function* () {
      const sleep = (interval) => new Promise((resolve) => setTimeout(resolve, interval));
      try {
        const response = yield fetchImpl(url, init);
        if (triesLeft <= 0 || response.status < 500) {
          return response;
        }
      } catch (e) {
        if (triesLeft <= 0) {
          throw e;
        }
      }
      yield sleep(nextInterval);
      init.headers["svix-retry-count"] = retryCount.toString();
      nextInterval = (retryScheduleInMs === null || retryScheduleInMs === undefined ? undefined : retryScheduleInMs[retryCount]) || nextInterval * 2;
      return yield sendWithRetry(url, init, retryScheduleInMs, nextInterval, --triesLeft, fetchImpl, ++retryCount);
    });
  }
});

// node_modules/svix/dist/api/application.js
var require_application = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Application = undefined;
  var applicationIn_1 = require_applicationIn();
  var applicationOut_1 = require_applicationOut();
  var applicationPatch_1 = require_applicationPatch();
  var listResponseApplicationOut_1 = require_listResponseApplicationOut();
  var request_1 = require_request3();

  class Application {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app");
      request.setQueryParams({
        exclude_apps_with_no_endpoints: options === null || options === undefined ? undefined : options.excludeAppsWithNoEndpoints,
        exclude_apps_with_disabled_endpoints: options === null || options === undefined ? undefined : options.excludeAppsWithDisabledEndpoints,
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        order: options === null || options === undefined ? undefined : options.order
      });
      return request.send(this.requestCtx, listResponseApplicationOut_1.ListResponseApplicationOutSerializer._fromJsonObject);
    }
    create(applicationIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(applicationIn_1.ApplicationInSerializer._toJsonObject(applicationIn));
      return request.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
    getOrCreate(applicationIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app");
      request.setQueryParam("get_if_exists", true);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(applicationIn_1.ApplicationInSerializer._toJsonObject(applicationIn));
      return request.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
    get(appId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}");
      request.setPathParam("app_id", appId);
      return request.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
    update(appId, applicationIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/app/{app_id}");
      request.setPathParam("app_id", appId);
      request.setBody(applicationIn_1.ApplicationInSerializer._toJsonObject(applicationIn));
      return request.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
    delete(appId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}");
      request.setPathParam("app_id", appId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    patch(appId, applicationPatch) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}");
      request.setPathParam("app_id", appId);
      request.setBody(applicationPatch_1.ApplicationPatchSerializer._toJsonObject(applicationPatch));
      return request.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
  }
  exports.Application = Application;
});

// node_modules/svix/dist/models/apiTokenOut.js
var require_apiTokenOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApiTokenOutSerializer = undefined;
  exports.ApiTokenOutSerializer = {
    _fromJsonObject(object) {
      return {
        createdAt: new Date(object["createdAt"]),
        expiresAt: object["expiresAt"] ? new Date(object["expiresAt"]) : null,
        id: object["id"],
        name: object["name"],
        scopes: object["scopes"],
        token: object["token"]
      };
    },
    _toJsonObject(self2) {
      return {
        createdAt: self2.createdAt,
        expiresAt: self2.expiresAt,
        id: self2.id,
        name: self2.name,
        scopes: self2.scopes,
        token: self2.token
      };
    }
  };
});

// node_modules/svix/dist/models/appPortalCapability.js
var require_appPortalCapability = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AppPortalCapabilitySerializer = exports.AppPortalCapability = undefined;
  var AppPortalCapability;
  (function(AppPortalCapability2) {
    AppPortalCapability2["ViewBase"] = "ViewBase";
    AppPortalCapability2["ViewEndpointSecret"] = "ViewEndpointSecret";
    AppPortalCapability2["ManageEndpointSecret"] = "ManageEndpointSecret";
    AppPortalCapability2["ManageTransformations"] = "ManageTransformations";
    AppPortalCapability2["CreateAttempts"] = "CreateAttempts";
    AppPortalCapability2["ManageEndpoint"] = "ManageEndpoint";
  })(AppPortalCapability = exports.AppPortalCapability || (exports.AppPortalCapability = {}));
  exports.AppPortalCapabilitySerializer = {
    _fromJsonObject(object) {
      return object;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/appPortalAccessIn.js
var require_appPortalAccessIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AppPortalAccessInSerializer = undefined;
  var appPortalCapability_1 = require_appPortalCapability();
  var applicationIn_1 = require_applicationIn();
  exports.AppPortalAccessInSerializer = {
    _fromJsonObject(object) {
      var _a;
      return {
        application: object["application"] ? applicationIn_1.ApplicationInSerializer._fromJsonObject(object["application"]) : undefined,
        capabilities: (_a = object["capabilities"]) === null || _a === undefined ? undefined : _a.map((item) => appPortalCapability_1.AppPortalCapabilitySerializer._fromJsonObject(item)),
        expiry: object["expiry"],
        featureFlags: object["featureFlags"],
        readOnly: object["readOnly"],
        sessionId: object["sessionId"]
      };
    },
    _toJsonObject(self2) {
      var _a;
      return {
        application: self2.application ? applicationIn_1.ApplicationInSerializer._toJsonObject(self2.application) : undefined,
        capabilities: (_a = self2.capabilities) === null || _a === undefined ? undefined : _a.map((item) => appPortalCapability_1.AppPortalCapabilitySerializer._toJsonObject(item)),
        expiry: self2.expiry,
        featureFlags: self2.featureFlags,
        readOnly: self2.readOnly,
        sessionId: self2.sessionId
      };
    }
  };
});

// node_modules/svix/dist/models/appPortalAccessOut.js
var require_appPortalAccessOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AppPortalAccessOutSerializer = undefined;
  exports.AppPortalAccessOutSerializer = {
    _fromJsonObject(object) {
      return {
        token: object["token"],
        url: object["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        token: self2.token,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/applicationTokenExpireIn.js
var require_applicationTokenExpireIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationTokenExpireInSerializer = undefined;
  exports.ApplicationTokenExpireInSerializer = {
    _fromJsonObject(object) {
      return {
        expiry: object["expiry"],
        sessionIds: object["sessionIds"]
      };
    },
    _toJsonObject(self2) {
      return {
        expiry: self2.expiry,
        sessionIds: self2.sessionIds
      };
    }
  };
});

// node_modules/svix/dist/models/rotatePollerTokenIn.js
var require_rotatePollerTokenIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RotatePollerTokenInSerializer = undefined;
  exports.RotatePollerTokenInSerializer = {
    _fromJsonObject(object) {
      return {
        expiry: object["expiry"],
        oldTokenExpiry: object["oldTokenExpiry"]
      };
    },
    _toJsonObject(self2) {
      return {
        expiry: self2.expiry,
        oldTokenExpiry: self2.oldTokenExpiry
      };
    }
  };
});

// node_modules/svix/dist/models/streamPortalAccessIn.js
var require_streamPortalAccessIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamPortalAccessInSerializer = undefined;
  exports.StreamPortalAccessInSerializer = {
    _fromJsonObject(object) {
      return {
        expiry: object["expiry"],
        featureFlags: object["featureFlags"],
        sessionId: object["sessionId"]
      };
    },
    _toJsonObject(self2) {
      return {
        expiry: self2.expiry,
        featureFlags: self2.featureFlags,
        sessionId: self2.sessionId
      };
    }
  };
});

// node_modules/svix/dist/models/dashboardAccessOut.js
var require_dashboardAccessOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DashboardAccessOutSerializer = undefined;
  exports.DashboardAccessOutSerializer = {
    _fromJsonObject(object) {
      return {
        token: object["token"],
        url: object["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        token: self2.token,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/api/authentication.js
var require_authentication = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Authentication = undefined;
  var apiTokenOut_1 = require_apiTokenOut();
  var appPortalAccessIn_1 = require_appPortalAccessIn();
  var appPortalAccessOut_1 = require_appPortalAccessOut();
  var applicationTokenExpireIn_1 = require_applicationTokenExpireIn();
  var rotatePollerTokenIn_1 = require_rotatePollerTokenIn();
  var streamPortalAccessIn_1 = require_streamPortalAccessIn();
  var dashboardAccessOut_1 = require_dashboardAccessOut();
  var request_1 = require_request3();

  class Authentication {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    appPortalAccess(appId, appPortalAccessIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/auth/app-portal-access/{app_id}");
      request.setPathParam("app_id", appId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(appPortalAccessIn_1.AppPortalAccessInSerializer._toJsonObject(appPortalAccessIn));
      return request.send(this.requestCtx, appPortalAccessOut_1.AppPortalAccessOutSerializer._fromJsonObject);
    }
    expireAll(appId, applicationTokenExpireIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/auth/app/{app_id}/expire-all");
      request.setPathParam("app_id", appId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(applicationTokenExpireIn_1.ApplicationTokenExpireInSerializer._toJsonObject(applicationTokenExpireIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
    dashboardAccess(appId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/auth/dashboard-access/{app_id}");
      request.setPathParam("app_id", appId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      return request.send(this.requestCtx, dashboardAccessOut_1.DashboardAccessOutSerializer._fromJsonObject);
    }
    logout(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/auth/logout");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      return request.sendNoResponseBody(this.requestCtx);
    }
    streamPortalAccess(streamId, streamPortalAccessIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/auth/stream-portal-access/{stream_id}");
      request.setPathParam("stream_id", streamId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(streamPortalAccessIn_1.StreamPortalAccessInSerializer._toJsonObject(streamPortalAccessIn));
      return request.send(this.requestCtx, appPortalAccessOut_1.AppPortalAccessOutSerializer._fromJsonObject);
    }
    getStreamPollerToken(streamId, sinkId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/auth/stream/{stream_id}/sink/{sink_id}/poller/token");
      request.setPathParam("stream_id", streamId);
      request.setPathParam("sink_id", sinkId);
      return request.send(this.requestCtx, apiTokenOut_1.ApiTokenOutSerializer._fromJsonObject);
    }
    rotateStreamPollerToken(streamId, sinkId, rotatePollerTokenIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/auth/stream/{stream_id}/sink/{sink_id}/poller/token/rotate");
      request.setPathParam("stream_id", streamId);
      request.setPathParam("sink_id", sinkId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(rotatePollerTokenIn_1.RotatePollerTokenInSerializer._toJsonObject(rotatePollerTokenIn));
      return request.send(this.requestCtx, apiTokenOut_1.ApiTokenOutSerializer._fromJsonObject);
    }
  }
  exports.Authentication = Authentication;
});

// node_modules/svix/dist/models/backgroundTaskStatus.js
var require_backgroundTaskStatus = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BackgroundTaskStatusSerializer = exports.BackgroundTaskStatus = undefined;
  var BackgroundTaskStatus;
  (function(BackgroundTaskStatus2) {
    BackgroundTaskStatus2["Running"] = "running";
    BackgroundTaskStatus2["Finished"] = "finished";
    BackgroundTaskStatus2["Failed"] = "failed";
  })(BackgroundTaskStatus = exports.BackgroundTaskStatus || (exports.BackgroundTaskStatus = {}));
  exports.BackgroundTaskStatusSerializer = {
    _fromJsonObject(object) {
      return object;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/backgroundTaskType.js
var require_backgroundTaskType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BackgroundTaskTypeSerializer = exports.BackgroundTaskType = undefined;
  var BackgroundTaskType;
  (function(BackgroundTaskType2) {
    BackgroundTaskType2["EndpointReplay"] = "endpoint.replay";
    BackgroundTaskType2["EndpointRecover"] = "endpoint.recover";
    BackgroundTaskType2["ApplicationStats"] = "application.stats";
    BackgroundTaskType2["MessageBroadcast"] = "message.broadcast";
    BackgroundTaskType2["SdkGenerate"] = "sdk.generate";
    BackgroundTaskType2["EventTypeAggregate"] = "event-type.aggregate";
    BackgroundTaskType2["ApplicationPurgeContent"] = "application.purge_content";
    BackgroundTaskType2["EndpointBulkReplay"] = "endpoint.bulk_replay";
  })(BackgroundTaskType = exports.BackgroundTaskType || (exports.BackgroundTaskType = {}));
  exports.BackgroundTaskTypeSerializer = {
    _fromJsonObject(object) {
      return object;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/backgroundTaskOut.js
var require_backgroundTaskOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BackgroundTaskOutSerializer = undefined;
  var backgroundTaskStatus_1 = require_backgroundTaskStatus();
  var backgroundTaskType_1 = require_backgroundTaskType();
  exports.BackgroundTaskOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"],
        id: object["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object["task"])
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data,
        id: self2.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self2.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self2.task)
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseBackgroundTaskOut.js
var require_listResponseBackgroundTaskOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseBackgroundTaskOutSerializer = undefined;
  var backgroundTaskOut_1 = require_backgroundTaskOut();
  exports.ListResponseBackgroundTaskOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => backgroundTaskOut_1.BackgroundTaskOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => backgroundTaskOut_1.BackgroundTaskOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/api/backgroundTask.js
var require_backgroundTask = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BackgroundTask = undefined;
  var backgroundTaskOut_1 = require_backgroundTaskOut();
  var listResponseBackgroundTaskOut_1 = require_listResponseBackgroundTaskOut();
  var request_1 = require_request3();

  class BackgroundTask {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/background-task");
      request.setQueryParams({
        status: options === null || options === undefined ? undefined : options.status,
        task: options === null || options === undefined ? undefined : options.task,
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        order: options === null || options === undefined ? undefined : options.order
      });
      return request.send(this.requestCtx, listResponseBackgroundTaskOut_1.ListResponseBackgroundTaskOutSerializer._fromJsonObject);
    }
    listByEndpoint(options) {
      return this.list(options);
    }
    get(taskId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/background-task/{task_id}");
      request.setPathParam("task_id", taskId);
      return request.send(this.requestCtx, backgroundTaskOut_1.BackgroundTaskOutSerializer._fromJsonObject);
    }
  }
  exports.BackgroundTask = BackgroundTask;
});

// node_modules/svix/dist/models/connectorKind.js
var require_connectorKind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectorKindSerializer = exports.ConnectorKind = undefined;
  var ConnectorKind;
  (function(ConnectorKind2) {
    ConnectorKind2["Custom"] = "Custom";
    ConnectorKind2["AgenticCommerceProtocol"] = "AgenticCommerceProtocol";
    ConnectorKind2["CloseCrm"] = "CloseCRM";
    ConnectorKind2["CustomerIo"] = "CustomerIO";
    ConnectorKind2["Discord"] = "Discord";
    ConnectorKind2["Hubspot"] = "Hubspot";
    ConnectorKind2["Inngest"] = "Inngest";
    ConnectorKind2["Loops"] = "Loops";
    ConnectorKind2["Otel"] = "Otel";
    ConnectorKind2["Resend"] = "Resend";
    ConnectorKind2["Salesforce"] = "Salesforce";
    ConnectorKind2["Segment"] = "Segment";
    ConnectorKind2["Sendgrid"] = "Sendgrid";
    ConnectorKind2["Slack"] = "Slack";
    ConnectorKind2["Teams"] = "Teams";
    ConnectorKind2["TriggerDev"] = "TriggerDev";
    ConnectorKind2["Windmill"] = "Windmill";
    ConnectorKind2["Zapier"] = "Zapier";
  })(ConnectorKind = exports.ConnectorKind || (exports.ConnectorKind = {}));
  exports.ConnectorKindSerializer = {
    _fromJsonObject(object) {
      return object;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/connectorProduct.js
var require_connectorProduct = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectorProductSerializer = exports.ConnectorProduct = undefined;
  var ConnectorProduct;
  (function(ConnectorProduct2) {
    ConnectorProduct2["Dispatch"] = "Dispatch";
    ConnectorProduct2["Stream"] = "Stream";
  })(ConnectorProduct = exports.ConnectorProduct || (exports.ConnectorProduct = {}));
  exports.ConnectorProductSerializer = {
    _fromJsonObject(object) {
      return object;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/connectorIn.js
var require_connectorIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectorInSerializer = undefined;
  var connectorKind_1 = require_connectorKind();
  var connectorProduct_1 = require_connectorProduct();
  exports.ConnectorInSerializer = {
    _fromJsonObject(object) {
      return {
        allowedEventTypes: object["allowedEventTypes"],
        description: object["description"],
        featureFlags: object["featureFlags"],
        instructions: object["instructions"],
        kind: object["kind"] ? connectorKind_1.ConnectorKindSerializer._fromJsonObject(object["kind"]) : undefined,
        logo: object["logo"],
        name: object["name"],
        productType: object["productType"] ? connectorProduct_1.ConnectorProductSerializer._fromJsonObject(object["productType"]) : undefined,
        transformation: object["transformation"],
        uid: object["uid"]
      };
    },
    _toJsonObject(self2) {
      return {
        allowedEventTypes: self2.allowedEventTypes,
        description: self2.description,
        featureFlags: self2.featureFlags,
        instructions: self2.instructions,
        kind: self2.kind ? connectorKind_1.ConnectorKindSerializer._toJsonObject(self2.kind) : undefined,
        logo: self2.logo,
        name: self2.name,
        productType: self2.productType ? connectorProduct_1.ConnectorProductSerializer._toJsonObject(self2.productType) : undefined,
        transformation: self2.transformation,
        uid: self2.uid
      };
    }
  };
});

// node_modules/svix/dist/models/connectorOut.js
var require_connectorOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectorOutSerializer = undefined;
  var connectorKind_1 = require_connectorKind();
  var connectorProduct_1 = require_connectorProduct();
  exports.ConnectorOutSerializer = {
    _fromJsonObject(object) {
      return {
        allowedEventTypes: object["allowedEventTypes"],
        createdAt: new Date(object["createdAt"]),
        description: object["description"],
        featureFlags: object["featureFlags"],
        id: object["id"],
        instructions: object["instructions"],
        kind: connectorKind_1.ConnectorKindSerializer._fromJsonObject(object["kind"]),
        logo: object["logo"],
        name: object["name"],
        orgId: object["orgId"],
        productType: connectorProduct_1.ConnectorProductSerializer._fromJsonObject(object["productType"]),
        transformation: object["transformation"],
        transformationUpdatedAt: new Date(object["transformationUpdatedAt"]),
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"])
      };
    },
    _toJsonObject(self2) {
      return {
        allowedEventTypes: self2.allowedEventTypes,
        createdAt: self2.createdAt,
        description: self2.description,
        featureFlags: self2.featureFlags,
        id: self2.id,
        instructions: self2.instructions,
        kind: connectorKind_1.ConnectorKindSerializer._toJsonObject(self2.kind),
        logo: self2.logo,
        name: self2.name,
        orgId: self2.orgId,
        productType: connectorProduct_1.ConnectorProductSerializer._toJsonObject(self2.productType),
        transformation: self2.transformation,
        transformationUpdatedAt: self2.transformationUpdatedAt,
        uid: self2.uid,
        updatedAt: self2.updatedAt
      };
    }
  };
});

// node_modules/svix/dist/models/connectorPatch.js
var require_connectorPatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectorPatchSerializer = undefined;
  var connectorKind_1 = require_connectorKind();
  exports.ConnectorPatchSerializer = {
    _fromJsonObject(object) {
      return {
        allowedEventTypes: object["allowedEventTypes"],
        description: object["description"],
        featureFlags: object["featureFlags"],
        instructions: object["instructions"],
        kind: object["kind"] ? connectorKind_1.ConnectorKindSerializer._fromJsonObject(object["kind"]) : undefined,
        logo: object["logo"],
        name: object["name"],
        transformation: object["transformation"]
      };
    },
    _toJsonObject(self2) {
      return {
        allowedEventTypes: self2.allowedEventTypes,
        description: self2.description,
        featureFlags: self2.featureFlags,
        instructions: self2.instructions,
        kind: self2.kind ? connectorKind_1.ConnectorKindSerializer._toJsonObject(self2.kind) : undefined,
        logo: self2.logo,
        name: self2.name,
        transformation: self2.transformation
      };
    }
  };
});

// node_modules/svix/dist/models/connectorUpdate.js
var require_connectorUpdate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectorUpdateSerializer = undefined;
  var connectorKind_1 = require_connectorKind();
  exports.ConnectorUpdateSerializer = {
    _fromJsonObject(object) {
      return {
        allowedEventTypes: object["allowedEventTypes"],
        description: object["description"],
        featureFlags: object["featureFlags"],
        instructions: object["instructions"],
        kind: object["kind"] ? connectorKind_1.ConnectorKindSerializer._fromJsonObject(object["kind"]) : undefined,
        logo: object["logo"],
        name: object["name"],
        transformation: object["transformation"]
      };
    },
    _toJsonObject(self2) {
      return {
        allowedEventTypes: self2.allowedEventTypes,
        description: self2.description,
        featureFlags: self2.featureFlags,
        instructions: self2.instructions,
        kind: self2.kind ? connectorKind_1.ConnectorKindSerializer._toJsonObject(self2.kind) : undefined,
        logo: self2.logo,
        name: self2.name,
        transformation: self2.transformation
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseConnectorOut.js
var require_listResponseConnectorOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseConnectorOutSerializer = undefined;
  var connectorOut_1 = require_connectorOut();
  exports.ListResponseConnectorOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => connectorOut_1.ConnectorOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => connectorOut_1.ConnectorOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/api/connector.js
var require_connector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Connector = undefined;
  var connectorIn_1 = require_connectorIn();
  var connectorOut_1 = require_connectorOut();
  var connectorPatch_1 = require_connectorPatch();
  var connectorUpdate_1 = require_connectorUpdate();
  var listResponseConnectorOut_1 = require_listResponseConnectorOut();
  var request_1 = require_request3();

  class Connector {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/connector");
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        order: options === null || options === undefined ? undefined : options.order,
        product_type: options === null || options === undefined ? undefined : options.productType
      });
      return request.send(this.requestCtx, listResponseConnectorOut_1.ListResponseConnectorOutSerializer._fromJsonObject);
    }
    create(connectorIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/connector");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(connectorIn_1.ConnectorInSerializer._toJsonObject(connectorIn));
      return request.send(this.requestCtx, connectorOut_1.ConnectorOutSerializer._fromJsonObject);
    }
    get(connectorId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/connector/{connector_id}");
      request.setPathParam("connector_id", connectorId);
      return request.send(this.requestCtx, connectorOut_1.ConnectorOutSerializer._fromJsonObject);
    }
    update(connectorId, connectorUpdate) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/connector/{connector_id}");
      request.setPathParam("connector_id", connectorId);
      request.setBody(connectorUpdate_1.ConnectorUpdateSerializer._toJsonObject(connectorUpdate));
      return request.send(this.requestCtx, connectorOut_1.ConnectorOutSerializer._fromJsonObject);
    }
    delete(connectorId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/connector/{connector_id}");
      request.setPathParam("connector_id", connectorId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    patch(connectorId, connectorPatch) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/connector/{connector_id}");
      request.setPathParam("connector_id", connectorId);
      request.setBody(connectorPatch_1.ConnectorPatchSerializer._toJsonObject(connectorPatch));
      return request.send(this.requestCtx, connectorOut_1.ConnectorOutSerializer._fromJsonObject);
    }
  }
  exports.Connector = Connector;
});

// node_modules/svix/dist/models/endpointHeadersIn.js
var require_endpointHeadersIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointHeadersInSerializer = undefined;
  exports.EndpointHeadersInSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers
      };
    }
  };
});

// node_modules/svix/dist/models/endpointHeadersOut.js
var require_endpointHeadersOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointHeadersOutSerializer = undefined;
  exports.EndpointHeadersOutSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"],
        sensitive: object["sensitive"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers,
        sensitive: self2.sensitive
      };
    }
  };
});

// node_modules/svix/dist/models/endpointHeadersPatchIn.js
var require_endpointHeadersPatchIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointHeadersPatchInSerializer = undefined;
  exports.EndpointHeadersPatchInSerializer = {
    _fromJsonObject(object) {
      return {
        deleteHeaders: object["deleteHeaders"],
        headers: object["headers"]
      };
    },
    _toJsonObject(self2) {
      return {
        deleteHeaders: self2.deleteHeaders,
        headers: self2.headers
      };
    }
  };
});

// node_modules/svix/dist/models/endpointIn.js
var require_endpointIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointInSerializer = undefined;
  exports.EndpointInSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        headers: object["headers"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        secret: object["secret"],
        uid: object["uid"],
        url: object["url"],
        version: object["version"]
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        headers: self2.headers,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        secret: self2.secret,
        uid: self2.uid,
        url: self2.url,
        version: self2.version
      };
    }
  };
});

// node_modules/svix/dist/models/endpointOut.js
var require_endpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointOutSerializer = undefined;
  exports.EndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        createdAt: new Date(object["createdAt"]),
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        id: object["id"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"]),
        url: object["url"],
        version: object["version"]
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        createdAt: self2.createdAt,
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        id: self2.id,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        uid: self2.uid,
        updatedAt: self2.updatedAt,
        url: self2.url,
        version: self2.version
      };
    }
  };
});

// node_modules/svix/dist/models/endpointPatch.js
var require_endpointPatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointPatchSerializer = undefined;
  exports.EndpointPatchSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        secret: object["secret"],
        uid: object["uid"],
        url: object["url"],
        version: object["version"]
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        secret: self2.secret,
        uid: self2.uid,
        url: self2.url,
        version: self2.version
      };
    }
  };
});

// node_modules/svix/dist/models/endpointSecretOut.js
var require_endpointSecretOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointSecretOutSerializer = undefined;
  exports.EndpointSecretOutSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/endpointSecretRotateIn.js
var require_endpointSecretRotateIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointSecretRotateInSerializer = undefined;
  exports.EndpointSecretRotateInSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/endpointStats.js
var require_endpointStats = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointStatsSerializer = undefined;
  exports.EndpointStatsSerializer = {
    _fromJsonObject(object) {
      return {
        fail: object["fail"],
        pending: object["pending"],
        sending: object["sending"],
        success: object["success"]
      };
    },
    _toJsonObject(self2) {
      return {
        fail: self2.fail,
        pending: self2.pending,
        sending: self2.sending,
        success: self2.success
      };
    }
  };
});

// node_modules/svix/dist/models/endpointTransformationIn.js
var require_endpointTransformationIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointTransformationInSerializer = undefined;
  exports.EndpointTransformationInSerializer = {
    _fromJsonObject(object) {
      return {
        code: object["code"],
        enabled: object["enabled"]
      };
    },
    _toJsonObject(self2) {
      return {
        code: self2.code,
        enabled: self2.enabled
      };
    }
  };
});

// node_modules/svix/dist/models/endpointTransformationOut.js
var require_endpointTransformationOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointTransformationOutSerializer = undefined;
  exports.EndpointTransformationOutSerializer = {
    _fromJsonObject(object) {
      return {
        code: object["code"],
        enabled: object["enabled"],
        updatedAt: object["updatedAt"] ? new Date(object["updatedAt"]) : null
      };
    },
    _toJsonObject(self2) {
      return {
        code: self2.code,
        enabled: self2.enabled,
        updatedAt: self2.updatedAt
      };
    }
  };
});

// node_modules/svix/dist/models/endpointTransformationPatch.js
var require_endpointTransformationPatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointTransformationPatchSerializer = undefined;
  exports.EndpointTransformationPatchSerializer = {
    _fromJsonObject(object) {
      return {
        code: object["code"],
        enabled: object["enabled"]
      };
    },
    _toJsonObject(self2) {
      return {
        code: self2.code,
        enabled: self2.enabled
      };
    }
  };
});

// node_modules/svix/dist/models/endpointUpdate.js
var require_endpointUpdate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointUpdateSerializer = undefined;
  exports.EndpointUpdateSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        uid: object["uid"],
        url: object["url"],
        version: object["version"]
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        uid: self2.uid,
        url: self2.url,
        version: self2.version
      };
    }
  };
});

// node_modules/svix/dist/models/eventExampleIn.js
var require_eventExampleIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventExampleInSerializer = undefined;
  exports.EventExampleInSerializer = {
    _fromJsonObject(object) {
      return {
        eventType: object["eventType"],
        exampleIndex: object["exampleIndex"]
      };
    },
    _toJsonObject(self2) {
      return {
        eventType: self2.eventType,
        exampleIndex: self2.exampleIndex
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseEndpointOut.js
var require_listResponseEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseEndpointOutSerializer = undefined;
  var endpointOut_1 = require_endpointOut();
  exports.ListResponseEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => endpointOut_1.EndpointOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => endpointOut_1.EndpointOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/messageOut.js
var require_messageOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageOutSerializer = undefined;
  exports.MessageOutSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        deliverAt: object["deliverAt"] ? new Date(object["deliverAt"]) : null,
        eventId: object["eventId"],
        eventType: object["eventType"],
        id: object["id"],
        payload: object["payload"],
        tags: object["tags"],
        timestamp: new Date(object["timestamp"])
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        deliverAt: self2.deliverAt,
        eventId: self2.eventId,
        eventType: self2.eventType,
        id: self2.id,
        payload: self2.payload,
        tags: self2.tags,
        timestamp: self2.timestamp
      };
    }
  };
});

// node_modules/svix/dist/models/recoverIn.js
var require_recoverIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RecoverInSerializer = undefined;
  exports.RecoverInSerializer = {
    _fromJsonObject(object) {
      return {
        since: new Date(object["since"]),
        until: object["until"] ? new Date(object["until"]) : null
      };
    },
    _toJsonObject(self2) {
      return {
        since: self2.since,
        until: self2.until
      };
    }
  };
});

// node_modules/svix/dist/models/recoverOut.js
var require_recoverOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RecoverOutSerializer = undefined;
  var backgroundTaskStatus_1 = require_backgroundTaskStatus();
  var backgroundTaskType_1 = require_backgroundTaskType();
  exports.RecoverOutSerializer = {
    _fromJsonObject(object) {
      return {
        id: object["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object["task"])
      };
    },
    _toJsonObject(self2) {
      return {
        id: self2.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self2.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self2.task)
      };
    }
  };
});

// node_modules/svix/dist/models/replayIn.js
var require_replayIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReplayInSerializer = undefined;
  exports.ReplayInSerializer = {
    _fromJsonObject(object) {
      return {
        since: new Date(object["since"]),
        until: object["until"] ? new Date(object["until"]) : null
      };
    },
    _toJsonObject(self2) {
      return {
        since: self2.since,
        until: self2.until
      };
    }
  };
});

// node_modules/svix/dist/models/replayOut.js
var require_replayOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReplayOutSerializer = undefined;
  var backgroundTaskStatus_1 = require_backgroundTaskStatus();
  var backgroundTaskType_1 = require_backgroundTaskType();
  exports.ReplayOutSerializer = {
    _fromJsonObject(object) {
      return {
        id: object["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object["task"])
      };
    },
    _toJsonObject(self2) {
      return {
        id: self2.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self2.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self2.task)
      };
    }
  };
});

// node_modules/svix/dist/api/endpoint.js
var require_endpoint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Endpoint = undefined;
  var endpointHeadersIn_1 = require_endpointHeadersIn();
  var endpointHeadersOut_1 = require_endpointHeadersOut();
  var endpointHeadersPatchIn_1 = require_endpointHeadersPatchIn();
  var endpointIn_1 = require_endpointIn();
  var endpointOut_1 = require_endpointOut();
  var endpointPatch_1 = require_endpointPatch();
  var endpointSecretOut_1 = require_endpointSecretOut();
  var endpointSecretRotateIn_1 = require_endpointSecretRotateIn();
  var endpointStats_1 = require_endpointStats();
  var endpointTransformationIn_1 = require_endpointTransformationIn();
  var endpointTransformationOut_1 = require_endpointTransformationOut();
  var endpointTransformationPatch_1 = require_endpointTransformationPatch();
  var endpointUpdate_1 = require_endpointUpdate();
  var eventExampleIn_1 = require_eventExampleIn();
  var listResponseEndpointOut_1 = require_listResponseEndpointOut();
  var messageOut_1 = require_messageOut();
  var recoverIn_1 = require_recoverIn();
  var recoverOut_1 = require_recoverOut();
  var replayIn_1 = require_replayIn();
  var replayOut_1 = require_replayOut();
  var request_1 = require_request3();

  class Endpoint {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(appId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint");
      request.setPathParam("app_id", appId);
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        order: options === null || options === undefined ? undefined : options.order
      });
      return request.send(this.requestCtx, listResponseEndpointOut_1.ListResponseEndpointOutSerializer._fromJsonObject);
    }
    create(appId, endpointIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint");
      request.setPathParam("app_id", appId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(endpointIn_1.EndpointInSerializer._toJsonObject(endpointIn));
      return request.send(this.requestCtx, endpointOut_1.EndpointOutSerializer._fromJsonObject);
    }
    get(appId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, endpointOut_1.EndpointOutSerializer._fromJsonObject);
    }
    update(appId, endpointId, endpointUpdate) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/app/{app_id}/endpoint/{endpoint_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(endpointUpdate_1.EndpointUpdateSerializer._toJsonObject(endpointUpdate));
      return request.send(this.requestCtx, endpointOut_1.EndpointOutSerializer._fromJsonObject);
    }
    delete(appId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}/endpoint/{endpoint_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    patch(appId, endpointId, endpointPatch) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}/endpoint/{endpoint_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(endpointPatch_1.EndpointPatchSerializer._toJsonObject(endpointPatch));
      return request.send(this.requestCtx, endpointOut_1.EndpointOutSerializer._fromJsonObject);
    }
    getHeaders(appId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/headers");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, endpointHeadersOut_1.EndpointHeadersOutSerializer._fromJsonObject);
    }
    updateHeaders(appId, endpointId, endpointHeadersIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/headers");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(endpointHeadersIn_1.EndpointHeadersInSerializer._toJsonObject(endpointHeadersIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
    headersUpdate(appId, endpointId, endpointHeadersIn) {
      return this.updateHeaders(appId, endpointId, endpointHeadersIn);
    }
    patchHeaders(appId, endpointId, endpointHeadersPatchIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/headers");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(endpointHeadersPatchIn_1.EndpointHeadersPatchInSerializer._toJsonObject(endpointHeadersPatchIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
    headersPatch(appId, endpointId, endpointHeadersPatchIn) {
      return this.patchHeaders(appId, endpointId, endpointHeadersPatchIn);
    }
    recover(appId, endpointId, recoverIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/recover");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(recoverIn_1.RecoverInSerializer._toJsonObject(recoverIn));
      return request.send(this.requestCtx, recoverOut_1.RecoverOutSerializer._fromJsonObject);
    }
    replayMissing(appId, endpointId, replayIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/replay-missing");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(replayIn_1.ReplayInSerializer._toJsonObject(replayIn));
      return request.send(this.requestCtx, replayOut_1.ReplayOutSerializer._fromJsonObject);
    }
    getSecret(appId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/secret");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, endpointSecretOut_1.EndpointSecretOutSerializer._fromJsonObject);
    }
    rotateSecret(appId, endpointId, endpointSecretRotateIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/secret/rotate");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(endpointSecretRotateIn_1.EndpointSecretRotateInSerializer._toJsonObject(endpointSecretRotateIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
    sendExample(appId, endpointId, eventExampleIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/send-example");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(eventExampleIn_1.EventExampleInSerializer._toJsonObject(eventExampleIn));
      return request.send(this.requestCtx, messageOut_1.MessageOutSerializer._fromJsonObject);
    }
    getStats(appId, endpointId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/stats");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setQueryParams({
        since: options === null || options === undefined ? undefined : options.since,
        until: options === null || options === undefined ? undefined : options.until
      });
      return request.send(this.requestCtx, endpointStats_1.EndpointStatsSerializer._fromJsonObject);
    }
    transformationGet(appId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/transformation");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, endpointTransformationOut_1.EndpointTransformationOutSerializer._fromJsonObject);
    }
    patchTransformation(appId, endpointId, endpointTransformationPatch) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/transformation");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(endpointTransformationPatch_1.EndpointTransformationPatchSerializer._toJsonObject(endpointTransformationPatch));
      return request.sendNoResponseBody(this.requestCtx);
    }
    transformationPartialUpdate(appId, endpointId, endpointTransformationIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/transformation");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(endpointTransformationIn_1.EndpointTransformationInSerializer._toJsonObject(endpointTransformationIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
  }
  exports.Endpoint = Endpoint;
});

// node_modules/svix/dist/models/eventTypeIn.js
var require_eventTypeIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypeInSerializer = undefined;
  exports.EventTypeInSerializer = {
    _fromJsonObject(object) {
      return {
        archived: object["archived"],
        deprecated: object["deprecated"],
        description: object["description"],
        featureFlag: object["featureFlag"],
        featureFlags: object["featureFlags"],
        groupName: object["groupName"],
        name: object["name"],
        schemas: object["schemas"]
      };
    },
    _toJsonObject(self2) {
      return {
        archived: self2.archived,
        deprecated: self2.deprecated,
        description: self2.description,
        featureFlag: self2.featureFlag,
        featureFlags: self2.featureFlags,
        groupName: self2.groupName,
        name: self2.name,
        schemas: self2.schemas
      };
    }
  };
});

// node_modules/svix/dist/models/environmentIn.js
var require_environmentIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EnvironmentInSerializer = undefined;
  var connectorIn_1 = require_connectorIn();
  var eventTypeIn_1 = require_eventTypeIn();
  exports.EnvironmentInSerializer = {
    _fromJsonObject(object) {
      var _a, _b;
      return {
        connectors: (_a = object["connectors"]) === null || _a === undefined ? undefined : _a.map((item) => connectorIn_1.ConnectorInSerializer._fromJsonObject(item)),
        eventTypes: (_b = object["eventTypes"]) === null || _b === undefined ? undefined : _b.map((item) => eventTypeIn_1.EventTypeInSerializer._fromJsonObject(item)),
        settings: object["settings"]
      };
    },
    _toJsonObject(self2) {
      var _a, _b;
      return {
        connectors: (_a = self2.connectors) === null || _a === undefined ? undefined : _a.map((item) => connectorIn_1.ConnectorInSerializer._toJsonObject(item)),
        eventTypes: (_b = self2.eventTypes) === null || _b === undefined ? undefined : _b.map((item) => eventTypeIn_1.EventTypeInSerializer._toJsonObject(item)),
        settings: self2.settings
      };
    }
  };
});

// node_modules/svix/dist/models/eventTypeOut.js
var require_eventTypeOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypeOutSerializer = undefined;
  exports.EventTypeOutSerializer = {
    _fromJsonObject(object) {
      return {
        archived: object["archived"],
        createdAt: new Date(object["createdAt"]),
        deprecated: object["deprecated"],
        description: object["description"],
        featureFlag: object["featureFlag"],
        featureFlags: object["featureFlags"],
        groupName: object["groupName"],
        name: object["name"],
        schemas: object["schemas"],
        updatedAt: new Date(object["updatedAt"])
      };
    },
    _toJsonObject(self2) {
      return {
        archived: self2.archived,
        createdAt: self2.createdAt,
        deprecated: self2.deprecated,
        description: self2.description,
        featureFlag: self2.featureFlag,
        featureFlags: self2.featureFlags,
        groupName: self2.groupName,
        name: self2.name,
        schemas: self2.schemas,
        updatedAt: self2.updatedAt
      };
    }
  };
});

// node_modules/svix/dist/models/environmentOut.js
var require_environmentOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EnvironmentOutSerializer = undefined;
  var connectorOut_1 = require_connectorOut();
  var eventTypeOut_1 = require_eventTypeOut();
  exports.EnvironmentOutSerializer = {
    _fromJsonObject(object) {
      return {
        connectors: object["connectors"].map((item) => connectorOut_1.ConnectorOutSerializer._fromJsonObject(item)),
        createdAt: new Date(object["createdAt"]),
        eventTypes: object["eventTypes"].map((item) => eventTypeOut_1.EventTypeOutSerializer._fromJsonObject(item)),
        settings: object["settings"],
        version: object["version"]
      };
    },
    _toJsonObject(self2) {
      return {
        connectors: self2.connectors.map((item) => connectorOut_1.ConnectorOutSerializer._toJsonObject(item)),
        createdAt: self2.createdAt,
        eventTypes: self2.eventTypes.map((item) => eventTypeOut_1.EventTypeOutSerializer._toJsonObject(item)),
        settings: self2.settings,
        version: self2.version
      };
    }
  };
});

// node_modules/svix/dist/api/environment.js
var require_environment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Environment = undefined;
  var environmentIn_1 = require_environmentIn();
  var environmentOut_1 = require_environmentOut();
  var request_1 = require_request3();

  class Environment {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    export(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/environment/export");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      return request.send(this.requestCtx, environmentOut_1.EnvironmentOutSerializer._fromJsonObject);
    }
    import(environmentIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/environment/import");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(environmentIn_1.EnvironmentInSerializer._toJsonObject(environmentIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
  }
  exports.Environment = Environment;
});

// node_modules/svix/dist/models/eventTypeImportOpenApiIn.js
var require_eventTypeImportOpenApiIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypeImportOpenApiInSerializer = undefined;
  exports.EventTypeImportOpenApiInSerializer = {
    _fromJsonObject(object) {
      return {
        dryRun: object["dryRun"],
        replaceAll: object["replaceAll"],
        spec: object["spec"],
        specRaw: object["specRaw"]
      };
    },
    _toJsonObject(self2) {
      return {
        dryRun: self2.dryRun,
        replaceAll: self2.replaceAll,
        spec: self2.spec,
        specRaw: self2.specRaw
      };
    }
  };
});

// node_modules/svix/dist/models/eventTypeFromOpenApi.js
var require_eventTypeFromOpenApi = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypeFromOpenApiSerializer = undefined;
  exports.EventTypeFromOpenApiSerializer = {
    _fromJsonObject(object) {
      return {
        deprecated: object["deprecated"],
        description: object["description"],
        featureFlag: object["featureFlag"],
        featureFlags: object["featureFlags"],
        groupName: object["groupName"],
        name: object["name"],
        schemas: object["schemas"]
      };
    },
    _toJsonObject(self2) {
      return {
        deprecated: self2.deprecated,
        description: self2.description,
        featureFlag: self2.featureFlag,
        featureFlags: self2.featureFlags,
        groupName: self2.groupName,
        name: self2.name,
        schemas: self2.schemas
      };
    }
  };
});

// node_modules/svix/dist/models/eventTypeImportOpenApiOutData.js
var require_eventTypeImportOpenApiOutData = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypeImportOpenApiOutDataSerializer = undefined;
  var eventTypeFromOpenApi_1 = require_eventTypeFromOpenApi();
  exports.EventTypeImportOpenApiOutDataSerializer = {
    _fromJsonObject(object) {
      var _a;
      return {
        modified: object["modified"],
        toModify: (_a = object["to_modify"]) === null || _a === undefined ? undefined : _a.map((item) => eventTypeFromOpenApi_1.EventTypeFromOpenApiSerializer._fromJsonObject(item))
      };
    },
    _toJsonObject(self2) {
      var _a;
      return {
        modified: self2.modified,
        to_modify: (_a = self2.toModify) === null || _a === undefined ? undefined : _a.map((item) => eventTypeFromOpenApi_1.EventTypeFromOpenApiSerializer._toJsonObject(item))
      };
    }
  };
});

// node_modules/svix/dist/models/eventTypeImportOpenApiOut.js
var require_eventTypeImportOpenApiOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypeImportOpenApiOutSerializer = undefined;
  var eventTypeImportOpenApiOutData_1 = require_eventTypeImportOpenApiOutData();
  exports.EventTypeImportOpenApiOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: eventTypeImportOpenApiOutData_1.EventTypeImportOpenApiOutDataSerializer._fromJsonObject(object["data"])
      };
    },
    _toJsonObject(self2) {
      return {
        data: eventTypeImportOpenApiOutData_1.EventTypeImportOpenApiOutDataSerializer._toJsonObject(self2.data)
      };
    }
  };
});

// node_modules/svix/dist/models/eventTypePatch.js
var require_eventTypePatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypePatchSerializer = undefined;
  exports.EventTypePatchSerializer = {
    _fromJsonObject(object) {
      return {
        archived: object["archived"],
        deprecated: object["deprecated"],
        description: object["description"],
        featureFlag: object["featureFlag"],
        featureFlags: object["featureFlags"],
        groupName: object["groupName"],
        schemas: object["schemas"]
      };
    },
    _toJsonObject(self2) {
      return {
        archived: self2.archived,
        deprecated: self2.deprecated,
        description: self2.description,
        featureFlag: self2.featureFlag,
        featureFlags: self2.featureFlags,
        groupName: self2.groupName,
        schemas: self2.schemas
      };
    }
  };
});

// node_modules/svix/dist/models/eventTypeUpdate.js
var require_eventTypeUpdate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypeUpdateSerializer = undefined;
  exports.EventTypeUpdateSerializer = {
    _fromJsonObject(object) {
      return {
        archived: object["archived"],
        deprecated: object["deprecated"],
        description: object["description"],
        featureFlag: object["featureFlag"],
        featureFlags: object["featureFlags"],
        groupName: object["groupName"],
        schemas: object["schemas"]
      };
    },
    _toJsonObject(self2) {
      return {
        archived: self2.archived,
        deprecated: self2.deprecated,
        description: self2.description,
        featureFlag: self2.featureFlag,
        featureFlags: self2.featureFlags,
        groupName: self2.groupName,
        schemas: self2.schemas
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseEventTypeOut.js
var require_listResponseEventTypeOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseEventTypeOutSerializer = undefined;
  var eventTypeOut_1 = require_eventTypeOut();
  exports.ListResponseEventTypeOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => eventTypeOut_1.EventTypeOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => eventTypeOut_1.EventTypeOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/api/eventType.js
var require_eventType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventType = undefined;
  var eventTypeImportOpenApiIn_1 = require_eventTypeImportOpenApiIn();
  var eventTypeImportOpenApiOut_1 = require_eventTypeImportOpenApiOut();
  var eventTypeIn_1 = require_eventTypeIn();
  var eventTypeOut_1 = require_eventTypeOut();
  var eventTypePatch_1 = require_eventTypePatch();
  var eventTypeUpdate_1 = require_eventTypeUpdate();
  var listResponseEventTypeOut_1 = require_listResponseEventTypeOut();
  var request_1 = require_request3();

  class EventType {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/event-type");
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        order: options === null || options === undefined ? undefined : options.order,
        include_archived: options === null || options === undefined ? undefined : options.includeArchived,
        with_content: options === null || options === undefined ? undefined : options.withContent
      });
      return request.send(this.requestCtx, listResponseEventTypeOut_1.ListResponseEventTypeOutSerializer._fromJsonObject);
    }
    create(eventTypeIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/event-type");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(eventTypeIn_1.EventTypeInSerializer._toJsonObject(eventTypeIn));
      return request.send(this.requestCtx, eventTypeOut_1.EventTypeOutSerializer._fromJsonObject);
    }
    importOpenapi(eventTypeImportOpenApiIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/event-type/import/openapi");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(eventTypeImportOpenApiIn_1.EventTypeImportOpenApiInSerializer._toJsonObject(eventTypeImportOpenApiIn));
      return request.send(this.requestCtx, eventTypeImportOpenApiOut_1.EventTypeImportOpenApiOutSerializer._fromJsonObject);
    }
    get(eventTypeName) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/event-type/{event_type_name}");
      request.setPathParam("event_type_name", eventTypeName);
      return request.send(this.requestCtx, eventTypeOut_1.EventTypeOutSerializer._fromJsonObject);
    }
    update(eventTypeName, eventTypeUpdate) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/event-type/{event_type_name}");
      request.setPathParam("event_type_name", eventTypeName);
      request.setBody(eventTypeUpdate_1.EventTypeUpdateSerializer._toJsonObject(eventTypeUpdate));
      return request.send(this.requestCtx, eventTypeOut_1.EventTypeOutSerializer._fromJsonObject);
    }
    delete(eventTypeName, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/event-type/{event_type_name}");
      request.setPathParam("event_type_name", eventTypeName);
      request.setQueryParams({
        expunge: options === null || options === undefined ? undefined : options.expunge
      });
      return request.sendNoResponseBody(this.requestCtx);
    }
    patch(eventTypeName, eventTypePatch) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/event-type/{event_type_name}");
      request.setPathParam("event_type_name", eventTypeName);
      request.setBody(eventTypePatch_1.EventTypePatchSerializer._toJsonObject(eventTypePatch));
      return request.send(this.requestCtx, eventTypeOut_1.EventTypeOutSerializer._fromJsonObject);
    }
  }
  exports.EventType = EventType;
});

// node_modules/svix/dist/api/health.js
var require_health = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Health = undefined;
  var request_1 = require_request3();

  class Health {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    get() {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/health");
      return request.sendNoResponseBody(this.requestCtx);
    }
  }
  exports.Health = Health;
});

// node_modules/svix/dist/models/ingestSourceConsumerPortalAccessIn.js
var require_ingestSourceConsumerPortalAccessIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestSourceConsumerPortalAccessInSerializer = undefined;
  exports.IngestSourceConsumerPortalAccessInSerializer = {
    _fromJsonObject(object) {
      return {
        expiry: object["expiry"],
        readOnly: object["readOnly"]
      };
    },
    _toJsonObject(self2) {
      return {
        expiry: self2.expiry,
        readOnly: self2.readOnly
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointHeadersIn.js
var require_ingestEndpointHeadersIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointHeadersInSerializer = undefined;
  exports.IngestEndpointHeadersInSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointHeadersOut.js
var require_ingestEndpointHeadersOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointHeadersOutSerializer = undefined;
  exports.IngestEndpointHeadersOutSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"],
        sensitive: object["sensitive"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers,
        sensitive: self2.sensitive
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointIn.js
var require_ingestEndpointIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointInSerializer = undefined;
  exports.IngestEndpointInSerializer = {
    _fromJsonObject(object) {
      return {
        description: object["description"],
        disabled: object["disabled"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        secret: object["secret"],
        uid: object["uid"],
        url: object["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        description: self2.description,
        disabled: self2.disabled,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        secret: self2.secret,
        uid: self2.uid,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointOut.js
var require_ingestEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointOutSerializer = undefined;
  exports.IngestEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        createdAt: new Date(object["createdAt"]),
        description: object["description"],
        disabled: object["disabled"],
        id: object["id"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"]),
        url: object["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        createdAt: self2.createdAt,
        description: self2.description,
        disabled: self2.disabled,
        id: self2.id,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        uid: self2.uid,
        updatedAt: self2.updatedAt,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointSecretIn.js
var require_ingestEndpointSecretIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointSecretInSerializer = undefined;
  exports.IngestEndpointSecretInSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointSecretOut.js
var require_ingestEndpointSecretOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointSecretOutSerializer = undefined;
  exports.IngestEndpointSecretOutSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointTransformationOut.js
var require_ingestEndpointTransformationOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointTransformationOutSerializer = undefined;
  exports.IngestEndpointTransformationOutSerializer = {
    _fromJsonObject(object) {
      return {
        code: object["code"],
        enabled: object["enabled"]
      };
    },
    _toJsonObject(self2) {
      return {
        code: self2.code,
        enabled: self2.enabled
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointTransformationPatch.js
var require_ingestEndpointTransformationPatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointTransformationPatchSerializer = undefined;
  exports.IngestEndpointTransformationPatchSerializer = {
    _fromJsonObject(object) {
      return {
        code: object["code"],
        enabled: object["enabled"]
      };
    },
    _toJsonObject(self2) {
      return {
        code: self2.code,
        enabled: self2.enabled
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointUpdate.js
var require_ingestEndpointUpdate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointUpdateSerializer = undefined;
  exports.IngestEndpointUpdateSerializer = {
    _fromJsonObject(object) {
      return {
        description: object["description"],
        disabled: object["disabled"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        uid: object["uid"],
        url: object["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        description: self2.description,
        disabled: self2.disabled,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        uid: self2.uid,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseIngestEndpointOut.js
var require_listResponseIngestEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseIngestEndpointOutSerializer = undefined;
  var ingestEndpointOut_1 = require_ingestEndpointOut();
  exports.ListResponseIngestEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => ingestEndpointOut_1.IngestEndpointOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => ingestEndpointOut_1.IngestEndpointOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/api/ingestEndpoint.js
var require_ingestEndpoint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpoint = undefined;
  var ingestEndpointHeadersIn_1 = require_ingestEndpointHeadersIn();
  var ingestEndpointHeadersOut_1 = require_ingestEndpointHeadersOut();
  var ingestEndpointIn_1 = require_ingestEndpointIn();
  var ingestEndpointOut_1 = require_ingestEndpointOut();
  var ingestEndpointSecretIn_1 = require_ingestEndpointSecretIn();
  var ingestEndpointSecretOut_1 = require_ingestEndpointSecretOut();
  var ingestEndpointTransformationOut_1 = require_ingestEndpointTransformationOut();
  var ingestEndpointTransformationPatch_1 = require_ingestEndpointTransformationPatch();
  var ingestEndpointUpdate_1 = require_ingestEndpointUpdate();
  var listResponseIngestEndpointOut_1 = require_listResponseIngestEndpointOut();
  var request_1 = require_request3();

  class IngestEndpoint {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(sourceId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint");
      request.setPathParam("source_id", sourceId);
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        order: options === null || options === undefined ? undefined : options.order
      });
      return request.send(this.requestCtx, listResponseIngestEndpointOut_1.ListResponseIngestEndpointOutSerializer._fromJsonObject);
    }
    create(sourceId, ingestEndpointIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source/{source_id}/endpoint");
      request.setPathParam("source_id", sourceId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(ingestEndpointIn_1.IngestEndpointInSerializer._toJsonObject(ingestEndpointIn));
      return request.send(this.requestCtx, ingestEndpointOut_1.IngestEndpointOutSerializer._fromJsonObject);
    }
    get(sourceId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, ingestEndpointOut_1.IngestEndpointOutSerializer._fromJsonObject);
    }
    update(sourceId, endpointId, ingestEndpointUpdate) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(ingestEndpointUpdate_1.IngestEndpointUpdateSerializer._toJsonObject(ingestEndpointUpdate));
      return request.send(this.requestCtx, ingestEndpointOut_1.IngestEndpointOutSerializer._fromJsonObject);
    }
    delete(sourceId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    getHeaders(sourceId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/headers");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, ingestEndpointHeadersOut_1.IngestEndpointHeadersOutSerializer._fromJsonObject);
    }
    updateHeaders(sourceId, endpointId, ingestEndpointHeadersIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/headers");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(ingestEndpointHeadersIn_1.IngestEndpointHeadersInSerializer._toJsonObject(ingestEndpointHeadersIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
    getSecret(sourceId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/secret");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, ingestEndpointSecretOut_1.IngestEndpointSecretOutSerializer._fromJsonObject);
    }
    rotateSecret(sourceId, endpointId, ingestEndpointSecretIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/secret/rotate");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(ingestEndpointSecretIn_1.IngestEndpointSecretInSerializer._toJsonObject(ingestEndpointSecretIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
    getTransformation(sourceId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/transformation");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, ingestEndpointTransformationOut_1.IngestEndpointTransformationOutSerializer._fromJsonObject);
    }
    setTransformation(sourceId, endpointId, ingestEndpointTransformationPatch) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/transformation");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(ingestEndpointTransformationPatch_1.IngestEndpointTransformationPatchSerializer._toJsonObject(ingestEndpointTransformationPatch));
      return request.sendNoResponseBody(this.requestCtx);
    }
  }
  exports.IngestEndpoint = IngestEndpoint;
});

// node_modules/svix/dist/models/adobeSignConfig.js
var require_adobeSignConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AdobeSignConfigSerializer = undefined;
  exports.AdobeSignConfigSerializer = {
    _fromJsonObject(object) {
      return {
        clientId: object["clientId"]
      };
    },
    _toJsonObject(self2) {
      return {
        clientId: self2.clientId
      };
    }
  };
});

// node_modules/svix/dist/models/airwallexConfig.js
var require_airwallexConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AirwallexConfigSerializer = undefined;
  exports.AirwallexConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/checkbookConfig.js
var require_checkbookConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CheckbookConfigSerializer = undefined;
  exports.CheckbookConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/cronConfig.js
var require_cronConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CronConfigSerializer = undefined;
  exports.CronConfigSerializer = {
    _fromJsonObject(object) {
      return {
        contentType: object["contentType"],
        payload: object["payload"],
        schedule: object["schedule"]
      };
    },
    _toJsonObject(self2) {
      return {
        contentType: self2.contentType,
        payload: self2.payload,
        schedule: self2.schedule
      };
    }
  };
});

// node_modules/svix/dist/models/docusignConfig.js
var require_docusignConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DocusignConfigSerializer = undefined;
  exports.DocusignConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/easypostConfig.js
var require_easypostConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EasypostConfigSerializer = undefined;
  exports.EasypostConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/githubConfig.js
var require_githubConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GithubConfigSerializer = undefined;
  exports.GithubConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/hubspotConfig.js
var require_hubspotConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HubspotConfigSerializer = undefined;
  exports.HubspotConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/orumIoConfig.js
var require_orumIoConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OrumIoConfigSerializer = undefined;
  exports.OrumIoConfigSerializer = {
    _fromJsonObject(object) {
      return {
        publicKey: object["publicKey"]
      };
    },
    _toJsonObject(self2) {
      return {
        publicKey: self2.publicKey
      };
    }
  };
});

// node_modules/svix/dist/models/pandaDocConfig.js
var require_pandaDocConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PandaDocConfigSerializer = undefined;
  exports.PandaDocConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/portIoConfig.js
var require_portIoConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PortIoConfigSerializer = undefined;
  exports.PortIoConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/rutterConfig.js
var require_rutterConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RutterConfigSerializer = undefined;
  exports.RutterConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/segmentConfig.js
var require_segmentConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SegmentConfigSerializer = undefined;
  exports.SegmentConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/shopifyConfig.js
var require_shopifyConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ShopifyConfigSerializer = undefined;
  exports.ShopifyConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/slackConfig.js
var require_slackConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SlackConfigSerializer = undefined;
  exports.SlackConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/stripeConfig.js
var require_stripeConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StripeConfigSerializer = undefined;
  exports.StripeConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/svixConfig.js
var require_svixConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SvixConfigSerializer = undefined;
  exports.SvixConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/telnyxConfig.js
var require_telnyxConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TelnyxConfigSerializer = undefined;
  exports.TelnyxConfigSerializer = {
    _fromJsonObject(object) {
      return {
        publicKey: object["publicKey"]
      };
    },
    _toJsonObject(self2) {
      return {
        publicKey: self2.publicKey
      };
    }
  };
});

// node_modules/svix/dist/models/vapiConfig.js
var require_vapiConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VapiConfigSerializer = undefined;
  exports.VapiConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/veriffConfig.js
var require_veriffConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VeriffConfigSerializer = undefined;
  exports.VeriffConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/zoomConfig.js
var require_zoomConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ZoomConfigSerializer = undefined;
  exports.ZoomConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/ingestSourceIn.js
var require_ingestSourceIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestSourceInSerializer = undefined;
  var adobeSignConfig_1 = require_adobeSignConfig();
  var airwallexConfig_1 = require_airwallexConfig();
  var checkbookConfig_1 = require_checkbookConfig();
  var cronConfig_1 = require_cronConfig();
  var docusignConfig_1 = require_docusignConfig();
  var easypostConfig_1 = require_easypostConfig();
  var githubConfig_1 = require_githubConfig();
  var hubspotConfig_1 = require_hubspotConfig();
  var orumIoConfig_1 = require_orumIoConfig();
  var pandaDocConfig_1 = require_pandaDocConfig();
  var portIoConfig_1 = require_portIoConfig();
  var rutterConfig_1 = require_rutterConfig();
  var segmentConfig_1 = require_segmentConfig();
  var shopifyConfig_1 = require_shopifyConfig();
  var slackConfig_1 = require_slackConfig();
  var stripeConfig_1 = require_stripeConfig();
  var svixConfig_1 = require_svixConfig();
  var telnyxConfig_1 = require_telnyxConfig();
  var vapiConfig_1 = require_vapiConfig();
  var veriffConfig_1 = require_veriffConfig();
  var zoomConfig_1 = require_zoomConfig();
  exports.IngestSourceInSerializer = {
    _fromJsonObject(object) {
      const type = object["type"];
      function getConfig(type2) {
        switch (type2) {
          case "generic-webhook":
            return {};
          case "cron":
            return cronConfig_1.CronConfigSerializer._fromJsonObject(object["config"]);
          case "adobe-sign":
            return adobeSignConfig_1.AdobeSignConfigSerializer._fromJsonObject(object["config"]);
          case "beehiiv":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "brex":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "checkbook":
            return checkbookConfig_1.CheckbookConfigSerializer._fromJsonObject(object["config"]);
          case "clerk":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "docusign":
            return docusignConfig_1.DocusignConfigSerializer._fromJsonObject(object["config"]);
          case "easypost":
            return easypostConfig_1.EasypostConfigSerializer._fromJsonObject(object["config"]);
          case "github":
            return githubConfig_1.GithubConfigSerializer._fromJsonObject(object["config"]);
          case "guesty":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "hubspot":
            return hubspotConfig_1.HubspotConfigSerializer._fromJsonObject(object["config"]);
          case "incident-io":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "lithic":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "nash":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "orum-io":
            return orumIoConfig_1.OrumIoConfigSerializer._fromJsonObject(object["config"]);
          case "panda-doc":
            return pandaDocConfig_1.PandaDocConfigSerializer._fromJsonObject(object["config"]);
          case "port-io":
            return portIoConfig_1.PortIoConfigSerializer._fromJsonObject(object["config"]);
          case "pleo":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "replicate":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "resend":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "rutter":
            return rutterConfig_1.RutterConfigSerializer._fromJsonObject(object["config"]);
          case "safebase":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "sardine":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "segment":
            return segmentConfig_1.SegmentConfigSerializer._fromJsonObject(object["config"]);
          case "shopify":
            return shopifyConfig_1.ShopifyConfigSerializer._fromJsonObject(object["config"]);
          case "slack":
            return slackConfig_1.SlackConfigSerializer._fromJsonObject(object["config"]);
          case "stripe":
            return stripeConfig_1.StripeConfigSerializer._fromJsonObject(object["config"]);
          case "stych":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "svix":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "zoom":
            return zoomConfig_1.ZoomConfigSerializer._fromJsonObject(object["config"]);
          case "telnyx":
            return telnyxConfig_1.TelnyxConfigSerializer._fromJsonObject(object["config"]);
          case "vapi":
            return vapiConfig_1.VapiConfigSerializer._fromJsonObject(object["config"]);
          case "open-ai":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "render":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "veriff":
            return veriffConfig_1.VeriffConfigSerializer._fromJsonObject(object["config"]);
          case "airwallex":
            return airwallexConfig_1.AirwallexConfigSerializer._fromJsonObject(object["config"]);
          default:
            throw new Error(`Unexpected type: ${type2}`);
        }
      }
      return {
        type,
        config: getConfig(type),
        metadata: object["metadata"],
        name: object["name"],
        uid: object["uid"]
      };
    },
    _toJsonObject(self2) {
      let config;
      switch (self2.type) {
        case "generic-webhook":
          config = {};
          break;
        case "cron":
          config = cronConfig_1.CronConfigSerializer._toJsonObject(self2.config);
          break;
        case "adobe-sign":
          config = adobeSignConfig_1.AdobeSignConfigSerializer._toJsonObject(self2.config);
          break;
        case "beehiiv":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "brex":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "checkbook":
          config = checkbookConfig_1.CheckbookConfigSerializer._toJsonObject(self2.config);
          break;
        case "clerk":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "docusign":
          config = docusignConfig_1.DocusignConfigSerializer._toJsonObject(self2.config);
          break;
        case "easypost":
          config = easypostConfig_1.EasypostConfigSerializer._toJsonObject(self2.config);
          break;
        case "github":
          config = githubConfig_1.GithubConfigSerializer._toJsonObject(self2.config);
          break;
        case "guesty":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "hubspot":
          config = hubspotConfig_1.HubspotConfigSerializer._toJsonObject(self2.config);
          break;
        case "incident-io":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "lithic":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "nash":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "orum-io":
          config = orumIoConfig_1.OrumIoConfigSerializer._toJsonObject(self2.config);
          break;
        case "panda-doc":
          config = pandaDocConfig_1.PandaDocConfigSerializer._toJsonObject(self2.config);
          break;
        case "port-io":
          config = portIoConfig_1.PortIoConfigSerializer._toJsonObject(self2.config);
          break;
        case "pleo":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "replicate":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "resend":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "rutter":
          config = rutterConfig_1.RutterConfigSerializer._toJsonObject(self2.config);
          break;
        case "safebase":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "sardine":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "segment":
          config = segmentConfig_1.SegmentConfigSerializer._toJsonObject(self2.config);
          break;
        case "shopify":
          config = shopifyConfig_1.ShopifyConfigSerializer._toJsonObject(self2.config);
          break;
        case "slack":
          config = slackConfig_1.SlackConfigSerializer._toJsonObject(self2.config);
          break;
        case "stripe":
          config = stripeConfig_1.StripeConfigSerializer._toJsonObject(self2.config);
          break;
        case "stych":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "svix":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "zoom":
          config = zoomConfig_1.ZoomConfigSerializer._toJsonObject(self2.config);
          break;
        case "telnyx":
          config = telnyxConfig_1.TelnyxConfigSerializer._toJsonObject(self2.config);
          break;
        case "vapi":
          config = vapiConfig_1.VapiConfigSerializer._toJsonObject(self2.config);
          break;
        case "open-ai":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "render":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "veriff":
          config = veriffConfig_1.VeriffConfigSerializer._toJsonObject(self2.config);
          break;
        case "airwallex":
          config = airwallexConfig_1.AirwallexConfigSerializer._toJsonObject(self2.config);
          break;
      }
      return {
        type: self2.type,
        config,
        metadata: self2.metadata,
        name: self2.name,
        uid: self2.uid
      };
    }
  };
});

// node_modules/svix/dist/models/adobeSignConfigOut.js
var require_adobeSignConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AdobeSignConfigOutSerializer = undefined;
  exports.AdobeSignConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/airwallexConfigOut.js
var require_airwallexConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AirwallexConfigOutSerializer = undefined;
  exports.AirwallexConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/checkbookConfigOut.js
var require_checkbookConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CheckbookConfigOutSerializer = undefined;
  exports.CheckbookConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/docusignConfigOut.js
var require_docusignConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DocusignConfigOutSerializer = undefined;
  exports.DocusignConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/easypostConfigOut.js
var require_easypostConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EasypostConfigOutSerializer = undefined;
  exports.EasypostConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/githubConfigOut.js
var require_githubConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GithubConfigOutSerializer = undefined;
  exports.GithubConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/hubspotConfigOut.js
var require_hubspotConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HubspotConfigOutSerializer = undefined;
  exports.HubspotConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/orumIoConfigOut.js
var require_orumIoConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OrumIoConfigOutSerializer = undefined;
  exports.OrumIoConfigOutSerializer = {
    _fromJsonObject(object) {
      return {
        publicKey: object["publicKey"]
      };
    },
    _toJsonObject(self2) {
      return {
        publicKey: self2.publicKey
      };
    }
  };
});

// node_modules/svix/dist/models/pandaDocConfigOut.js
var require_pandaDocConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PandaDocConfigOutSerializer = undefined;
  exports.PandaDocConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/portIoConfigOut.js
var require_portIoConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PortIoConfigOutSerializer = undefined;
  exports.PortIoConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/rutterConfigOut.js
var require_rutterConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RutterConfigOutSerializer = undefined;
  exports.RutterConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/segmentConfigOut.js
var require_segmentConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SegmentConfigOutSerializer = undefined;
  exports.SegmentConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/shopifyConfigOut.js
var require_shopifyConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ShopifyConfigOutSerializer = undefined;
  exports.ShopifyConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/slackConfigOut.js
var require_slackConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SlackConfigOutSerializer = undefined;
  exports.SlackConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/stripeConfigOut.js
var require_stripeConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StripeConfigOutSerializer = undefined;
  exports.StripeConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/svixConfigOut.js
var require_svixConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SvixConfigOutSerializer = undefined;
  exports.SvixConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/telnyxConfigOut.js
var require_telnyxConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TelnyxConfigOutSerializer = undefined;
  exports.TelnyxConfigOutSerializer = {
    _fromJsonObject(object) {
      return {
        publicKey: object["publicKey"]
      };
    },
    _toJsonObject(self2) {
      return {
        publicKey: self2.publicKey
      };
    }
  };
});

// node_modules/svix/dist/models/vapiConfigOut.js
var require_vapiConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VapiConfigOutSerializer = undefined;
  exports.VapiConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/veriffConfigOut.js
var require_veriffConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VeriffConfigOutSerializer = undefined;
  exports.VeriffConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/zoomConfigOut.js
var require_zoomConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ZoomConfigOutSerializer = undefined;
  exports.ZoomConfigOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/ingestSourceOut.js
var require_ingestSourceOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestSourceOutSerializer = undefined;
  var adobeSignConfigOut_1 = require_adobeSignConfigOut();
  var airwallexConfigOut_1 = require_airwallexConfigOut();
  var checkbookConfigOut_1 = require_checkbookConfigOut();
  var cronConfig_1 = require_cronConfig();
  var docusignConfigOut_1 = require_docusignConfigOut();
  var easypostConfigOut_1 = require_easypostConfigOut();
  var githubConfigOut_1 = require_githubConfigOut();
  var hubspotConfigOut_1 = require_hubspotConfigOut();
  var orumIoConfigOut_1 = require_orumIoConfigOut();
  var pandaDocConfigOut_1 = require_pandaDocConfigOut();
  var portIoConfigOut_1 = require_portIoConfigOut();
  var rutterConfigOut_1 = require_rutterConfigOut();
  var segmentConfigOut_1 = require_segmentConfigOut();
  var shopifyConfigOut_1 = require_shopifyConfigOut();
  var slackConfigOut_1 = require_slackConfigOut();
  var stripeConfigOut_1 = require_stripeConfigOut();
  var svixConfigOut_1 = require_svixConfigOut();
  var telnyxConfigOut_1 = require_telnyxConfigOut();
  var vapiConfigOut_1 = require_vapiConfigOut();
  var veriffConfigOut_1 = require_veriffConfigOut();
  var zoomConfigOut_1 = require_zoomConfigOut();
  exports.IngestSourceOutSerializer = {
    _fromJsonObject(object) {
      const type = object["type"];
      function getConfig(type2) {
        switch (type2) {
          case "generic-webhook":
            return {};
          case "cron":
            return cronConfig_1.CronConfigSerializer._fromJsonObject(object["config"]);
          case "adobe-sign":
            return adobeSignConfigOut_1.AdobeSignConfigOutSerializer._fromJsonObject(object["config"]);
          case "beehiiv":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "brex":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "checkbook":
            return checkbookConfigOut_1.CheckbookConfigOutSerializer._fromJsonObject(object["config"]);
          case "clerk":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "docusign":
            return docusignConfigOut_1.DocusignConfigOutSerializer._fromJsonObject(object["config"]);
          case "easypost":
            return easypostConfigOut_1.EasypostConfigOutSerializer._fromJsonObject(object["config"]);
          case "github":
            return githubConfigOut_1.GithubConfigOutSerializer._fromJsonObject(object["config"]);
          case "guesty":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "hubspot":
            return hubspotConfigOut_1.HubspotConfigOutSerializer._fromJsonObject(object["config"]);
          case "incident-io":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "lithic":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "nash":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "orum-io":
            return orumIoConfigOut_1.OrumIoConfigOutSerializer._fromJsonObject(object["config"]);
          case "panda-doc":
            return pandaDocConfigOut_1.PandaDocConfigOutSerializer._fromJsonObject(object["config"]);
          case "port-io":
            return portIoConfigOut_1.PortIoConfigOutSerializer._fromJsonObject(object["config"]);
          case "pleo":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "replicate":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "resend":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "rutter":
            return rutterConfigOut_1.RutterConfigOutSerializer._fromJsonObject(object["config"]);
          case "safebase":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "sardine":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "segment":
            return segmentConfigOut_1.SegmentConfigOutSerializer._fromJsonObject(object["config"]);
          case "shopify":
            return shopifyConfigOut_1.ShopifyConfigOutSerializer._fromJsonObject(object["config"]);
          case "slack":
            return slackConfigOut_1.SlackConfigOutSerializer._fromJsonObject(object["config"]);
          case "stripe":
            return stripeConfigOut_1.StripeConfigOutSerializer._fromJsonObject(object["config"]);
          case "stych":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "svix":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "zoom":
            return zoomConfigOut_1.ZoomConfigOutSerializer._fromJsonObject(object["config"]);
          case "telnyx":
            return telnyxConfigOut_1.TelnyxConfigOutSerializer._fromJsonObject(object["config"]);
          case "vapi":
            return vapiConfigOut_1.VapiConfigOutSerializer._fromJsonObject(object["config"]);
          case "open-ai":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "render":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "veriff":
            return veriffConfigOut_1.VeriffConfigOutSerializer._fromJsonObject(object["config"]);
          case "airwallex":
            return airwallexConfigOut_1.AirwallexConfigOutSerializer._fromJsonObject(object["config"]);
          default:
            throw new Error(`Unexpected type: ${type2}`);
        }
      }
      return {
        type,
        config: getConfig(type),
        createdAt: new Date(object["createdAt"]),
        id: object["id"],
        ingestUrl: object["ingestUrl"],
        metadata: object["metadata"],
        name: object["name"],
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"])
      };
    },
    _toJsonObject(self2) {
      let config;
      switch (self2.type) {
        case "generic-webhook":
          config = {};
          break;
        case "cron":
          config = cronConfig_1.CronConfigSerializer._toJsonObject(self2.config);
          break;
        case "adobe-sign":
          config = adobeSignConfigOut_1.AdobeSignConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "beehiiv":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "brex":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "checkbook":
          config = checkbookConfigOut_1.CheckbookConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "clerk":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "docusign":
          config = docusignConfigOut_1.DocusignConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "easypost":
          config = easypostConfigOut_1.EasypostConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "github":
          config = githubConfigOut_1.GithubConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "guesty":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "hubspot":
          config = hubspotConfigOut_1.HubspotConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "incident-io":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "lithic":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "nash":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "orum-io":
          config = orumIoConfigOut_1.OrumIoConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "panda-doc":
          config = pandaDocConfigOut_1.PandaDocConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "port-io":
          config = portIoConfigOut_1.PortIoConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "pleo":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "replicate":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "resend":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "rutter":
          config = rutterConfigOut_1.RutterConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "safebase":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "sardine":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "segment":
          config = segmentConfigOut_1.SegmentConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "shopify":
          config = shopifyConfigOut_1.ShopifyConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "slack":
          config = slackConfigOut_1.SlackConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "stripe":
          config = stripeConfigOut_1.StripeConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "stych":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "svix":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "zoom":
          config = zoomConfigOut_1.ZoomConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "telnyx":
          config = telnyxConfigOut_1.TelnyxConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "vapi":
          config = vapiConfigOut_1.VapiConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "open-ai":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "render":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "veriff":
          config = veriffConfigOut_1.VeriffConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "airwallex":
          config = airwallexConfigOut_1.AirwallexConfigOutSerializer._toJsonObject(self2.config);
          break;
      }
      return {
        type: self2.type,
        config,
        createdAt: self2.createdAt,
        id: self2.id,
        ingestUrl: self2.ingestUrl,
        metadata: self2.metadata,
        name: self2.name,
        uid: self2.uid,
        updatedAt: self2.updatedAt
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseIngestSourceOut.js
var require_listResponseIngestSourceOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseIngestSourceOutSerializer = undefined;
  var ingestSourceOut_1 = require_ingestSourceOut();
  exports.ListResponseIngestSourceOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => ingestSourceOut_1.IngestSourceOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => ingestSourceOut_1.IngestSourceOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/rotateTokenOut.js
var require_rotateTokenOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RotateTokenOutSerializer = undefined;
  exports.RotateTokenOutSerializer = {
    _fromJsonObject(object) {
      return {
        ingestUrl: object["ingestUrl"]
      };
    },
    _toJsonObject(self2) {
      return {
        ingestUrl: self2.ingestUrl
      };
    }
  };
});

// node_modules/svix/dist/api/ingestSource.js
var require_ingestSource = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestSource = undefined;
  var ingestSourceIn_1 = require_ingestSourceIn();
  var ingestSourceOut_1 = require_ingestSourceOut();
  var listResponseIngestSourceOut_1 = require_listResponseIngestSourceOut();
  var rotateTokenOut_1 = require_rotateTokenOut();
  var request_1 = require_request3();

  class IngestSource {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source");
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        order: options === null || options === undefined ? undefined : options.order
      });
      return request.send(this.requestCtx, listResponseIngestSourceOut_1.ListResponseIngestSourceOutSerializer._fromJsonObject);
    }
    create(ingestSourceIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(ingestSourceIn_1.IngestSourceInSerializer._toJsonObject(ingestSourceIn));
      return request.send(this.requestCtx, ingestSourceOut_1.IngestSourceOutSerializer._fromJsonObject);
    }
    get(sourceId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}");
      request.setPathParam("source_id", sourceId);
      return request.send(this.requestCtx, ingestSourceOut_1.IngestSourceOutSerializer._fromJsonObject);
    }
    update(sourceId, ingestSourceIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/ingest/api/v1/source/{source_id}");
      request.setPathParam("source_id", sourceId);
      request.setBody(ingestSourceIn_1.IngestSourceInSerializer._toJsonObject(ingestSourceIn));
      return request.send(this.requestCtx, ingestSourceOut_1.IngestSourceOutSerializer._fromJsonObject);
    }
    delete(sourceId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/ingest/api/v1/source/{source_id}");
      request.setPathParam("source_id", sourceId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    rotateToken(sourceId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source/{source_id}/token/rotate");
      request.setPathParam("source_id", sourceId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      return request.send(this.requestCtx, rotateTokenOut_1.RotateTokenOutSerializer._fromJsonObject);
    }
  }
  exports.IngestSource = IngestSource;
});

// node_modules/svix/dist/api/ingest.js
var require_ingest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Ingest = undefined;
  var dashboardAccessOut_1 = require_dashboardAccessOut();
  var ingestSourceConsumerPortalAccessIn_1 = require_ingestSourceConsumerPortalAccessIn();
  var ingestEndpoint_1 = require_ingestEndpoint();
  var ingestSource_1 = require_ingestSource();
  var request_1 = require_request3();

  class Ingest {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    get endpoint() {
      return new ingestEndpoint_1.IngestEndpoint(this.requestCtx);
    }
    get source() {
      return new ingestSource_1.IngestSource(this.requestCtx);
    }
    dashboard(sourceId, ingestSourceConsumerPortalAccessIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source/{source_id}/dashboard");
      request.setPathParam("source_id", sourceId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(ingestSourceConsumerPortalAccessIn_1.IngestSourceConsumerPortalAccessInSerializer._toJsonObject(ingestSourceConsumerPortalAccessIn));
      return request.send(this.requestCtx, dashboardAccessOut_1.DashboardAccessOutSerializer._fromJsonObject);
    }
  }
  exports.Ingest = Ingest;
});

// node_modules/svix/dist/models/integrationIn.js
var require_integrationIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntegrationInSerializer = undefined;
  exports.IntegrationInSerializer = {
    _fromJsonObject(object) {
      return {
        featureFlags: object["featureFlags"],
        name: object["name"]
      };
    },
    _toJsonObject(self2) {
      return {
        featureFlags: self2.featureFlags,
        name: self2.name
      };
    }
  };
});

// node_modules/svix/dist/models/integrationKeyOut.js
var require_integrationKeyOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntegrationKeyOutSerializer = undefined;
  exports.IntegrationKeyOutSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/integrationOut.js
var require_integrationOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntegrationOutSerializer = undefined;
  exports.IntegrationOutSerializer = {
    _fromJsonObject(object) {
      return {
        createdAt: new Date(object["createdAt"]),
        featureFlags: object["featureFlags"],
        id: object["id"],
        name: object["name"],
        updatedAt: new Date(object["updatedAt"])
      };
    },
    _toJsonObject(self2) {
      return {
        createdAt: self2.createdAt,
        featureFlags: self2.featureFlags,
        id: self2.id,
        name: self2.name,
        updatedAt: self2.updatedAt
      };
    }
  };
});

// node_modules/svix/dist/models/integrationUpdate.js
var require_integrationUpdate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntegrationUpdateSerializer = undefined;
  exports.IntegrationUpdateSerializer = {
    _fromJsonObject(object) {
      return {
        featureFlags: object["featureFlags"],
        name: object["name"]
      };
    },
    _toJsonObject(self2) {
      return {
        featureFlags: self2.featureFlags,
        name: self2.name
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseIntegrationOut.js
var require_listResponseIntegrationOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseIntegrationOutSerializer = undefined;
  var integrationOut_1 = require_integrationOut();
  exports.ListResponseIntegrationOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => integrationOut_1.IntegrationOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => integrationOut_1.IntegrationOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/api/integration.js
var require_integration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Integration = undefined;
  var integrationIn_1 = require_integrationIn();
  var integrationKeyOut_1 = require_integrationKeyOut();
  var integrationOut_1 = require_integrationOut();
  var integrationUpdate_1 = require_integrationUpdate();
  var listResponseIntegrationOut_1 = require_listResponseIntegrationOut();
  var request_1 = require_request3();

  class Integration {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(appId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/integration");
      request.setPathParam("app_id", appId);
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        order: options === null || options === undefined ? undefined : options.order
      });
      return request.send(this.requestCtx, listResponseIntegrationOut_1.ListResponseIntegrationOutSerializer._fromJsonObject);
    }
    create(appId, integrationIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/integration");
      request.setPathParam("app_id", appId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(integrationIn_1.IntegrationInSerializer._toJsonObject(integrationIn));
      return request.send(this.requestCtx, integrationOut_1.IntegrationOutSerializer._fromJsonObject);
    }
    get(appId, integId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/integration/{integ_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("integ_id", integId);
      return request.send(this.requestCtx, integrationOut_1.IntegrationOutSerializer._fromJsonObject);
    }
    update(appId, integId, integrationUpdate) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/app/{app_id}/integration/{integ_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("integ_id", integId);
      request.setBody(integrationUpdate_1.IntegrationUpdateSerializer._toJsonObject(integrationUpdate));
      return request.send(this.requestCtx, integrationOut_1.IntegrationOutSerializer._fromJsonObject);
    }
    delete(appId, integId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}/integration/{integ_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("integ_id", integId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    getKey(appId, integId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/integration/{integ_id}/key");
      request.setPathParam("app_id", appId);
      request.setPathParam("integ_id", integId);
      return request.send(this.requestCtx, integrationKeyOut_1.IntegrationKeyOutSerializer._fromJsonObject);
    }
    rotateKey(appId, integId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/integration/{integ_id}/key/rotate");
      request.setPathParam("app_id", appId);
      request.setPathParam("integ_id", integId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      return request.send(this.requestCtx, integrationKeyOut_1.IntegrationKeyOutSerializer._fromJsonObject);
    }
  }
  exports.Integration = Integration;
});

// node_modules/svix/dist/models/expungeAllContentsOut.js
var require_expungeAllContentsOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExpungeAllContentsOutSerializer = undefined;
  var backgroundTaskStatus_1 = require_backgroundTaskStatus();
  var backgroundTaskType_1 = require_backgroundTaskType();
  exports.ExpungeAllContentsOutSerializer = {
    _fromJsonObject(object) {
      return {
        id: object["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object["task"])
      };
    },
    _toJsonObject(self2) {
      return {
        id: self2.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self2.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self2.task)
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseMessageOut.js
var require_listResponseMessageOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseMessageOutSerializer = undefined;
  var messageOut_1 = require_messageOut();
  exports.ListResponseMessageOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => messageOut_1.MessageOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => messageOut_1.MessageOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/pollingEndpointConsumerSeekIn.js
var require_pollingEndpointConsumerSeekIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PollingEndpointConsumerSeekInSerializer = undefined;
  exports.PollingEndpointConsumerSeekInSerializer = {
    _fromJsonObject(object) {
      return {
        after: new Date(object["after"])
      };
    },
    _toJsonObject(self2) {
      return {
        after: self2.after
      };
    }
  };
});

// node_modules/svix/dist/models/pollingEndpointConsumerSeekOut.js
var require_pollingEndpointConsumerSeekOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PollingEndpointConsumerSeekOutSerializer = undefined;
  exports.PollingEndpointConsumerSeekOutSerializer = {
    _fromJsonObject(object) {
      return {
        iterator: object["iterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        iterator: self2.iterator
      };
    }
  };
});

// node_modules/svix/dist/models/pollingEndpointMessageOut.js
var require_pollingEndpointMessageOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PollingEndpointMessageOutSerializer = undefined;
  exports.PollingEndpointMessageOutSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        deliverAt: object["deliverAt"] ? new Date(object["deliverAt"]) : null,
        eventId: object["eventId"],
        eventType: object["eventType"],
        headers: object["headers"],
        id: object["id"],
        payload: object["payload"],
        tags: object["tags"],
        timestamp: new Date(object["timestamp"])
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        deliverAt: self2.deliverAt,
        eventId: self2.eventId,
        eventType: self2.eventType,
        headers: self2.headers,
        id: self2.id,
        payload: self2.payload,
        tags: self2.tags,
        timestamp: self2.timestamp
      };
    }
  };
});

// node_modules/svix/dist/models/pollingEndpointOut.js
var require_pollingEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PollingEndpointOutSerializer = undefined;
  var pollingEndpointMessageOut_1 = require_pollingEndpointMessageOut();
  exports.PollingEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => pollingEndpointMessageOut_1.PollingEndpointMessageOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => pollingEndpointMessageOut_1.PollingEndpointMessageOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator
      };
    }
  };
});

// node_modules/svix/dist/api/messagePoller.js
var require_messagePoller = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessagePoller = undefined;
  var pollingEndpointConsumerSeekIn_1 = require_pollingEndpointConsumerSeekIn();
  var pollingEndpointConsumerSeekOut_1 = require_pollingEndpointConsumerSeekOut();
  var pollingEndpointOut_1 = require_pollingEndpointOut();
  var request_1 = require_request3();

  class MessagePoller {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    poll(appId, sinkId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/poller/{sink_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("sink_id", sinkId);
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        event_type: options === null || options === undefined ? undefined : options.eventType,
        channel: options === null || options === undefined ? undefined : options.channel,
        after: options === null || options === undefined ? undefined : options.after
      });
      return request.send(this.requestCtx, pollingEndpointOut_1.PollingEndpointOutSerializer._fromJsonObject);
    }
    consumerPoll(appId, sinkId, consumerId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/poller/{sink_id}/consumer/{consumer_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("sink_id", sinkId);
      request.setPathParam("consumer_id", consumerId);
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator
      });
      return request.send(this.requestCtx, pollingEndpointOut_1.PollingEndpointOutSerializer._fromJsonObject);
    }
    consumerSeek(appId, sinkId, consumerId, pollingEndpointConsumerSeekIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/poller/{sink_id}/consumer/{consumer_id}/seek");
      request.setPathParam("app_id", appId);
      request.setPathParam("sink_id", sinkId);
      request.setPathParam("consumer_id", consumerId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(pollingEndpointConsumerSeekIn_1.PollingEndpointConsumerSeekInSerializer._toJsonObject(pollingEndpointConsumerSeekIn));
      return request.send(this.requestCtx, pollingEndpointConsumerSeekOut_1.PollingEndpointConsumerSeekOutSerializer._fromJsonObject);
    }
  }
  exports.MessagePoller = MessagePoller;
});

// node_modules/svix/dist/models/messageIn.js
var require_messageIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageInSerializer = undefined;
  var applicationIn_1 = require_applicationIn();
  exports.MessageInSerializer = {
    _fromJsonObject(object) {
      return {
        application: object["application"] ? applicationIn_1.ApplicationInSerializer._fromJsonObject(object["application"]) : undefined,
        channels: object["channels"],
        deliverAt: object["deliverAt"] ? new Date(object["deliverAt"]) : null,
        eventId: object["eventId"],
        eventType: object["eventType"],
        payload: object["payload"],
        payloadRetentionHours: object["payloadRetentionHours"],
        payloadRetentionPeriod: object["payloadRetentionPeriod"],
        tags: object["tags"],
        transformationsParams: object["transformationsParams"]
      };
    },
    _toJsonObject(self2) {
      return {
        application: self2.application ? applicationIn_1.ApplicationInSerializer._toJsonObject(self2.application) : undefined,
        channels: self2.channels,
        deliverAt: self2.deliverAt,
        eventId: self2.eventId,
        eventType: self2.eventType,
        payload: self2.payload,
        payloadRetentionHours: self2.payloadRetentionHours,
        payloadRetentionPeriod: self2.payloadRetentionPeriod,
        tags: self2.tags,
        transformationsParams: self2.transformationsParams
      };
    }
  };
});

// node_modules/svix/dist/api/message.js
var require_message = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.messageInRaw = exports.Message = undefined;
  var expungeAllContentsOut_1 = require_expungeAllContentsOut();
  var listResponseMessageOut_1 = require_listResponseMessageOut();
  var messageOut_1 = require_messageOut();
  var messagePoller_1 = require_messagePoller();
  var request_1 = require_request3();
  var messageIn_1 = require_messageIn();

  class Message {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    get poller() {
      return new messagePoller_1.MessagePoller(this.requestCtx);
    }
    list(appId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/msg");
      request.setPathParam("app_id", appId);
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        channel: options === null || options === undefined ? undefined : options.channel,
        before: options === null || options === undefined ? undefined : options.before,
        after: options === null || options === undefined ? undefined : options.after,
        with_content: options === null || options === undefined ? undefined : options.withContent,
        tag: options === null || options === undefined ? undefined : options.tag,
        event_types: options === null || options === undefined ? undefined : options.eventTypes
      });
      return request.send(this.requestCtx, listResponseMessageOut_1.ListResponseMessageOutSerializer._fromJsonObject);
    }
    create(appId, messageIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/msg");
      request.setPathParam("app_id", appId);
      request.setQueryParams({
        with_content: options === null || options === undefined ? undefined : options.withContent
      });
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(messageIn_1.MessageInSerializer._toJsonObject(messageIn));
      return request.send(this.requestCtx, messageOut_1.MessageOutSerializer._fromJsonObject);
    }
    expungeAllContents(appId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/msg/expunge-all-contents");
      request.setPathParam("app_id", appId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      return request.send(this.requestCtx, expungeAllContentsOut_1.ExpungeAllContentsOutSerializer._fromJsonObject);
    }
    get(appId, msgId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/msg/{msg_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("msg_id", msgId);
      request.setQueryParams({
        with_content: options === null || options === undefined ? undefined : options.withContent
      });
      return request.send(this.requestCtx, messageOut_1.MessageOutSerializer._fromJsonObject);
    }
    expungeContent(appId, msgId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}/msg/{msg_id}/content");
      request.setPathParam("app_id", appId);
      request.setPathParam("msg_id", msgId);
      return request.sendNoResponseBody(this.requestCtx);
    }
  }
  exports.Message = Message;
  function messageInRaw(eventType, payload, contentType) {
    const headers = contentType ? { "content-type": contentType } : undefined;
    return {
      eventType,
      payload: {},
      transformationsParams: {
        rawPayload: payload,
        headers
      }
    };
  }
  exports.messageInRaw = messageInRaw;
});

// node_modules/svix/dist/models/emptyResponse.js
var require_emptyResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmptyResponseSerializer = undefined;
  exports.EmptyResponseSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/messageStatus.js
var require_messageStatus = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageStatusSerializer = exports.MessageStatus = undefined;
  var MessageStatus;
  (function(MessageStatus2) {
    MessageStatus2[MessageStatus2["Success"] = 0] = "Success";
    MessageStatus2[MessageStatus2["Pending"] = 1] = "Pending";
    MessageStatus2[MessageStatus2["Fail"] = 2] = "Fail";
    MessageStatus2[MessageStatus2["Sending"] = 3] = "Sending";
  })(MessageStatus = exports.MessageStatus || (exports.MessageStatus = {}));
  exports.MessageStatusSerializer = {
    _fromJsonObject(object) {
      return object;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/messageStatusText.js
var require_messageStatusText = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageStatusTextSerializer = exports.MessageStatusText = undefined;
  var MessageStatusText;
  (function(MessageStatusText2) {
    MessageStatusText2["Success"] = "success";
    MessageStatusText2["Pending"] = "pending";
    MessageStatusText2["Fail"] = "fail";
    MessageStatusText2["Sending"] = "sending";
  })(MessageStatusText = exports.MessageStatusText || (exports.MessageStatusText = {}));
  exports.MessageStatusTextSerializer = {
    _fromJsonObject(object) {
      return object;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/endpointMessageOut.js
var require_endpointMessageOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointMessageOutSerializer = undefined;
  var messageStatus_1 = require_messageStatus();
  var messageStatusText_1 = require_messageStatusText();
  exports.EndpointMessageOutSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        deliverAt: object["deliverAt"] ? new Date(object["deliverAt"]) : null,
        eventId: object["eventId"],
        eventType: object["eventType"],
        id: object["id"],
        nextAttempt: object["nextAttempt"] ? new Date(object["nextAttempt"]) : null,
        payload: object["payload"],
        status: messageStatus_1.MessageStatusSerializer._fromJsonObject(object["status"]),
        statusText: messageStatusText_1.MessageStatusTextSerializer._fromJsonObject(object["statusText"]),
        tags: object["tags"],
        timestamp: new Date(object["timestamp"])
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        deliverAt: self2.deliverAt,
        eventId: self2.eventId,
        eventType: self2.eventType,
        id: self2.id,
        nextAttempt: self2.nextAttempt,
        payload: self2.payload,
        status: messageStatus_1.MessageStatusSerializer._toJsonObject(self2.status),
        statusText: messageStatusText_1.MessageStatusTextSerializer._toJsonObject(self2.statusText),
        tags: self2.tags,
        timestamp: self2.timestamp
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseEndpointMessageOut.js
var require_listResponseEndpointMessageOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseEndpointMessageOutSerializer = undefined;
  var endpointMessageOut_1 = require_endpointMessageOut();
  exports.ListResponseEndpointMessageOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => endpointMessageOut_1.EndpointMessageOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => endpointMessageOut_1.EndpointMessageOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/messageAttemptTriggerType.js
var require_messageAttemptTriggerType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageAttemptTriggerTypeSerializer = exports.MessageAttemptTriggerType = undefined;
  var MessageAttemptTriggerType;
  (function(MessageAttemptTriggerType2) {
    MessageAttemptTriggerType2[MessageAttemptTriggerType2["Scheduled"] = 0] = "Scheduled";
    MessageAttemptTriggerType2[MessageAttemptTriggerType2["Manual"] = 1] = "Manual";
  })(MessageAttemptTriggerType = exports.MessageAttemptTriggerType || (exports.MessageAttemptTriggerType = {}));
  exports.MessageAttemptTriggerTypeSerializer = {
    _fromJsonObject(object) {
      return object;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/messageAttemptOut.js
var require_messageAttemptOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageAttemptOutSerializer = undefined;
  var messageAttemptTriggerType_1 = require_messageAttemptTriggerType();
  var messageOut_1 = require_messageOut();
  var messageStatus_1 = require_messageStatus();
  var messageStatusText_1 = require_messageStatusText();
  exports.MessageAttemptOutSerializer = {
    _fromJsonObject(object) {
      return {
        endpointId: object["endpointId"],
        id: object["id"],
        msg: object["msg"] ? messageOut_1.MessageOutSerializer._fromJsonObject(object["msg"]) : undefined,
        msgId: object["msgId"],
        response: object["response"],
        responseDurationMs: object["responseDurationMs"],
        responseStatusCode: object["responseStatusCode"],
        status: messageStatus_1.MessageStatusSerializer._fromJsonObject(object["status"]),
        statusText: messageStatusText_1.MessageStatusTextSerializer._fromJsonObject(object["statusText"]),
        timestamp: new Date(object["timestamp"]),
        triggerType: messageAttemptTriggerType_1.MessageAttemptTriggerTypeSerializer._fromJsonObject(object["triggerType"]),
        url: object["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        endpointId: self2.endpointId,
        id: self2.id,
        msg: self2.msg ? messageOut_1.MessageOutSerializer._toJsonObject(self2.msg) : undefined,
        msgId: self2.msgId,
        response: self2.response,
        responseDurationMs: self2.responseDurationMs,
        responseStatusCode: self2.responseStatusCode,
        status: messageStatus_1.MessageStatusSerializer._toJsonObject(self2.status),
        statusText: messageStatusText_1.MessageStatusTextSerializer._toJsonObject(self2.statusText),
        timestamp: self2.timestamp,
        triggerType: messageAttemptTriggerType_1.MessageAttemptTriggerTypeSerializer._toJsonObject(self2.triggerType),
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseMessageAttemptOut.js
var require_listResponseMessageAttemptOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseMessageAttemptOutSerializer = undefined;
  var messageAttemptOut_1 = require_messageAttemptOut();
  exports.ListResponseMessageAttemptOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => messageAttemptOut_1.MessageAttemptOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => messageAttemptOut_1.MessageAttemptOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/messageEndpointOut.js
var require_messageEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageEndpointOutSerializer = undefined;
  var messageStatus_1 = require_messageStatus();
  var messageStatusText_1 = require_messageStatusText();
  exports.MessageEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        createdAt: new Date(object["createdAt"]),
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        id: object["id"],
        nextAttempt: object["nextAttempt"] ? new Date(object["nextAttempt"]) : null,
        rateLimit: object["rateLimit"],
        status: messageStatus_1.MessageStatusSerializer._fromJsonObject(object["status"]),
        statusText: messageStatusText_1.MessageStatusTextSerializer._fromJsonObject(object["statusText"]),
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"]),
        url: object["url"],
        version: object["version"]
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        createdAt: self2.createdAt,
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        id: self2.id,
        nextAttempt: self2.nextAttempt,
        rateLimit: self2.rateLimit,
        status: messageStatus_1.MessageStatusSerializer._toJsonObject(self2.status),
        statusText: messageStatusText_1.MessageStatusTextSerializer._toJsonObject(self2.statusText),
        uid: self2.uid,
        updatedAt: self2.updatedAt,
        url: self2.url,
        version: self2.version
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseMessageEndpointOut.js
var require_listResponseMessageEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseMessageEndpointOutSerializer = undefined;
  var messageEndpointOut_1 = require_messageEndpointOut();
  exports.ListResponseMessageEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => messageEndpointOut_1.MessageEndpointOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => messageEndpointOut_1.MessageEndpointOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/api/messageAttempt.js
var require_messageAttempt = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageAttempt = undefined;
  var emptyResponse_1 = require_emptyResponse();
  var listResponseEndpointMessageOut_1 = require_listResponseEndpointMessageOut();
  var listResponseMessageAttemptOut_1 = require_listResponseMessageAttemptOut();
  var listResponseMessageEndpointOut_1 = require_listResponseMessageEndpointOut();
  var messageAttemptOut_1 = require_messageAttemptOut();
  var request_1 = require_request3();

  class MessageAttempt {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    listByEndpoint(appId, endpointId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/attempt/endpoint/{endpoint_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        status: options === null || options === undefined ? undefined : options.status,
        status_code_class: options === null || options === undefined ? undefined : options.statusCodeClass,
        channel: options === null || options === undefined ? undefined : options.channel,
        tag: options === null || options === undefined ? undefined : options.tag,
        before: options === null || options === undefined ? undefined : options.before,
        after: options === null || options === undefined ? undefined : options.after,
        with_content: options === null || options === undefined ? undefined : options.withContent,
        with_msg: options === null || options === undefined ? undefined : options.withMsg,
        event_types: options === null || options === undefined ? undefined : options.eventTypes
      });
      return request.send(this.requestCtx, listResponseMessageAttemptOut_1.ListResponseMessageAttemptOutSerializer._fromJsonObject);
    }
    listByMsg(appId, msgId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/attempt/msg/{msg_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("msg_id", msgId);
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        status: options === null || options === undefined ? undefined : options.status,
        status_code_class: options === null || options === undefined ? undefined : options.statusCodeClass,
        channel: options === null || options === undefined ? undefined : options.channel,
        tag: options === null || options === undefined ? undefined : options.tag,
        endpoint_id: options === null || options === undefined ? undefined : options.endpointId,
        before: options === null || options === undefined ? undefined : options.before,
        after: options === null || options === undefined ? undefined : options.after,
        with_content: options === null || options === undefined ? undefined : options.withContent,
        event_types: options === null || options === undefined ? undefined : options.eventTypes
      });
      return request.send(this.requestCtx, listResponseMessageAttemptOut_1.ListResponseMessageAttemptOutSerializer._fromJsonObject);
    }
    listAttemptedMessages(appId, endpointId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/msg");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        channel: options === null || options === undefined ? undefined : options.channel,
        tag: options === null || options === undefined ? undefined : options.tag,
        status: options === null || options === undefined ? undefined : options.status,
        before: options === null || options === undefined ? undefined : options.before,
        after: options === null || options === undefined ? undefined : options.after,
        with_content: options === null || options === undefined ? undefined : options.withContent,
        event_types: options === null || options === undefined ? undefined : options.eventTypes
      });
      return request.send(this.requestCtx, listResponseEndpointMessageOut_1.ListResponseEndpointMessageOutSerializer._fromJsonObject);
    }
    get(appId, msgId, attemptId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/msg/{msg_id}/attempt/{attempt_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("msg_id", msgId);
      request.setPathParam("attempt_id", attemptId);
      return request.send(this.requestCtx, messageAttemptOut_1.MessageAttemptOutSerializer._fromJsonObject);
    }
    expungeContent(appId, msgId, attemptId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}/msg/{msg_id}/attempt/{attempt_id}/content");
      request.setPathParam("app_id", appId);
      request.setPathParam("msg_id", msgId);
      request.setPathParam("attempt_id", attemptId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    listAttemptedDestinations(appId, msgId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/msg/{msg_id}/endpoint");
      request.setPathParam("app_id", appId);
      request.setPathParam("msg_id", msgId);
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator
      });
      return request.send(this.requestCtx, listResponseMessageEndpointOut_1.ListResponseMessageEndpointOutSerializer._fromJsonObject);
    }
    resend(appId, msgId, endpointId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/msg/{msg_id}/endpoint/{endpoint_id}/resend");
      request.setPathParam("app_id", appId);
      request.setPathParam("msg_id", msgId);
      request.setPathParam("endpoint_id", endpointId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      return request.send(this.requestCtx, emptyResponse_1.EmptyResponseSerializer._fromJsonObject);
    }
  }
  exports.MessageAttempt = MessageAttempt;
});

// node_modules/svix/dist/models/operationalWebhookEndpointOut.js
var require_operationalWebhookEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpointOutSerializer = undefined;
  exports.OperationalWebhookEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        createdAt: new Date(object["createdAt"]),
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        id: object["id"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"]),
        url: object["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        createdAt: self2.createdAt,
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        id: self2.id,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        uid: self2.uid,
        updatedAt: self2.updatedAt,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseOperationalWebhookEndpointOut.js
var require_listResponseOperationalWebhookEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseOperationalWebhookEndpointOutSerializer = undefined;
  var operationalWebhookEndpointOut_1 = require_operationalWebhookEndpointOut();
  exports.ListResponseOperationalWebhookEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/operationalWebhookEndpointHeadersIn.js
var require_operationalWebhookEndpointHeadersIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpointHeadersInSerializer = undefined;
  exports.OperationalWebhookEndpointHeadersInSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers
      };
    }
  };
});

// node_modules/svix/dist/models/operationalWebhookEndpointHeadersOut.js
var require_operationalWebhookEndpointHeadersOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpointHeadersOutSerializer = undefined;
  exports.OperationalWebhookEndpointHeadersOutSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"],
        sensitive: object["sensitive"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers,
        sensitive: self2.sensitive
      };
    }
  };
});

// node_modules/svix/dist/models/operationalWebhookEndpointIn.js
var require_operationalWebhookEndpointIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpointInSerializer = undefined;
  exports.OperationalWebhookEndpointInSerializer = {
    _fromJsonObject(object) {
      return {
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        secret: object["secret"],
        uid: object["uid"],
        url: object["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        secret: self2.secret,
        uid: self2.uid,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/operationalWebhookEndpointSecretIn.js
var require_operationalWebhookEndpointSecretIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpointSecretInSerializer = undefined;
  exports.OperationalWebhookEndpointSecretInSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/operationalWebhookEndpointSecretOut.js
var require_operationalWebhookEndpointSecretOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpointSecretOutSerializer = undefined;
  exports.OperationalWebhookEndpointSecretOutSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/operationalWebhookEndpointUpdate.js
var require_operationalWebhookEndpointUpdate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpointUpdateSerializer = undefined;
  exports.OperationalWebhookEndpointUpdateSerializer = {
    _fromJsonObject(object) {
      return {
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        uid: object["uid"],
        url: object["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        uid: self2.uid,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/api/operationalWebhookEndpoint.js
var require_operationalWebhookEndpoint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpoint = undefined;
  var listResponseOperationalWebhookEndpointOut_1 = require_listResponseOperationalWebhookEndpointOut();
  var operationalWebhookEndpointHeadersIn_1 = require_operationalWebhookEndpointHeadersIn();
  var operationalWebhookEndpointHeadersOut_1 = require_operationalWebhookEndpointHeadersOut();
  var operationalWebhookEndpointIn_1 = require_operationalWebhookEndpointIn();
  var operationalWebhookEndpointOut_1 = require_operationalWebhookEndpointOut();
  var operationalWebhookEndpointSecretIn_1 = require_operationalWebhookEndpointSecretIn();
  var operationalWebhookEndpointSecretOut_1 = require_operationalWebhookEndpointSecretOut();
  var operationalWebhookEndpointUpdate_1 = require_operationalWebhookEndpointUpdate();
  var request_1 = require_request3();

  class OperationalWebhookEndpoint {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/operational-webhook/endpoint");
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        order: options === null || options === undefined ? undefined : options.order
      });
      return request.send(this.requestCtx, listResponseOperationalWebhookEndpointOut_1.ListResponseOperationalWebhookEndpointOutSerializer._fromJsonObject);
    }
    create(operationalWebhookEndpointIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/operational-webhook/endpoint");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(operationalWebhookEndpointIn_1.OperationalWebhookEndpointInSerializer._toJsonObject(operationalWebhookEndpointIn));
      return request.send(this.requestCtx, operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._fromJsonObject);
    }
    get(endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/operational-webhook/endpoint/{endpoint_id}");
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._fromJsonObject);
    }
    update(endpointId, operationalWebhookEndpointUpdate) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/operational-webhook/endpoint/{endpoint_id}");
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(operationalWebhookEndpointUpdate_1.OperationalWebhookEndpointUpdateSerializer._toJsonObject(operationalWebhookEndpointUpdate));
      return request.send(this.requestCtx, operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._fromJsonObject);
    }
    delete(endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/operational-webhook/endpoint/{endpoint_id}");
      request.setPathParam("endpoint_id", endpointId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    getHeaders(endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/operational-webhook/endpoint/{endpoint_id}/headers");
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, operationalWebhookEndpointHeadersOut_1.OperationalWebhookEndpointHeadersOutSerializer._fromJsonObject);
    }
    updateHeaders(endpointId, operationalWebhookEndpointHeadersIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/operational-webhook/endpoint/{endpoint_id}/headers");
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(operationalWebhookEndpointHeadersIn_1.OperationalWebhookEndpointHeadersInSerializer._toJsonObject(operationalWebhookEndpointHeadersIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
    getSecret(endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/operational-webhook/endpoint/{endpoint_id}/secret");
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, operationalWebhookEndpointSecretOut_1.OperationalWebhookEndpointSecretOutSerializer._fromJsonObject);
    }
    rotateSecret(endpointId, operationalWebhookEndpointSecretIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/operational-webhook/endpoint/{endpoint_id}/secret/rotate");
      request.setPathParam("endpoint_id", endpointId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(operationalWebhookEndpointSecretIn_1.OperationalWebhookEndpointSecretInSerializer._toJsonObject(operationalWebhookEndpointSecretIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
  }
  exports.OperationalWebhookEndpoint = OperationalWebhookEndpoint;
});

// node_modules/svix/dist/api/operationalWebhook.js
var require_operationalWebhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhook = undefined;
  var operationalWebhookEndpoint_1 = require_operationalWebhookEndpoint();

  class OperationalWebhook {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    get endpoint() {
      return new operationalWebhookEndpoint_1.OperationalWebhookEndpoint(this.requestCtx);
    }
  }
  exports.OperationalWebhook = OperationalWebhook;
});

// node_modules/svix/dist/models/aggregateEventTypesOut.js
var require_aggregateEventTypesOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregateEventTypesOutSerializer = undefined;
  var backgroundTaskStatus_1 = require_backgroundTaskStatus();
  var backgroundTaskType_1 = require_backgroundTaskType();
  exports.AggregateEventTypesOutSerializer = {
    _fromJsonObject(object) {
      return {
        id: object["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object["task"])
      };
    },
    _toJsonObject(self2) {
      return {
        id: self2.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self2.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self2.task)
      };
    }
  };
});

// node_modules/svix/dist/models/appUsageStatsIn.js
var require_appUsageStatsIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AppUsageStatsInSerializer = undefined;
  exports.AppUsageStatsInSerializer = {
    _fromJsonObject(object) {
      return {
        appIds: object["appIds"],
        since: new Date(object["since"]),
        until: new Date(object["until"])
      };
    },
    _toJsonObject(self2) {
      return {
        appIds: self2.appIds,
        since: self2.since,
        until: self2.until
      };
    }
  };
});

// node_modules/svix/dist/models/appUsageStatsOut.js
var require_appUsageStatsOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AppUsageStatsOutSerializer = undefined;
  var backgroundTaskStatus_1 = require_backgroundTaskStatus();
  var backgroundTaskType_1 = require_backgroundTaskType();
  exports.AppUsageStatsOutSerializer = {
    _fromJsonObject(object) {
      return {
        id: object["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object["task"]),
        unresolvedAppIds: object["unresolvedAppIds"]
      };
    },
    _toJsonObject(self2) {
      return {
        id: self2.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self2.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self2.task),
        unresolvedAppIds: self2.unresolvedAppIds
      };
    }
  };
});

// node_modules/svix/dist/api/statistics.js
var require_statistics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Statistics = undefined;
  var aggregateEventTypesOut_1 = require_aggregateEventTypesOut();
  var appUsageStatsIn_1 = require_appUsageStatsIn();
  var appUsageStatsOut_1 = require_appUsageStatsOut();
  var request_1 = require_request3();

  class Statistics {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    aggregateAppStats(appUsageStatsIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/stats/usage/app");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(appUsageStatsIn_1.AppUsageStatsInSerializer._toJsonObject(appUsageStatsIn));
      return request.send(this.requestCtx, appUsageStatsOut_1.AppUsageStatsOutSerializer._fromJsonObject);
    }
    aggregateEventTypes() {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/stats/usage/event-types");
      return request.send(this.requestCtx, aggregateEventTypesOut_1.AggregateEventTypesOutSerializer._fromJsonObject);
    }
  }
  exports.Statistics = Statistics;
});

// node_modules/svix/dist/models/httpSinkHeadersPatchIn.js
var require_httpSinkHeadersPatchIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpSinkHeadersPatchInSerializer = undefined;
  exports.HttpSinkHeadersPatchInSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers
      };
    }
  };
});

// node_modules/svix/dist/models/sinkTransformationOut.js
var require_sinkTransformationOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SinkTransformationOutSerializer = undefined;
  exports.SinkTransformationOutSerializer = {
    _fromJsonObject(object) {
      return {
        code: object["code"],
        enabled: object["enabled"]
      };
    },
    _toJsonObject(self2) {
      return {
        code: self2.code,
        enabled: self2.enabled
      };
    }
  };
});

// node_modules/svix/dist/models/streamEventTypeOut.js
var require_streamEventTypeOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamEventTypeOutSerializer = undefined;
  exports.StreamEventTypeOutSerializer = {
    _fromJsonObject(object) {
      return {
        archived: object["archived"],
        createdAt: new Date(object["createdAt"]),
        deprecated: object["deprecated"],
        description: object["description"],
        featureFlags: object["featureFlags"],
        name: object["name"],
        updatedAt: new Date(object["updatedAt"])
      };
    },
    _toJsonObject(self2) {
      return {
        archived: self2.archived,
        createdAt: self2.createdAt,
        deprecated: self2.deprecated,
        description: self2.description,
        featureFlags: self2.featureFlags,
        name: self2.name,
        updatedAt: self2.updatedAt
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseStreamEventTypeOut.js
var require_listResponseStreamEventTypeOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseStreamEventTypeOutSerializer = undefined;
  var streamEventTypeOut_1 = require_streamEventTypeOut();
  exports.ListResponseStreamEventTypeOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => streamEventTypeOut_1.StreamEventTypeOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => streamEventTypeOut_1.StreamEventTypeOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/streamEventTypeIn.js
var require_streamEventTypeIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamEventTypeInSerializer = undefined;
  exports.StreamEventTypeInSerializer = {
    _fromJsonObject(object) {
      return {
        archived: object["archived"],
        deprecated: object["deprecated"],
        description: object["description"],
        featureFlags: object["featureFlags"],
        name: object["name"]
      };
    },
    _toJsonObject(self2) {
      return {
        archived: self2.archived,
        deprecated: self2.deprecated,
        description: self2.description,
        featureFlags: self2.featureFlags,
        name: self2.name
      };
    }
  };
});

// node_modules/svix/dist/models/streamEventTypePatch.js
var require_streamEventTypePatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamEventTypePatchSerializer = undefined;
  exports.StreamEventTypePatchSerializer = {
    _fromJsonObject(object) {
      return {
        archived: object["archived"],
        deprecated: object["deprecated"],
        description: object["description"],
        featureFlags: object["featureFlags"],
        name: object["name"]
      };
    },
    _toJsonObject(self2) {
      return {
        archived: self2.archived,
        deprecated: self2.deprecated,
        description: self2.description,
        featureFlags: self2.featureFlags,
        name: self2.name
      };
    }
  };
});

// node_modules/svix/dist/api/streamingEventType.js
var require_streamingEventType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamingEventType = undefined;
  var listResponseStreamEventTypeOut_1 = require_listResponseStreamEventTypeOut();
  var streamEventTypeIn_1 = require_streamEventTypeIn();
  var streamEventTypeOut_1 = require_streamEventTypeOut();
  var streamEventTypePatch_1 = require_streamEventTypePatch();
  var request_1 = require_request3();

  class StreamingEventType {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/stream/event-type");
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        order: options === null || options === undefined ? undefined : options.order,
        include_archived: options === null || options === undefined ? undefined : options.includeArchived
      });
      return request.send(this.requestCtx, listResponseStreamEventTypeOut_1.ListResponseStreamEventTypeOutSerializer._fromJsonObject);
    }
    create(streamEventTypeIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/stream/event-type");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(streamEventTypeIn_1.StreamEventTypeInSerializer._toJsonObject(streamEventTypeIn));
      return request.send(this.requestCtx, streamEventTypeOut_1.StreamEventTypeOutSerializer._fromJsonObject);
    }
    get(name) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/stream/event-type/{name}");
      request.setPathParam("name", name);
      return request.send(this.requestCtx, streamEventTypeOut_1.StreamEventTypeOutSerializer._fromJsonObject);
    }
    update(name, streamEventTypeIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/stream/event-type/{name}");
      request.setPathParam("name", name);
      request.setBody(streamEventTypeIn_1.StreamEventTypeInSerializer._toJsonObject(streamEventTypeIn));
      return request.send(this.requestCtx, streamEventTypeOut_1.StreamEventTypeOutSerializer._fromJsonObject);
    }
    delete(name, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/stream/event-type/{name}");
      request.setPathParam("name", name);
      request.setQueryParams({
        expunge: options === null || options === undefined ? undefined : options.expunge
      });
      return request.sendNoResponseBody(this.requestCtx);
    }
    patch(name, streamEventTypePatch) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/stream/event-type/{name}");
      request.setPathParam("name", name);
      request.setBody(streamEventTypePatch_1.StreamEventTypePatchSerializer._toJsonObject(streamEventTypePatch));
      return request.send(this.requestCtx, streamEventTypeOut_1.StreamEventTypeOutSerializer._fromJsonObject);
    }
  }
  exports.StreamingEventType = StreamingEventType;
});

// node_modules/svix/dist/models/eventIn.js
var require_eventIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventInSerializer = undefined;
  exports.EventInSerializer = {
    _fromJsonObject(object) {
      return {
        eventType: object["eventType"],
        payload: object["payload"]
      };
    },
    _toJsonObject(self2) {
      return {
        eventType: self2.eventType,
        payload: self2.payload
      };
    }
  };
});

// node_modules/svix/dist/models/streamIn.js
var require_streamIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamInSerializer = undefined;
  exports.StreamInSerializer = {
    _fromJsonObject(object) {
      return {
        metadata: object["metadata"],
        name: object["name"],
        uid: object["uid"]
      };
    },
    _toJsonObject(self2) {
      return {
        metadata: self2.metadata,
        name: self2.name,
        uid: self2.uid
      };
    }
  };
});

// node_modules/svix/dist/models/createStreamEventsIn.js
var require_createStreamEventsIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateStreamEventsInSerializer = undefined;
  var eventIn_1 = require_eventIn();
  var streamIn_1 = require_streamIn();
  exports.CreateStreamEventsInSerializer = {
    _fromJsonObject(object) {
      return {
        events: object["events"].map((item) => eventIn_1.EventInSerializer._fromJsonObject(item)),
        stream: object["stream"] ? streamIn_1.StreamInSerializer._fromJsonObject(object["stream"]) : undefined
      };
    },
    _toJsonObject(self2) {
      return {
        events: self2.events.map((item) => eventIn_1.EventInSerializer._toJsonObject(item)),
        stream: self2.stream ? streamIn_1.StreamInSerializer._toJsonObject(self2.stream) : undefined
      };
    }
  };
});

// node_modules/svix/dist/models/createStreamEventsOut.js
var require_createStreamEventsOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateStreamEventsOutSerializer = undefined;
  exports.CreateStreamEventsOutSerializer = {
    _fromJsonObject(_object) {
      return {};
    },
    _toJsonObject(_self) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/eventOut.js
var require_eventOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventOutSerializer = undefined;
  exports.EventOutSerializer = {
    _fromJsonObject(object) {
      return {
        eventType: object["eventType"],
        payload: object["payload"],
        timestamp: new Date(object["timestamp"])
      };
    },
    _toJsonObject(self2) {
      return {
        eventType: self2.eventType,
        payload: self2.payload,
        timestamp: self2.timestamp
      };
    }
  };
});

// node_modules/svix/dist/models/eventStreamOut.js
var require_eventStreamOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventStreamOutSerializer = undefined;
  var eventOut_1 = require_eventOut();
  exports.EventStreamOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => eventOut_1.EventOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => eventOut_1.EventOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator
      };
    }
  };
});

// node_modules/svix/dist/api/streamingEvents.js
var require_streamingEvents = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamingEvents = undefined;
  var createStreamEventsIn_1 = require_createStreamEventsIn();
  var createStreamEventsOut_1 = require_createStreamEventsOut();
  var eventStreamOut_1 = require_eventStreamOut();
  var request_1 = require_request3();

  class StreamingEvents {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    create(streamId, createStreamEventsIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/stream/{stream_id}/events");
      request.setPathParam("stream_id", streamId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(createStreamEventsIn_1.CreateStreamEventsInSerializer._toJsonObject(createStreamEventsIn));
      return request.send(this.requestCtx, createStreamEventsOut_1.CreateStreamEventsOutSerializer._fromJsonObject);
    }
    get(streamId, sinkId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/stream/{stream_id}/sink/{sink_id}/events");
      request.setPathParam("stream_id", streamId);
      request.setPathParam("sink_id", sinkId);
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        after: options === null || options === undefined ? undefined : options.after
      });
      return request.send(this.requestCtx, eventStreamOut_1.EventStreamOutSerializer._fromJsonObject);
    }
  }
  exports.StreamingEvents = StreamingEvents;
});

// node_modules/svix/dist/models/azureBlobStorageConfig.js
var require_azureBlobStorageConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureBlobStorageConfigSerializer = undefined;
  exports.AzureBlobStorageConfigSerializer = {
    _fromJsonObject(object) {
      return {
        accessKey: object["accessKey"],
        account: object["account"],
        container: object["container"]
      };
    },
    _toJsonObject(self2) {
      return {
        accessKey: self2.accessKey,
        account: self2.account,
        container: self2.container
      };
    }
  };
});

// node_modules/svix/dist/models/googleCloudStorageConfig.js
var require_googleCloudStorageConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GoogleCloudStorageConfigSerializer = undefined;
  exports.GoogleCloudStorageConfigSerializer = {
    _fromJsonObject(object) {
      return {
        bucket: object["bucket"],
        credentials: object["credentials"]
      };
    },
    _toJsonObject(self2) {
      return {
        bucket: self2.bucket,
        credentials: self2.credentials
      };
    }
  };
});

// node_modules/svix/dist/models/s3Config.js
var require_s3Config = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.S3ConfigSerializer = undefined;
  exports.S3ConfigSerializer = {
    _fromJsonObject(object) {
      return {
        accessKeyId: object["accessKeyId"],
        bucket: object["bucket"],
        region: object["region"],
        secretAccessKey: object["secretAccessKey"]
      };
    },
    _toJsonObject(self2) {
      return {
        accessKeyId: self2.accessKeyId,
        bucket: self2.bucket,
        region: self2.region,
        secretAccessKey: self2.secretAccessKey
      };
    }
  };
});

// node_modules/svix/dist/models/sinkHttpConfig.js
var require_sinkHttpConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SinkHttpConfigSerializer = undefined;
  exports.SinkHttpConfigSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"],
        key: object["key"],
        url: object["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers,
        key: self2.key,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/sinkOtelV1Config.js
var require_sinkOtelV1Config = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SinkOtelV1ConfigSerializer = undefined;
  exports.SinkOtelV1ConfigSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"],
        url: object["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/sinkStatus.js
var require_sinkStatus = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SinkStatusSerializer = exports.SinkStatus = undefined;
  var SinkStatus;
  (function(SinkStatus2) {
    SinkStatus2["Enabled"] = "enabled";
    SinkStatus2["Paused"] = "paused";
    SinkStatus2["Disabled"] = "disabled";
    SinkStatus2["Retrying"] = "retrying";
  })(SinkStatus = exports.SinkStatus || (exports.SinkStatus = {}));
  exports.SinkStatusSerializer = {
    _fromJsonObject(object) {
      return object;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/streamSinkOut.js
var require_streamSinkOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamSinkOutSerializer = undefined;
  var azureBlobStorageConfig_1 = require_azureBlobStorageConfig();
  var googleCloudStorageConfig_1 = require_googleCloudStorageConfig();
  var s3Config_1 = require_s3Config();
  var sinkHttpConfig_1 = require_sinkHttpConfig();
  var sinkOtelV1Config_1 = require_sinkOtelV1Config();
  var sinkStatus_1 = require_sinkStatus();
  exports.StreamSinkOutSerializer = {
    _fromJsonObject(object) {
      const type = object["type"];
      function getConfig(type2) {
        switch (type2) {
          case "poller":
            return {};
          case "azureBlobStorage":
            return azureBlobStorageConfig_1.AzureBlobStorageConfigSerializer._fromJsonObject(object["config"]);
          case "otelTracing":
            return sinkOtelV1Config_1.SinkOtelV1ConfigSerializer._fromJsonObject(object["config"]);
          case "http":
            return sinkHttpConfig_1.SinkHttpConfigSerializer._fromJsonObject(object["config"]);
          case "amazonS3":
            return s3Config_1.S3ConfigSerializer._fromJsonObject(object["config"]);
          case "googleCloudStorage":
            return googleCloudStorageConfig_1.GoogleCloudStorageConfigSerializer._fromJsonObject(object["config"]);
          default:
            throw new Error(`Unexpected type: ${type2}`);
        }
      }
      return {
        type,
        config: getConfig(type),
        batchSize: object["batchSize"],
        createdAt: new Date(object["createdAt"]),
        currentIterator: object["currentIterator"],
        eventTypes: object["eventTypes"],
        failureReason: object["failureReason"],
        id: object["id"],
        maxWaitSecs: object["maxWaitSecs"],
        metadata: object["metadata"],
        nextRetryAt: object["nextRetryAt"] ? new Date(object["nextRetryAt"]) : null,
        status: sinkStatus_1.SinkStatusSerializer._fromJsonObject(object["status"]),
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"])
      };
    },
    _toJsonObject(self2) {
      let config;
      switch (self2.type) {
        case "poller":
          config = {};
          break;
        case "azureBlobStorage":
          config = azureBlobStorageConfig_1.AzureBlobStorageConfigSerializer._toJsonObject(self2.config);
          break;
        case "otelTracing":
          config = sinkOtelV1Config_1.SinkOtelV1ConfigSerializer._toJsonObject(self2.config);
          break;
        case "http":
          config = sinkHttpConfig_1.SinkHttpConfigSerializer._toJsonObject(self2.config);
          break;
        case "amazonS3":
          config = s3Config_1.S3ConfigSerializer._toJsonObject(self2.config);
          break;
        case "googleCloudStorage":
          config = googleCloudStorageConfig_1.GoogleCloudStorageConfigSerializer._toJsonObject(self2.config);
          break;
      }
      return {
        type: self2.type,
        config,
        batchSize: self2.batchSize,
        createdAt: self2.createdAt,
        currentIterator: self2.currentIterator,
        eventTypes: self2.eventTypes,
        failureReason: self2.failureReason,
        id: self2.id,
        maxWaitSecs: self2.maxWaitSecs,
        metadata: self2.metadata,
        nextRetryAt: self2.nextRetryAt,
        status: sinkStatus_1.SinkStatusSerializer._toJsonObject(self2.status),
        uid: self2.uid,
        updatedAt: self2.updatedAt
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseStreamSinkOut.js
var require_listResponseStreamSinkOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseStreamSinkOutSerializer = undefined;
  var streamSinkOut_1 = require_streamSinkOut();
  exports.ListResponseStreamSinkOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => streamSinkOut_1.StreamSinkOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => streamSinkOut_1.StreamSinkOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/sinkSecretOut.js
var require_sinkSecretOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SinkSecretOutSerializer = undefined;
  exports.SinkSecretOutSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/sinkTransformIn.js
var require_sinkTransformIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SinkTransformInSerializer = undefined;
  exports.SinkTransformInSerializer = {
    _fromJsonObject(object) {
      return {
        code: object["code"]
      };
    },
    _toJsonObject(self2) {
      return {
        code: self2.code
      };
    }
  };
});

// node_modules/svix/dist/models/sinkStatusIn.js
var require_sinkStatusIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SinkStatusInSerializer = exports.SinkStatusIn = undefined;
  var SinkStatusIn;
  (function(SinkStatusIn2) {
    SinkStatusIn2["Enabled"] = "enabled";
    SinkStatusIn2["Disabled"] = "disabled";
  })(SinkStatusIn = exports.SinkStatusIn || (exports.SinkStatusIn = {}));
  exports.SinkStatusInSerializer = {
    _fromJsonObject(object) {
      return object;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/streamSinkIn.js
var require_streamSinkIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamSinkInSerializer = undefined;
  var azureBlobStorageConfig_1 = require_azureBlobStorageConfig();
  var googleCloudStorageConfig_1 = require_googleCloudStorageConfig();
  var s3Config_1 = require_s3Config();
  var sinkHttpConfig_1 = require_sinkHttpConfig();
  var sinkOtelV1Config_1 = require_sinkOtelV1Config();
  var sinkStatusIn_1 = require_sinkStatusIn();
  exports.StreamSinkInSerializer = {
    _fromJsonObject(object) {
      const type = object["type"];
      function getConfig(type2) {
        switch (type2) {
          case "poller":
            return {};
          case "azureBlobStorage":
            return azureBlobStorageConfig_1.AzureBlobStorageConfigSerializer._fromJsonObject(object["config"]);
          case "otelTracing":
            return sinkOtelV1Config_1.SinkOtelV1ConfigSerializer._fromJsonObject(object["config"]);
          case "http":
            return sinkHttpConfig_1.SinkHttpConfigSerializer._fromJsonObject(object["config"]);
          case "amazonS3":
            return s3Config_1.S3ConfigSerializer._fromJsonObject(object["config"]);
          case "googleCloudStorage":
            return googleCloudStorageConfig_1.GoogleCloudStorageConfigSerializer._fromJsonObject(object["config"]);
          default:
            throw new Error(`Unexpected type: ${type2}`);
        }
      }
      return {
        type,
        config: getConfig(type),
        batchSize: object["batchSize"],
        eventTypes: object["eventTypes"],
        maxWaitSecs: object["maxWaitSecs"],
        metadata: object["metadata"],
        status: object["status"] ? sinkStatusIn_1.SinkStatusInSerializer._fromJsonObject(object["status"]) : undefined,
        uid: object["uid"]
      };
    },
    _toJsonObject(self2) {
      let config;
      switch (self2.type) {
        case "poller":
          config = {};
          break;
        case "azureBlobStorage":
          config = azureBlobStorageConfig_1.AzureBlobStorageConfigSerializer._toJsonObject(self2.config);
          break;
        case "otelTracing":
          config = sinkOtelV1Config_1.SinkOtelV1ConfigSerializer._toJsonObject(self2.config);
          break;
        case "http":
          config = sinkHttpConfig_1.SinkHttpConfigSerializer._toJsonObject(self2.config);
          break;
        case "amazonS3":
          config = s3Config_1.S3ConfigSerializer._toJsonObject(self2.config);
          break;
        case "googleCloudStorage":
          config = googleCloudStorageConfig_1.GoogleCloudStorageConfigSerializer._toJsonObject(self2.config);
          break;
      }
      return {
        type: self2.type,
        config,
        batchSize: self2.batchSize,
        eventTypes: self2.eventTypes,
        maxWaitSecs: self2.maxWaitSecs,
        metadata: self2.metadata,
        status: self2.status ? sinkStatusIn_1.SinkStatusInSerializer._toJsonObject(self2.status) : undefined,
        uid: self2.uid
      };
    }
  };
});

// node_modules/svix/dist/models/amazonS3PatchConfig.js
var require_amazonS3PatchConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AmazonS3PatchConfigSerializer = undefined;
  exports.AmazonS3PatchConfigSerializer = {
    _fromJsonObject(object) {
      return {
        accessKeyId: object["accessKeyId"],
        bucket: object["bucket"],
        region: object["region"],
        secretAccessKey: object["secretAccessKey"]
      };
    },
    _toJsonObject(self2) {
      return {
        accessKeyId: self2.accessKeyId,
        bucket: self2.bucket,
        region: self2.region,
        secretAccessKey: self2.secretAccessKey
      };
    }
  };
});

// node_modules/svix/dist/models/azureBlobStoragePatchConfig.js
var require_azureBlobStoragePatchConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureBlobStoragePatchConfigSerializer = undefined;
  exports.AzureBlobStoragePatchConfigSerializer = {
    _fromJsonObject(object) {
      return {
        accessKey: object["accessKey"],
        account: object["account"],
        container: object["container"]
      };
    },
    _toJsonObject(self2) {
      return {
        accessKey: self2.accessKey,
        account: self2.account,
        container: self2.container
      };
    }
  };
});

// node_modules/svix/dist/models/googleCloudStoragePatchConfig.js
var require_googleCloudStoragePatchConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GoogleCloudStoragePatchConfigSerializer = undefined;
  exports.GoogleCloudStoragePatchConfigSerializer = {
    _fromJsonObject(object) {
      return {
        bucket: object["bucket"],
        credentials: object["credentials"]
      };
    },
    _toJsonObject(self2) {
      return {
        bucket: self2.bucket,
        credentials: self2.credentials
      };
    }
  };
});

// node_modules/svix/dist/models/httpPatchConfig.js
var require_httpPatchConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpPatchConfigSerializer = undefined;
  exports.HttpPatchConfigSerializer = {
    _fromJsonObject(object) {
      return {
        url: object["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/otelTracingPatchConfig.js
var require_otelTracingPatchConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OtelTracingPatchConfigSerializer = undefined;
  exports.OtelTracingPatchConfigSerializer = {
    _fromJsonObject(object) {
      return {
        url: object["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/streamSinkPatch.js
var require_streamSinkPatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamSinkPatchSerializer = undefined;
  var amazonS3PatchConfig_1 = require_amazonS3PatchConfig();
  var azureBlobStoragePatchConfig_1 = require_azureBlobStoragePatchConfig();
  var googleCloudStoragePatchConfig_1 = require_googleCloudStoragePatchConfig();
  var httpPatchConfig_1 = require_httpPatchConfig();
  var otelTracingPatchConfig_1 = require_otelTracingPatchConfig();
  var sinkStatusIn_1 = require_sinkStatusIn();
  exports.StreamSinkPatchSerializer = {
    _fromJsonObject(object) {
      const type = object["type"];
      function getConfig(type2) {
        switch (type2) {
          case "poller":
            return {};
          case "azureBlobStorage":
            return azureBlobStoragePatchConfig_1.AzureBlobStoragePatchConfigSerializer._fromJsonObject(object["config"]);
          case "otelTracing":
            return otelTracingPatchConfig_1.OtelTracingPatchConfigSerializer._fromJsonObject(object["config"]);
          case "http":
            return httpPatchConfig_1.HttpPatchConfigSerializer._fromJsonObject(object["config"]);
          case "amazonS3":
            return amazonS3PatchConfig_1.AmazonS3PatchConfigSerializer._fromJsonObject(object["config"]);
          case "googleCloudStorage":
            return googleCloudStoragePatchConfig_1.GoogleCloudStoragePatchConfigSerializer._fromJsonObject(object["config"]);
          default:
            throw new Error(`Unexpected type: ${type2}`);
        }
      }
      return {
        type,
        config: getConfig(type),
        batchSize: object["batchSize"],
        eventTypes: object["eventTypes"],
        maxWaitSecs: object["maxWaitSecs"],
        metadata: object["metadata"],
        status: object["status"] ? sinkStatusIn_1.SinkStatusInSerializer._fromJsonObject(object["status"]) : undefined,
        uid: object["uid"]
      };
    },
    _toJsonObject(self2) {
      let config;
      switch (self2.type) {
        case "poller":
          config = {};
          break;
        case "azureBlobStorage":
          config = azureBlobStoragePatchConfig_1.AzureBlobStoragePatchConfigSerializer._toJsonObject(self2.config);
          break;
        case "otelTracing":
          config = otelTracingPatchConfig_1.OtelTracingPatchConfigSerializer._toJsonObject(self2.config);
          break;
        case "http":
          config = httpPatchConfig_1.HttpPatchConfigSerializer._toJsonObject(self2.config);
          break;
        case "amazonS3":
          config = amazonS3PatchConfig_1.AmazonS3PatchConfigSerializer._toJsonObject(self2.config);
          break;
        case "googleCloudStorage":
          config = googleCloudStoragePatchConfig_1.GoogleCloudStoragePatchConfigSerializer._toJsonObject(self2.config);
          break;
      }
      return {
        type: self2.type,
        config,
        batchSize: self2.batchSize,
        eventTypes: self2.eventTypes,
        maxWaitSecs: self2.maxWaitSecs,
        metadata: self2.metadata,
        status: self2.status ? sinkStatusIn_1.SinkStatusInSerializer._toJsonObject(self2.status) : undefined,
        uid: self2.uid
      };
    }
  };
});

// node_modules/svix/dist/api/streamingSink.js
var require_streamingSink = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamingSink = undefined;
  var emptyResponse_1 = require_emptyResponse();
  var endpointSecretRotateIn_1 = require_endpointSecretRotateIn();
  var listResponseStreamSinkOut_1 = require_listResponseStreamSinkOut();
  var sinkSecretOut_1 = require_sinkSecretOut();
  var sinkTransformIn_1 = require_sinkTransformIn();
  var streamSinkIn_1 = require_streamSinkIn();
  var streamSinkOut_1 = require_streamSinkOut();
  var streamSinkPatch_1 = require_streamSinkPatch();
  var request_1 = require_request3();

  class StreamingSink {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(streamId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/stream/{stream_id}/sink");
      request.setPathParam("stream_id", streamId);
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        order: options === null || options === undefined ? undefined : options.order
      });
      return request.send(this.requestCtx, listResponseStreamSinkOut_1.ListResponseStreamSinkOutSerializer._fromJsonObject);
    }
    create(streamId, streamSinkIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/stream/{stream_id}/sink");
      request.setPathParam("stream_id", streamId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(streamSinkIn_1.StreamSinkInSerializer._toJsonObject(streamSinkIn));
      return request.send(this.requestCtx, streamSinkOut_1.StreamSinkOutSerializer._fromJsonObject);
    }
    get(streamId, sinkId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/stream/{stream_id}/sink/{sink_id}");
      request.setPathParam("stream_id", streamId);
      request.setPathParam("sink_id", sinkId);
      return request.send(this.requestCtx, streamSinkOut_1.StreamSinkOutSerializer._fromJsonObject);
    }
    update(streamId, sinkId, streamSinkIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/stream/{stream_id}/sink/{sink_id}");
      request.setPathParam("stream_id", streamId);
      request.setPathParam("sink_id", sinkId);
      request.setBody(streamSinkIn_1.StreamSinkInSerializer._toJsonObject(streamSinkIn));
      return request.send(this.requestCtx, streamSinkOut_1.StreamSinkOutSerializer._fromJsonObject);
    }
    delete(streamId, sinkId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/stream/{stream_id}/sink/{sink_id}");
      request.setPathParam("stream_id", streamId);
      request.setPathParam("sink_id", sinkId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    patch(streamId, sinkId, streamSinkPatch) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/stream/{stream_id}/sink/{sink_id}");
      request.setPathParam("stream_id", streamId);
      request.setPathParam("sink_id", sinkId);
      request.setBody(streamSinkPatch_1.StreamSinkPatchSerializer._toJsonObject(streamSinkPatch));
      return request.send(this.requestCtx, streamSinkOut_1.StreamSinkOutSerializer._fromJsonObject);
    }
    getSecret(streamId, sinkId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/stream/{stream_id}/sink/{sink_id}/secret");
      request.setPathParam("stream_id", streamId);
      request.setPathParam("sink_id", sinkId);
      return request.send(this.requestCtx, sinkSecretOut_1.SinkSecretOutSerializer._fromJsonObject);
    }
    rotateSecret(streamId, sinkId, endpointSecretRotateIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/stream/{stream_id}/sink/{sink_id}/secret/rotate");
      request.setPathParam("stream_id", streamId);
      request.setPathParam("sink_id", sinkId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(endpointSecretRotateIn_1.EndpointSecretRotateInSerializer._toJsonObject(endpointSecretRotateIn));
      return request.send(this.requestCtx, emptyResponse_1.EmptyResponseSerializer._fromJsonObject);
    }
    transformationPartialUpdate(streamId, sinkId, sinkTransformIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/stream/{stream_id}/sink/{sink_id}/transformation");
      request.setPathParam("stream_id", streamId);
      request.setPathParam("sink_id", sinkId);
      request.setBody(sinkTransformIn_1.SinkTransformInSerializer._toJsonObject(sinkTransformIn));
      return request.send(this.requestCtx, emptyResponse_1.EmptyResponseSerializer._fromJsonObject);
    }
  }
  exports.StreamingSink = StreamingSink;
});

// node_modules/svix/dist/models/streamOut.js
var require_streamOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamOutSerializer = undefined;
  exports.StreamOutSerializer = {
    _fromJsonObject(object) {
      return {
        createdAt: new Date(object["createdAt"]),
        id: object["id"],
        metadata: object["metadata"],
        name: object["name"],
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"])
      };
    },
    _toJsonObject(self2) {
      return {
        createdAt: self2.createdAt,
        id: self2.id,
        metadata: self2.metadata,
        name: self2.name,
        uid: self2.uid,
        updatedAt: self2.updatedAt
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseStreamOut.js
var require_listResponseStreamOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseStreamOutSerializer = undefined;
  var streamOut_1 = require_streamOut();
  exports.ListResponseStreamOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => streamOut_1.StreamOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => streamOut_1.StreamOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/streamPatch.js
var require_streamPatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamPatchSerializer = undefined;
  exports.StreamPatchSerializer = {
    _fromJsonObject(object) {
      return {
        description: object["description"],
        metadata: object["metadata"],
        uid: object["uid"]
      };
    },
    _toJsonObject(self2) {
      return {
        description: self2.description,
        metadata: self2.metadata,
        uid: self2.uid
      };
    }
  };
});

// node_modules/svix/dist/api/streamingStream.js
var require_streamingStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamingStream = undefined;
  var listResponseStreamOut_1 = require_listResponseStreamOut();
  var streamIn_1 = require_streamIn();
  var streamOut_1 = require_streamOut();
  var streamPatch_1 = require_streamPatch();
  var request_1 = require_request3();

  class StreamingStream {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/stream");
      request.setQueryParams({
        limit: options === null || options === undefined ? undefined : options.limit,
        iterator: options === null || options === undefined ? undefined : options.iterator,
        order: options === null || options === undefined ? undefined : options.order
      });
      return request.send(this.requestCtx, listResponseStreamOut_1.ListResponseStreamOutSerializer._fromJsonObject);
    }
    create(streamIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/stream");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(streamIn_1.StreamInSerializer._toJsonObject(streamIn));
      return request.send(this.requestCtx, streamOut_1.StreamOutSerializer._fromJsonObject);
    }
    get(streamId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/stream/{stream_id}");
      request.setPathParam("stream_id", streamId);
      return request.send(this.requestCtx, streamOut_1.StreamOutSerializer._fromJsonObject);
    }
    update(streamId, streamIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/stream/{stream_id}");
      request.setPathParam("stream_id", streamId);
      request.setBody(streamIn_1.StreamInSerializer._toJsonObject(streamIn));
      return request.send(this.requestCtx, streamOut_1.StreamOutSerializer._fromJsonObject);
    }
    delete(streamId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/stream/{stream_id}");
      request.setPathParam("stream_id", streamId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    patch(streamId, streamPatch) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/stream/{stream_id}");
      request.setPathParam("stream_id", streamId);
      request.setBody(streamPatch_1.StreamPatchSerializer._toJsonObject(streamPatch));
      return request.send(this.requestCtx, streamOut_1.StreamOutSerializer._fromJsonObject);
    }
  }
  exports.StreamingStream = StreamingStream;
});

// node_modules/svix/dist/api/streaming.js
var require_streaming = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Streaming = undefined;
  var endpointHeadersOut_1 = require_endpointHeadersOut();
  var httpSinkHeadersPatchIn_1 = require_httpSinkHeadersPatchIn();
  var sinkTransformationOut_1 = require_sinkTransformationOut();
  var streamingEventType_1 = require_streamingEventType();
  var streamingEvents_1 = require_streamingEvents();
  var streamingSink_1 = require_streamingSink();
  var streamingStream_1 = require_streamingStream();
  var request_1 = require_request3();

  class Streaming {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    get event_type() {
      return new streamingEventType_1.StreamingEventType(this.requestCtx);
    }
    get events() {
      return new streamingEvents_1.StreamingEvents(this.requestCtx);
    }
    get sink() {
      return new streamingSink_1.StreamingSink(this.requestCtx);
    }
    get stream() {
      return new streamingStream_1.StreamingStream(this.requestCtx);
    }
    sinkHeadersGet(streamId, sinkId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/stream/{stream_id}/sink/{sink_id}/headers");
      request.setPathParam("stream_id", streamId);
      request.setPathParam("sink_id", sinkId);
      return request.send(this.requestCtx, endpointHeadersOut_1.EndpointHeadersOutSerializer._fromJsonObject);
    }
    sinkHeadersPatch(streamId, sinkId, httpSinkHeadersPatchIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/stream/{stream_id}/sink/{sink_id}/headers");
      request.setPathParam("stream_id", streamId);
      request.setPathParam("sink_id", sinkId);
      request.setBody(httpSinkHeadersPatchIn_1.HttpSinkHeadersPatchInSerializer._toJsonObject(httpSinkHeadersPatchIn));
      return request.send(this.requestCtx, endpointHeadersOut_1.EndpointHeadersOutSerializer._fromJsonObject);
    }
    sinkTransformationGet(streamId, sinkId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/stream/{stream_id}/sink/{sink_id}/transformation");
      request.setPathParam("stream_id", streamId);
      request.setPathParam("sink_id", sinkId);
      return request.send(this.requestCtx, sinkTransformationOut_1.SinkTransformationOutSerializer._fromJsonObject);
    }
  }
  exports.Streaming = Streaming;
});

// node_modules/svix/dist/HttpErrors.js
var require_HttpErrors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HTTPValidationError = exports.ValidationError = exports.HttpErrorOut = undefined;

  class HttpErrorOut {
    static getAttributeTypeMap() {
      return HttpErrorOut.attributeTypeMap;
    }
  }
  exports.HttpErrorOut = HttpErrorOut;
  HttpErrorOut.discriminator = undefined;
  HttpErrorOut.mapping = undefined;
  HttpErrorOut.attributeTypeMap = [
    {
      name: "code",
      baseName: "code",
      type: "string",
      format: ""
    },
    {
      name: "detail",
      baseName: "detail",
      type: "string",
      format: ""
    }
  ];

  class ValidationError {
    static getAttributeTypeMap() {
      return ValidationError.attributeTypeMap;
    }
  }
  exports.ValidationError = ValidationError;
  ValidationError.discriminator = undefined;
  ValidationError.mapping = undefined;
  ValidationError.attributeTypeMap = [
    {
      name: "loc",
      baseName: "loc",
      type: "Array<string>",
      format: ""
    },
    {
      name: "msg",
      baseName: "msg",
      type: "string",
      format: ""
    },
    {
      name: "type",
      baseName: "type",
      type: "string",
      format: ""
    }
  ];

  class HTTPValidationError {
    static getAttributeTypeMap() {
      return HTTPValidationError.attributeTypeMap;
    }
  }
  exports.HTTPValidationError = HTTPValidationError;
  HTTPValidationError.discriminator = undefined;
  HTTPValidationError.mapping = undefined;
  HTTPValidationError.attributeTypeMap = [
    {
      name: "detail",
      baseName: "detail",
      type: "Array<ValidationError>",
      format: ""
    }
  ];
});

// node_modules/standardwebhooks/dist/timing_safe_equal.js
var require_timing_safe_equal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timingSafeEqual = undefined;
  function assert(expr, msg = "") {
    if (!expr) {
      throw new Error(msg);
    }
  }
  function timingSafeEqual(a, b) {
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    if (!(a instanceof DataView)) {
      a = new DataView(ArrayBuffer.isView(a) ? a.buffer : a);
    }
    if (!(b instanceof DataView)) {
      b = new DataView(ArrayBuffer.isView(b) ? b.buffer : b);
    }
    assert(a instanceof DataView);
    assert(b instanceof DataView);
    const length = a.byteLength;
    let out = 0;
    let i2 = -1;
    while (++i2 < length) {
      out |= a.getUint8(i2) ^ b.getUint8(i2);
    }
    return out === 0;
  }
  exports.timingSafeEqual = timingSafeEqual;
});

// node_modules/@stablelib/base64/lib/base64.js
var require_base64 = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var INVALID_BYTE = 256;
  var Coder = function() {
    function Coder2(_paddingCharacter) {
      if (_paddingCharacter === undefined) {
        _paddingCharacter = "=";
      }
      this._paddingCharacter = _paddingCharacter;
    }
    Coder2.prototype.encodedLength = function(length) {
      if (!this._paddingCharacter) {
        return (length * 8 + 5) / 6 | 0;
      }
      return (length + 2) / 3 * 4 | 0;
    };
    Coder2.prototype.encode = function(data) {
      var out = "";
      var i2 = 0;
      for (;i2 < data.length - 2; i2 += 3) {
        var c = data[i2] << 16 | data[i2 + 1] << 8 | data[i2 + 2];
        out += this._encodeByte(c >>> 3 * 6 & 63);
        out += this._encodeByte(c >>> 2 * 6 & 63);
        out += this._encodeByte(c >>> 1 * 6 & 63);
        out += this._encodeByte(c >>> 0 * 6 & 63);
      }
      var left = data.length - i2;
      if (left > 0) {
        var c = data[i2] << 16 | (left === 2 ? data[i2 + 1] << 8 : 0);
        out += this._encodeByte(c >>> 3 * 6 & 63);
        out += this._encodeByte(c >>> 2 * 6 & 63);
        if (left === 2) {
          out += this._encodeByte(c >>> 1 * 6 & 63);
        } else {
          out += this._paddingCharacter || "";
        }
        out += this._paddingCharacter || "";
      }
      return out;
    };
    Coder2.prototype.maxDecodedLength = function(length) {
      if (!this._paddingCharacter) {
        return (length * 6 + 7) / 8 | 0;
      }
      return length / 4 * 3 | 0;
    };
    Coder2.prototype.decodedLength = function(s) {
      return this.maxDecodedLength(s.length - this._getPaddingLength(s));
    };
    Coder2.prototype.decode = function(s) {
      if (s.length === 0) {
        return new Uint8Array(0);
      }
      var paddingLength = this._getPaddingLength(s);
      var length = s.length - paddingLength;
      var out = new Uint8Array(this.maxDecodedLength(length));
      var op = 0;
      var i2 = 0;
      var haveBad = 0;
      var v0 = 0, v1 = 0, v2 = 0, v3 = 0;
      for (;i2 < length - 4; i2 += 4) {
        v0 = this._decodeChar(s.charCodeAt(i2 + 0));
        v1 = this._decodeChar(s.charCodeAt(i2 + 1));
        v2 = this._decodeChar(s.charCodeAt(i2 + 2));
        v3 = this._decodeChar(s.charCodeAt(i2 + 3));
        out[op++] = v0 << 2 | v1 >>> 4;
        out[op++] = v1 << 4 | v2 >>> 2;
        out[op++] = v2 << 6 | v3;
        haveBad |= v0 & INVALID_BYTE;
        haveBad |= v1 & INVALID_BYTE;
        haveBad |= v2 & INVALID_BYTE;
        haveBad |= v3 & INVALID_BYTE;
      }
      if (i2 < length - 1) {
        v0 = this._decodeChar(s.charCodeAt(i2));
        v1 = this._decodeChar(s.charCodeAt(i2 + 1));
        out[op++] = v0 << 2 | v1 >>> 4;
        haveBad |= v0 & INVALID_BYTE;
        haveBad |= v1 & INVALID_BYTE;
      }
      if (i2 < length - 2) {
        v2 = this._decodeChar(s.charCodeAt(i2 + 2));
        out[op++] = v1 << 4 | v2 >>> 2;
        haveBad |= v2 & INVALID_BYTE;
      }
      if (i2 < length - 3) {
        v3 = this._decodeChar(s.charCodeAt(i2 + 3));
        out[op++] = v2 << 6 | v3;
        haveBad |= v3 & INVALID_BYTE;
      }
      if (haveBad !== 0) {
        throw new Error("Base64Coder: incorrect characters for decoding");
      }
      return out;
    };
    Coder2.prototype._encodeByte = function(b) {
      var result = b;
      result += 65;
      result += 25 - b >>> 8 & 0 - 65 - 26 + 97;
      result += 51 - b >>> 8 & 26 - 97 - 52 + 48;
      result += 61 - b >>> 8 & 52 - 48 - 62 + 43;
      result += 62 - b >>> 8 & 62 - 43 - 63 + 47;
      return String.fromCharCode(result);
    };
    Coder2.prototype._decodeChar = function(c) {
      var result = INVALID_BYTE;
      result += (42 - c & c - 44) >>> 8 & -INVALID_BYTE + c - 43 + 62;
      result += (46 - c & c - 48) >>> 8 & -INVALID_BYTE + c - 47 + 63;
      result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
      result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
      result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
      return result;
    };
    Coder2.prototype._getPaddingLength = function(s) {
      var paddingLength = 0;
      if (this._paddingCharacter) {
        for (var i2 = s.length - 1;i2 >= 0; i2--) {
          if (s[i2] !== this._paddingCharacter) {
            break;
          }
          paddingLength++;
        }
        if (s.length < 4 || paddingLength > 2) {
          throw new Error("Base64Coder: incorrect padding");
        }
      }
      return paddingLength;
    };
    return Coder2;
  }();
  exports.Coder = Coder;
  var stdCoder = new Coder;
  function encode2(data) {
    return stdCoder.encode(data);
  }
  exports.encode = encode2;
  function decode2(s) {
    return stdCoder.decode(s);
  }
  exports.decode = decode2;
  var URLSafeCoder = function(_super) {
    __extends(URLSafeCoder2, _super);
    function URLSafeCoder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    URLSafeCoder2.prototype._encodeByte = function(b) {
      var result = b;
      result += 65;
      result += 25 - b >>> 8 & 0 - 65 - 26 + 97;
      result += 51 - b >>> 8 & 26 - 97 - 52 + 48;
      result += 61 - b >>> 8 & 52 - 48 - 62 + 45;
      result += 62 - b >>> 8 & 62 - 45 - 63 + 95;
      return String.fromCharCode(result);
    };
    URLSafeCoder2.prototype._decodeChar = function(c) {
      var result = INVALID_BYTE;
      result += (44 - c & c - 46) >>> 8 & -INVALID_BYTE + c - 45 + 62;
      result += (94 - c & c - 96) >>> 8 & -INVALID_BYTE + c - 95 + 63;
      result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
      result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
      result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
      return result;
    };
    return URLSafeCoder2;
  }(Coder);
  exports.URLSafeCoder = URLSafeCoder;
  var urlSafeCoder = new URLSafeCoder;
  function encodeURLSafe(data) {
    return urlSafeCoder.encode(data);
  }
  exports.encodeURLSafe = encodeURLSafe;
  function decodeURLSafe(s) {
    return urlSafeCoder.decode(s);
  }
  exports.decodeURLSafe = decodeURLSafe;
  exports.encodedLength = function(length) {
    return stdCoder.encodedLength(length);
  };
  exports.maxDecodedLength = function(length) {
    return stdCoder.maxDecodedLength(length);
  };
  exports.decodedLength = function(s) {
    return stdCoder.decodedLength(s);
  };
});

// node_modules/fast-sha256/sha256.js
var require_sha256 = __commonJS((exports, module) => {
  (function(root, factory) {
    var exports2 = {};
    factory(exports2);
    var sha256 = exports2["default"];
    for (var k in exports2) {
      sha256[k] = exports2[k];
    }
    if (typeof module === "object" && typeof module.exports === "object") {
      module.exports = sha256;
    } else if (typeof define === "function" && define.amd) {
      define(function() {
        return sha256;
      });
    } else {
      root.sha256 = sha256;
    }
  })(exports, function(exports2) {
    exports2.__esModule = true;
    exports2.digestLength = 32;
    exports2.blockSize = 64;
    var K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w, v, p, pos, len) {
      var a, b, c, d, e, f, g, h, u, i2, j, t1, t2;
      while (len >= 64) {
        a = v[0];
        b = v[1];
        c = v[2];
        d = v[3];
        e = v[4];
        f = v[5];
        g = v[6];
        h = v[7];
        for (i2 = 0;i2 < 16; i2++) {
          j = pos + i2 * 4;
          w[i2] = (p[j] & 255) << 24 | (p[j + 1] & 255) << 16 | (p[j + 2] & 255) << 8 | p[j + 3] & 255;
        }
        for (i2 = 16;i2 < 64; i2++) {
          u = w[i2 - 2];
          t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
          u = w[i2 - 15];
          t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
          w[i2] = (t1 + w[i2 - 7] | 0) + (t2 + w[i2 - 16] | 0);
        }
        for (i2 = 0;i2 < 64; i2++) {
          t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i2] + w[i2] | 0) | 0) | 0;
          t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
          h = g;
          g = f;
          f = e;
          e = d + t1 | 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    var Hash = function() {
      function Hash2() {
        this.digestLength = exports2.digestLength;
        this.blockSize = exports2.blockSize;
        this.state = new Int32Array(8);
        this.temp = new Int32Array(64);
        this.buffer = new Uint8Array(128);
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
        this.reset();
      }
      Hash2.prototype.reset = function() {
        this.state[0] = 1779033703;
        this.state[1] = 3144134277;
        this.state[2] = 1013904242;
        this.state[3] = 2773480762;
        this.state[4] = 1359893119;
        this.state[5] = 2600822924;
        this.state[6] = 528734635;
        this.state[7] = 1541459225;
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
        return this;
      };
      Hash2.prototype.clean = function() {
        for (var i2 = 0;i2 < this.buffer.length; i2++) {
          this.buffer[i2] = 0;
        }
        for (var i2 = 0;i2 < this.temp.length; i2++) {
          this.temp[i2] = 0;
        }
        this.reset();
      };
      Hash2.prototype.update = function(data, dataLength) {
        if (dataLength === undefined) {
          dataLength = data.length;
        }
        if (this.finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this.bytesHashed += dataLength;
        if (this.bufferLength > 0) {
          while (this.bufferLength < 64 && dataLength > 0) {
            this.buffer[this.bufferLength++] = data[dataPos++];
            dataLength--;
          }
          if (this.bufferLength === 64) {
            hashBlocks(this.temp, this.state, this.buffer, 0, 64);
            this.bufferLength = 0;
          }
        }
        if (dataLength >= 64) {
          dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);
          dataLength %= 64;
        }
        while (dataLength > 0) {
          this.buffer[this.bufferLength++] = data[dataPos++];
          dataLength--;
        }
        return this;
      };
      Hash2.prototype.finish = function(out) {
        if (!this.finished) {
          var bytesHashed = this.bytesHashed;
          var left = this.bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this.buffer[left] = 128;
          for (var i2 = left + 1;i2 < padLength - 8; i2++) {
            this.buffer[i2] = 0;
          }
          this.buffer[padLength - 8] = bitLenHi >>> 24 & 255;
          this.buffer[padLength - 7] = bitLenHi >>> 16 & 255;
          this.buffer[padLength - 6] = bitLenHi >>> 8 & 255;
          this.buffer[padLength - 5] = bitLenHi >>> 0 & 255;
          this.buffer[padLength - 4] = bitLenLo >>> 24 & 255;
          this.buffer[padLength - 3] = bitLenLo >>> 16 & 255;
          this.buffer[padLength - 2] = bitLenLo >>> 8 & 255;
          this.buffer[padLength - 1] = bitLenLo >>> 0 & 255;
          hashBlocks(this.temp, this.state, this.buffer, 0, padLength);
          this.finished = true;
        }
        for (var i2 = 0;i2 < 8; i2++) {
          out[i2 * 4 + 0] = this.state[i2] >>> 24 & 255;
          out[i2 * 4 + 1] = this.state[i2] >>> 16 & 255;
          out[i2 * 4 + 2] = this.state[i2] >>> 8 & 255;
          out[i2 * 4 + 3] = this.state[i2] >>> 0 & 255;
        }
        return this;
      };
      Hash2.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      Hash2.prototype._saveState = function(out) {
        for (var i2 = 0;i2 < this.state.length; i2++) {
          out[i2] = this.state[i2];
        }
      };
      Hash2.prototype._restoreState = function(from, bytesHashed) {
        for (var i2 = 0;i2 < this.state.length; i2++) {
          this.state[i2] = from[i2];
        }
        this.bytesHashed = bytesHashed;
        this.finished = false;
        this.bufferLength = 0;
      };
      return Hash2;
    }();
    exports2.Hash = Hash;
    var HMAC = function() {
      function HMAC2(key) {
        this.inner = new Hash;
        this.outer = new Hash;
        this.blockSize = this.inner.blockSize;
        this.digestLength = this.inner.digestLength;
        var pad = new Uint8Array(this.blockSize);
        if (key.length > this.blockSize) {
          new Hash().update(key).finish(pad).clean();
        } else {
          for (var i2 = 0;i2 < key.length; i2++) {
            pad[i2] = key[i2];
          }
        }
        for (var i2 = 0;i2 < pad.length; i2++) {
          pad[i2] ^= 54;
        }
        this.inner.update(pad);
        for (var i2 = 0;i2 < pad.length; i2++) {
          pad[i2] ^= 54 ^ 92;
        }
        this.outer.update(pad);
        this.istate = new Uint32Array(8);
        this.ostate = new Uint32Array(8);
        this.inner._saveState(this.istate);
        this.outer._saveState(this.ostate);
        for (var i2 = 0;i2 < pad.length; i2++) {
          pad[i2] = 0;
        }
      }
      HMAC2.prototype.reset = function() {
        this.inner._restoreState(this.istate, this.inner.blockSize);
        this.outer._restoreState(this.ostate, this.outer.blockSize);
        return this;
      };
      HMAC2.prototype.clean = function() {
        for (var i2 = 0;i2 < this.istate.length; i2++) {
          this.ostate[i2] = this.istate[i2] = 0;
        }
        this.inner.clean();
        this.outer.clean();
      };
      HMAC2.prototype.update = function(data) {
        this.inner.update(data);
        return this;
      };
      HMAC2.prototype.finish = function(out) {
        if (this.outer.finished) {
          this.outer.finish(out);
        } else {
          this.inner.finish(out);
          this.outer.update(out, this.digestLength).finish(out);
        }
        return this;
      };
      HMAC2.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      return HMAC2;
    }();
    exports2.HMAC = HMAC;
    function hash(data) {
      var h = new Hash().update(data);
      var digest = h.digest();
      h.clean();
      return digest;
    }
    exports2.hash = hash;
    exports2["default"] = hash;
    function hmac(key, data) {
      var h = new HMAC(key).update(data);
      var digest = h.digest();
      h.clean();
      return digest;
    }
    exports2.hmac = hmac;
    function fillBuffer(buffer, hmac2, info, counter) {
      var num = counter[0];
      if (num === 0) {
        throw new Error("hkdf: cannot expand more");
      }
      hmac2.reset();
      if (num > 1) {
        hmac2.update(buffer);
      }
      if (info) {
        hmac2.update(info);
      }
      hmac2.update(counter);
      hmac2.finish(buffer);
      counter[0]++;
    }
    var hkdfSalt = new Uint8Array(exports2.digestLength);
    function hkdf(key, salt, info, length) {
      if (salt === undefined) {
        salt = hkdfSalt;
      }
      if (length === undefined) {
        length = 32;
      }
      var counter = new Uint8Array([1]);
      var okm = hmac(salt, key);
      var hmac_ = new HMAC(okm);
      var buffer = new Uint8Array(hmac_.digestLength);
      var bufpos = buffer.length;
      var out = new Uint8Array(length);
      for (var i2 = 0;i2 < length; i2++) {
        if (bufpos === buffer.length) {
          fillBuffer(buffer, hmac_, info, counter);
          bufpos = 0;
        }
        out[i2] = buffer[bufpos++];
      }
      hmac_.clean();
      buffer.fill(0);
      counter.fill(0);
      return out;
    }
    exports2.hkdf = hkdf;
    function pbkdf2(password, salt, iterations, dkLen) {
      var prf = new HMAC(password);
      var len = prf.digestLength;
      var ctr = new Uint8Array(4);
      var t = new Uint8Array(len);
      var u = new Uint8Array(len);
      var dk = new Uint8Array(dkLen);
      for (var i2 = 0;i2 * len < dkLen; i2++) {
        var c = i2 + 1;
        ctr[0] = c >>> 24 & 255;
        ctr[1] = c >>> 16 & 255;
        ctr[2] = c >>> 8 & 255;
        ctr[3] = c >>> 0 & 255;
        prf.reset();
        prf.update(salt);
        prf.update(ctr);
        prf.finish(u);
        for (var j = 0;j < len; j++) {
          t[j] = u[j];
        }
        for (var j = 2;j <= iterations; j++) {
          prf.reset();
          prf.update(u).finish(u);
          for (var k = 0;k < len; k++) {
            t[k] ^= u[k];
          }
        }
        for (var j = 0;j < len && i2 * len + j < dkLen; j++) {
          dk[i2 * len + j] = t[j];
        }
      }
      for (var i2 = 0;i2 < len; i2++) {
        t[i2] = u[i2] = 0;
      }
      for (var i2 = 0;i2 < 4; i2++) {
        ctr[i2] = 0;
      }
      prf.clean();
      return dk;
    }
    exports2.pbkdf2 = pbkdf2;
  });
});

// node_modules/standardwebhooks/dist/index.js
var require_dist6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Webhook = exports.WebhookVerificationError = undefined;
  var timing_safe_equal_1 = require_timing_safe_equal();
  var base64 = require_base64();
  var sha256 = require_sha256();
  var WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;

  class ExtendableError extends Error {
    constructor(message3) {
      super(message3);
      Object.setPrototypeOf(this, ExtendableError.prototype);
      this.name = "ExtendableError";
      this.stack = new Error(message3).stack;
    }
  }

  class WebhookVerificationError extends ExtendableError {
    constructor(message3) {
      super(message3);
      Object.setPrototypeOf(this, WebhookVerificationError.prototype);
      this.name = "WebhookVerificationError";
    }
  }
  exports.WebhookVerificationError = WebhookVerificationError;

  class Webhook {
    constructor(secret, options) {
      if (!secret) {
        throw new Error("Secret can't be empty.");
      }
      if ((options === null || options === undefined ? undefined : options.format) === "raw") {
        if (secret instanceof Uint8Array) {
          this.key = secret;
        } else {
          this.key = Uint8Array.from(secret, (c) => c.charCodeAt(0));
        }
      } else {
        if (typeof secret !== "string") {
          throw new Error("Expected secret to be of type string");
        }
        if (secret.startsWith(Webhook.prefix)) {
          secret = secret.substring(Webhook.prefix.length);
        }
        this.key = base64.decode(secret);
      }
    }
    verify(payload, headers_) {
      const headers = {};
      for (const key of Object.keys(headers_)) {
        headers[key.toLowerCase()] = headers_[key];
      }
      const msgId = headers["webhook-id"];
      const msgSignature = headers["webhook-signature"];
      const msgTimestamp = headers["webhook-timestamp"];
      if (!msgSignature || !msgId || !msgTimestamp) {
        throw new WebhookVerificationError("Missing required headers");
      }
      const timestamp = this.verifyTimestamp(msgTimestamp);
      const computedSignature = this.sign(msgId, timestamp, payload);
      const expectedSignature = computedSignature.split(",")[1];
      const passedSignatures = msgSignature.split(" ");
      const encoder2 = new globalThis.TextEncoder;
      for (const versionedSignature of passedSignatures) {
        const [version, signature] = versionedSignature.split(",");
        if (version !== "v1") {
          continue;
        }
        if ((0, timing_safe_equal_1.timingSafeEqual)(encoder2.encode(signature), encoder2.encode(expectedSignature))) {
          return JSON.parse(payload.toString());
        }
      }
      throw new WebhookVerificationError("No matching signature found");
    }
    sign(msgId, timestamp, payload) {
      if (typeof payload === "string") {} else if (payload.constructor.name === "Buffer") {
        payload = payload.toString();
      } else {
        throw new Error("Expected payload to be of type string or Buffer.");
      }
      const encoder2 = new TextEncoder;
      const timestampNumber = Math.floor(timestamp.getTime() / 1000);
      const toSign = encoder2.encode(`${msgId}.${timestampNumber}.${payload}`);
      const expectedSignature = base64.encode(sha256.hmac(this.key, toSign));
      return `v1,${expectedSignature}`;
    }
    verifyTimestamp(timestampHeader) {
      const now = Math.floor(Date.now() / 1000);
      const timestamp = parseInt(timestampHeader, 10);
      if (isNaN(timestamp)) {
        throw new WebhookVerificationError("Invalid Signature Headers");
      }
      if (now - timestamp > WEBHOOK_TOLERANCE_IN_SECONDS) {
        throw new WebhookVerificationError("Message timestamp too old");
      }
      if (timestamp > now + WEBHOOK_TOLERANCE_IN_SECONDS) {
        throw new WebhookVerificationError("Message timestamp too new");
      }
      return new Date(timestamp * 1000);
    }
  }
  exports.Webhook = Webhook;
  Webhook.prefix = "whsec_";
});

// node_modules/svix/dist/webhook.js
var require_webhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Webhook = exports.WebhookVerificationError = undefined;
  var standardwebhooks_1 = require_dist6();
  var standardwebhooks_2 = require_dist6();
  Object.defineProperty(exports, "WebhookVerificationError", { enumerable: true, get: function() {
    return standardwebhooks_2.WebhookVerificationError;
  } });

  class Webhook {
    constructor(secret, options) {
      this.inner = new standardwebhooks_1.Webhook(secret, options);
    }
    verify(payload, headers_) {
      var _a, _b, _c, _d, _e, _f;
      const headers = {};
      for (const key of Object.keys(headers_)) {
        headers[key.toLowerCase()] = headers_[key];
      }
      headers["webhook-id"] = (_b = (_a = headers["svix-id"]) !== null && _a !== undefined ? _a : headers["webhook-id"]) !== null && _b !== undefined ? _b : "";
      headers["webhook-signature"] = (_d = (_c = headers["svix-signature"]) !== null && _c !== undefined ? _c : headers["webhook-signature"]) !== null && _d !== undefined ? _d : "";
      headers["webhook-timestamp"] = (_f = (_e = headers["svix-timestamp"]) !== null && _e !== undefined ? _e : headers["webhook-timestamp"]) !== null && _f !== undefined ? _f : "";
      return this.inner.verify(payload, headers);
    }
    sign(msgId, timestamp, payload) {
      return this.inner.sign(msgId, timestamp, payload);
    }
  }
  exports.Webhook = Webhook;
});

// node_modules/svix/dist/models/endpointDisabledTrigger.js
var require_endpointDisabledTrigger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointDisabledTriggerSerializer = exports.EndpointDisabledTrigger = undefined;
  var EndpointDisabledTrigger;
  (function(EndpointDisabledTrigger2) {
    EndpointDisabledTrigger2["Manual"] = "manual";
    EndpointDisabledTrigger2["Automatic"] = "automatic";
  })(EndpointDisabledTrigger = exports.EndpointDisabledTrigger || (exports.EndpointDisabledTrigger = {}));
  exports.EndpointDisabledTriggerSerializer = {
    _fromJsonObject(object) {
      return object;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/ordering.js
var require_ordering = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OrderingSerializer = exports.Ordering = undefined;
  var Ordering;
  (function(Ordering2) {
    Ordering2["Ascending"] = "ascending";
    Ordering2["Descending"] = "descending";
  })(Ordering = exports.Ordering || (exports.Ordering = {}));
  exports.OrderingSerializer = {
    _fromJsonObject(object) {
      return object;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/statusCodeClass.js
var require_statusCodeClass = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StatusCodeClassSerializer = exports.StatusCodeClass = undefined;
  var StatusCodeClass;
  (function(StatusCodeClass2) {
    StatusCodeClass2[StatusCodeClass2["CodeNone"] = 0] = "CodeNone";
    StatusCodeClass2[StatusCodeClass2["Code1xx"] = 100] = "Code1xx";
    StatusCodeClass2[StatusCodeClass2["Code2xx"] = 200] = "Code2xx";
    StatusCodeClass2[StatusCodeClass2["Code3xx"] = 300] = "Code3xx";
    StatusCodeClass2[StatusCodeClass2["Code4xx"] = 400] = "Code4xx";
    StatusCodeClass2[StatusCodeClass2["Code5xx"] = 500] = "Code5xx";
  })(StatusCodeClass = exports.StatusCodeClass || (exports.StatusCodeClass = {}));
  exports.StatusCodeClassSerializer = {
    _fromJsonObject(object) {
      return object;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/index.js
var require_models = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StatusCodeClass = exports.SinkStatusIn = exports.SinkStatus = exports.Ordering = exports.MessageStatusText = exports.MessageStatus = exports.MessageAttemptTriggerType = exports.EndpointDisabledTrigger = exports.ConnectorProduct = exports.ConnectorKind = exports.BackgroundTaskType = exports.BackgroundTaskStatus = exports.AppPortalCapability = undefined;
  var appPortalCapability_1 = require_appPortalCapability();
  Object.defineProperty(exports, "AppPortalCapability", { enumerable: true, get: function() {
    return appPortalCapability_1.AppPortalCapability;
  } });
  var backgroundTaskStatus_1 = require_backgroundTaskStatus();
  Object.defineProperty(exports, "BackgroundTaskStatus", { enumerable: true, get: function() {
    return backgroundTaskStatus_1.BackgroundTaskStatus;
  } });
  var backgroundTaskType_1 = require_backgroundTaskType();
  Object.defineProperty(exports, "BackgroundTaskType", { enumerable: true, get: function() {
    return backgroundTaskType_1.BackgroundTaskType;
  } });
  var connectorKind_1 = require_connectorKind();
  Object.defineProperty(exports, "ConnectorKind", { enumerable: true, get: function() {
    return connectorKind_1.ConnectorKind;
  } });
  var connectorProduct_1 = require_connectorProduct();
  Object.defineProperty(exports, "ConnectorProduct", { enumerable: true, get: function() {
    return connectorProduct_1.ConnectorProduct;
  } });
  var endpointDisabledTrigger_1 = require_endpointDisabledTrigger();
  Object.defineProperty(exports, "EndpointDisabledTrigger", { enumerable: true, get: function() {
    return endpointDisabledTrigger_1.EndpointDisabledTrigger;
  } });
  var messageAttemptTriggerType_1 = require_messageAttemptTriggerType();
  Object.defineProperty(exports, "MessageAttemptTriggerType", { enumerable: true, get: function() {
    return messageAttemptTriggerType_1.MessageAttemptTriggerType;
  } });
  var messageStatus_1 = require_messageStatus();
  Object.defineProperty(exports, "MessageStatus", { enumerable: true, get: function() {
    return messageStatus_1.MessageStatus;
  } });
  var messageStatusText_1 = require_messageStatusText();
  Object.defineProperty(exports, "MessageStatusText", { enumerable: true, get: function() {
    return messageStatusText_1.MessageStatusText;
  } });
  var ordering_1 = require_ordering();
  Object.defineProperty(exports, "Ordering", { enumerable: true, get: function() {
    return ordering_1.Ordering;
  } });
  var sinkStatus_1 = require_sinkStatus();
  Object.defineProperty(exports, "SinkStatus", { enumerable: true, get: function() {
    return sinkStatus_1.SinkStatus;
  } });
  var sinkStatusIn_1 = require_sinkStatusIn();
  Object.defineProperty(exports, "SinkStatusIn", { enumerable: true, get: function() {
    return sinkStatusIn_1.SinkStatusIn;
  } });
  var statusCodeClass_1 = require_statusCodeClass();
  Object.defineProperty(exports, "StatusCodeClass", { enumerable: true, get: function() {
    return statusCodeClass_1.StatusCodeClass;
  } });
});

// node_modules/svix/dist/index.js
var require_dist7 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Svix = exports.messageInRaw = exports.ValidationError = exports.HttpErrorOut = exports.HTTPValidationError = exports.ApiException = undefined;
  var application_1 = require_application();
  var authentication_1 = require_authentication();
  var backgroundTask_1 = require_backgroundTask();
  var connector_1 = require_connector();
  var endpoint_1 = require_endpoint();
  var environment_1 = require_environment();
  var eventType_1 = require_eventType();
  var health_1 = require_health();
  var ingest_1 = require_ingest();
  var integration_1 = require_integration();
  var message_1 = require_message();
  var messageAttempt_1 = require_messageAttempt();
  var operationalWebhook_1 = require_operationalWebhook();
  var statistics_1 = require_statistics();
  var streaming_1 = require_streaming();
  var operationalWebhookEndpoint_1 = require_operationalWebhookEndpoint();
  var util_1 = require_util3();
  Object.defineProperty(exports, "ApiException", { enumerable: true, get: function() {
    return util_1.ApiException;
  } });
  var HttpErrors_1 = require_HttpErrors();
  Object.defineProperty(exports, "HTTPValidationError", { enumerable: true, get: function() {
    return HttpErrors_1.HTTPValidationError;
  } });
  Object.defineProperty(exports, "HttpErrorOut", { enumerable: true, get: function() {
    return HttpErrors_1.HttpErrorOut;
  } });
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return HttpErrors_1.ValidationError;
  } });
  __exportStar(require_webhook(), exports);
  __exportStar(require_models(), exports);
  var message_2 = require_message();
  Object.defineProperty(exports, "messageInRaw", { enumerable: true, get: function() {
    return message_2.messageInRaw;
  } });
  var REGIONS = [
    { region: "us", url: "https://api.us.svix.com" },
    { region: "eu", url: "https://api.eu.svix.com" },
    { region: "in", url: "https://api.in.svix.com" },
    { region: "ca", url: "https://api.ca.svix.com" },
    { region: "au", url: "https://api.au.svix.com" }
  ];

  class Svix {
    constructor(token2, options = {}) {
      var _a, _b, _c;
      const regionalUrl = (_a = REGIONS.find((x) => x.region === token2.split(".")[1])) === null || _a === undefined ? undefined : _a.url;
      const baseUrl = (_c = (_b = options.serverUrl) !== null && _b !== undefined ? _b : regionalUrl) !== null && _c !== undefined ? _c : "https://api.svix.com";
      if (options.retryScheduleInMs) {
        this.requestCtx = {
          baseUrl,
          token: token2,
          timeout: options.requestTimeout,
          retryScheduleInMs: options.retryScheduleInMs,
          fetch: options.fetch
        };
        return;
      }
      if (options.numRetries) {
        this.requestCtx = {
          baseUrl,
          token: token2,
          timeout: options.requestTimeout,
          numRetries: options.numRetries,
          fetch: options.fetch
        };
        return;
      }
      this.requestCtx = {
        baseUrl,
        token: token2,
        timeout: options.requestTimeout,
        fetch: options.fetch
      };
    }
    get application() {
      return new application_1.Application(this.requestCtx);
    }
    get authentication() {
      return new authentication_1.Authentication(this.requestCtx);
    }
    get backgroundTask() {
      return new backgroundTask_1.BackgroundTask(this.requestCtx);
    }
    get connector() {
      return new connector_1.Connector(this.requestCtx);
    }
    get endpoint() {
      return new endpoint_1.Endpoint(this.requestCtx);
    }
    get environment() {
      return new environment_1.Environment(this.requestCtx);
    }
    get eventType() {
      return new eventType_1.EventType(this.requestCtx);
    }
    get health() {
      return new health_1.Health(this.requestCtx);
    }
    get ingest() {
      return new ingest_1.Ingest(this.requestCtx);
    }
    get integration() {
      return new integration_1.Integration(this.requestCtx);
    }
    get message() {
      return new message_1.Message(this.requestCtx);
    }
    get messageAttempt() {
      return new messageAttempt_1.MessageAttempt(this.requestCtx);
    }
    get operationalWebhook() {
      return new operationalWebhook_1.OperationalWebhook(this.requestCtx);
    }
    get statistics() {
      return new statistics_1.Statistics(this.requestCtx);
    }
    get streaming() {
      return new streaming_1.Streaming(this.requestCtx);
    }
    get operationalWebhookEndpoint() {
      return new operationalWebhookEndpoint_1.OperationalWebhookEndpoint(this.requestCtx);
    }
  }
  exports.Svix = Svix;
});

// node_modules/resend/dist/index.mjs
var exports_dist2 = {};
__export(exports_dist2, {
  Resend: () => Resend
});
function buildPaginationQuery(options) {
  const searchParams = new URLSearchParams;
  if (options.limit !== undefined)
    searchParams.set("limit", options.limit.toString());
  if ("after" in options && options.after !== undefined)
    searchParams.set("after", options.after);
  if ("before" in options && options.before !== undefined)
    searchParams.set("before", options.before);
  return searchParams.toString();
}
function parseAttachments(attachments) {
  return attachments?.map((attachment) => ({
    content: attachment.content,
    filename: attachment.filename,
    path: attachment.path,
    content_type: attachment.contentType,
    content_id: attachment.contentId
  }));
}
function parseEmailToApiOptions(email) {
  return {
    attachments: parseAttachments(email.attachments),
    bcc: email.bcc,
    cc: email.cc,
    from: email.from,
    headers: email.headers,
    html: email.html,
    reply_to: email.replyTo,
    scheduled_at: email.scheduledAt,
    subject: email.subject,
    tags: email.tags,
    text: email.text,
    to: email.to,
    template: email.template ? {
      id: email.template.id,
      variables: email.template.variables
    } : undefined,
    topic_id: email.topicId
  };
}
async function render(node) {
  let render2;
  try {
    ({ render: render2 } = __require("@react-email/render"));
  } catch {
    throw new Error("Failed to render React component. Make sure to install `@react-email/render` or `@react-email/components`.");
  }
  return render2(node);
}
function parseContactPropertyFromApi(contactProperty) {
  return {
    id: contactProperty.id,
    key: contactProperty.key,
    createdAt: contactProperty.created_at,
    type: contactProperty.type,
    fallbackValue: contactProperty.fallback_value
  };
}
function parseContactPropertyToApiOptions(contactProperty) {
  if ("key" in contactProperty)
    return {
      key: contactProperty.key,
      type: contactProperty.type,
      fallback_value: contactProperty.fallbackValue
    };
  return { fallback_value: contactProperty.fallbackValue };
}
function parseDomainToApiOptions(domain) {
  return {
    name: domain.name,
    region: domain.region,
    custom_return_path: domain.customReturnPath,
    capabilities: domain.capabilities,
    open_tracking: domain.openTracking,
    click_tracking: domain.clickTracking,
    tls: domain.tls
  };
}
function getPaginationQueryProperties(options = {}) {
  const query = new URLSearchParams;
  if (options.before)
    query.set("before", options.before);
  if (options.after)
    query.set("after", options.after);
  if (options.limit)
    query.set("limit", options.limit.toString());
  return query.size > 0 ? `?${query.toString()}` : "";
}
function parseVariables(variables) {
  return variables?.map((variable) => ({
    key: variable.key,
    type: variable.type,
    fallback_value: variable.fallbackValue
  }));
}
function parseTemplateToApiOptions(template) {
  return {
    name: "name" in template ? template.name : undefined,
    subject: template.subject,
    html: template.html,
    text: template.text,
    alias: template.alias,
    from: template.from,
    reply_to: template.replyTo,
    variables: parseVariables(template.variables)
  };
}
var import_svix, version = "6.9.2", ApiKeys = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    return await this.resend.post("/api-keys", payload, options);
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/api-keys?${queryString}` : "/api-keys";
    return await this.resend.get(url);
  }
  async remove(id) {
    return await this.resend.delete(`/api-keys/${id}`);
  }
}, Batch = class {
  constructor(resend) {
    this.resend = resend;
  }
  async send(payload, options) {
    return this.create(payload, options);
  }
  async create(payload, options) {
    const emails = [];
    for (const email of payload) {
      if (email.react) {
        email.html = await render(email.react);
        email.react = undefined;
      }
      emails.push(parseEmailToApiOptions(email));
    }
    return await this.resend.post("/emails/batch", emails, {
      ...options,
      headers: {
        "x-batch-validation": options?.batchValidation ?? "strict",
        ...options?.headers
      }
    });
  }
}, Broadcasts = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    if (payload.react)
      payload.html = await render(payload.react);
    return await this.resend.post("/broadcasts", {
      name: payload.name,
      segment_id: payload.segmentId,
      audience_id: payload.audienceId,
      preview_text: payload.previewText,
      from: payload.from,
      html: payload.html,
      reply_to: payload.replyTo,
      subject: payload.subject,
      text: payload.text,
      topic_id: payload.topicId,
      send: payload.send,
      scheduled_at: payload.scheduledAt
    }, options);
  }
  async send(id, payload) {
    return await this.resend.post(`/broadcasts/${id}/send`, { scheduled_at: payload?.scheduledAt });
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/broadcasts?${queryString}` : "/broadcasts";
    return await this.resend.get(url);
  }
  async get(id) {
    return await this.resend.get(`/broadcasts/${id}`);
  }
  async remove(id) {
    return await this.resend.delete(`/broadcasts/${id}`);
  }
  async update(id, payload) {
    if (payload.react)
      payload.html = await render(payload.react);
    return await this.resend.patch(`/broadcasts/${id}`, {
      name: payload.name,
      segment_id: payload.segmentId,
      audience_id: payload.audienceId,
      from: payload.from,
      html: payload.html,
      text: payload.text,
      subject: payload.subject,
      reply_to: payload.replyTo,
      preview_text: payload.previewText,
      topic_id: payload.topicId
    });
  }
}, ContactProperties = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(options) {
    const apiOptions = parseContactPropertyToApiOptions(options);
    return await this.resend.post("/contact-properties", apiOptions);
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/contact-properties?${queryString}` : "/contact-properties";
    const response = await this.resend.get(url);
    if (response.data)
      return {
        data: {
          ...response.data,
          data: response.data.data.map((apiContactProperty) => parseContactPropertyFromApi(apiContactProperty))
        },
        headers: response.headers,
        error: null
      };
    return response;
  }
  async get(id) {
    if (!id)
      return {
        data: null,
        headers: null,
        error: {
          message: "Missing `id` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    const response = await this.resend.get(`/contact-properties/${id}`);
    if (response.data)
      return {
        data: {
          object: "contact_property",
          ...parseContactPropertyFromApi(response.data)
        },
        headers: response.headers,
        error: null
      };
    return response;
  }
  async update(payload) {
    if (!payload.id)
      return {
        data: null,
        headers: null,
        error: {
          message: "Missing `id` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    const apiOptions = parseContactPropertyToApiOptions(payload);
    return await this.resend.patch(`/contact-properties/${payload.id}`, apiOptions);
  }
  async remove(id) {
    if (!id)
      return {
        data: null,
        headers: null,
        error: {
          message: "Missing `id` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    return await this.resend.delete(`/contact-properties/${id}`);
  }
}, ContactSegments = class {
  constructor(resend) {
    this.resend = resend;
  }
  async list(options) {
    if (!options.contactId && !options.email)
      return {
        data: null,
        headers: null,
        error: {
          message: "Missing `id` or `email` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    const identifier = options.email ? options.email : options.contactId;
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/contacts/${identifier}/segments?${queryString}` : `/contacts/${identifier}/segments`;
    return await this.resend.get(url);
  }
  async add(options) {
    if (!options.contactId && !options.email)
      return {
        data: null,
        headers: null,
        error: {
          message: "Missing `id` or `email` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    const identifier = options.email ? options.email : options.contactId;
    return this.resend.post(`/contacts/${identifier}/segments/${options.segmentId}`);
  }
  async remove(options) {
    if (!options.contactId && !options.email)
      return {
        data: null,
        headers: null,
        error: {
          message: "Missing `id` or `email` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    const identifier = options.email ? options.email : options.contactId;
    return this.resend.delete(`/contacts/${identifier}/segments/${options.segmentId}`);
  }
}, ContactTopics = class {
  constructor(resend) {
    this.resend = resend;
  }
  async update(payload) {
    if (!payload.id && !payload.email)
      return {
        data: null,
        headers: null,
        error: {
          message: "Missing `id` or `email` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    const identifier = payload.email ? payload.email : payload.id;
    return this.resend.patch(`/contacts/${identifier}/topics`, payload.topics);
  }
  async list(options) {
    if (!options.id && !options.email)
      return {
        data: null,
        headers: null,
        error: {
          message: "Missing `id` or `email` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    const identifier = options.email ? options.email : options.id;
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/contacts/${identifier}/topics?${queryString}` : `/contacts/${identifier}/topics`;
    return this.resend.get(url);
  }
}, Contacts = class {
  constructor(resend) {
    this.resend = resend;
    this.topics = new ContactTopics(this.resend);
    this.segments = new ContactSegments(this.resend);
  }
  async create(payload, options = {}) {
    if ("audienceId" in payload) {
      if ("segments" in payload || "topics" in payload)
        return {
          data: null,
          headers: null,
          error: {
            message: "`audienceId` is deprecated, and cannot be used together with `segments` or `topics`. Use `segments` instead to add one or more segments to the new contact.",
            statusCode: null,
            name: "invalid_parameter"
          }
        };
      return await this.resend.post(`/audiences/${payload.audienceId}/contacts`, {
        unsubscribed: payload.unsubscribed,
        email: payload.email,
        first_name: payload.firstName,
        last_name: payload.lastName,
        properties: payload.properties
      }, options);
    }
    return await this.resend.post("/contacts", {
      unsubscribed: payload.unsubscribed,
      email: payload.email,
      first_name: payload.firstName,
      last_name: payload.lastName,
      properties: payload.properties,
      segments: payload.segments,
      topics: payload.topics
    }, options);
  }
  async list(options = {}) {
    const segmentId = options.segmentId ?? options.audienceId;
    if (!segmentId) {
      const queryString2 = buildPaginationQuery(options);
      const url2 = queryString2 ? `/contacts?${queryString2}` : "/contacts";
      return await this.resend.get(url2);
    }
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/segments/${segmentId}/contacts?${queryString}` : `/segments/${segmentId}/contacts`;
    return await this.resend.get(url);
  }
  async get(options) {
    if (typeof options === "string")
      return this.resend.get(`/contacts/${options}`);
    if (!options.id && !options.email)
      return {
        data: null,
        headers: null,
        error: {
          message: "Missing `id` or `email` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    if (!options.audienceId)
      return this.resend.get(`/contacts/${options?.email ? options?.email : options?.id}`);
    return this.resend.get(`/audiences/${options.audienceId}/contacts/${options?.email ? options?.email : options?.id}`);
  }
  async update(options) {
    if (!options.id && !options.email)
      return {
        data: null,
        headers: null,
        error: {
          message: "Missing `id` or `email` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    if (!options.audienceId)
      return await this.resend.patch(`/contacts/${options?.email ? options?.email : options?.id}`, {
        unsubscribed: options.unsubscribed,
        first_name: options.firstName,
        last_name: options.lastName,
        properties: options.properties
      });
    return await this.resend.patch(`/audiences/${options.audienceId}/contacts/${options?.email ? options?.email : options?.id}`, {
      unsubscribed: options.unsubscribed,
      first_name: options.firstName,
      last_name: options.lastName,
      properties: options.properties
    });
  }
  async remove(payload) {
    if (typeof payload === "string")
      return this.resend.delete(`/contacts/${payload}`);
    if (!payload.id && !payload.email)
      return {
        data: null,
        headers: null,
        error: {
          message: "Missing `id` or `email` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    if (!payload.audienceId)
      return this.resend.delete(`/contacts/${payload?.email ? payload?.email : payload?.id}`);
    return this.resend.delete(`/audiences/${payload.audienceId}/contacts/${payload?.email ? payload?.email : payload?.id}`);
  }
}, Domains = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    return await this.resend.post("/domains", parseDomainToApiOptions(payload), options);
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/domains?${queryString}` : "/domains";
    return await this.resend.get(url);
  }
  async get(id) {
    return await this.resend.get(`/domains/${id}`);
  }
  async update(payload) {
    return await this.resend.patch(`/domains/${payload.id}`, {
      click_tracking: payload.clickTracking,
      open_tracking: payload.openTracking,
      tls: payload.tls,
      capabilities: payload.capabilities
    });
  }
  async remove(id) {
    return await this.resend.delete(`/domains/${id}`);
  }
  async verify(id) {
    return await this.resend.post(`/domains/${id}/verify`);
  }
}, Attachments$1 = class {
  constructor(resend) {
    this.resend = resend;
  }
  async get(options) {
    const { emailId, id } = options;
    return await this.resend.get(`/emails/${emailId}/attachments/${id}`);
  }
  async list(options) {
    const { emailId } = options;
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/emails/${emailId}/attachments?${queryString}` : `/emails/${emailId}/attachments`;
    return await this.resend.get(url);
  }
}, Attachments = class {
  constructor(resend) {
    this.resend = resend;
  }
  async get(options) {
    const { emailId, id } = options;
    return await this.resend.get(`/emails/receiving/${emailId}/attachments/${id}`);
  }
  async list(options) {
    const { emailId } = options;
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/emails/receiving/${emailId}/attachments?${queryString}` : `/emails/receiving/${emailId}/attachments`;
    return await this.resend.get(url);
  }
}, Receiving = class {
  constructor(resend) {
    this.resend = resend;
    this.attachments = new Attachments(resend);
  }
  async get(id) {
    return await this.resend.get(`/emails/receiving/${id}`);
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/emails/receiving?${queryString}` : "/emails/receiving";
    return await this.resend.get(url);
  }
  async forward(options) {
    const { emailId, to, from } = options;
    const passthrough = options.passthrough !== false;
    const emailResponse = await this.get(emailId);
    if (emailResponse.error)
      return {
        data: null,
        error: emailResponse.error,
        headers: emailResponse.headers
      };
    const email = emailResponse.data;
    const originalSubject = email.subject || "(no subject)";
    if (passthrough)
      return this.forwardPassthrough(email, {
        to,
        from,
        subject: originalSubject
      });
    const forwardSubject = originalSubject.startsWith("Fwd:") ? originalSubject : `Fwd: ${originalSubject}`;
    return this.forwardWrapped(email, {
      to,
      from,
      subject: forwardSubject,
      text: "text" in options ? options.text : undefined,
      html: "html" in options ? options.html : undefined
    });
  }
  async forwardPassthrough(email, options) {
    const { to, from, subject } = options;
    if (!email.raw?.download_url)
      return {
        data: null,
        error: {
          name: "validation_error",
          message: "Raw email content is not available for this email",
          statusCode: 400
        },
        headers: null
      };
    const rawResponse = await fetch(email.raw.download_url);
    if (!rawResponse.ok)
      return {
        data: null,
        error: {
          name: "application_error",
          message: "Failed to download raw email content",
          statusCode: rawResponse.status
        },
        headers: null
      };
    const rawEmailContent = await rawResponse.text();
    const parsed = await PostalMime.parse(rawEmailContent, { attachmentEncoding: "base64" });
    const attachments = parsed.attachments.map((attachment) => {
      const contentId = attachment.contentId ? attachment.contentId.replace(/^<|>$/g, "") : undefined;
      return {
        filename: attachment.filename,
        content: attachment.content.toString(),
        content_type: attachment.mimeType,
        content_id: contentId || undefined
      };
    });
    return await this.resend.post("/emails", {
      from,
      to,
      subject,
      text: parsed.text || undefined,
      html: parsed.html || undefined,
      attachments: attachments.length > 0 ? attachments : undefined
    });
  }
  async forwardWrapped(email, options) {
    const { to, from, subject, text, html } = options;
    if (!email.raw?.download_url)
      return {
        data: null,
        error: {
          name: "validation_error",
          message: "Raw email content is not available for this email",
          statusCode: 400
        },
        headers: null
      };
    const rawResponse = await fetch(email.raw.download_url);
    if (!rawResponse.ok)
      return {
        data: null,
        error: {
          name: "application_error",
          message: "Failed to download raw email content",
          statusCode: rawResponse.status
        },
        headers: null
      };
    const rawEmailContent = await rawResponse.text();
    return await this.resend.post("/emails", {
      from,
      to,
      subject,
      text,
      html,
      attachments: [{
        filename: "forwarded_message.eml",
        content: Buffer.from(rawEmailContent).toString("base64"),
        content_type: "message/rfc822"
      }]
    });
  }
}, Emails = class {
  constructor(resend) {
    this.resend = resend;
    this.attachments = new Attachments$1(resend);
    this.receiving = new Receiving(resend);
  }
  async send(payload, options = {}) {
    return this.create(payload, options);
  }
  async create(payload, options = {}) {
    if (payload.react)
      payload.html = await render(payload.react);
    return await this.resend.post("/emails", parseEmailToApiOptions(payload), options);
  }
  async get(id) {
    return await this.resend.get(`/emails/${id}`);
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/emails?${queryString}` : "/emails";
    return await this.resend.get(url);
  }
  async update(payload) {
    return await this.resend.patch(`/emails/${payload.id}`, { scheduled_at: payload.scheduledAt });
  }
  async cancel(id) {
    return await this.resend.post(`/emails/${id}/cancel`);
  }
}, Segments = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    return await this.resend.post("/segments", payload, options);
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/segments?${queryString}` : "/segments";
    return await this.resend.get(url);
  }
  async get(id) {
    return await this.resend.get(`/segments/${id}`);
  }
  async remove(id) {
    return await this.resend.delete(`/segments/${id}`);
  }
}, ChainableTemplateResult = class {
  constructor(promise, publishFn) {
    this.promise = promise;
    this.publishFn = publishFn;
  }
  then(onfulfilled, onrejected) {
    return this.promise.then(onfulfilled, onrejected);
  }
  async publish() {
    const { data, error } = await this.promise;
    if (error)
      return {
        data: null,
        headers: null,
        error
      };
    return this.publishFn(data.id);
  }
}, Templates = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(payload) {
    return new ChainableTemplateResult(this.performCreate(payload), this.publish.bind(this));
  }
  async performCreate(payload) {
    if (payload.react) {
      if (!this.renderAsync)
        try {
          const { renderAsync } = __require("@react-email/render");
          this.renderAsync = renderAsync;
        } catch {
          throw new Error("Failed to render React component. Make sure to install `@react-email/render`");
        }
      payload.html = await this.renderAsync(payload.react);
    }
    return this.resend.post("/templates", parseTemplateToApiOptions(payload));
  }
  async remove(identifier) {
    return await this.resend.delete(`/templates/${identifier}`);
  }
  async get(identifier) {
    return await this.resend.get(`/templates/${identifier}`);
  }
  async list(options = {}) {
    return this.resend.get(`/templates${getPaginationQueryProperties(options)}`);
  }
  duplicate(identifier) {
    return new ChainableTemplateResult(this.resend.post(`/templates/${identifier}/duplicate`), this.publish.bind(this));
  }
  async publish(identifier) {
    return await this.resend.post(`/templates/${identifier}/publish`);
  }
  async update(identifier, payload) {
    return await this.resend.patch(`/templates/${identifier}`, parseTemplateToApiOptions(payload));
  }
}, Topics = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload) {
    const { defaultSubscription, ...body } = payload;
    return await this.resend.post("/topics", {
      ...body,
      default_subscription: defaultSubscription
    });
  }
  async list() {
    return await this.resend.get("/topics");
  }
  async get(id) {
    if (!id)
      return {
        data: null,
        headers: null,
        error: {
          message: "Missing `id` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    return await this.resend.get(`/topics/${id}`);
  }
  async update(payload) {
    if (!payload.id)
      return {
        data: null,
        headers: null,
        error: {
          message: "Missing `id` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    return await this.resend.patch(`/topics/${payload.id}`, payload);
  }
  async remove(id) {
    if (!id)
      return {
        data: null,
        headers: null,
        error: {
          message: "Missing `id` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    return await this.resend.delete(`/topics/${id}`);
  }
}, Webhooks = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    return await this.resend.post("/webhooks", payload, options);
  }
  async get(id) {
    return await this.resend.get(`/webhooks/${id}`);
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/webhooks?${queryString}` : "/webhooks";
    return await this.resend.get(url);
  }
  async update(id, payload) {
    return await this.resend.patch(`/webhooks/${id}`, payload);
  }
  async remove(id) {
    return await this.resend.delete(`/webhooks/${id}`);
  }
  verify(payload) {
    return new import_svix.Webhook(payload.webhookSecret).verify(payload.payload, {
      "svix-id": payload.headers.id,
      "svix-timestamp": payload.headers.timestamp,
      "svix-signature": payload.headers.signature
    });
  }
}, defaultBaseUrl = "https://api.resend.com", defaultUserAgent, baseUrl, userAgent, Resend = class {
  constructor(key) {
    this.key = key;
    this.apiKeys = new ApiKeys(this);
    this.segments = new Segments(this);
    this.audiences = this.segments;
    this.batch = new Batch(this);
    this.broadcasts = new Broadcasts(this);
    this.contacts = new Contacts(this);
    this.contactProperties = new ContactProperties(this);
    this.domains = new Domains(this);
    this.emails = new Emails(this);
    this.webhooks = new Webhooks(this);
    this.templates = new Templates(this);
    this.topics = new Topics(this);
    if (!key) {
      if (typeof process !== "undefined" && process.env)
        this.key = process.env.RESEND_API_KEY;
      if (!this.key)
        throw new Error('Missing API key. Pass it to the constructor `new Resend("re_123")`');
    }
    this.headers = new Headers({
      Authorization: `Bearer ${this.key}`,
      "User-Agent": userAgent,
      "Content-Type": "application/json"
    });
  }
  async fetchRequest(path, options = {}) {
    try {
      const response = await fetch(`${baseUrl}${path}`, options);
      if (!response.ok)
        try {
          const rawError = await response.text();
          return {
            data: null,
            error: JSON.parse(rawError),
            headers: Object.fromEntries(response.headers.entries())
          };
        } catch (err) {
          if (err instanceof SyntaxError)
            return {
              data: null,
              error: {
                name: "application_error",
                statusCode: response.status,
                message: "Internal server error. We are unable to process your request right now, please try again later."
              },
              headers: Object.fromEntries(response.headers.entries())
            };
          const error = {
            message: response.statusText,
            statusCode: response.status,
            name: "application_error"
          };
          if (err instanceof Error)
            return {
              data: null,
              error: {
                ...error,
                message: err.message
              },
              headers: Object.fromEntries(response.headers.entries())
            };
          return {
            data: null,
            error,
            headers: Object.fromEntries(response.headers.entries())
          };
        }
      return {
        data: await response.json(),
        error: null,
        headers: Object.fromEntries(response.headers.entries())
      };
    } catch {
      return {
        data: null,
        error: {
          name: "application_error",
          statusCode: null,
          message: "Unable to fetch data. The request could not be resolved."
        },
        headers: null
      };
    }
  }
  async post(path, entity, options = {}) {
    const headers = new Headers(this.headers);
    if (options.headers)
      for (const [key, value] of new Headers(options.headers).entries())
        headers.set(key, value);
    if (options.idempotencyKey)
      headers.set("Idempotency-Key", options.idempotencyKey);
    const requestOptions = {
      method: "POST",
      body: JSON.stringify(entity),
      ...options,
      headers
    };
    return this.fetchRequest(path, requestOptions);
  }
  async get(path, options = {}) {
    const headers = new Headers(this.headers);
    if (options.headers)
      for (const [key, value] of new Headers(options.headers).entries())
        headers.set(key, value);
    const requestOptions = {
      method: "GET",
      ...options,
      headers
    };
    return this.fetchRequest(path, requestOptions);
  }
  async put(path, entity, options = {}) {
    const headers = new Headers(this.headers);
    if (options.headers)
      for (const [key, value] of new Headers(options.headers).entries())
        headers.set(key, value);
    const requestOptions = {
      method: "PUT",
      body: JSON.stringify(entity),
      ...options,
      headers
    };
    return this.fetchRequest(path, requestOptions);
  }
  async patch(path, entity, options = {}) {
    const headers = new Headers(this.headers);
    if (options.headers)
      for (const [key, value] of new Headers(options.headers).entries())
        headers.set(key, value);
    const requestOptions = {
      method: "PATCH",
      body: JSON.stringify(entity),
      ...options,
      headers
    };
    return this.fetchRequest(path, requestOptions);
  }
  async delete(path, query) {
    const requestOptions = {
      method: "DELETE",
      body: JSON.stringify(query),
      headers: this.headers
    };
    return this.fetchRequest(path, requestOptions);
  }
};
var init_dist2 = __esm(() => {
  init_postal_mime();
  import_svix = __toESM(require_dist7(), 1);
  defaultUserAgent = `resend-node:${version}`;
  baseUrl = typeof process !== "undefined" && process.env ? process.env.RESEND_BASE_URL || defaultBaseUrl : defaultBaseUrl;
  userAgent = typeof process !== "undefined" && process.env ? process.env.RESEND_USER_AGENT || defaultUserAgent : defaultUserAgent;
});

// node_modules/@smithy/types/dist-cjs/index.js
var require_dist_cjs = __commonJS((exports) => {
  exports.HttpAuthLocation = undefined;
  (function(HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
  })(exports.HttpAuthLocation || (exports.HttpAuthLocation = {}));
  exports.HttpApiKeyAuthLocation = undefined;
  (function(HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
  })(exports.HttpApiKeyAuthLocation || (exports.HttpApiKeyAuthLocation = {}));
  exports.EndpointURLScheme = undefined;
  (function(EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
  })(exports.EndpointURLScheme || (exports.EndpointURLScheme = {}));
  exports.AlgorithmId = undefined;
  (function(AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
  })(exports.AlgorithmId || (exports.AlgorithmId = {}));
  var getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
      checksumAlgorithms.push({
        algorithmId: () => exports.AlgorithmId.SHA256,
        checksumConstructor: () => runtimeConfig.sha256
      });
    }
    if (runtimeConfig.md5 != null) {
      checksumAlgorithms.push({
        algorithmId: () => exports.AlgorithmId.MD5,
        checksumConstructor: () => runtimeConfig.md5
      });
    }
    return {
      addChecksumAlgorithm(algo) {
        checksumAlgorithms.push(algo);
      },
      checksumAlgorithms() {
        return checksumAlgorithms;
      }
    };
  };
  var resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
      runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
  };
  var getDefaultClientConfiguration = (runtimeConfig) => {
    return getChecksumConfiguration(runtimeConfig);
  };
  var resolveDefaultRuntimeConfig = (config) => {
    return resolveChecksumRuntimeConfig(config);
  };
  exports.FieldPosition = undefined;
  (function(FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
  })(exports.FieldPosition || (exports.FieldPosition = {}));
  var SMITHY_CONTEXT_KEY = "__smithy_context";
  exports.IniSectionType = undefined;
  (function(IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
  })(exports.IniSectionType || (exports.IniSectionType = {}));
  exports.RequestHandlerProtocol = undefined;
  (function(RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
  })(exports.RequestHandlerProtocol || (exports.RequestHandlerProtocol = {}));
  exports.SMITHY_CONTEXT_KEY = SMITHY_CONTEXT_KEY;
  exports.getDefaultClientConfiguration = getDefaultClientConfiguration;
  exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig;
});

// node_modules/@smithy/protocol-http/dist-cjs/index.js
var require_dist_cjs2 = __commonJS((exports) => {
  var types = require_dist_cjs();
  var getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
    return {
      setHttpHandler(handler) {
        runtimeConfig.httpHandler = handler;
      },
      httpHandler() {
        return runtimeConfig.httpHandler;
      },
      updateHttpClientConfig(key, value) {
        runtimeConfig.httpHandler?.updateHttpClientConfig(key, value);
      },
      httpHandlerConfigs() {
        return runtimeConfig.httpHandler.httpHandlerConfigs();
      }
    };
  };
  var resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
    return {
      httpHandler: httpHandlerExtensionConfiguration.httpHandler()
    };
  };

  class Field {
    name;
    kind;
    values;
    constructor({ name, kind = types.FieldPosition.HEADER, values = [] }) {
      this.name = name;
      this.kind = kind;
      this.values = values;
    }
    add(value) {
      this.values.push(value);
    }
    set(values) {
      this.values = values;
    }
    remove(value) {
      this.values = this.values.filter((v) => v !== value);
    }
    toString() {
      return this.values.map((v) => v.includes(",") || v.includes(" ") ? `"${v}"` : v).join(", ");
    }
    get() {
      return this.values;
    }
  }

  class Fields {
    entries = {};
    encoding;
    constructor({ fields = [], encoding = "utf-8" }) {
      fields.forEach(this.setField.bind(this));
      this.encoding = encoding;
    }
    setField(field) {
      this.entries[field.name.toLowerCase()] = field;
    }
    getField(name) {
      return this.entries[name.toLowerCase()];
    }
    removeField(name) {
      delete this.entries[name.toLowerCase()];
    }
    getByType(kind) {
      return Object.values(this.entries).filter((field) => field.kind === kind);
    }
  }

  class HttpRequest {
    method;
    protocol;
    hostname;
    port;
    path;
    query;
    headers;
    username;
    password;
    fragment;
    body;
    constructor(options) {
      this.method = options.method || "GET";
      this.hostname = options.hostname || "localhost";
      this.port = options.port;
      this.query = options.query || {};
      this.headers = options.headers || {};
      this.body = options.body;
      this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
      this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
      this.username = options.username;
      this.password = options.password;
      this.fragment = options.fragment;
    }
    static clone(request) {
      const cloned = new HttpRequest({
        ...request,
        headers: { ...request.headers }
      });
      if (cloned.query) {
        cloned.query = cloneQuery(cloned.query);
      }
      return cloned;
    }
    static isInstance(request) {
      if (!request) {
        return false;
      }
      const req = request;
      return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
    }
    clone() {
      return HttpRequest.clone(this);
    }
  }
  function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
      const param = query[paramName];
      return {
        ...carry,
        [paramName]: Array.isArray(param) ? [...param] : param
      };
    }, {});
  }

  class HttpResponse {
    statusCode;
    reason;
    headers;
    body;
    constructor(options) {
      this.statusCode = options.statusCode;
      this.reason = options.reason;
      this.headers = options.headers || {};
      this.body = options.body;
    }
    static isInstance(response) {
      if (!response)
        return false;
      const resp = response;
      return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
  }
  function isValidHostname(hostname) {
    const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
    return hostPattern.test(hostname);
  }
  exports.Field = Field;
  exports.Fields = Fields;
  exports.HttpRequest = HttpRequest;
  exports.HttpResponse = HttpResponse;
  exports.getHttpHandlerExtensionConfiguration = getHttpHandlerExtensionConfiguration;
  exports.isValidHostname = isValidHostname;
  exports.resolveHttpHandlerRuntimeConfig = resolveHttpHandlerRuntimeConfig;
});

// node_modules/@aws-sdk/middleware-expect-continue/dist-cjs/index.js
var require_dist_cjs3 = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs2();
  function addExpectContinueMiddleware(options) {
    return (next) => async (args) => {
      const { request } = args;
      if (options.expectContinueHeader !== false && protocolHttp.HttpRequest.isInstance(request) && request.body && options.runtime === "node" && options.requestHandler?.constructor?.name !== "FetchHttpHandler") {
        let sendHeader = true;
        if (typeof options.expectContinueHeader === "number") {
          try {
            const bodyLength = Number(request.headers?.["content-length"]) ?? options.bodyLengthChecker?.(request.body) ?? Infinity;
            sendHeader = bodyLength >= options.expectContinueHeader;
          } catch (e) {}
        } else {
          sendHeader = !!options.expectContinueHeader;
        }
        if (sendHeader) {
          request.headers.Expect = "100-continue";
        }
      }
      return next({
        ...args,
        request
      });
    };
  }
  var addExpectContinueMiddlewareOptions = {
    step: "build",
    tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
    name: "addExpectContinueMiddleware",
    override: true
  };
  var getAddExpectContinuePlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(addExpectContinueMiddleware(options), addExpectContinueMiddlewareOptions);
    }
  });
  exports.addExpectContinueMiddleware = addExpectContinueMiddleware;
  exports.addExpectContinueMiddlewareOptions = addExpectContinueMiddlewareOptions;
  exports.getAddExpectContinuePlugin = getAddExpectContinuePlugin;
});

// node_modules/@smithy/util-middleware/dist-cjs/index.js
var require_dist_cjs4 = __commonJS((exports) => {
  var types = require_dist_cjs();
  var getSmithyContext = (context) => context[types.SMITHY_CONTEXT_KEY] || (context[types.SMITHY_CONTEXT_KEY] = {});
  var normalizeProvider = (input) => {
    if (typeof input === "function")
      return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
  };
  exports.getSmithyContext = getSmithyContext;
  exports.normalizeProvider = normalizeProvider;
});

// node_modules/@smithy/middleware-serde/dist-cjs/index.js
var require_dist_cjs5 = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs2();
  var deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {
    const { response } = await next(args);
    try {
      const parsed = await deserializer(response, options);
      return {
        response,
        output: parsed
      };
    } catch (error) {
      Object.defineProperty(error, "$response", {
        value: response,
        enumerable: false,
        writable: false,
        configurable: false
      });
      if (!("$metadata" in error)) {
        const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
        try {
          error.message += `
  ` + hint;
        } catch (e) {
          if (!context.logger || context.logger?.constructor?.name === "NoOpLogger") {
            console.warn(hint);
          } else {
            context.logger?.warn?.(hint);
          }
        }
        if (typeof error.$responseBodyText !== "undefined") {
          if (error.$response) {
            error.$response.body = error.$responseBodyText;
          }
        }
        try {
          if (protocolHttp.HttpResponse.isInstance(response)) {
            const { headers = {} } = response;
            const headerEntries = Object.entries(headers);
            error.$metadata = {
              httpStatusCode: response.statusCode,
              requestId: findHeader(/^x-[\w-]+-request-?id$/, headerEntries),
              extendedRequestId: findHeader(/^x-[\w-]+-id-2$/, headerEntries),
              cfId: findHeader(/^x-[\w-]+-cf-id$/, headerEntries)
            };
          }
        } catch (e) {}
      }
      throw error;
    }
  };
  var findHeader = (pattern, headers) => {
    return (headers.find(([k]) => {
      return k.match(pattern);
    }) || [undefined, undefined])[1];
  };
  var serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
    const endpointConfig = options;
    const endpoint = context.endpointV2?.url && endpointConfig.urlParser ? async () => endpointConfig.urlParser(context.endpointV2.url) : endpointConfig.endpoint;
    if (!endpoint) {
      throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint });
    return next({
      ...args,
      request
    });
  };
  var deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true
  };
  var serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true
  };
  function getSerdePlugin(config, serializer, deserializer) {
    return {
      applyToStack: (commandStack) => {
        commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
        commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
      }
    };
  }
  exports.deserializerMiddleware = deserializerMiddleware;
  exports.deserializerMiddlewareOption = deserializerMiddlewareOption;
  exports.getSerdePlugin = getSerdePlugin;
  exports.serializerMiddleware = serializerMiddleware;
  exports.serializerMiddlewareOption = serializerMiddlewareOption;
});

// node_modules/@smithy/is-array-buffer/dist-cjs/index.js
var require_dist_cjs6 = __commonJS((exports) => {
  var isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
  exports.isArrayBuffer = isArrayBuffer;
});

// node_modules/@smithy/util-buffer-from/dist-cjs/index.js
var require_dist_cjs7 = __commonJS((exports) => {
  var isArrayBuffer = require_dist_cjs6();
  var buffer = __require("buffer");
  var fromArrayBuffer = (input, offset2 = 0, length = input.byteLength - offset2) => {
    if (!isArrayBuffer.isArrayBuffer(input)) {
      throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return buffer.Buffer.from(input, offset2, length);
  };
  var fromString = (input, encoding) => {
    if (typeof input !== "string") {
      throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? buffer.Buffer.from(input, encoding) : buffer.Buffer.from(input);
  };
  exports.fromArrayBuffer = fromArrayBuffer;
  exports.fromString = fromString;
});

// node_modules/@smithy/util-base64/dist-cjs/fromBase64.js
var require_fromBase64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromBase64 = undefined;
  var util_buffer_from_1 = require_dist_cjs7();
  var BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
  var fromBase64 = (input) => {
    if (input.length * 3 % 4 !== 0) {
      throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
      throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = (0, util_buffer_from_1.fromString)(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  };
  exports.fromBase64 = fromBase64;
});

// node_modules/@smithy/util-utf8/dist-cjs/index.js
var require_dist_cjs8 = __commonJS((exports) => {
  var utilBufferFrom = require_dist_cjs7();
  var fromUtf8 = (input) => {
    const buf = utilBufferFrom.fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  };
  var toUint8Array = (data) => {
    if (typeof data === "string") {
      return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  };
  var toUtf8 = (input) => {
    if (typeof input === "string") {
      return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
      throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return utilBufferFrom.fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
  };
  exports.fromUtf8 = fromUtf8;
  exports.toUint8Array = toUint8Array;
  exports.toUtf8 = toUtf8;
});

// node_modules/@smithy/util-base64/dist-cjs/toBase64.js
var require_toBase64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toBase64 = undefined;
  var util_buffer_from_1 = require_dist_cjs7();
  var util_utf8_1 = require_dist_cjs8();
  var toBase64 = (_input) => {
    let input;
    if (typeof _input === "string") {
      input = (0, util_utf8_1.fromUtf8)(_input);
    } else {
      input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
      throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
  };
  exports.toBase64 = toBase64;
});

// node_modules/@smithy/util-base64/dist-cjs/index.js
var require_dist_cjs9 = __commonJS((exports) => {
  var fromBase64 = require_fromBase64();
  var toBase64 = require_toBase64();
  Object.prototype.hasOwnProperty.call(fromBase64, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: fromBase64["__proto__"]
  });
  Object.keys(fromBase64).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = fromBase64[k];
  });
  Object.prototype.hasOwnProperty.call(toBase64, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: toBase64["__proto__"]
  });
  Object.keys(toBase64).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = toBase64[k];
  });
});

// node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.js
var require_ChecksumStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChecksumStream = undefined;
  var util_base64_1 = require_dist_cjs9();
  var stream_1 = __require("stream");

  class ChecksumStream extends stream_1.Duplex {
    expectedChecksum;
    checksumSourceLocation;
    checksum;
    source;
    base64Encoder;
    pendingCallback = null;
    constructor({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder }) {
      super();
      if (typeof source.pipe === "function") {
        this.source = source;
      } else {
        throw new Error(`@smithy/util-stream: unsupported source type ${source?.constructor?.name ?? source} in ChecksumStream.`);
      }
      this.base64Encoder = base64Encoder ?? util_base64_1.toBase64;
      this.expectedChecksum = expectedChecksum;
      this.checksum = checksum;
      this.checksumSourceLocation = checksumSourceLocation;
      this.source.pipe(this);
    }
    _read(size) {
      if (this.pendingCallback) {
        const callback = this.pendingCallback;
        this.pendingCallback = null;
        callback();
      }
    }
    _write(chunk, encoding, callback) {
      try {
        this.checksum.update(chunk);
        const canPushMore = this.push(chunk);
        if (!canPushMore) {
          this.pendingCallback = callback;
          return;
        }
      } catch (e) {
        return callback(e);
      }
      return callback();
    }
    async _final(callback) {
      try {
        const digest = await this.checksum.digest();
        const received = this.base64Encoder(digest);
        if (this.expectedChecksum !== received) {
          return callback(new Error(`Checksum mismatch: expected "${this.expectedChecksum}" but received "${received}"` + ` in response header "${this.checksumSourceLocation}".`));
        }
      } catch (e) {
        return callback(e);
      }
      this.push(null);
      return callback();
    }
  }
  exports.ChecksumStream = ChecksumStream;
});

// node_modules/@smithy/util-stream/dist-cjs/stream-type-check.js
var require_stream_type_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isBlob = exports.isReadableStream = undefined;
  var isReadableStream = (stream3) => typeof ReadableStream === "function" && (stream3?.constructor?.name === ReadableStream.name || stream3 instanceof ReadableStream);
  exports.isReadableStream = isReadableStream;
  var isBlob = (blob) => {
    return typeof Blob === "function" && (blob?.constructor?.name === Blob.name || blob instanceof Blob);
  };
  exports.isBlob = isBlob;
});

// node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.browser.js
var require_ChecksumStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChecksumStream = undefined;
  var ReadableStreamRef = typeof ReadableStream === "function" ? ReadableStream : function() {};

  class ChecksumStream extends ReadableStreamRef {
  }
  exports.ChecksumStream = ChecksumStream;
});

// node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.browser.js
var require_createChecksumStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createChecksumStream = undefined;
  var util_base64_1 = require_dist_cjs9();
  var stream_type_check_1 = require_stream_type_check();
  var ChecksumStream_browser_1 = require_ChecksumStream_browser();
  var createChecksumStream = ({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder }) => {
    if (!(0, stream_type_check_1.isReadableStream)(source)) {
      throw new Error(`@smithy/util-stream: unsupported source type ${source?.constructor?.name ?? source} in ChecksumStream.`);
    }
    const encoder2 = base64Encoder ?? util_base64_1.toBase64;
    if (typeof TransformStream !== "function") {
      throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");
    }
    const transform = new TransformStream({
      start() {},
      async transform(chunk, controller) {
        checksum.update(chunk);
        controller.enqueue(chunk);
      },
      async flush(controller) {
        const digest = await checksum.digest();
        const received = encoder2(digest);
        if (expectedChecksum !== received) {
          const error = new Error(`Checksum mismatch: expected "${expectedChecksum}" but received "${received}"` + ` in response header "${checksumSourceLocation}".`);
          controller.error(error);
        } else {
          controller.terminate();
        }
      }
    });
    source.pipeThrough(transform);
    const readable = transform.readable;
    Object.setPrototypeOf(readable, ChecksumStream_browser_1.ChecksumStream.prototype);
    return readable;
  };
  exports.createChecksumStream = createChecksumStream;
});

// node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.js
var require_createChecksumStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createChecksumStream = createChecksumStream;
  var stream_type_check_1 = require_stream_type_check();
  var ChecksumStream_1 = require_ChecksumStream();
  var createChecksumStream_browser_1 = require_createChecksumStream_browser();
  function createChecksumStream(init) {
    if (typeof ReadableStream === "function" && (0, stream_type_check_1.isReadableStream)(init.source)) {
      return (0, createChecksumStream_browser_1.createChecksumStream)(init);
    }
    return new ChecksumStream_1.ChecksumStream(init);
  }
});

// node_modules/@smithy/util-stream/dist-cjs/ByteArrayCollector.js
var require_ByteArrayCollector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ByteArrayCollector = undefined;

  class ByteArrayCollector {
    allocByteArray;
    byteLength = 0;
    byteArrays = [];
    constructor(allocByteArray) {
      this.allocByteArray = allocByteArray;
    }
    push(byteArray) {
      this.byteArrays.push(byteArray);
      this.byteLength += byteArray.byteLength;
    }
    flush() {
      if (this.byteArrays.length === 1) {
        const bytes = this.byteArrays[0];
        this.reset();
        return bytes;
      }
      const aggregation = this.allocByteArray(this.byteLength);
      let cursor = 0;
      for (let i2 = 0;i2 < this.byteArrays.length; ++i2) {
        const bytes = this.byteArrays[i2];
        aggregation.set(bytes, cursor);
        cursor += bytes.byteLength;
      }
      this.reset();
      return aggregation;
    }
    reset() {
      this.byteArrays = [];
      this.byteLength = 0;
    }
  }
  exports.ByteArrayCollector = ByteArrayCollector;
});

// node_modules/@smithy/util-stream/dist-cjs/createBufferedReadableStream.js
var require_createBufferedReadableStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createBufferedReadable = undefined;
  exports.createBufferedReadableStream = createBufferedReadableStream;
  exports.merge = merge;
  exports.flush = flush;
  exports.sizeOf = sizeOf;
  exports.modeOf = modeOf;
  var ByteArrayCollector_1 = require_ByteArrayCollector();
  function createBufferedReadableStream(upstream, size, logger) {
    const reader = upstream.getReader();
    let streamBufferingLoggedWarning = false;
    let bytesSeen = 0;
    const buffers = ["", new ByteArrayCollector_1.ByteArrayCollector((size2) => new Uint8Array(size2))];
    let mode = -1;
    const pull = async (controller) => {
      const { value, done } = await reader.read();
      const chunk = value;
      if (done) {
        if (mode !== -1) {
          const remainder = flush(buffers, mode);
          if (sizeOf(remainder) > 0) {
            controller.enqueue(remainder);
          }
        }
        controller.close();
      } else {
        const chunkMode = modeOf(chunk, false);
        if (mode !== chunkMode) {
          if (mode >= 0) {
            controller.enqueue(flush(buffers, mode));
          }
          mode = chunkMode;
        }
        if (mode === -1) {
          controller.enqueue(chunk);
          return;
        }
        const chunkSize = sizeOf(chunk);
        bytesSeen += chunkSize;
        const bufferSize = sizeOf(buffers[mode]);
        if (chunkSize >= size && bufferSize === 0) {
          controller.enqueue(chunk);
        } else {
          const newSize = merge(buffers, mode, chunk);
          if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {
            streamBufferingLoggedWarning = true;
            logger?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);
          }
          if (newSize >= size) {
            controller.enqueue(flush(buffers, mode));
          } else {
            await pull(controller);
          }
        }
      }
    };
    return new ReadableStream({
      pull
    });
  }
  exports.createBufferedReadable = createBufferedReadableStream;
  function merge(buffers, mode, chunk) {
    switch (mode) {
      case 0:
        buffers[0] += chunk;
        return sizeOf(buffers[0]);
      case 1:
      case 2:
        buffers[mode].push(chunk);
        return sizeOf(buffers[mode]);
    }
  }
  function flush(buffers, mode) {
    switch (mode) {
      case 0:
        const s = buffers[0];
        buffers[0] = "";
        return s;
      case 1:
      case 2:
        return buffers[mode].flush();
    }
    throw new Error(`@smithy/util-stream - invalid index ${mode} given to flush()`);
  }
  function sizeOf(chunk) {
    return chunk?.byteLength ?? chunk?.length ?? 0;
  }
  function modeOf(chunk, allowBuffer = true) {
    if (allowBuffer && typeof Buffer !== "undefined" && chunk instanceof Buffer) {
      return 2;
    }
    if (chunk instanceof Uint8Array) {
      return 1;
    }
    if (typeof chunk === "string") {
      return 0;
    }
    return -1;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/createBufferedReadable.js
var require_createBufferedReadable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createBufferedReadable = createBufferedReadable;
  var node_stream_1 = __require("node:stream");
  var ByteArrayCollector_1 = require_ByteArrayCollector();
  var createBufferedReadableStream_1 = require_createBufferedReadableStream();
  var stream_type_check_1 = require_stream_type_check();
  function createBufferedReadable(upstream, size, logger) {
    if ((0, stream_type_check_1.isReadableStream)(upstream)) {
      return (0, createBufferedReadableStream_1.createBufferedReadableStream)(upstream, size, logger);
    }
    const downstream = new node_stream_1.Readable({ read() {} });
    let streamBufferingLoggedWarning = false;
    let bytesSeen = 0;
    const buffers = [
      "",
      new ByteArrayCollector_1.ByteArrayCollector((size2) => new Uint8Array(size2)),
      new ByteArrayCollector_1.ByteArrayCollector((size2) => Buffer.from(new Uint8Array(size2)))
    ];
    let mode = -1;
    upstream.on("data", (chunk) => {
      const chunkMode = (0, createBufferedReadableStream_1.modeOf)(chunk, true);
      if (mode !== chunkMode) {
        if (mode >= 0) {
          downstream.push((0, createBufferedReadableStream_1.flush)(buffers, mode));
        }
        mode = chunkMode;
      }
      if (mode === -1) {
        downstream.push(chunk);
        return;
      }
      const chunkSize = (0, createBufferedReadableStream_1.sizeOf)(chunk);
      bytesSeen += chunkSize;
      const bufferSize = (0, createBufferedReadableStream_1.sizeOf)(buffers[mode]);
      if (chunkSize >= size && bufferSize === 0) {
        downstream.push(chunk);
      } else {
        const newSize = (0, createBufferedReadableStream_1.merge)(buffers, mode, chunk);
        if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {
          streamBufferingLoggedWarning = true;
          logger?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);
        }
        if (newSize >= size) {
          downstream.push((0, createBufferedReadableStream_1.flush)(buffers, mode));
        }
      }
    });
    upstream.on("end", () => {
      if (mode !== -1) {
        const remainder = (0, createBufferedReadableStream_1.flush)(buffers, mode);
        if ((0, createBufferedReadableStream_1.sizeOf)(remainder) > 0) {
          downstream.push(remainder);
        }
      }
      downstream.push(null);
    });
    return downstream;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/getAwsChunkedEncodingStream.browser.js
var require_getAwsChunkedEncodingStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAwsChunkedEncodingStream = undefined;
  var getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined && bodyLengthChecker !== undefined && checksumAlgorithmFn !== undefined && checksumLocationName !== undefined && streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const reader = readableStream.getReader();
    return new ReadableStream({
      async pull(controller) {
        const { value, done } = await reader.read();
        if (done) {
          controller.enqueue(`0\r
`);
          if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            controller.enqueue(`${checksumLocationName}:${checksum}\r
`);
            controller.enqueue(`\r
`);
          }
          controller.close();
        } else {
          controller.enqueue(`${(bodyLengthChecker(value) || 0).toString(16)}\r
${value}\r
`);
        }
      }
    });
  };
  exports.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream;
});

// node_modules/@smithy/util-stream/dist-cjs/getAwsChunkedEncodingStream.js
var require_getAwsChunkedEncodingStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream;
  var node_stream_1 = __require("node:stream");
  var getAwsChunkedEncodingStream_browser_1 = require_getAwsChunkedEncodingStream_browser();
  var stream_type_check_1 = require_stream_type_check();
  function getAwsChunkedEncodingStream(stream3, options) {
    const readable = stream3;
    const readableStream = stream3;
    if ((0, stream_type_check_1.isReadableStream)(readableStream)) {
      return (0, getAwsChunkedEncodingStream_browser_1.getAwsChunkedEncodingStream)(readableStream, options);
    }
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined && checksumAlgorithmFn !== undefined && checksumLocationName !== undefined && streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readable) : undefined;
    const awsChunkedEncodingStream = new node_stream_1.Readable({
      read: () => {}
    });
    readable.on("data", (data) => {
      const length = bodyLengthChecker(data) || 0;
      if (length === 0) {
        return;
      }
      awsChunkedEncodingStream.push(`${length.toString(16)}\r
`);
      awsChunkedEncodingStream.push(data);
      awsChunkedEncodingStream.push(`\r
`);
    });
    readable.on("end", async () => {
      awsChunkedEncodingStream.push(`0\r
`);
      if (checksumRequired) {
        const checksum = base64Encoder(await digest);
        awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r
`);
        awsChunkedEncodingStream.push(`\r
`);
      }
      awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/headStream.browser.js
var require_headStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.headStream = headStream;
  async function headStream(stream3, bytes) {
    let byteLengthCounter = 0;
    const chunks = [];
    const reader = stream3.getReader();
    let isDone = false;
    while (!isDone) {
      const { done, value } = await reader.read();
      if (value) {
        chunks.push(value);
        byteLengthCounter += value?.byteLength ?? 0;
      }
      if (byteLengthCounter >= bytes) {
        break;
      }
      isDone = done;
    }
    reader.releaseLock();
    const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));
    let offset2 = 0;
    for (const chunk of chunks) {
      if (chunk.byteLength > collected.byteLength - offset2) {
        collected.set(chunk.subarray(0, collected.byteLength - offset2), offset2);
        break;
      } else {
        collected.set(chunk, offset2);
      }
      offset2 += chunk.length;
    }
    return collected;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/headStream.js
var require_headStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.headStream = undefined;
  var stream_1 = __require("stream");
  var headStream_browser_1 = require_headStream_browser();
  var stream_type_check_1 = require_stream_type_check();
  var headStream = (stream3, bytes) => {
    if ((0, stream_type_check_1.isReadableStream)(stream3)) {
      return (0, headStream_browser_1.headStream)(stream3, bytes);
    }
    return new Promise((resolve, reject) => {
      const collector = new Collector;
      collector.limit = bytes;
      stream3.pipe(collector);
      stream3.on("error", (err) => {
        collector.end();
        reject(err);
      });
      collector.on("error", reject);
      collector.on("finish", function() {
        const bytes2 = new Uint8Array(Buffer.concat(this.buffers));
        resolve(bytes2);
      });
    });
  };
  exports.headStream = headStream;

  class Collector extends stream_1.Writable {
    buffers = [];
    limit = Infinity;
    bytesBuffered = 0;
    _write(chunk, encoding, callback) {
      this.buffers.push(chunk);
      this.bytesBuffered += chunk.byteLength ?? 0;
      if (this.bytesBuffered >= this.limit) {
        const excess = this.bytesBuffered - this.limit;
        const tailBuffer = this.buffers[this.buffers.length - 1];
        this.buffers[this.buffers.length - 1] = tailBuffer.subarray(0, tailBuffer.byteLength - excess);
        this.emit("finish");
      }
      callback();
    }
  }
});

// node_modules/@smithy/util-uri-escape/dist-cjs/index.js
var require_dist_cjs10 = __commonJS((exports) => {
  var escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
  var hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;
  var escapeUriPath = (uri) => uri.split("/").map(escapeUri).join("/");
  exports.escapeUri = escapeUri;
  exports.escapeUriPath = escapeUriPath;
});

// node_modules/@smithy/querystring-builder/dist-cjs/index.js
var require_dist_cjs11 = __commonJS((exports) => {
  var utilUriEscape = require_dist_cjs10();
  function buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
      const value = query[key];
      key = utilUriEscape.escapeUri(key);
      if (Array.isArray(value)) {
        for (let i2 = 0, iLen = value.length;i2 < iLen; i2++) {
          parts.push(`${key}=${utilUriEscape.escapeUri(value[i2])}`);
        }
      } else {
        let qsEntry = key;
        if (value || typeof value === "string") {
          qsEntry += `=${utilUriEscape.escapeUri(value)}`;
        }
        parts.push(qsEntry);
      }
    }
    return parts.join("&");
  }
  exports.buildQueryString = buildQueryString;
});

// node_modules/@smithy/node-http-handler/dist-cjs/index.js
var require_dist_cjs12 = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs2();
  var querystringBuilder = require_dist_cjs11();
  var http = __require("http");
  var https = __require("https");
  var stream3 = __require("stream");
  var http2 = __require("http2");
  var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
  var getTransformedHeaders = (headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
      const headerValues = headers[name];
      transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
  };
  var timing = {
    setTimeout: (cb, ms) => setTimeout(cb, ms),
    clearTimeout: (timeoutId) => clearTimeout(timeoutId)
  };
  var DEFER_EVENT_LISTENER_TIME$2 = 1000;
  var setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
      return -1;
    }
    const registerTimeout = (offset2) => {
      const timeoutId = timing.setTimeout(() => {
        request.destroy();
        reject(Object.assign(new Error(`@smithy/node-http-handler - the request socket did not establish a connection with the server within the configured timeout of ${timeoutInMs} ms.`), {
          name: "TimeoutError"
        }));
      }, timeoutInMs - offset2);
      const doWithSocket = (socket) => {
        if (socket?.connecting) {
          socket.on("connect", () => {
            timing.clearTimeout(timeoutId);
          });
        } else {
          timing.clearTimeout(timeoutId);
        }
      };
      if (request.socket) {
        doWithSocket(request.socket);
      } else {
        request.on("socket", doWithSocket);
      }
    };
    if (timeoutInMs < 2000) {
      registerTimeout(0);
      return 0;
    }
    return timing.setTimeout(registerTimeout.bind(null, DEFER_EVENT_LISTENER_TIME$2), DEFER_EVENT_LISTENER_TIME$2);
  };
  var setRequestTimeout = (req, reject, timeoutInMs = 0, throwOnRequestTimeout, logger) => {
    if (timeoutInMs) {
      return timing.setTimeout(() => {
        let msg = `@smithy/node-http-handler - [${throwOnRequestTimeout ? "ERROR" : "WARN"}] a request has exceeded the configured ${timeoutInMs} ms requestTimeout.`;
        if (throwOnRequestTimeout) {
          const error = Object.assign(new Error(msg), {
            name: "TimeoutError",
            code: "ETIMEDOUT"
          });
          req.destroy(error);
          reject(error);
        } else {
          msg += ` Init client requestHandler with throwOnRequestTimeout=true to turn this into an error.`;
          logger?.warn?.(msg);
        }
      }, timeoutInMs);
    }
    return -1;
  };
  var DEFER_EVENT_LISTENER_TIME$1 = 3000;
  var setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }, deferTimeMs = DEFER_EVENT_LISTENER_TIME$1) => {
    if (keepAlive !== true) {
      return -1;
    }
    const registerListener = () => {
      if (request.socket) {
        request.socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
      } else {
        request.on("socket", (socket) => {
          socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
        });
      }
    };
    if (deferTimeMs === 0) {
      registerListener();
      return 0;
    }
    return timing.setTimeout(registerListener, deferTimeMs);
  };
  var DEFER_EVENT_LISTENER_TIME = 3000;
  var setSocketTimeout = (request, reject, timeoutInMs = 0) => {
    const registerTimeout = (offset2) => {
      const timeout = timeoutInMs - offset2;
      const onTimeout = () => {
        request.destroy();
        reject(Object.assign(new Error(`@smithy/node-http-handler - the request socket timed out after ${timeoutInMs} ms of inactivity (configured by client requestHandler).`), { name: "TimeoutError" }));
      };
      if (request.socket) {
        request.socket.setTimeout(timeout, onTimeout);
        request.on("close", () => request.socket?.removeListener("timeout", onTimeout));
      } else {
        request.setTimeout(timeout, onTimeout);
      }
    };
    if (0 < timeoutInMs && timeoutInMs < 6000) {
      registerTimeout(0);
      return 0;
    }
    return timing.setTimeout(registerTimeout.bind(null, timeoutInMs === 0 ? 0 : DEFER_EVENT_LISTENER_TIME), DEFER_EVENT_LISTENER_TIME);
  };
  var MIN_WAIT_TIME = 6000;
  async function writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME, externalAgent = false) {
    const headers = request.headers ?? {};
    const expect = headers.Expect || headers.expect;
    let timeoutId = -1;
    let sendBody = true;
    if (!externalAgent && expect === "100-continue") {
      sendBody = await Promise.race([
        new Promise((resolve) => {
          timeoutId = Number(timing.setTimeout(() => resolve(true), Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
        }),
        new Promise((resolve) => {
          httpRequest.on("continue", () => {
            timing.clearTimeout(timeoutId);
            resolve(true);
          });
          httpRequest.on("response", () => {
            timing.clearTimeout(timeoutId);
            resolve(false);
          });
          httpRequest.on("error", () => {
            timing.clearTimeout(timeoutId);
            resolve(false);
          });
        })
      ]);
    }
    if (sendBody) {
      writeBody(httpRequest, request.body);
    }
  }
  function writeBody(httpRequest, body) {
    if (body instanceof stream3.Readable) {
      body.pipe(httpRequest);
      return;
    }
    if (body) {
      const isBuffer = Buffer.isBuffer(body);
      const isString = typeof body === "string";
      if (isBuffer || isString) {
        if (isBuffer && body.byteLength === 0) {
          httpRequest.end();
        } else {
          httpRequest.end(body);
        }
        return;
      }
      const uint8 = body;
      if (typeof uint8 === "object" && uint8.buffer && typeof uint8.byteOffset === "number" && typeof uint8.byteLength === "number") {
        httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
        return;
      }
      httpRequest.end(Buffer.from(body));
      return;
    }
    httpRequest.end();
  }
  var DEFAULT_REQUEST_TIMEOUT = 0;

  class NodeHttpHandler {
    config;
    configProvider;
    socketWarningTimestamp = 0;
    externalAgent = false;
    metadata = { handlerProtocol: "http/1.1" };
    static create(instanceOrOptions) {
      if (typeof instanceOrOptions?.handle === "function") {
        return instanceOrOptions;
      }
      return new NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp, logger = console) {
      const { sockets, requests, maxSockets } = agent;
      if (typeof maxSockets !== "number" || maxSockets === Infinity) {
        return socketWarningTimestamp;
      }
      const interval = 15000;
      if (Date.now() - interval < socketWarningTimestamp) {
        return socketWarningTimestamp;
      }
      if (sockets && requests) {
        for (const origin in sockets) {
          const socketsInUse = sockets[origin]?.length ?? 0;
          const requestsEnqueued = requests[origin]?.length ?? 0;
          if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
            logger?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`);
            return Date.now();
          }
        }
      }
      return socketWarningTimestamp;
    }
    constructor(options) {
      this.configProvider = new Promise((resolve, reject) => {
        if (typeof options === "function") {
          options().then((_options) => {
            resolve(this.resolveDefaultConfig(_options));
          }).catch(reject);
        } else {
          resolve(this.resolveDefaultConfig(options));
        }
      });
    }
    resolveDefaultConfig(options) {
      const { requestTimeout, connectionTimeout, socketTimeout, socketAcquisitionWarningTimeout, httpAgent, httpsAgent, throwOnRequestTimeout, logger } = options || {};
      const keepAlive = true;
      const maxSockets = 50;
      return {
        connectionTimeout,
        requestTimeout,
        socketTimeout,
        socketAcquisitionWarningTimeout,
        throwOnRequestTimeout,
        httpAgent: (() => {
          if (httpAgent instanceof http.Agent || typeof httpAgent?.destroy === "function") {
            this.externalAgent = true;
            return httpAgent;
          }
          return new http.Agent({ keepAlive, maxSockets, ...httpAgent });
        })(),
        httpsAgent: (() => {
          if (httpsAgent instanceof https.Agent || typeof httpsAgent?.destroy === "function") {
            this.externalAgent = true;
            return httpsAgent;
          }
          return new https.Agent({ keepAlive, maxSockets, ...httpsAgent });
        })(),
        logger
      };
    }
    destroy() {
      this.config?.httpAgent?.destroy();
      this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal, requestTimeout } = {}) {
      if (!this.config) {
        this.config = await this.configProvider;
      }
      return new Promise((_resolve, _reject) => {
        const config = this.config;
        let writeRequestBodyPromise = undefined;
        const timeouts = [];
        const resolve = async (arg) => {
          await writeRequestBodyPromise;
          timeouts.forEach(timing.clearTimeout);
          _resolve(arg);
        };
        const reject = async (arg) => {
          await writeRequestBodyPromise;
          timeouts.forEach(timing.clearTimeout);
          _reject(arg);
        };
        if (abortSignal?.aborted) {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
          return;
        }
        const isSSL = request.protocol === "https:";
        const headers = request.headers ?? {};
        const expectContinue = (headers.Expect ?? headers.expect) === "100-continue";
        let agent = isSSL ? config.httpsAgent : config.httpAgent;
        if (expectContinue && !this.externalAgent) {
          agent = new (isSSL ? https.Agent : http.Agent)({
            keepAlive: false,
            maxSockets: Infinity
          });
        }
        timeouts.push(timing.setTimeout(() => {
          this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp, config.logger);
        }, config.socketAcquisitionWarningTimeout ?? (config.requestTimeout ?? 2000) + (config.connectionTimeout ?? 1000)));
        const queryString = querystringBuilder.buildQueryString(request.query || {});
        let auth = undefined;
        if (request.username != null || request.password != null) {
          const username = request.username ?? "";
          const password = request.password ?? "";
          auth = `${username}:${password}`;
        }
        let path = request.path;
        if (queryString) {
          path += `?${queryString}`;
        }
        if (request.fragment) {
          path += `#${request.fragment}`;
        }
        let hostname = request.hostname ?? "";
        if (hostname[0] === "[" && hostname.endsWith("]")) {
          hostname = request.hostname.slice(1, -1);
        } else {
          hostname = request.hostname;
        }
        const nodeHttpsOptions = {
          headers: request.headers,
          host: hostname,
          method: request.method,
          path,
          port: request.port,
          agent,
          auth
        };
        const requestFunc = isSSL ? https.request : http.request;
        const req = requestFunc(nodeHttpsOptions, (res) => {
          const httpResponse = new protocolHttp.HttpResponse({
            statusCode: res.statusCode || -1,
            reason: res.statusMessage,
            headers: getTransformedHeaders(res.headers),
            body: res
          });
          resolve({ response: httpResponse });
        });
        req.on("error", (err) => {
          if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
            reject(Object.assign(err, { name: "TimeoutError" }));
          } else {
            reject(err);
          }
        });
        if (abortSignal) {
          const onAbort = () => {
            req.destroy();
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
          };
          if (typeof abortSignal.addEventListener === "function") {
            const signal = abortSignal;
            signal.addEventListener("abort", onAbort, { once: true });
            req.once("close", () => signal.removeEventListener("abort", onAbort));
          } else {
            abortSignal.onabort = onAbort;
          }
        }
        const effectiveRequestTimeout = requestTimeout ?? config.requestTimeout;
        timeouts.push(setConnectionTimeout(req, reject, config.connectionTimeout));
        timeouts.push(setRequestTimeout(req, reject, effectiveRequestTimeout, config.throwOnRequestTimeout, config.logger ?? console));
        timeouts.push(setSocketTimeout(req, reject, config.socketTimeout));
        const httpAgent = nodeHttpsOptions.agent;
        if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
          timeouts.push(setSocketKeepAlive(req, {
            keepAlive: httpAgent.keepAlive,
            keepAliveMsecs: httpAgent.keepAliveMsecs
          }));
        }
        writeRequestBodyPromise = writeRequestBody(req, request, effectiveRequestTimeout, this.externalAgent).catch((e) => {
          timeouts.forEach(timing.clearTimeout);
          return _reject(e);
        });
      });
    }
    updateHttpClientConfig(key, value) {
      this.config = undefined;
      this.configProvider = this.configProvider.then((config) => {
        return {
          ...config,
          [key]: value
        };
      });
    }
    httpHandlerConfigs() {
      return this.config ?? {};
    }
  }

  class NodeHttp2ConnectionPool {
    sessions = [];
    constructor(sessions) {
      this.sessions = sessions ?? [];
    }
    poll() {
      if (this.sessions.length > 0) {
        return this.sessions.shift();
      }
    }
    offerLast(session2) {
      this.sessions.push(session2);
    }
    contains(session2) {
      return this.sessions.includes(session2);
    }
    remove(session2) {
      this.sessions = this.sessions.filter((s) => s !== session2);
    }
    [Symbol.iterator]() {
      return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
      for (const session2 of this.sessions) {
        if (session2 === connection) {
          if (!session2.destroyed) {
            session2.destroy();
          }
        }
      }
    }
  }

  class NodeHttp2ConnectionManager {
    constructor(config) {
      this.config = config;
      if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
        throw new RangeError("maxConcurrency must be greater than zero.");
      }
    }
    config;
    sessionCache = new Map;
    lease(requestContext, connectionConfiguration) {
      const url = this.getUrlString(requestContext);
      const existingPool = this.sessionCache.get(url);
      if (existingPool) {
        const existingSession = existingPool.poll();
        if (existingSession && !this.config.disableConcurrency) {
          return existingSession;
        }
      }
      const session2 = http2.connect(url);
      if (this.config.maxConcurrency) {
        session2.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
          if (err) {
            throw new Error("Fail to set maxConcurrentStreams to " + this.config.maxConcurrency + "when creating new session for " + requestContext.destination.toString());
          }
        });
      }
      session2.unref();
      const destroySessionCb = () => {
        session2.destroy();
        this.deleteSession(url, session2);
      };
      session2.on("goaway", destroySessionCb);
      session2.on("error", destroySessionCb);
      session2.on("frameError", destroySessionCb);
      session2.on("close", () => this.deleteSession(url, session2));
      if (connectionConfiguration.requestTimeout) {
        session2.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
      }
      const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool;
      connectionPool.offerLast(session2);
      this.sessionCache.set(url, connectionPool);
      return session2;
    }
    deleteSession(authority, session2) {
      const existingConnectionPool = this.sessionCache.get(authority);
      if (!existingConnectionPool) {
        return;
      }
      if (!existingConnectionPool.contains(session2)) {
        return;
      }
      existingConnectionPool.remove(session2);
      this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session2) {
      const cacheKey = this.getUrlString(requestContext);
      this.sessionCache.get(cacheKey)?.offerLast(session2);
    }
    destroy() {
      for (const [key, connectionPool] of this.sessionCache) {
        for (const session2 of connectionPool) {
          if (!session2.destroyed) {
            session2.destroy();
          }
          connectionPool.remove(session2);
        }
        this.sessionCache.delete(key);
      }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
      if (maxConcurrentStreams && maxConcurrentStreams <= 0) {
        throw new RangeError("maxConcurrentStreams must be greater than zero.");
      }
      this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
      this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
      return request.destination.toString();
    }
  }

  class NodeHttp2Handler {
    config;
    configProvider;
    metadata = { handlerProtocol: "h2" };
    connectionManager = new NodeHttp2ConnectionManager({});
    static create(instanceOrOptions) {
      if (typeof instanceOrOptions?.handle === "function") {
        return instanceOrOptions;
      }
      return new NodeHttp2Handler(instanceOrOptions);
    }
    constructor(options) {
      this.configProvider = new Promise((resolve, reject) => {
        if (typeof options === "function") {
          options().then((opts) => {
            resolve(opts || {});
          }).catch(reject);
        } else {
          resolve(options || {});
        }
      });
    }
    destroy() {
      this.connectionManager.destroy();
    }
    async handle(request, { abortSignal, requestTimeout } = {}) {
      if (!this.config) {
        this.config = await this.configProvider;
        this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
        if (this.config.maxConcurrentStreams) {
          this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
        }
      }
      const { requestTimeout: configRequestTimeout, disableConcurrentStreams } = this.config;
      const effectiveRequestTimeout = requestTimeout ?? configRequestTimeout;
      return new Promise((_resolve, _reject) => {
        let fulfilled = false;
        let writeRequestBodyPromise = undefined;
        const resolve = async (arg) => {
          await writeRequestBodyPromise;
          _resolve(arg);
        };
        const reject = async (arg) => {
          await writeRequestBodyPromise;
          _reject(arg);
        };
        if (abortSignal?.aborted) {
          fulfilled = true;
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
          return;
        }
        const { hostname, method, port, protocol, query } = request;
        let auth = "";
        if (request.username != null || request.password != null) {
          const username = request.username ?? "";
          const password = request.password ?? "";
          auth = `${username}:${password}@`;
        }
        const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
        const requestContext = { destination: new URL(authority) };
        const session2 = this.connectionManager.lease(requestContext, {
          requestTimeout: this.config?.sessionTimeout,
          disableConcurrentStreams: disableConcurrentStreams || false
        });
        const rejectWithDestroy = (err) => {
          if (disableConcurrentStreams) {
            this.destroySession(session2);
          }
          fulfilled = true;
          reject(err);
        };
        const queryString = querystringBuilder.buildQueryString(query || {});
        let path = request.path;
        if (queryString) {
          path += `?${queryString}`;
        }
        if (request.fragment) {
          path += `#${request.fragment}`;
        }
        const req = session2.request({
          ...request.headers,
          [http2.constants.HTTP2_HEADER_PATH]: path,
          [http2.constants.HTTP2_HEADER_METHOD]: method
        });
        session2.ref();
        req.on("response", (headers) => {
          const httpResponse = new protocolHttp.HttpResponse({
            statusCode: headers[":status"] || -1,
            headers: getTransformedHeaders(headers),
            body: req
          });
          fulfilled = true;
          resolve({ response: httpResponse });
          if (disableConcurrentStreams) {
            session2.close();
            this.connectionManager.deleteSession(authority, session2);
          }
        });
        if (effectiveRequestTimeout) {
          req.setTimeout(effectiveRequestTimeout, () => {
            req.close();
            const timeoutError = new Error(`Stream timed out because of no activity for ${effectiveRequestTimeout} ms`);
            timeoutError.name = "TimeoutError";
            rejectWithDestroy(timeoutError);
          });
        }
        if (abortSignal) {
          const onAbort = () => {
            req.close();
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            rejectWithDestroy(abortError);
          };
          if (typeof abortSignal.addEventListener === "function") {
            const signal = abortSignal;
            signal.addEventListener("abort", onAbort, { once: true });
            req.once("close", () => signal.removeEventListener("abort", onAbort));
          } else {
            abortSignal.onabort = onAbort;
          }
        }
        req.on("frameError", (type, code, id) => {
          rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
        });
        req.on("error", rejectWithDestroy);
        req.on("aborted", () => {
          rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
        });
        req.on("close", () => {
          session2.unref();
          if (disableConcurrentStreams) {
            session2.destroy();
          }
          if (!fulfilled) {
            rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
          }
        });
        writeRequestBodyPromise = writeRequestBody(req, request, effectiveRequestTimeout);
      });
    }
    updateHttpClientConfig(key, value) {
      this.config = undefined;
      this.configProvider = this.configProvider.then((config) => {
        return {
          ...config,
          [key]: value
        };
      });
    }
    httpHandlerConfigs() {
      return this.config ?? {};
    }
    destroySession(session2) {
      if (!session2.destroyed) {
        session2.destroy();
      }
    }
  }

  class Collector extends stream3.Writable {
    bufferedBytes = [];
    _write(chunk, encoding, callback) {
      this.bufferedBytes.push(chunk);
      callback();
    }
  }
  var streamCollector = (stream4) => {
    if (isReadableStreamInstance(stream4)) {
      return collectReadableStream(stream4);
    }
    return new Promise((resolve, reject) => {
      const collector = new Collector;
      stream4.pipe(collector);
      stream4.on("error", (err) => {
        collector.end();
        reject(err);
      });
      collector.on("error", reject);
      collector.on("finish", function() {
        const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
        resolve(bytes);
      });
    });
  };
  var isReadableStreamInstance = (stream4) => typeof ReadableStream === "function" && stream4 instanceof ReadableStream;
  async function collectReadableStream(stream4) {
    const chunks = [];
    const reader = stream4.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
      const { done, value } = await reader.read();
      if (value) {
        chunks.push(value);
        length += value.length;
      }
      isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset2 = 0;
    for (const chunk of chunks) {
      collected.set(chunk, offset2);
      offset2 += chunk.length;
    }
    return collected;
  }
  exports.DEFAULT_REQUEST_TIMEOUT = DEFAULT_REQUEST_TIMEOUT;
  exports.NodeHttp2Handler = NodeHttp2Handler;
  exports.NodeHttpHandler = NodeHttpHandler;
  exports.streamCollector = streamCollector;
});

// node_modules/@smithy/fetch-http-handler/dist-cjs/index.js
var require_dist_cjs13 = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs2();
  var querystringBuilder = require_dist_cjs11();
  var utilBase64 = require_dist_cjs9();
  function createRequest(url, requestOptions) {
    return new Request(url, requestOptions);
  }
  function requestTimeout(timeoutInMs = 0) {
    return new Promise((resolve, reject) => {
      if (timeoutInMs) {
        setTimeout(() => {
          const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
          timeoutError.name = "TimeoutError";
          reject(timeoutError);
        }, timeoutInMs);
      }
    });
  }
  var keepAliveSupport = {
    supported: undefined
  };

  class FetchHttpHandler {
    config;
    configProvider;
    static create(instanceOrOptions) {
      if (typeof instanceOrOptions?.handle === "function") {
        return instanceOrOptions;
      }
      return new FetchHttpHandler(instanceOrOptions);
    }
    constructor(options) {
      if (typeof options === "function") {
        this.configProvider = options().then((opts) => opts || {});
      } else {
        this.config = options ?? {};
        this.configProvider = Promise.resolve(this.config);
      }
      if (keepAliveSupport.supported === undefined) {
        keepAliveSupport.supported = Boolean(typeof Request !== "undefined" && "keepalive" in createRequest("https://[::1]"));
      }
    }
    destroy() {}
    async handle(request, { abortSignal, requestTimeout: requestTimeout$1 } = {}) {
      if (!this.config) {
        this.config = await this.configProvider;
      }
      const requestTimeoutInMs = requestTimeout$1 ?? this.config.requestTimeout;
      const keepAlive = this.config.keepAlive === true;
      const credentials = this.config.credentials;
      if (abortSignal?.aborted) {
        const abortError = new Error("Request aborted");
        abortError.name = "AbortError";
        return Promise.reject(abortError);
      }
      let path = request.path;
      const queryString = querystringBuilder.buildQueryString(request.query || {});
      if (queryString) {
        path += `?${queryString}`;
      }
      if (request.fragment) {
        path += `#${request.fragment}`;
      }
      let auth = "";
      if (request.username != null || request.password != null) {
        const username = request.username ?? "";
        const password = request.password ?? "";
        auth = `${username}:${password}@`;
      }
      const { port, method } = request;
      const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
      const body = method === "GET" || method === "HEAD" ? undefined : request.body;
      const requestOptions = {
        body,
        headers: new Headers(request.headers),
        method,
        credentials
      };
      if (this.config?.cache) {
        requestOptions.cache = this.config.cache;
      }
      if (body) {
        requestOptions.duplex = "half";
      }
      if (typeof AbortController !== "undefined") {
        requestOptions.signal = abortSignal;
      }
      if (keepAliveSupport.supported) {
        requestOptions.keepalive = keepAlive;
      }
      if (typeof this.config.requestInit === "function") {
        Object.assign(requestOptions, this.config.requestInit(request));
      }
      let removeSignalEventListener = () => {};
      const fetchRequest = createRequest(url, requestOptions);
      const raceOfPromises = [
        fetch(fetchRequest).then((response) => {
          const fetchHeaders = response.headers;
          const transformedHeaders = {};
          for (const pair of fetchHeaders.entries()) {
            transformedHeaders[pair[0]] = pair[1];
          }
          const hasReadableStream = response.body != null;
          if (!hasReadableStream) {
            return response.blob().then((body2) => ({
              response: new protocolHttp.HttpResponse({
                headers: transformedHeaders,
                reason: response.statusText,
                statusCode: response.status,
                body: body2
              })
            }));
          }
          return {
            response: new protocolHttp.HttpResponse({
              headers: transformedHeaders,
              reason: response.statusText,
              statusCode: response.status,
              body: response.body
            })
          };
        }),
        requestTimeout(requestTimeoutInMs)
      ];
      if (abortSignal) {
        raceOfPromises.push(new Promise((resolve, reject) => {
          const onAbort = () => {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
          };
          if (typeof abortSignal.addEventListener === "function") {
            const signal = abortSignal;
            signal.addEventListener("abort", onAbort, { once: true });
            removeSignalEventListener = () => signal.removeEventListener("abort", onAbort);
          } else {
            abortSignal.onabort = onAbort;
          }
        }));
      }
      return Promise.race(raceOfPromises).finally(removeSignalEventListener);
    }
    updateHttpClientConfig(key, value) {
      this.config = undefined;
      this.configProvider = this.configProvider.then((config) => {
        config[key] = value;
        return config;
      });
    }
    httpHandlerConfigs() {
      return this.config ?? {};
    }
  }
  var streamCollector = async (stream3) => {
    if (typeof Blob === "function" && stream3 instanceof Blob || stream3.constructor?.name === "Blob") {
      if (Blob.prototype.arrayBuffer !== undefined) {
        return new Uint8Array(await stream3.arrayBuffer());
      }
      return collectBlob(stream3);
    }
    return collectStream(stream3);
  };
  async function collectBlob(blob) {
    const base64 = await readToBase64(blob);
    const arrayBuffer = utilBase64.fromBase64(base64);
    return new Uint8Array(arrayBuffer);
  }
  async function collectStream(stream3) {
    const chunks = [];
    const reader = stream3.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
      const { done, value } = await reader.read();
      if (value) {
        chunks.push(value);
        length += value.length;
      }
      isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset2 = 0;
    for (const chunk of chunks) {
      collected.set(chunk, offset2);
      offset2 += chunk.length;
    }
    return collected;
  }
  function readToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader;
      reader.onloadend = () => {
        if (reader.readyState !== 2) {
          return reject(new Error("Reader aborted too early"));
        }
        const result = reader.result ?? "";
        const commaIndex = result.indexOf(",");
        const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
        resolve(result.substring(dataOffset));
      };
      reader.onabort = () => reject(new Error("Read aborted"));
      reader.onerror = () => reject(reader.error);
      reader.readAsDataURL(blob);
    });
  }
  exports.FetchHttpHandler = FetchHttpHandler;
  exports.keepAliveSupport = keepAliveSupport;
  exports.streamCollector = streamCollector;
});

// node_modules/@smithy/util-hex-encoding/dist-cjs/index.js
var require_dist_cjs14 = __commonJS((exports) => {
  var SHORT_TO_HEX = {};
  var HEX_TO_SHORT = {};
  for (let i2 = 0;i2 < 256; i2++) {
    let encodedByte = i2.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
      encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i2] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i2;
  }
  function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
      throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i2 = 0;i2 < encoded.length; i2 += 2) {
      const encodedByte = encoded.slice(i2, i2 + 2).toLowerCase();
      if (encodedByte in HEX_TO_SHORT) {
        out[i2 / 2] = HEX_TO_SHORT[encodedByte];
      } else {
        throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
      }
    }
    return out;
  }
  function toHex(bytes) {
    let out = "";
    for (let i2 = 0;i2 < bytes.byteLength; i2++) {
      out += SHORT_TO_HEX[bytes[i2]];
    }
    return out;
  }
  exports.fromHex = fromHex;
  exports.toHex = toHex;
});

// node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.browser.js
var require_sdk_stream_mixin_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sdkStreamMixin = undefined;
  var fetch_http_handler_1 = require_dist_cjs13();
  var util_base64_1 = require_dist_cjs9();
  var util_hex_encoding_1 = require_dist_cjs14();
  var util_utf8_1 = require_dist_cjs8();
  var stream_type_check_1 = require_stream_type_check();
  var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
  var sdkStreamMixin = (stream3) => {
    if (!isBlobInstance(stream3) && !(0, stream_type_check_1.isReadableStream)(stream3)) {
      const name = stream3?.__proto__?.constructor?.name || stream3;
      throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      transformed = true;
      return await (0, fetch_http_handler_1.streamCollector)(stream3);
    };
    const blobToWebStream = (blob) => {
      if (typeof blob.stream !== "function") {
        throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
` + "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
      }
      return blob.stream();
    };
    return Object.assign(stream3, {
      transformToByteArray,
      transformToString: async (encoding) => {
        const buf = await transformToByteArray();
        if (encoding === "base64") {
          return (0, util_base64_1.toBase64)(buf);
        } else if (encoding === "hex") {
          return (0, util_hex_encoding_1.toHex)(buf);
        } else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
          return (0, util_utf8_1.toUtf8)(buf);
        } else if (typeof TextDecoder === "function") {
          return new TextDecoder(encoding).decode(buf);
        } else {
          throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
        }
      },
      transformToWebStream: () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        if (isBlobInstance(stream3)) {
          return blobToWebStream(stream3);
        } else if ((0, stream_type_check_1.isReadableStream)(stream3)) {
          return stream3;
        } else {
          throw new Error(`Cannot transform payload to web stream, got ${stream3}`);
        }
      }
    });
  };
  exports.sdkStreamMixin = sdkStreamMixin;
  var isBlobInstance = (stream3) => typeof Blob === "function" && stream3 instanceof Blob;
});

// node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.js
var require_sdk_stream_mixin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sdkStreamMixin = undefined;
  var node_http_handler_1 = require_dist_cjs12();
  var util_buffer_from_1 = require_dist_cjs7();
  var stream_1 = __require("stream");
  var sdk_stream_mixin_browser_1 = require_sdk_stream_mixin_browser();
  var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
  var sdkStreamMixin = (stream3) => {
    if (!(stream3 instanceof stream_1.Readable)) {
      try {
        return (0, sdk_stream_mixin_browser_1.sdkStreamMixin)(stream3);
      } catch (e) {
        const name = stream3?.__proto__?.constructor?.name || stream3;
        throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
      }
    }
    let transformed = false;
    const transformToByteArray = async () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      transformed = true;
      return await (0, node_http_handler_1.streamCollector)(stream3);
    };
    return Object.assign(stream3, {
      transformToByteArray,
      transformToString: async (encoding) => {
        const buf = await transformToByteArray();
        if (encoding === undefined || Buffer.isEncoding(encoding)) {
          return (0, util_buffer_from_1.fromArrayBuffer)(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
        } else {
          const decoder2 = new TextDecoder(encoding);
          return decoder2.decode(buf);
        }
      },
      transformToWebStream: () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        if (stream3.readableFlowing !== null) {
          throw new Error("The stream has been consumed by other callbacks.");
        }
        if (typeof stream_1.Readable.toWeb !== "function") {
          throw new Error("Readable.toWeb() is not supported. Please ensure a polyfill is available.");
        }
        transformed = true;
        return stream_1.Readable.toWeb(stream3);
      }
    });
  };
  exports.sdkStreamMixin = sdkStreamMixin;
});

// node_modules/@smithy/util-stream/dist-cjs/splitStream.browser.js
var require_splitStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitStream = splitStream;
  async function splitStream(stream3) {
    if (typeof stream3.stream === "function") {
      stream3 = stream3.stream();
    }
    const readableStream = stream3;
    return readableStream.tee();
  }
});

// node_modules/@smithy/util-stream/dist-cjs/splitStream.js
var require_splitStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitStream = splitStream;
  var stream_1 = __require("stream");
  var splitStream_browser_1 = require_splitStream_browser();
  var stream_type_check_1 = require_stream_type_check();
  async function splitStream(stream3) {
    if ((0, stream_type_check_1.isReadableStream)(stream3) || (0, stream_type_check_1.isBlob)(stream3)) {
      return (0, splitStream_browser_1.splitStream)(stream3);
    }
    const stream1 = new stream_1.PassThrough;
    const stream22 = new stream_1.PassThrough;
    stream3.pipe(stream1);
    stream3.pipe(stream22);
    return [stream1, stream22];
  }
});

// node_modules/@smithy/util-stream/dist-cjs/index.js
var require_dist_cjs15 = __commonJS((exports) => {
  var utilBase64 = require_dist_cjs9();
  var utilUtf8 = require_dist_cjs8();
  var ChecksumStream = require_ChecksumStream();
  var createChecksumStream = require_createChecksumStream();
  var createBufferedReadable = require_createBufferedReadable();
  var getAwsChunkedEncodingStream = require_getAwsChunkedEncodingStream();
  var headStream = require_headStream();
  var sdkStreamMixin = require_sdk_stream_mixin();
  var splitStream = require_splitStream();
  var streamTypeCheck = require_stream_type_check();

  class Uint8ArrayBlobAdapter extends Uint8Array {
    static fromString(source, encoding = "utf-8") {
      if (typeof source === "string") {
        if (encoding === "base64") {
          return Uint8ArrayBlobAdapter.mutate(utilBase64.fromBase64(source));
        }
        return Uint8ArrayBlobAdapter.mutate(utilUtf8.fromUtf8(source));
      }
      throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
    }
    static mutate(source) {
      Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
      return source;
    }
    transformToString(encoding = "utf-8") {
      if (encoding === "base64") {
        return utilBase64.toBase64(this);
      }
      return utilUtf8.toUtf8(this);
    }
  }
  exports.isBlob = streamTypeCheck.isBlob;
  exports.isReadableStream = streamTypeCheck.isReadableStream;
  exports.Uint8ArrayBlobAdapter = Uint8ArrayBlobAdapter;
  Object.prototype.hasOwnProperty.call(ChecksumStream, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: ChecksumStream["__proto__"]
  });
  Object.keys(ChecksumStream).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = ChecksumStream[k];
  });
  Object.prototype.hasOwnProperty.call(createChecksumStream, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: createChecksumStream["__proto__"]
  });
  Object.keys(createChecksumStream).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = createChecksumStream[k];
  });
  Object.prototype.hasOwnProperty.call(createBufferedReadable, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: createBufferedReadable["__proto__"]
  });
  Object.keys(createBufferedReadable).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = createBufferedReadable[k];
  });
  Object.prototype.hasOwnProperty.call(getAwsChunkedEncodingStream, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: getAwsChunkedEncodingStream["__proto__"]
  });
  Object.keys(getAwsChunkedEncodingStream).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = getAwsChunkedEncodingStream[k];
  });
  Object.prototype.hasOwnProperty.call(headStream, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: headStream["__proto__"]
  });
  Object.keys(headStream).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = headStream[k];
  });
  Object.prototype.hasOwnProperty.call(sdkStreamMixin, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: sdkStreamMixin["__proto__"]
  });
  Object.keys(sdkStreamMixin).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = sdkStreamMixin[k];
  });
  Object.prototype.hasOwnProperty.call(splitStream, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: splitStream["__proto__"]
  });
  Object.keys(splitStream).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = splitStream[k];
  });
});

// node_modules/@smithy/core/dist-cjs/submodules/schema/index.js
var require_schema = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs2();
  var utilMiddleware = require_dist_cjs4();
  var deref = (schemaRef) => {
    if (typeof schemaRef === "function") {
      return schemaRef();
    }
    return schemaRef;
  };
  var operation = (namespace, name, traits, input, output) => ({
    name,
    namespace,
    traits,
    input,
    output
  });
  var schemaDeserializationMiddleware = (config) => (next, context) => async (args) => {
    const { response } = await next(args);
    const { operationSchema } = utilMiddleware.getSmithyContext(context);
    const [, ns, n, t, i2, o] = operationSchema ?? [];
    try {
      const parsed = await config.protocol.deserializeResponse(operation(ns, n, t, i2, o), {
        ...config,
        ...context
      }, response);
      return {
        response,
        output: parsed
      };
    } catch (error2) {
      Object.defineProperty(error2, "$response", {
        value: response,
        enumerable: false,
        writable: false,
        configurable: false
      });
      if (!("$metadata" in error2)) {
        const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
        try {
          error2.message += `
  ` + hint;
        } catch (e) {
          if (!context.logger || context.logger?.constructor?.name === "NoOpLogger") {
            console.warn(hint);
          } else {
            context.logger?.warn?.(hint);
          }
        }
        if (typeof error2.$responseBodyText !== "undefined") {
          if (error2.$response) {
            error2.$response.body = error2.$responseBodyText;
          }
        }
        try {
          if (protocolHttp.HttpResponse.isInstance(response)) {
            const { headers = {} } = response;
            const headerEntries = Object.entries(headers);
            error2.$metadata = {
              httpStatusCode: response.statusCode,
              requestId: findHeader(/^x-[\w-]+-request-?id$/, headerEntries),
              extendedRequestId: findHeader(/^x-[\w-]+-id-2$/, headerEntries),
              cfId: findHeader(/^x-[\w-]+-cf-id$/, headerEntries)
            };
          }
        } catch (e) {}
      }
      throw error2;
    }
  };
  var findHeader = (pattern, headers) => {
    return (headers.find(([k]) => {
      return k.match(pattern);
    }) || [undefined, undefined])[1];
  };
  var schemaSerializationMiddleware = (config) => (next, context) => async (args) => {
    const { operationSchema } = utilMiddleware.getSmithyContext(context);
    const [, ns, n, t, i2, o] = operationSchema ?? [];
    const endpoint = context.endpointV2?.url && config.urlParser ? async () => config.urlParser(context.endpointV2.url) : config.endpoint;
    const request = await config.protocol.serializeRequest(operation(ns, n, t, i2, o), args.input, {
      ...config,
      ...context,
      endpoint
    });
    return next({
      ...args,
      request
    });
  };
  var deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true
  };
  var serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true
  };
  function getSchemaSerdePlugin(config) {
    return {
      applyToStack: (commandStack) => {
        commandStack.add(schemaSerializationMiddleware(config), serializerMiddlewareOption);
        commandStack.add(schemaDeserializationMiddleware(config), deserializerMiddlewareOption);
        config.protocol.setSerdeContext(config);
      }
    };
  }

  class Schema {
    name;
    namespace;
    traits;
    static assign(instance, values) {
      const schema = Object.assign(instance, values);
      return schema;
    }
    static [Symbol.hasInstance](lhs) {
      const isPrototype = this.prototype.isPrototypeOf(lhs);
      if (!isPrototype && typeof lhs === "object" && lhs !== null) {
        const list2 = lhs;
        return list2.symbol === this.symbol;
      }
      return isPrototype;
    }
    getName() {
      return this.namespace + "#" + this.name;
    }
  }

  class ListSchema extends Schema {
    static symbol = Symbol.for("@smithy/lis");
    name;
    traits;
    valueSchema;
    symbol = ListSchema.symbol;
  }
  var list = (namespace, name, traits, valueSchema) => Schema.assign(new ListSchema, {
    name,
    namespace,
    traits,
    valueSchema
  });

  class MapSchema extends Schema {
    static symbol = Symbol.for("@smithy/map");
    name;
    traits;
    keySchema;
    valueSchema;
    symbol = MapSchema.symbol;
  }
  var map = (namespace, name, traits, keySchema, valueSchema) => Schema.assign(new MapSchema, {
    name,
    namespace,
    traits,
    keySchema,
    valueSchema
  });

  class OperationSchema extends Schema {
    static symbol = Symbol.for("@smithy/ope");
    name;
    traits;
    input;
    output;
    symbol = OperationSchema.symbol;
  }
  var op = (namespace, name, traits, input, output) => Schema.assign(new OperationSchema, {
    name,
    namespace,
    traits,
    input,
    output
  });

  class StructureSchema extends Schema {
    static symbol = Symbol.for("@smithy/str");
    name;
    traits;
    memberNames;
    memberList;
    symbol = StructureSchema.symbol;
  }
  var struct = (namespace, name, traits, memberNames, memberList) => Schema.assign(new StructureSchema, {
    name,
    namespace,
    traits,
    memberNames,
    memberList
  });

  class ErrorSchema extends StructureSchema {
    static symbol = Symbol.for("@smithy/err");
    ctor;
    symbol = ErrorSchema.symbol;
  }
  var error = (namespace, name, traits, memberNames, memberList, ctor) => Schema.assign(new ErrorSchema, {
    name,
    namespace,
    traits,
    memberNames,
    memberList,
    ctor: null
  });
  function translateTraits(indicator) {
    if (typeof indicator === "object") {
      return indicator;
    }
    indicator = indicator | 0;
    const traits = {};
    let i2 = 0;
    for (const trait of [
      "httpLabel",
      "idempotent",
      "idempotencyToken",
      "sensitive",
      "httpPayload",
      "httpResponseCode",
      "httpQueryParams"
    ]) {
      if ((indicator >> i2++ & 1) === 1) {
        traits[trait] = 1;
      }
    }
    return traits;
  }
  var anno = {
    it: Symbol.for("@smithy/nor-struct-it")
  };

  class NormalizedSchema {
    ref;
    memberName;
    static symbol = Symbol.for("@smithy/nor");
    symbol = NormalizedSchema.symbol;
    name;
    schema;
    _isMemberSchema;
    traits;
    memberTraits;
    normalizedTraits;
    constructor(ref, memberName) {
      this.ref = ref;
      this.memberName = memberName;
      const traitStack = [];
      let _ref = ref;
      let schema = ref;
      this._isMemberSchema = false;
      while (isMemberSchema(_ref)) {
        traitStack.push(_ref[1]);
        _ref = _ref[0];
        schema = deref(_ref);
        this._isMemberSchema = true;
      }
      if (traitStack.length > 0) {
        this.memberTraits = {};
        for (let i2 = traitStack.length - 1;i2 >= 0; --i2) {
          const traitSet = traitStack[i2];
          Object.assign(this.memberTraits, translateTraits(traitSet));
        }
      } else {
        this.memberTraits = 0;
      }
      if (schema instanceof NormalizedSchema) {
        const computedMemberTraits = this.memberTraits;
        Object.assign(this, schema);
        this.memberTraits = Object.assign({}, computedMemberTraits, schema.getMemberTraits(), this.getMemberTraits());
        this.normalizedTraits = undefined;
        this.memberName = memberName ?? schema.memberName;
        return;
      }
      this.schema = deref(schema);
      if (isStaticSchema(this.schema)) {
        this.name = `${this.schema[1]}#${this.schema[2]}`;
        this.traits = this.schema[3];
      } else {
        this.name = this.memberName ?? String(schema);
        this.traits = 0;
      }
      if (this._isMemberSchema && !memberName) {
        throw new Error(`@smithy/core/schema - NormalizedSchema member init ${this.getName(true)} missing member name.`);
      }
    }
    static [Symbol.hasInstance](lhs) {
      const isPrototype = this.prototype.isPrototypeOf(lhs);
      if (!isPrototype && typeof lhs === "object" && lhs !== null) {
        const ns = lhs;
        return ns.symbol === this.symbol;
      }
      return isPrototype;
    }
    static of(ref) {
      const sc = deref(ref);
      if (sc instanceof NormalizedSchema) {
        return sc;
      }
      if (isMemberSchema(sc)) {
        const [ns, traits] = sc;
        if (ns instanceof NormalizedSchema) {
          Object.assign(ns.getMergedTraits(), translateTraits(traits));
          return ns;
        }
        throw new Error(`@smithy/core/schema - may not init unwrapped member schema=${JSON.stringify(ref, null, 2)}.`);
      }
      return new NormalizedSchema(sc);
    }
    getSchema() {
      const sc = this.schema;
      if (Array.isArray(sc) && sc[0] === 0) {
        return sc[4];
      }
      return sc;
    }
    getName(withNamespace = false) {
      const { name } = this;
      const short = !withNamespace && name && name.includes("#");
      return short ? name.split("#")[1] : name || undefined;
    }
    getMemberName() {
      return this.memberName;
    }
    isMemberSchema() {
      return this._isMemberSchema;
    }
    isListSchema() {
      const sc = this.getSchema();
      return typeof sc === "number" ? sc >= 64 && sc < 128 : sc[0] === 1;
    }
    isMapSchema() {
      const sc = this.getSchema();
      return typeof sc === "number" ? sc >= 128 && sc <= 255 : sc[0] === 2;
    }
    isStructSchema() {
      const sc = this.getSchema();
      if (typeof sc !== "object") {
        return false;
      }
      const id = sc[0];
      return id === 3 || id === -3 || id === 4;
    }
    isUnionSchema() {
      const sc = this.getSchema();
      if (typeof sc !== "object") {
        return false;
      }
      return sc[0] === 4;
    }
    isBlobSchema() {
      const sc = this.getSchema();
      return sc === 21 || sc === 42;
    }
    isTimestampSchema() {
      const sc = this.getSchema();
      return typeof sc === "number" && sc >= 4 && sc <= 7;
    }
    isUnitSchema() {
      return this.getSchema() === "unit";
    }
    isDocumentSchema() {
      return this.getSchema() === 15;
    }
    isStringSchema() {
      return this.getSchema() === 0;
    }
    isBooleanSchema() {
      return this.getSchema() === 2;
    }
    isNumericSchema() {
      return this.getSchema() === 1;
    }
    isBigIntegerSchema() {
      return this.getSchema() === 17;
    }
    isBigDecimalSchema() {
      return this.getSchema() === 19;
    }
    isStreaming() {
      const { streaming } = this.getMergedTraits();
      return !!streaming || this.getSchema() === 42;
    }
    isIdempotencyToken() {
      return !!this.getMergedTraits().idempotencyToken;
    }
    getMergedTraits() {
      return this.normalizedTraits ?? (this.normalizedTraits = {
        ...this.getOwnTraits(),
        ...this.getMemberTraits()
      });
    }
    getMemberTraits() {
      return translateTraits(this.memberTraits);
    }
    getOwnTraits() {
      return translateTraits(this.traits);
    }
    getKeySchema() {
      const [isDoc, isMap] = [this.isDocumentSchema(), this.isMapSchema()];
      if (!isDoc && !isMap) {
        throw new Error(`@smithy/core/schema - cannot get key for non-map: ${this.getName(true)}`);
      }
      const schema = this.getSchema();
      const memberSchema = isDoc ? 15 : schema[4] ?? 0;
      return member([memberSchema, 0], "key");
    }
    getValueSchema() {
      const sc = this.getSchema();
      const [isDoc, isMap, isList] = [this.isDocumentSchema(), this.isMapSchema(), this.isListSchema()];
      const memberSchema = typeof sc === "number" ? 63 & sc : sc && typeof sc === "object" && (isMap || isList) ? sc[3 + sc[0]] : isDoc ? 15 : undefined;
      if (memberSchema != null) {
        return member([memberSchema, 0], isMap ? "value" : "member");
      }
      throw new Error(`@smithy/core/schema - ${this.getName(true)} has no value member.`);
    }
    getMemberSchema(memberName) {
      const struct2 = this.getSchema();
      if (this.isStructSchema() && struct2[4].includes(memberName)) {
        const i2 = struct2[4].indexOf(memberName);
        const memberSchema = struct2[5][i2];
        return member(isMemberSchema(memberSchema) ? memberSchema : [memberSchema, 0], memberName);
      }
      if (this.isDocumentSchema()) {
        return member([15, 0], memberName);
      }
      throw new Error(`@smithy/core/schema - ${this.getName(true)} has no no member=${memberName}.`);
    }
    getMemberSchemas() {
      const buffer = {};
      try {
        for (const [k, v] of this.structIterator()) {
          buffer[k] = v;
        }
      } catch (ignored) {}
      return buffer;
    }
    getEventStreamMember() {
      if (this.isStructSchema()) {
        for (const [memberName, memberSchema] of this.structIterator()) {
          if (memberSchema.isStreaming() && memberSchema.isStructSchema()) {
            return memberName;
          }
        }
      }
      return "";
    }
    *structIterator() {
      if (this.isUnitSchema()) {
        return;
      }
      if (!this.isStructSchema()) {
        throw new Error("@smithy/core/schema - cannot iterate non-struct schema.");
      }
      const struct2 = this.getSchema();
      const z = struct2[4].length;
      let it = struct2[anno.it];
      if (it && z === it.length) {
        yield* it;
        return;
      }
      it = Array(z);
      for (let i2 = 0;i2 < z; ++i2) {
        const k = struct2[4][i2];
        const v = member([struct2[5][i2], 0], k);
        yield it[i2] = [k, v];
      }
      struct2[anno.it] = it;
    }
  }
  function member(memberSchema, memberName) {
    if (memberSchema instanceof NormalizedSchema) {
      return Object.assign(memberSchema, {
        memberName,
        _isMemberSchema: true
      });
    }
    const internalCtorAccess = NormalizedSchema;
    return new internalCtorAccess(memberSchema, memberName);
  }
  var isMemberSchema = (sc) => Array.isArray(sc) && sc.length === 2;
  var isStaticSchema = (sc) => Array.isArray(sc) && sc.length >= 5;

  class SimpleSchema extends Schema {
    static symbol = Symbol.for("@smithy/sim");
    name;
    schemaRef;
    traits;
    symbol = SimpleSchema.symbol;
  }
  var sim = (namespace, name, schemaRef, traits) => Schema.assign(new SimpleSchema, {
    name,
    namespace,
    traits,
    schemaRef
  });
  var simAdapter = (namespace, name, traits, schemaRef) => Schema.assign(new SimpleSchema, {
    name,
    namespace,
    traits,
    schemaRef
  });
  var SCHEMA = {
    BLOB: 21,
    STREAMING_BLOB: 42,
    BOOLEAN: 2,
    STRING: 0,
    NUMERIC: 1,
    BIG_INTEGER: 17,
    BIG_DECIMAL: 19,
    DOCUMENT: 15,
    TIMESTAMP_DEFAULT: 4,
    TIMESTAMP_DATE_TIME: 5,
    TIMESTAMP_HTTP_DATE: 6,
    TIMESTAMP_EPOCH_SECONDS: 7,
    LIST_MODIFIER: 64,
    MAP_MODIFIER: 128
  };

  class TypeRegistry {
    namespace;
    schemas;
    exceptions;
    static registries = new Map;
    constructor(namespace, schemas = new Map, exceptions = new Map) {
      this.namespace = namespace;
      this.schemas = schemas;
      this.exceptions = exceptions;
    }
    static for(namespace) {
      if (!TypeRegistry.registries.has(namespace)) {
        TypeRegistry.registries.set(namespace, new TypeRegistry(namespace));
      }
      return TypeRegistry.registries.get(namespace);
    }
    copyFrom(other) {
      const { schemas, exceptions } = this;
      for (const [k, v] of other.schemas) {
        if (!schemas.has(k)) {
          schemas.set(k, v);
        }
      }
      for (const [k, v] of other.exceptions) {
        if (!exceptions.has(k)) {
          exceptions.set(k, v);
        }
      }
    }
    register(shapeId, schema) {
      const qualifiedName = this.normalizeShapeId(shapeId);
      for (const r of [this, TypeRegistry.for(qualifiedName.split("#")[0])]) {
        r.schemas.set(qualifiedName, schema);
      }
    }
    getSchema(shapeId) {
      const id = this.normalizeShapeId(shapeId);
      if (!this.schemas.has(id)) {
        throw new Error(`@smithy/core/schema - schema not found for ${id}`);
      }
      return this.schemas.get(id);
    }
    registerError(es, ctor) {
      const $error2 = es;
      const ns = $error2[1];
      for (const r of [this, TypeRegistry.for(ns)]) {
        r.schemas.set(ns + "#" + $error2[2], $error2);
        r.exceptions.set($error2, ctor);
      }
    }
    getErrorCtor(es) {
      const $error2 = es;
      if (this.exceptions.has($error2)) {
        return this.exceptions.get($error2);
      }
      const registry = TypeRegistry.for($error2[1]);
      return registry.exceptions.get($error2);
    }
    getBaseException() {
      for (const exceptionKey of this.exceptions.keys()) {
        if (Array.isArray(exceptionKey)) {
          const [, ns, name] = exceptionKey;
          const id = ns + "#" + name;
          if (id.startsWith("smithy.ts.sdk.synthetic.") && id.endsWith("ServiceException")) {
            return exceptionKey;
          }
        }
      }
      return;
    }
    find(predicate) {
      return [...this.schemas.values()].find(predicate);
    }
    clear() {
      this.schemas.clear();
      this.exceptions.clear();
    }
    normalizeShapeId(shapeId) {
      if (shapeId.includes("#")) {
        return shapeId;
      }
      return this.namespace + "#" + shapeId;
    }
  }
  exports.ErrorSchema = ErrorSchema;
  exports.ListSchema = ListSchema;
  exports.MapSchema = MapSchema;
  exports.NormalizedSchema = NormalizedSchema;
  exports.OperationSchema = OperationSchema;
  exports.SCHEMA = SCHEMA;
  exports.Schema = Schema;
  exports.SimpleSchema = SimpleSchema;
  exports.StructureSchema = StructureSchema;
  exports.TypeRegistry = TypeRegistry;
  exports.deref = deref;
  exports.deserializerMiddlewareOption = deserializerMiddlewareOption;
  exports.error = error;
  exports.getSchemaSerdePlugin = getSchemaSerdePlugin;
  exports.isStaticSchema = isStaticSchema;
  exports.list = list;
  exports.map = map;
  exports.op = op;
  exports.operation = operation;
  exports.serializerMiddlewareOption = serializerMiddlewareOption;
  exports.sim = sim;
  exports.simAdapter = simAdapter;
  exports.struct = struct;
  exports.translateTraits = translateTraits;
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  var __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i2 = 1, n = arguments.length;i2 < n; i2++) {
        s = arguments[i2];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s);i2 < p.length; i2++) {
          if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
            t[p[i2]] = s[p[i2]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i2 = decorators.length - 1;i2 >= 0; i2--)
          if (d = decorators[i2])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i2 = decorators.length - 1;i2 >= 0; i2--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i2 = 0;i2 < initializers.length; i2++) {
        value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i2 >= o.length)
              o = undefined;
            return { value: o && o[i2++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i2 = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i2["return"]))
            m.call(i2);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i2 = 0;i2 < arguments.length; i2++)
        ar = ar.concat(__read(arguments[i2]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i2 = 0, il = arguments.length;i2 < il; i2++)
        s += arguments[i2].length;
      for (var r = Array(s), k = 0, i2 = 0;i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l = from.length, ar;i2 < l; i2++) {
          if (ar || !(i2 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i2);
            ar[i2] = from[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i2, q = [];
      return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i2[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i2[n] = f(i2[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i2, p;
      return i2 = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i2[Symbol.iterator] = function() {
        return this;
      }, i2;
      function verb(n, f) {
        i2[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i2;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n) {
        i2[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i2 = 0;i2 < k.length; i2++)
          if (k[i2] !== "default")
            __createBinding(result, mod, k[i2]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message3) {
      var e = new Error(message3);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    __rewriteRelativeImportExtension = function(path, preserveJsx) {
      if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
      }
      return path;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// node_modules/@smithy/uuid/dist-cjs/randomUUID.js
var require_randomUUID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomUUID = undefined;
  var tslib_1 = require_tslib();
  var crypto_1 = tslib_1.__importDefault(__require("crypto"));
  exports.randomUUID = crypto_1.default.randomUUID.bind(crypto_1.default);
});

// node_modules/@smithy/uuid/dist-cjs/index.js
var require_dist_cjs16 = __commonJS((exports) => {
  var randomUUID = require_randomUUID();
  var decimalToHex = Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
  var v4 = () => {
    if (randomUUID.randomUUID) {
      return randomUUID.randomUUID();
    }
    const rnds = new Uint8Array(16);
    crypto.getRandomValues(rnds);
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    return decimalToHex[rnds[0]] + decimalToHex[rnds[1]] + decimalToHex[rnds[2]] + decimalToHex[rnds[3]] + "-" + decimalToHex[rnds[4]] + decimalToHex[rnds[5]] + "-" + decimalToHex[rnds[6]] + decimalToHex[rnds[7]] + "-" + decimalToHex[rnds[8]] + decimalToHex[rnds[9]] + "-" + decimalToHex[rnds[10]] + decimalToHex[rnds[11]] + decimalToHex[rnds[12]] + decimalToHex[rnds[13]] + decimalToHex[rnds[14]] + decimalToHex[rnds[15]];
  };
  exports.v4 = v4;
});

// node_modules/@smithy/core/dist-cjs/submodules/serde/index.js
var require_serde = __commonJS((exports) => {
  var uuid = require_dist_cjs16();
  var copyDocumentWithTransform = (source, schemaRef, transform = (_) => _) => source;
  var parseBoolean = (value) => {
    switch (value) {
      case "true":
        return true;
      case "false":
        return false;
      default:
        throw new Error(`Unable to parse boolean value "${value}"`);
    }
  };
  var expectBoolean = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "number") {
      if (value === 0 || value === 1) {
        logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
      }
      if (value === 0) {
        return false;
      }
      if (value === 1) {
        return true;
      }
    }
    if (typeof value === "string") {
      const lower = value.toLowerCase();
      if (lower === "false" || lower === "true") {
        logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
      }
      if (lower === "false") {
        return false;
      }
      if (lower === "true") {
        return true;
      }
    }
    if (typeof value === "boolean") {
      return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
  };
  var expectNumber = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "string") {
      const parsed = parseFloat(value);
      if (!Number.isNaN(parsed)) {
        if (String(parsed) !== String(value)) {
          logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
        }
        return parsed;
      }
    }
    if (typeof value === "number") {
      return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
  };
  var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
  var expectFloat32 = (value) => {
    const expected = expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
      if (Math.abs(expected) > MAX_FLOAT) {
        throw new TypeError(`Expected 32-bit float, got ${value}`);
      }
    }
    return expected;
  };
  var expectLong = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
      return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
  };
  var expectInt = expectLong;
  var expectInt32 = (value) => expectSizedInt(value, 32);
  var expectShort = (value) => expectSizedInt(value, 16);
  var expectByte = (value) => expectSizedInt(value, 8);
  var expectSizedInt = (value, size) => {
    const expected = expectLong(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
      throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
  };
  var castInt = (value, size) => {
    switch (size) {
      case 32:
        return Int32Array.of(value)[0];
      case 16:
        return Int16Array.of(value)[0];
      case 8:
        return Int8Array.of(value)[0];
    }
  };
  var expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
      if (location) {
        throw new TypeError(`Expected a non-null value for ${location}`);
      }
      throw new TypeError("Expected a non-null value");
    }
    return value;
  };
  var expectObject = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
      return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
  };
  var expectString = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "string") {
      return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
      logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
      return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
  };
  var expectUnion = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    const asObject = expectObject(value);
    const setKeys = Object.entries(asObject).filter(([, v]) => v != null).map(([k]) => k);
    if (setKeys.length === 0) {
      throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
      throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
  };
  var strictParseDouble = (value) => {
    if (typeof value == "string") {
      return expectNumber(parseNumber(value));
    }
    return expectNumber(value);
  };
  var strictParseFloat = strictParseDouble;
  var strictParseFloat32 = (value) => {
    if (typeof value == "string") {
      return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
  };
  var NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
  var parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
      throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
  };
  var limitedParseDouble = (value) => {
    if (typeof value == "string") {
      return parseFloatString(value);
    }
    return expectNumber(value);
  };
  var handleFloat = limitedParseDouble;
  var limitedParseFloat = limitedParseDouble;
  var limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
      return parseFloatString(value);
    }
    return expectFloat32(value);
  };
  var parseFloatString = (value) => {
    switch (value) {
      case "NaN":
        return NaN;
      case "Infinity":
        return Infinity;
      case "-Infinity":
        return -Infinity;
      default:
        throw new Error(`Unable to parse float value: ${value}`);
    }
  };
  var strictParseLong = (value) => {
    if (typeof value === "string") {
      return expectLong(parseNumber(value));
    }
    return expectLong(value);
  };
  var strictParseInt = strictParseLong;
  var strictParseInt32 = (value) => {
    if (typeof value === "string") {
      return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
  };
  var strictParseShort = (value) => {
    if (typeof value === "string") {
      return expectShort(parseNumber(value));
    }
    return expectShort(value);
  };
  var strictParseByte = (value) => {
    if (typeof value === "string") {
      return expectByte(parseNumber(value));
    }
    return expectByte(value);
  };
  var stackTraceWarning = (message3) => {
    return String(new TypeError(message3).stack || message3).split(`
`).slice(0, 5).filter((s) => !s.includes("stackTraceWarning")).join(`
`);
  };
  var logger = {
    warn: console.warn
  };
  var DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function dateToUtcString(date2) {
    const year3 = date2.getUTCFullYear();
    const month = date2.getUTCMonth();
    const dayOfWeek = date2.getUTCDay();
    const dayOfMonthInt = date2.getUTCDate();
    const hoursInt = date2.getUTCHours();
    const minutesInt = date2.getUTCMinutes();
    const secondsInt = date2.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year3} ${hoursString}:${minutesString}:${secondsString} GMT`;
  }
  var RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
  var parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
      throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year3 = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day2 = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year3, month, day2, { hours, minutes, seconds, fractionalMilliseconds });
  };
  var RFC3339_WITH_OFFSET$1 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
  var parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET$1.exec(value);
    if (!match) {
      throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year3 = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day2 = parseDateValue(dayStr, "day", 1, 31);
    const date2 = buildDate(year3, month, day2, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
      date2.setTime(date2.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date2;
  };
  var IMF_FIXDATE$1 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  var RFC_850_DATE$1 = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  var ASC_TIME$1 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
  var parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE$1.exec(value);
    if (match) {
      const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
      return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE$1.exec(value);
    if (match) {
      const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
      return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
        hours,
        minutes,
        seconds,
        fractionalMilliseconds
      }));
    }
    match = ASC_TIME$1.exec(value);
    if (match) {
      const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
      return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
  };
  var parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    let valueAsDouble;
    if (typeof value === "number") {
      valueAsDouble = value;
    } else if (typeof value === "string") {
      valueAsDouble = strictParseDouble(value);
    } else if (typeof value === "object" && value.tag === 1) {
      valueAsDouble = value.value;
    } else {
      throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
      throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
  };
  var buildDate = (year3, month, day2, time2) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year3, adjustedMonth, day2);
    return new Date(Date.UTC(year3, adjustedMonth, day2, parseDateValue(time2.hours, "hour", 0, 23), parseDateValue(time2.minutes, "minute", 0, 59), parseDateValue(time2.seconds, "seconds", 0, 60), parseMilliseconds(time2.fractionalMilliseconds)));
  };
  var parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
      return valueInThisCentury + 100;
    }
    return valueInThisCentury;
  };
  var FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
  var adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
      return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
  };
  var parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
      throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
  };
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var validateDayOfMonth = (year3, month, day2) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year3)) {
      maxDays = 29;
    }
    if (day2 > maxDays) {
      throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year3}: ${day2}`);
    }
  };
  var isLeapYear = (year3) => {
    return year3 % 4 === 0 && (year3 % 100 !== 0 || year3 % 400 === 0);
  };
  var parseDateValue = (value, type, lower, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
      throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
  };
  var parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
      return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
  };
  var parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
      direction = 1;
    } else if (directionStr == "-") {
      direction = -1;
    } else {
      throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour2 = Number(value.substring(1, 3));
    const minute2 = Number(value.substring(4, 6));
    return direction * (hour2 * 60 + minute2) * 60 * 1000;
  };
  var stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
      idx++;
    }
    if (idx === 0) {
      return value;
    }
    return value.slice(idx);
  };
  var LazyJsonString = function LazyJsonString2(val) {
    const str = Object.assign(new String(val), {
      deserializeJSON() {
        return JSON.parse(String(val));
      },
      toString() {
        return String(val);
      },
      toJSON() {
        return String(val);
      }
    });
    return str;
  };
  LazyJsonString.from = (object) => {
    if (object && typeof object === "object" && (object instanceof LazyJsonString || ("deserializeJSON" in object))) {
      return object;
    } else if (typeof object === "string" || Object.getPrototypeOf(object) === String.prototype) {
      return LazyJsonString(String(object));
    }
    return LazyJsonString(JSON.stringify(object));
  };
  LazyJsonString.fromObject = LazyJsonString.from;
  function quoteHeader(part) {
    if (part.includes(",") || part.includes('"')) {
      part = `"${part.replace(/"/g, "\\\"")}"`;
    }
    return part;
  }
  var ddd = `(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)(?:[ne|u?r]?s?day)?`;
  var mmm = `(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)`;
  var time = `(\\d?\\d):(\\d{2}):(\\d{2})(?:\\.(\\d+))?`;
  var date = `(\\d?\\d)`;
  var year2 = `(\\d{4})`;
  var RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d\d)-(\d\d)[tT](\d\d):(\d\d):(\d\d)(\.(\d+))?(([-+]\d\d:\d\d)|[zZ])$/);
  var IMF_FIXDATE = new RegExp(`^${ddd}, ${date} ${mmm} ${year2} ${time} GMT$`);
  var RFC_850_DATE = new RegExp(`^${ddd}, ${date}-${mmm}-(\\d\\d) ${time} GMT$`);
  var ASC_TIME = new RegExp(`^${ddd} ${mmm} ( [1-9]|\\d\\d) ${time} ${year2}$`);
  var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  var _parseEpochTimestamp = (value) => {
    if (value == null) {
      return;
    }
    let num = NaN;
    if (typeof value === "number") {
      num = value;
    } else if (typeof value === "string") {
      if (!/^-?\d*\.?\d+$/.test(value)) {
        throw new TypeError(`parseEpochTimestamp - numeric string invalid.`);
      }
      num = Number.parseFloat(value);
    } else if (typeof value === "object" && value.tag === 1) {
      num = value.value;
    }
    if (isNaN(num) || Math.abs(num) === Infinity) {
      throw new TypeError("Epoch timestamps must be valid finite numbers.");
    }
    return new Date(Math.round(num * 1000));
  };
  var _parseRfc3339DateTimeWithOffset = (value) => {
    if (value == null) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC3339 timestamps must be strings");
    }
    const matches = RFC3339_WITH_OFFSET.exec(value);
    if (!matches) {
      throw new TypeError(`Invalid RFC3339 timestamp format ${value}`);
    }
    const [, yearStr, monthStr, dayStr, hours, minutes, seconds, , ms, offsetStr] = matches;
    range(monthStr, 1, 12);
    range(dayStr, 1, 31);
    range(hours, 0, 23);
    range(minutes, 0, 59);
    range(seconds, 0, 60);
    const date2 = new Date(Date.UTC(Number(yearStr), Number(monthStr) - 1, Number(dayStr), Number(hours), Number(minutes), Number(seconds), Number(ms) ? Math.round(parseFloat(`0.${ms}`) * 1000) : 0));
    date2.setUTCFullYear(Number(yearStr));
    if (offsetStr.toUpperCase() != "Z") {
      const [, sign, offsetH, offsetM] = /([+-])(\d\d):(\d\d)/.exec(offsetStr) || [undefined, "+", 0, 0];
      const scalar = sign === "-" ? 1 : -1;
      date2.setTime(date2.getTime() + scalar * (Number(offsetH) * 60 * 60 * 1000 + Number(offsetM) * 60 * 1000));
    }
    return date2;
  };
  var _parseRfc7231DateTime = (value) => {
    if (value == null) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC7231 timestamps must be strings.");
    }
    let day2;
    let month;
    let year3;
    let hour2;
    let minute2;
    let second;
    let fraction;
    let matches;
    if (matches = IMF_FIXDATE.exec(value)) {
      [, day2, month, year3, hour2, minute2, second, fraction] = matches;
    } else if (matches = RFC_850_DATE.exec(value)) {
      [, day2, month, year3, hour2, minute2, second, fraction] = matches;
      year3 = (Number(year3) + 1900).toString();
    } else if (matches = ASC_TIME.exec(value)) {
      [, month, day2, hour2, minute2, second, fraction, year3] = matches;
    }
    if (year3 && second) {
      const timestamp = Date.UTC(Number(year3), months.indexOf(month), Number(day2), Number(hour2), Number(minute2), Number(second), fraction ? Math.round(parseFloat(`0.${fraction}`) * 1000) : 0);
      range(day2, 1, 31);
      range(hour2, 0, 23);
      range(minute2, 0, 59);
      range(second, 0, 60);
      const date2 = new Date(timestamp);
      date2.setUTCFullYear(Number(year3));
      return date2;
    }
    throw new TypeError(`Invalid RFC7231 date-time value ${value}.`);
  };
  function range(v, min, max) {
    const _v = Number(v);
    if (_v < min || _v > max) {
      throw new Error(`Value ${_v} out of range [${min}, ${max}]`);
    }
  }
  function splitEvery(value, delimiter, numDelimiters) {
    if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {
      throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
    }
    const segments = value.split(delimiter);
    if (numDelimiters === 1) {
      return segments;
    }
    const compoundSegments = [];
    let currentSegment = "";
    for (let i2 = 0;i2 < segments.length; i2++) {
      if (currentSegment === "") {
        currentSegment = segments[i2];
      } else {
        currentSegment += delimiter + segments[i2];
      }
      if ((i2 + 1) % numDelimiters === 0) {
        compoundSegments.push(currentSegment);
        currentSegment = "";
      }
    }
    if (currentSegment !== "") {
      compoundSegments.push(currentSegment);
    }
    return compoundSegments;
  }
  var splitHeader = (value) => {
    const z = value.length;
    const values = [];
    let withinQuotes = false;
    let prevChar = undefined;
    let anchor = 0;
    for (let i2 = 0;i2 < z; ++i2) {
      const char = value[i2];
      switch (char) {
        case `"`:
          if (prevChar !== "\\") {
            withinQuotes = !withinQuotes;
          }
          break;
        case ",":
          if (!withinQuotes) {
            values.push(value.slice(anchor, i2));
            anchor = i2 + 1;
          }
          break;
      }
      prevChar = char;
    }
    values.push(value.slice(anchor));
    return values.map((v) => {
      v = v.trim();
      const z2 = v.length;
      if (z2 < 2) {
        return v;
      }
      if (v[0] === `"` && v[z2 - 1] === `"`) {
        v = v.slice(1, z2 - 1);
      }
      return v.replace(/\\"/g, '"');
    });
  };
  var format = /^-?\d*(\.\d+)?$/;

  class NumericValue {
    string;
    type;
    constructor(string, type) {
      this.string = string;
      this.type = type;
      if (!format.test(string)) {
        throw new Error(`@smithy/core/serde - NumericValue must only contain [0-9], at most one decimal point ".", and an optional negation prefix "-".`);
      }
    }
    toString() {
      return this.string;
    }
    static [Symbol.hasInstance](object) {
      if (!object || typeof object !== "object") {
        return false;
      }
      const _nv = object;
      return NumericValue.prototype.isPrototypeOf(object) || _nv.type === "bigDecimal" && format.test(_nv.string);
    }
  }
  function nv(input) {
    return new NumericValue(String(input), "bigDecimal");
  }
  exports.generateIdempotencyToken = uuid.v4;
  exports.LazyJsonString = LazyJsonString;
  exports.NumericValue = NumericValue;
  exports._parseEpochTimestamp = _parseEpochTimestamp;
  exports._parseRfc3339DateTimeWithOffset = _parseRfc3339DateTimeWithOffset;
  exports._parseRfc7231DateTime = _parseRfc7231DateTime;
  exports.copyDocumentWithTransform = copyDocumentWithTransform;
  exports.dateToUtcString = dateToUtcString;
  exports.expectBoolean = expectBoolean;
  exports.expectByte = expectByte;
  exports.expectFloat32 = expectFloat32;
  exports.expectInt = expectInt;
  exports.expectInt32 = expectInt32;
  exports.expectLong = expectLong;
  exports.expectNonNull = expectNonNull;
  exports.expectNumber = expectNumber;
  exports.expectObject = expectObject;
  exports.expectShort = expectShort;
  exports.expectString = expectString;
  exports.expectUnion = expectUnion;
  exports.handleFloat = handleFloat;
  exports.limitedParseDouble = limitedParseDouble;
  exports.limitedParseFloat = limitedParseFloat;
  exports.limitedParseFloat32 = limitedParseFloat32;
  exports.logger = logger;
  exports.nv = nv;
  exports.parseBoolean = parseBoolean;
  exports.parseEpochTimestamp = parseEpochTimestamp;
  exports.parseRfc3339DateTime = parseRfc3339DateTime;
  exports.parseRfc3339DateTimeWithOffset = parseRfc3339DateTimeWithOffset;
  exports.parseRfc7231DateTime = parseRfc7231DateTime;
  exports.quoteHeader = quoteHeader;
  exports.splitEvery = splitEvery;
  exports.splitHeader = splitHeader;
  exports.strictParseByte = strictParseByte;
  exports.strictParseDouble = strictParseDouble;
  exports.strictParseFloat = strictParseFloat;
  exports.strictParseFloat32 = strictParseFloat32;
  exports.strictParseInt = strictParseInt;
  exports.strictParseInt32 = strictParseInt32;
  exports.strictParseLong = strictParseLong;
  exports.strictParseShort = strictParseShort;
});

// node_modules/@smithy/core/dist-cjs/submodules/event-streams/index.js
var require_event_streams = __commonJS((exports) => {
  var utilUtf8 = require_dist_cjs8();

  class EventStreamSerde {
    marshaller;
    serializer;
    deserializer;
    serdeContext;
    defaultContentType;
    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType }) {
      this.marshaller = marshaller;
      this.serializer = serializer;
      this.deserializer = deserializer;
      this.serdeContext = serdeContext;
      this.defaultContentType = defaultContentType;
    }
    async serializeEventStream({ eventStream, requestSchema, initialRequest }) {
      const marshaller = this.marshaller;
      const eventStreamMember = requestSchema.getEventStreamMember();
      const unionSchema = requestSchema.getMemberSchema(eventStreamMember);
      const serializer = this.serializer;
      const defaultContentType = this.defaultContentType;
      const initialRequestMarker = Symbol("initialRequestMarker");
      const eventStreamIterable = {
        async* [Symbol.asyncIterator]() {
          if (initialRequest) {
            const headers = {
              ":event-type": { type: "string", value: "initial-request" },
              ":message-type": { type: "string", value: "event" },
              ":content-type": { type: "string", value: defaultContentType }
            };
            serializer.write(requestSchema, initialRequest);
            const body = serializer.flush();
            yield {
              [initialRequestMarker]: true,
              headers,
              body
            };
          }
          for await (const page of eventStream) {
            yield page;
          }
        }
      };
      return marshaller.serialize(eventStreamIterable, (event) => {
        if (event[initialRequestMarker]) {
          return {
            headers: event.headers,
            body: event.body
          };
        }
        const unionMember = Object.keys(event).find((key) => {
          return key !== "__type";
        }) ?? "";
        const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);
        const headers = {
          ":event-type": { type: "string", value: eventType },
          ":message-type": { type: "string", value: "event" },
          ":content-type": { type: "string", value: explicitPayloadContentType ?? defaultContentType },
          ...additionalHeaders
        };
        return {
          headers,
          body
        };
      });
    }
    async deserializeEventStream({ response, responseSchema, initialResponseContainer }) {
      const marshaller = this.marshaller;
      const eventStreamMember = responseSchema.getEventStreamMember();
      const unionSchema = responseSchema.getMemberSchema(eventStreamMember);
      const memberSchemas = unionSchema.getMemberSchemas();
      const initialResponseMarker = Symbol("initialResponseMarker");
      const asyncIterable = marshaller.deserialize(response.body, async (event) => {
        const unionMember = Object.keys(event).find((key) => {
          return key !== "__type";
        }) ?? "";
        const body = event[unionMember].body;
        if (unionMember === "initial-response") {
          const dataObject = await this.deserializer.read(responseSchema, body);
          delete dataObject[eventStreamMember];
          return {
            [initialResponseMarker]: true,
            ...dataObject
          };
        } else if (unionMember in memberSchemas) {
          const eventStreamSchema = memberSchemas[unionMember];
          if (eventStreamSchema.isStructSchema()) {
            const out = {};
            let hasBindings = false;
            for (const [name, member] of eventStreamSchema.structIterator()) {
              const { eventHeader, eventPayload } = member.getMergedTraits();
              hasBindings = hasBindings || Boolean(eventHeader || eventPayload);
              if (eventPayload) {
                if (member.isBlobSchema()) {
                  out[name] = body;
                } else if (member.isStringSchema()) {
                  out[name] = (this.serdeContext?.utf8Encoder ?? utilUtf8.toUtf8)(body);
                } else if (member.isStructSchema()) {
                  out[name] = await this.deserializer.read(member, body);
                }
              } else if (eventHeader) {
                const value = event[unionMember].headers[name]?.value;
                if (value != null) {
                  if (member.isNumericSchema()) {
                    if (value && typeof value === "object" && "bytes" in value) {
                      out[name] = BigInt(value.toString());
                    } else {
                      out[name] = Number(value);
                    }
                  } else {
                    out[name] = value;
                  }
                }
              }
            }
            if (hasBindings) {
              return {
                [unionMember]: out
              };
            }
            if (body.byteLength === 0) {
              return {
                [unionMember]: {}
              };
            }
          }
          return {
            [unionMember]: await this.deserializer.read(eventStreamSchema, body)
          };
        } else {
          return {
            $unknown: event
          };
        }
      });
      const asyncIterator = asyncIterable[Symbol.asyncIterator]();
      const firstEvent = await asyncIterator.next();
      if (firstEvent.done) {
        return asyncIterable;
      }
      if (firstEvent.value?.[initialResponseMarker]) {
        if (!responseSchema) {
          throw new Error("@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.");
        }
        for (const [key, value] of Object.entries(firstEvent.value)) {
          initialResponseContainer[key] = value;
        }
      }
      return {
        async* [Symbol.asyncIterator]() {
          if (!firstEvent?.value?.[initialResponseMarker]) {
            yield firstEvent.value;
          }
          while (true) {
            const { done, value } = await asyncIterator.next();
            if (done) {
              break;
            }
            yield value;
          }
        }
      };
    }
    writeEventBody(unionMember, unionSchema, event) {
      const serializer = this.serializer;
      let eventType = unionMember;
      let explicitPayloadMember = null;
      let explicitPayloadContentType;
      const isKnownSchema = (() => {
        const struct = unionSchema.getSchema();
        return struct[4].includes(unionMember);
      })();
      const additionalHeaders = {};
      if (!isKnownSchema) {
        const [type, value] = event[unionMember];
        eventType = type;
        serializer.write(15, value);
      } else {
        const eventSchema = unionSchema.getMemberSchema(unionMember);
        if (eventSchema.isStructSchema()) {
          for (const [memberName, memberSchema] of eventSchema.structIterator()) {
            const { eventHeader, eventPayload } = memberSchema.getMergedTraits();
            if (eventPayload) {
              explicitPayloadMember = memberName;
            } else if (eventHeader) {
              const value = event[unionMember][memberName];
              let type = "binary";
              if (memberSchema.isNumericSchema()) {
                if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {
                  type = "integer";
                } else {
                  type = "long";
                }
              } else if (memberSchema.isTimestampSchema()) {
                type = "timestamp";
              } else if (memberSchema.isStringSchema()) {
                type = "string";
              } else if (memberSchema.isBooleanSchema()) {
                type = "boolean";
              }
              if (value != null) {
                additionalHeaders[memberName] = {
                  type,
                  value
                };
                delete event[unionMember][memberName];
              }
            }
          }
          if (explicitPayloadMember !== null) {
            const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);
            if (payloadSchema.isBlobSchema()) {
              explicitPayloadContentType = "application/octet-stream";
            } else if (payloadSchema.isStringSchema()) {
              explicitPayloadContentType = "text/plain";
            }
            serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);
          } else {
            serializer.write(eventSchema, event[unionMember]);
          }
        } else if (eventSchema.isUnitSchema()) {
          serializer.write(eventSchema, {});
        } else {
          throw new Error("@smithy/core/event-streams - non-struct member not supported in event stream union.");
        }
      }
      const messageSerialization = serializer.flush();
      const body = typeof messageSerialization === "string" ? (this.serdeContext?.utf8Decoder ?? utilUtf8.fromUtf8)(messageSerialization) : messageSerialization;
      return {
        body,
        eventType,
        explicitPayloadContentType,
        additionalHeaders
      };
    }
  }
  exports.EventStreamSerde = EventStreamSerde;
});

// node_modules/@smithy/core/dist-cjs/submodules/protocols/index.js
var require_protocols = __commonJS((exports) => {
  var utilStream = require_dist_cjs15();
  var schema = require_schema();
  var serde = require_serde();
  var protocolHttp = require_dist_cjs2();
  var utilBase64 = require_dist_cjs9();
  var utilUtf8 = require_dist_cjs8();
  var collectBody = async (streamBody = new Uint8Array, context) => {
    if (streamBody instanceof Uint8Array) {
      return utilStream.Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
      return utilStream.Uint8ArrayBlobAdapter.mutate(new Uint8Array);
    }
    const fromContext = context.streamCollector(streamBody);
    return utilStream.Uint8ArrayBlobAdapter.mutate(await fromContext);
  };
  function extendedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }

  class SerdeContext {
    serdeContext;
    setSerdeContext(serdeContext) {
      this.serdeContext = serdeContext;
    }
  }

  class HttpProtocol extends SerdeContext {
    options;
    compositeErrorRegistry;
    constructor(options) {
      super();
      this.options = options;
      this.compositeErrorRegistry = schema.TypeRegistry.for(options.defaultNamespace);
      for (const etr of options.errorTypeRegistries ?? []) {
        this.compositeErrorRegistry.copyFrom(etr);
      }
    }
    getRequestType() {
      return protocolHttp.HttpRequest;
    }
    getResponseType() {
      return protocolHttp.HttpResponse;
    }
    setSerdeContext(serdeContext) {
      this.serdeContext = serdeContext;
      this.serializer.setSerdeContext(serdeContext);
      this.deserializer.setSerdeContext(serdeContext);
      if (this.getPayloadCodec()) {
        this.getPayloadCodec().setSerdeContext(serdeContext);
      }
    }
    updateServiceEndpoint(request, endpoint) {
      if ("url" in endpoint) {
        request.protocol = endpoint.url.protocol;
        request.hostname = endpoint.url.hostname;
        request.port = endpoint.url.port ? Number(endpoint.url.port) : undefined;
        request.path = endpoint.url.pathname;
        request.fragment = endpoint.url.hash || undefined;
        request.username = endpoint.url.username || undefined;
        request.password = endpoint.url.password || undefined;
        if (!request.query) {
          request.query = {};
        }
        for (const [k, v] of endpoint.url.searchParams.entries()) {
          request.query[k] = v;
        }
        return request;
      } else {
        request.protocol = endpoint.protocol;
        request.hostname = endpoint.hostname;
        request.port = endpoint.port ? Number(endpoint.port) : undefined;
        request.path = endpoint.path;
        request.query = {
          ...endpoint.query
        };
        return request;
      }
    }
    setHostPrefix(request, operationSchema, input) {
      if (this.serdeContext?.disableHostPrefix) {
        return;
      }
      const inputNs = schema.NormalizedSchema.of(operationSchema.input);
      const opTraits = schema.translateTraits(operationSchema.traits ?? {});
      if (opTraits.endpoint) {
        let hostPrefix = opTraits.endpoint?.[0];
        if (typeof hostPrefix === "string") {
          const hostLabelInputs = [...inputNs.structIterator()].filter(([, member]) => member.getMergedTraits().hostLabel);
          for (const [name] of hostLabelInputs) {
            const replacement = input[name];
            if (typeof replacement !== "string") {
              throw new Error(`@smithy/core/schema - ${name} in input must be a string as hostLabel.`);
            }
            hostPrefix = hostPrefix.replace(`{${name}}`, replacement);
          }
          request.hostname = hostPrefix + request.hostname;
        }
      }
    }
    deserializeMetadata(output) {
      return {
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"]
      };
    }
    async serializeEventStream({ eventStream, requestSchema, initialRequest }) {
      const eventStreamSerde = await this.loadEventStreamCapability();
      return eventStreamSerde.serializeEventStream({
        eventStream,
        requestSchema,
        initialRequest
      });
    }
    async deserializeEventStream({ response, responseSchema, initialResponseContainer }) {
      const eventStreamSerde = await this.loadEventStreamCapability();
      return eventStreamSerde.deserializeEventStream({
        response,
        responseSchema,
        initialResponseContainer
      });
    }
    async loadEventStreamCapability() {
      const { EventStreamSerde } = await Promise.resolve().then(() => __toESM(require_event_streams()));
      return new EventStreamSerde({
        marshaller: this.getEventStreamMarshaller(),
        serializer: this.serializer,
        deserializer: this.deserializer,
        serdeContext: this.serdeContext,
        defaultContentType: this.getDefaultContentType()
      });
    }
    getDefaultContentType() {
      throw new Error(`@smithy/core/protocols - ${this.constructor.name} getDefaultContentType() implementation missing.`);
    }
    async deserializeHttpMessage(schema2, context, response, arg4, arg5) {
      return [];
    }
    getEventStreamMarshaller() {
      const context = this.serdeContext;
      if (!context.eventStreamMarshaller) {
        throw new Error("@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext.");
      }
      return context.eventStreamMarshaller;
    }
  }

  class HttpBindingProtocol extends HttpProtocol {
    async serializeRequest(operationSchema, _input, context) {
      const input = {
        ..._input ?? {}
      };
      const serializer = this.serializer;
      const query = {};
      const headers = {};
      const endpoint = await context.endpoint();
      const ns = schema.NormalizedSchema.of(operationSchema?.input);
      const payloadMemberNames = [];
      const payloadMemberSchemas = [];
      let hasNonHttpBindingMember = false;
      let payload;
      const request = new protocolHttp.HttpRequest({
        protocol: "",
        hostname: "",
        port: undefined,
        path: "",
        fragment: undefined,
        query,
        headers,
        body: undefined
      });
      if (endpoint) {
        this.updateServiceEndpoint(request, endpoint);
        this.setHostPrefix(request, operationSchema, input);
        const opTraits = schema.translateTraits(operationSchema.traits);
        if (opTraits.http) {
          request.method = opTraits.http[0];
          const [path, search] = opTraits.http[1].split("?");
          if (request.path == "/") {
            request.path = path;
          } else {
            request.path += path;
          }
          const traitSearchParams = new URLSearchParams(search ?? "");
          Object.assign(query, Object.fromEntries(traitSearchParams));
        }
      }
      for (const [memberName, memberNs] of ns.structIterator()) {
        const memberTraits = memberNs.getMergedTraits() ?? {};
        const inputMemberValue = input[memberName];
        if (inputMemberValue == null && !memberNs.isIdempotencyToken()) {
          if (memberTraits.httpLabel) {
            if (request.path.includes(`{${memberName}+}`) || request.path.includes(`{${memberName}}`)) {
              throw new Error(`No value provided for input HTTP label: ${memberName}.`);
            }
          }
          continue;
        }
        if (memberTraits.httpPayload) {
          const isStreaming = memberNs.isStreaming();
          if (isStreaming) {
            const isEventStream = memberNs.isStructSchema();
            if (isEventStream) {
              if (input[memberName]) {
                payload = await this.serializeEventStream({
                  eventStream: input[memberName],
                  requestSchema: ns
                });
              }
            } else {
              payload = inputMemberValue;
            }
          } else {
            serializer.write(memberNs, inputMemberValue);
            payload = serializer.flush();
          }
          delete input[memberName];
        } else if (memberTraits.httpLabel) {
          serializer.write(memberNs, inputMemberValue);
          const replacement = serializer.flush();
          if (request.path.includes(`{${memberName}+}`)) {
            request.path = request.path.replace(`{${memberName}+}`, replacement.split("/").map(extendedEncodeURIComponent).join("/"));
          } else if (request.path.includes(`{${memberName}}`)) {
            request.path = request.path.replace(`{${memberName}}`, extendedEncodeURIComponent(replacement));
          }
          delete input[memberName];
        } else if (memberTraits.httpHeader) {
          serializer.write(memberNs, inputMemberValue);
          headers[memberTraits.httpHeader.toLowerCase()] = String(serializer.flush());
          delete input[memberName];
        } else if (typeof memberTraits.httpPrefixHeaders === "string") {
          for (const [key, val] of Object.entries(inputMemberValue)) {
            const amalgam = memberTraits.httpPrefixHeaders + key;
            serializer.write([memberNs.getValueSchema(), { httpHeader: amalgam }], val);
            headers[amalgam.toLowerCase()] = serializer.flush();
          }
          delete input[memberName];
        } else if (memberTraits.httpQuery || memberTraits.httpQueryParams) {
          this.serializeQuery(memberNs, inputMemberValue, query);
          delete input[memberName];
        } else {
          hasNonHttpBindingMember = true;
          payloadMemberNames.push(memberName);
          payloadMemberSchemas.push(memberNs);
        }
      }
      if (hasNonHttpBindingMember && input) {
        const [namespace, name] = (ns.getName(true) ?? "#Unknown").split("#");
        const requiredMembers = ns.getSchema()[6];
        const payloadSchema = [
          3,
          namespace,
          name,
          ns.getMergedTraits(),
          payloadMemberNames,
          payloadMemberSchemas,
          undefined
        ];
        if (requiredMembers) {
          payloadSchema[6] = requiredMembers;
        } else {
          payloadSchema.pop();
        }
        serializer.write(payloadSchema, input);
        payload = serializer.flush();
      }
      request.headers = headers;
      request.query = query;
      request.body = payload;
      return request;
    }
    serializeQuery(ns, data, query) {
      const serializer = this.serializer;
      const traits = ns.getMergedTraits();
      if (traits.httpQueryParams) {
        for (const [key, val] of Object.entries(data)) {
          if (!(key in query)) {
            const valueSchema = ns.getValueSchema();
            Object.assign(valueSchema.getMergedTraits(), {
              ...traits,
              httpQuery: key,
              httpQueryParams: undefined
            });
            this.serializeQuery(valueSchema, val, query);
          }
        }
        return;
      }
      if (ns.isListSchema()) {
        const sparse = !!ns.getMergedTraits().sparse;
        const buffer = [];
        for (const item of data) {
          serializer.write([ns.getValueSchema(), traits], item);
          const serializable = serializer.flush();
          if (sparse || serializable !== undefined) {
            buffer.push(serializable);
          }
        }
        query[traits.httpQuery] = buffer;
      } else {
        serializer.write([ns, traits], data);
        query[traits.httpQuery] = serializer.flush();
      }
    }
    async deserializeResponse(operationSchema, context, response) {
      const deserializer = this.deserializer;
      const ns = schema.NormalizedSchema.of(operationSchema.output);
      const dataObject = {};
      if (response.statusCode >= 300) {
        const bytes = await collectBody(response.body, context);
        if (bytes.byteLength > 0) {
          Object.assign(dataObject, await deserializer.read(15, bytes));
        }
        await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));
        throw new Error("@smithy/core/protocols - HTTP Protocol error handler failed to throw.");
      }
      for (const header in response.headers) {
        const value = response.headers[header];
        delete response.headers[header];
        response.headers[header.toLowerCase()] = value;
      }
      const nonHttpBindingMembers = await this.deserializeHttpMessage(ns, context, response, dataObject);
      if (nonHttpBindingMembers.length) {
        const bytes = await collectBody(response.body, context);
        if (bytes.byteLength > 0) {
          const dataFromBody = await deserializer.read(ns, bytes);
          for (const member of nonHttpBindingMembers) {
            if (dataFromBody[member] != null) {
              dataObject[member] = dataFromBody[member];
            }
          }
        }
      } else if (nonHttpBindingMembers.discardResponseBody) {
        await collectBody(response.body, context);
      }
      dataObject.$metadata = this.deserializeMetadata(response);
      return dataObject;
    }
    async deserializeHttpMessage(schema$1, context, response, arg4, arg5) {
      let dataObject;
      if (arg4 instanceof Set) {
        dataObject = arg5;
      } else {
        dataObject = arg4;
      }
      let discardResponseBody = true;
      const deserializer = this.deserializer;
      const ns = schema.NormalizedSchema.of(schema$1);
      const nonHttpBindingMembers = [];
      for (const [memberName, memberSchema] of ns.structIterator()) {
        const memberTraits = memberSchema.getMemberTraits();
        if (memberTraits.httpPayload) {
          discardResponseBody = false;
          const isStreaming = memberSchema.isStreaming();
          if (isStreaming) {
            const isEventStream = memberSchema.isStructSchema();
            if (isEventStream) {
              dataObject[memberName] = await this.deserializeEventStream({
                response,
                responseSchema: ns
              });
            } else {
              dataObject[memberName] = utilStream.sdkStreamMixin(response.body);
            }
          } else if (response.body) {
            const bytes = await collectBody(response.body, context);
            if (bytes.byteLength > 0) {
              dataObject[memberName] = await deserializer.read(memberSchema, bytes);
            }
          }
        } else if (memberTraits.httpHeader) {
          const key = String(memberTraits.httpHeader).toLowerCase();
          const value = response.headers[key];
          if (value != null) {
            if (memberSchema.isListSchema()) {
              const headerListValueSchema = memberSchema.getValueSchema();
              headerListValueSchema.getMergedTraits().httpHeader = key;
              let sections;
              if (headerListValueSchema.isTimestampSchema() && headerListValueSchema.getSchema() === 4) {
                sections = serde.splitEvery(value, ",", 2);
              } else {
                sections = serde.splitHeader(value);
              }
              const list = [];
              for (const section of sections) {
                list.push(await deserializer.read(headerListValueSchema, section.trim()));
              }
              dataObject[memberName] = list;
            } else {
              dataObject[memberName] = await deserializer.read(memberSchema, value);
            }
          }
        } else if (memberTraits.httpPrefixHeaders !== undefined) {
          dataObject[memberName] = {};
          for (const [header, value] of Object.entries(response.headers)) {
            if (header.startsWith(memberTraits.httpPrefixHeaders)) {
              const valueSchema = memberSchema.getValueSchema();
              valueSchema.getMergedTraits().httpHeader = header;
              dataObject[memberName][header.slice(memberTraits.httpPrefixHeaders.length)] = await deserializer.read(valueSchema, value);
            }
          }
        } else if (memberTraits.httpResponseCode) {
          dataObject[memberName] = response.statusCode;
        } else {
          nonHttpBindingMembers.push(memberName);
        }
      }
      nonHttpBindingMembers.discardResponseBody = discardResponseBody;
      return nonHttpBindingMembers;
    }
  }

  class RpcProtocol extends HttpProtocol {
    async serializeRequest(operationSchema, input, context) {
      const serializer = this.serializer;
      const query = {};
      const headers = {};
      const endpoint = await context.endpoint();
      const ns = schema.NormalizedSchema.of(operationSchema?.input);
      const schema$1 = ns.getSchema();
      let payload;
      const request = new protocolHttp.HttpRequest({
        protocol: "",
        hostname: "",
        port: undefined,
        path: "/",
        fragment: undefined,
        query,
        headers,
        body: undefined
      });
      if (endpoint) {
        this.updateServiceEndpoint(request, endpoint);
        this.setHostPrefix(request, operationSchema, input);
      }
      const _input = {
        ...input
      };
      if (input) {
        const eventStreamMember = ns.getEventStreamMember();
        if (eventStreamMember) {
          if (_input[eventStreamMember]) {
            const initialRequest = {};
            for (const [memberName, memberSchema] of ns.structIterator()) {
              if (memberName !== eventStreamMember && _input[memberName]) {
                serializer.write(memberSchema, _input[memberName]);
                initialRequest[memberName] = serializer.flush();
              }
            }
            payload = await this.serializeEventStream({
              eventStream: _input[eventStreamMember],
              requestSchema: ns,
              initialRequest
            });
          }
        } else {
          serializer.write(schema$1, _input);
          payload = serializer.flush();
        }
      }
      request.headers = headers;
      request.query = query;
      request.body = payload;
      request.method = "POST";
      return request;
    }
    async deserializeResponse(operationSchema, context, response) {
      const deserializer = this.deserializer;
      const ns = schema.NormalizedSchema.of(operationSchema.output);
      const dataObject = {};
      if (response.statusCode >= 300) {
        const bytes = await collectBody(response.body, context);
        if (bytes.byteLength > 0) {
          Object.assign(dataObject, await deserializer.read(15, bytes));
        }
        await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));
        throw new Error("@smithy/core/protocols - RPC Protocol error handler failed to throw.");
      }
      for (const header in response.headers) {
        const value = response.headers[header];
        delete response.headers[header];
        response.headers[header.toLowerCase()] = value;
      }
      const eventStreamMember = ns.getEventStreamMember();
      if (eventStreamMember) {
        dataObject[eventStreamMember] = await this.deserializeEventStream({
          response,
          responseSchema: ns,
          initialResponseContainer: dataObject
        });
      } else {
        const bytes = await collectBody(response.body, context);
        if (bytes.byteLength > 0) {
          Object.assign(dataObject, await deserializer.read(ns, bytes));
        }
      }
      dataObject.$metadata = this.deserializeMetadata(response);
      return dataObject;
    }
  }
  var resolvedPath = (resolvedPath2, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
    if (input != null && input[memberName] !== undefined) {
      const labelValue = labelValueProvider();
      if (labelValue == null || labelValue.length <= 0) {
        throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
      }
      resolvedPath2 = resolvedPath2.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent(segment)).join("/") : extendedEncodeURIComponent(labelValue));
    } else {
      throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath2;
  };
  function requestBuilder(input, context) {
    return new RequestBuilder(input, context);
  }

  class RequestBuilder {
    input;
    context;
    query = {};
    method = "";
    headers = {};
    path = "";
    body = null;
    hostname = "";
    resolvePathStack = [];
    constructor(input, context) {
      this.input = input;
      this.context = context;
    }
    async build() {
      const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
      this.path = basePath;
      for (const resolvePath of this.resolvePathStack) {
        resolvePath(this.path);
      }
      return new protocolHttp.HttpRequest({
        protocol,
        hostname: this.hostname || hostname,
        port,
        method: this.method,
        path: this.path,
        query: this.query,
        body: this.body,
        headers: this.headers
      });
    }
    hn(hostname) {
      this.hostname = hostname;
      return this;
    }
    bp(uriLabel) {
      this.resolvePathStack.push((basePath) => {
        this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
      });
      return this;
    }
    p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
      this.resolvePathStack.push((path) => {
        this.path = resolvedPath(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
      });
      return this;
    }
    h(headers) {
      this.headers = headers;
      return this;
    }
    q(query) {
      this.query = query;
      return this;
    }
    b(body) {
      this.body = body;
      return this;
    }
    m(method) {
      this.method = method;
      return this;
    }
  }
  function determineTimestampFormat(ns, settings) {
    if (settings.timestampFormat.useTrait) {
      if (ns.isTimestampSchema() && (ns.getSchema() === 5 || ns.getSchema() === 6 || ns.getSchema() === 7)) {
        return ns.getSchema();
      }
    }
    const { httpLabel, httpPrefixHeaders, httpHeader, httpQuery } = ns.getMergedTraits();
    const bindingFormat = settings.httpBindings ? typeof httpPrefixHeaders === "string" || Boolean(httpHeader) ? 6 : Boolean(httpQuery) || Boolean(httpLabel) ? 5 : undefined : undefined;
    return bindingFormat ?? settings.timestampFormat.default;
  }

  class FromStringShapeDeserializer extends SerdeContext {
    settings;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    read(_schema, data) {
      const ns = schema.NormalizedSchema.of(_schema);
      if (ns.isListSchema()) {
        return serde.splitHeader(data).map((item) => this.read(ns.getValueSchema(), item));
      }
      if (ns.isBlobSchema()) {
        return (this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(data);
      }
      if (ns.isTimestampSchema()) {
        const format = determineTimestampFormat(ns, this.settings);
        switch (format) {
          case 5:
            return serde._parseRfc3339DateTimeWithOffset(data);
          case 6:
            return serde._parseRfc7231DateTime(data);
          case 7:
            return serde._parseEpochTimestamp(data);
          default:
            console.warn("Missing timestamp format, parsing value with Date constructor:", data);
            return new Date(data);
        }
      }
      if (ns.isStringSchema()) {
        const mediaType = ns.getMergedTraits().mediaType;
        let intermediateValue = data;
        if (mediaType) {
          if (ns.getMergedTraits().httpHeader) {
            intermediateValue = this.base64ToUtf8(intermediateValue);
          }
          const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
          if (isJson) {
            intermediateValue = serde.LazyJsonString.from(intermediateValue);
          }
          return intermediateValue;
        }
      }
      if (ns.isNumericSchema()) {
        return Number(data);
      }
      if (ns.isBigIntegerSchema()) {
        return BigInt(data);
      }
      if (ns.isBigDecimalSchema()) {
        return new serde.NumericValue(data, "bigDecimal");
      }
      if (ns.isBooleanSchema()) {
        return String(data).toLowerCase() === "true";
      }
      return data;
    }
    base64ToUtf8(base64String) {
      return (this.serdeContext?.utf8Encoder ?? utilUtf8.toUtf8)((this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(base64String));
    }
  }

  class HttpInterceptingShapeDeserializer extends SerdeContext {
    codecDeserializer;
    stringDeserializer;
    constructor(codecDeserializer, codecSettings) {
      super();
      this.codecDeserializer = codecDeserializer;
      this.stringDeserializer = new FromStringShapeDeserializer(codecSettings);
    }
    setSerdeContext(serdeContext) {
      this.stringDeserializer.setSerdeContext(serdeContext);
      this.codecDeserializer.setSerdeContext(serdeContext);
      this.serdeContext = serdeContext;
    }
    read(schema$1, data) {
      const ns = schema.NormalizedSchema.of(schema$1);
      const traits = ns.getMergedTraits();
      const toString = this.serdeContext?.utf8Encoder ?? utilUtf8.toUtf8;
      if (traits.httpHeader || traits.httpResponseCode) {
        return this.stringDeserializer.read(ns, toString(data));
      }
      if (traits.httpPayload) {
        if (ns.isBlobSchema()) {
          const toBytes = this.serdeContext?.utf8Decoder ?? utilUtf8.fromUtf8;
          if (typeof data === "string") {
            return toBytes(data);
          }
          return data;
        } else if (ns.isStringSchema()) {
          if ("byteLength" in data) {
            return toString(data);
          }
          return data;
        }
      }
      return this.codecDeserializer.read(ns, data);
    }
  }

  class ToStringShapeSerializer extends SerdeContext {
    settings;
    stringBuffer = "";
    constructor(settings) {
      super();
      this.settings = settings;
    }
    write(schema$1, value) {
      const ns = schema.NormalizedSchema.of(schema$1);
      switch (typeof value) {
        case "object":
          if (value === null) {
            this.stringBuffer = "null";
            return;
          }
          if (ns.isTimestampSchema()) {
            if (!(value instanceof Date)) {
              throw new Error(`@smithy/core/protocols - received non-Date value ${value} when schema expected Date in ${ns.getName(true)}`);
            }
            const format = determineTimestampFormat(ns, this.settings);
            switch (format) {
              case 5:
                this.stringBuffer = value.toISOString().replace(".000Z", "Z");
                break;
              case 6:
                this.stringBuffer = serde.dateToUtcString(value);
                break;
              case 7:
                this.stringBuffer = String(value.getTime() / 1000);
                break;
              default:
                console.warn("Missing timestamp format, using epoch seconds", value);
                this.stringBuffer = String(value.getTime() / 1000);
            }
            return;
          }
          if (ns.isBlobSchema() && "byteLength" in value) {
            this.stringBuffer = (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
            return;
          }
          if (ns.isListSchema() && Array.isArray(value)) {
            let buffer = "";
            for (const item of value) {
              this.write([ns.getValueSchema(), ns.getMergedTraits()], item);
              const headerItem = this.flush();
              const serialized = ns.getValueSchema().isTimestampSchema() ? headerItem : serde.quoteHeader(headerItem);
              if (buffer !== "") {
                buffer += ", ";
              }
              buffer += serialized;
            }
            this.stringBuffer = buffer;
            return;
          }
          this.stringBuffer = JSON.stringify(value, null, 2);
          break;
        case "string":
          const mediaType = ns.getMergedTraits().mediaType;
          let intermediateValue = value;
          if (mediaType) {
            const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
            if (isJson) {
              intermediateValue = serde.LazyJsonString.from(intermediateValue);
            }
            if (ns.getMergedTraits().httpHeader) {
              this.stringBuffer = (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(intermediateValue.toString());
              return;
            }
          }
          this.stringBuffer = value;
          break;
        default:
          if (ns.isIdempotencyToken()) {
            this.stringBuffer = serde.generateIdempotencyToken();
          } else {
            this.stringBuffer = String(value);
          }
      }
    }
    flush() {
      const buffer = this.stringBuffer;
      this.stringBuffer = "";
      return buffer;
    }
  }

  class HttpInterceptingShapeSerializer {
    codecSerializer;
    stringSerializer;
    buffer;
    constructor(codecSerializer, codecSettings, stringSerializer = new ToStringShapeSerializer(codecSettings)) {
      this.codecSerializer = codecSerializer;
      this.stringSerializer = stringSerializer;
    }
    setSerdeContext(serdeContext) {
      this.codecSerializer.setSerdeContext(serdeContext);
      this.stringSerializer.setSerdeContext(serdeContext);
    }
    write(schema$1, value) {
      const ns = schema.NormalizedSchema.of(schema$1);
      const traits = ns.getMergedTraits();
      if (traits.httpHeader || traits.httpLabel || traits.httpQuery) {
        this.stringSerializer.write(ns, value);
        this.buffer = this.stringSerializer.flush();
        return;
      }
      return this.codecSerializer.write(ns, value);
    }
    flush() {
      if (this.buffer !== undefined) {
        const buffer = this.buffer;
        this.buffer = undefined;
        return buffer;
      }
      return this.codecSerializer.flush();
    }
  }
  exports.FromStringShapeDeserializer = FromStringShapeDeserializer;
  exports.HttpBindingProtocol = HttpBindingProtocol;
  exports.HttpInterceptingShapeDeserializer = HttpInterceptingShapeDeserializer;
  exports.HttpInterceptingShapeSerializer = HttpInterceptingShapeSerializer;
  exports.HttpProtocol = HttpProtocol;
  exports.RequestBuilder = RequestBuilder;
  exports.RpcProtocol = RpcProtocol;
  exports.SerdeContext = SerdeContext;
  exports.ToStringShapeSerializer = ToStringShapeSerializer;
  exports.collectBody = collectBody;
  exports.determineTimestampFormat = determineTimestampFormat;
  exports.extendedEncodeURIComponent = extendedEncodeURIComponent;
  exports.requestBuilder = requestBuilder;
  exports.resolvedPath = resolvedPath;
});

// node_modules/@smithy/core/dist-cjs/index.js
var require_dist_cjs17 = __commonJS((exports) => {
  var types = require_dist_cjs();
  var utilMiddleware = require_dist_cjs4();
  var middlewareSerde = require_dist_cjs5();
  var protocolHttp = require_dist_cjs2();
  var protocols = require_protocols();
  var getSmithyContext = (context) => context[types.SMITHY_CONTEXT_KEY] || (context[types.SMITHY_CONTEXT_KEY] = {});
  var resolveAuthOptions = (candidateAuthOptions, authSchemePreference) => {
    if (!authSchemePreference || authSchemePreference.length === 0) {
      return candidateAuthOptions;
    }
    const preferredAuthOptions = [];
    for (const preferredSchemeName of authSchemePreference) {
      for (const candidateAuthOption of candidateAuthOptions) {
        const candidateAuthSchemeName = candidateAuthOption.schemeId.split("#")[1];
        if (candidateAuthSchemeName === preferredSchemeName) {
          preferredAuthOptions.push(candidateAuthOption);
        }
      }
    }
    for (const candidateAuthOption of candidateAuthOptions) {
      if (!preferredAuthOptions.find(({ schemeId }) => schemeId === candidateAuthOption.schemeId)) {
        preferredAuthOptions.push(candidateAuthOption);
      }
    }
    return preferredAuthOptions;
  };
  function convertHttpAuthSchemesToMap(httpAuthSchemes) {
    const map = new Map;
    for (const scheme of httpAuthSchemes) {
      map.set(scheme.schemeId, scheme);
    }
    return map;
  }
  var httpAuthSchemeMiddleware = (config, mwOptions) => (next, context) => async (args) => {
    const options = config.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config, context, args.input));
    const authSchemePreference = config.authSchemePreference ? await config.authSchemePreference() : [];
    const resolvedOptions = resolveAuthOptions(options, authSchemePreference);
    const authSchemes = convertHttpAuthSchemesToMap(config.httpAuthSchemes);
    const smithyContext = utilMiddleware.getSmithyContext(context);
    const failureReasons = [];
    for (const option of resolvedOptions) {
      const scheme = authSchemes.get(option.schemeId);
      if (!scheme) {
        failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
        continue;
      }
      const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config));
      if (!identityProvider) {
        failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
        continue;
      }
      const { identityProperties = {}, signingProperties = {} } = option.propertiesExtractor?.(config, context) || {};
      option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
      option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
      smithyContext.selectedHttpAuthScheme = {
        httpAuthOption: option,
        identity: await identityProvider(option.identityProperties),
        signer: scheme.signer
      };
      break;
    }
    if (!smithyContext.selectedHttpAuthScheme) {
      throw new Error(failureReasons.join(`
`));
    }
    return next(args);
  };
  var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: "endpointV2Middleware"
  };
  var getHttpAuthSchemeEndpointRuleSetPlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
        httpAuthSchemeParametersProvider,
        identityProviderConfigProvider
      }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
    }
  });
  var httpAuthSchemeMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: middlewareSerde.serializerMiddlewareOption.name
  };
  var getHttpAuthSchemePlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
        httpAuthSchemeParametersProvider,
        identityProviderConfigProvider
      }), httpAuthSchemeMiddlewareOptions);
    }
  });
  var defaultErrorHandler = (signingProperties) => (error) => {
    throw error;
  };
  var defaultSuccessHandler = (httpResponse, signingProperties) => {};
  var httpSigningMiddleware = (config) => (next, context) => async (args) => {
    if (!protocolHttp.HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    const smithyContext = utilMiddleware.getSmithyContext(context);
    const scheme = smithyContext.selectedHttpAuthScheme;
    if (!scheme) {
      throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
    }
    const { httpAuthOption: { signingProperties = {} }, identity, signer } = scheme;
    const output = await next({
      ...args,
      request: await signer.sign(args.request, identity, signingProperties)
    }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
    (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
    return output;
  };
  var httpSigningMiddlewareOptions = {
    step: "finalizeRequest",
    tags: ["HTTP_SIGNING"],
    name: "httpSigningMiddleware",
    aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
    override: true,
    relation: "after",
    toMiddleware: "retryMiddleware"
  };
  var getHttpSigningPlugin = (config) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(httpSigningMiddleware(), httpSigningMiddlewareOptions);
    }
  });
  var normalizeProvider = (input) => {
    if (typeof input === "function")
      return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
  };
  var makePagedClientRequest = async (CommandCtor, client3, input, withCommand = (_) => _, ...args) => {
    let command = new CommandCtor(input);
    command = withCommand(command) ?? command;
    return await client3.send(command, ...args);
  };
  function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName, pageSizeTokenName) {
    return async function* paginateOperation(config, input, ...additionalArguments) {
      const _input = input;
      let token2 = config.startingToken ?? _input[inputTokenName];
      let hasNext = true;
      let page;
      while (hasNext) {
        _input[inputTokenName] = token2;
        if (pageSizeTokenName) {
          _input[pageSizeTokenName] = _input[pageSizeTokenName] ?? config.pageSize;
        }
        if (config.client instanceof ClientCtor) {
          page = await makePagedClientRequest(CommandCtor, config.client, input, config.withCommand, ...additionalArguments);
        } else {
          throw new Error(`Invalid client, expected instance of ${ClientCtor.name}`);
        }
        yield page;
        const prevToken = token2;
        token2 = get(page, outputTokenName);
        hasNext = !!(token2 && (!config.stopOnSameToken || token2 !== prevToken));
      }
      return;
    };
  }
  var get = (fromObject, path) => {
    let cursor = fromObject;
    const pathComponents = path.split(".");
    for (const step of pathComponents) {
      if (!cursor || typeof cursor !== "object") {
        return;
      }
      cursor = cursor[step];
    }
    return cursor;
  };
  function setFeature(context, feature, value) {
    if (!context.__smithy_context) {
      context.__smithy_context = {
        features: {}
      };
    } else if (!context.__smithy_context.features) {
      context.__smithy_context.features = {};
    }
    context.__smithy_context.features[feature] = value;
  }

  class DefaultIdentityProviderConfig {
    authSchemes = new Map;
    constructor(config) {
      for (const [key, value] of Object.entries(config)) {
        if (value !== undefined) {
          this.authSchemes.set(key, value);
        }
      }
    }
    getIdentityProvider(schemeId) {
      return this.authSchemes.get(schemeId);
    }
  }

  class HttpApiKeyAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
      if (!signingProperties) {
        throw new Error("request could not be signed with `apiKey` since the `name` and `in` signer properties are missing");
      }
      if (!signingProperties.name) {
        throw new Error("request could not be signed with `apiKey` since the `name` signer property is missing");
      }
      if (!signingProperties.in) {
        throw new Error("request could not be signed with `apiKey` since the `in` signer property is missing");
      }
      if (!identity.apiKey) {
        throw new Error("request could not be signed with `apiKey` since the `apiKey` is not defined");
      }
      const clonedRequest = protocolHttp.HttpRequest.clone(httpRequest);
      if (signingProperties.in === types.HttpApiKeyAuthLocation.QUERY) {
        clonedRequest.query[signingProperties.name] = identity.apiKey;
      } else if (signingProperties.in === types.HttpApiKeyAuthLocation.HEADER) {
        clonedRequest.headers[signingProperties.name] = signingProperties.scheme ? `${signingProperties.scheme} ${identity.apiKey}` : identity.apiKey;
      } else {
        throw new Error("request can only be signed with `apiKey` locations `query` or `header`, " + "but found: `" + signingProperties.in + "`");
      }
      return clonedRequest;
    }
  }

  class HttpBearerAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
      const clonedRequest = protocolHttp.HttpRequest.clone(httpRequest);
      if (!identity.token) {
        throw new Error("request could not be signed with `token` since the `token` is not defined");
      }
      clonedRequest.headers["Authorization"] = `Bearer ${identity.token}`;
      return clonedRequest;
    }
  }

  class NoAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
      return httpRequest;
    }
  }
  var createIsIdentityExpiredFunction = (expirationMs) => function isIdentityExpired2(identity) {
    return doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
  };
  var EXPIRATION_MS = 300000;
  var isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
  var doesIdentityRequireRefresh = (identity) => identity.expiration !== undefined;
  var memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {
    if (provider === undefined) {
      return;
    }
    const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async (options) => {
      if (!pending) {
        pending = normalizedProvider(options);
      }
      try {
        resolved = await pending;
        hasResult = true;
        isConstant = false;
      } finally {
        pending = undefined;
      }
      return resolved;
    };
    if (isExpired === undefined) {
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider(options);
        }
        return resolved;
      };
    }
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider(options);
      }
      if (isConstant) {
        return resolved;
      }
      if (!requiresRefresh(resolved)) {
        isConstant = true;
        return resolved;
      }
      if (isExpired(resolved)) {
        await coalesceProvider(options);
        return resolved;
      }
      return resolved;
    };
  };
  exports.requestBuilder = protocols.requestBuilder;
  exports.DefaultIdentityProviderConfig = DefaultIdentityProviderConfig;
  exports.EXPIRATION_MS = EXPIRATION_MS;
  exports.HttpApiKeyAuthSigner = HttpApiKeyAuthSigner;
  exports.HttpBearerAuthSigner = HttpBearerAuthSigner;
  exports.NoAuthSigner = NoAuthSigner;
  exports.createIsIdentityExpiredFunction = createIsIdentityExpiredFunction;
  exports.createPaginator = createPaginator;
  exports.doesIdentityRequireRefresh = doesIdentityRequireRefresh;
  exports.getHttpAuthSchemeEndpointRuleSetPlugin = getHttpAuthSchemeEndpointRuleSetPlugin;
  exports.getHttpAuthSchemePlugin = getHttpAuthSchemePlugin;
  exports.getHttpSigningPlugin = getHttpSigningPlugin;
  exports.getSmithyContext = getSmithyContext;
  exports.httpAuthSchemeEndpointRuleSetMiddlewareOptions = httpAuthSchemeEndpointRuleSetMiddlewareOptions;
  exports.httpAuthSchemeMiddleware = httpAuthSchemeMiddleware;
  exports.httpAuthSchemeMiddlewareOptions = httpAuthSchemeMiddlewareOptions;
  exports.httpSigningMiddleware = httpSigningMiddleware;
  exports.httpSigningMiddlewareOptions = httpSigningMiddlewareOptions;
  exports.isIdentityExpired = isIdentityExpired;
  exports.memoizeIdentityProvider = memoizeIdentityProvider;
  exports.normalizeProvider = normalizeProvider;
  exports.setFeature = setFeature;
});

// node_modules/@smithy/property-provider/dist-cjs/index.js
var require_dist_cjs18 = __commonJS((exports) => {
  class ProviderError extends Error {
    name = "ProviderError";
    tryNextLink;
    constructor(message3, options = true) {
      let logger;
      let tryNextLink = true;
      if (typeof options === "boolean") {
        logger = undefined;
        tryNextLink = options;
      } else if (options != null && typeof options === "object") {
        logger = options.logger;
        tryNextLink = options.tryNextLink ?? true;
      }
      super(message3);
      this.tryNextLink = tryNextLink;
      Object.setPrototypeOf(this, ProviderError.prototype);
      logger?.debug?.(`@smithy/property-provider ${tryNextLink ? "->" : "(!)"} ${message3}`);
    }
    static from(error, options = true) {
      return Object.assign(new this(error.message, options), error);
    }
  }

  class CredentialsProviderError extends ProviderError {
    name = "CredentialsProviderError";
    constructor(message3, options = true) {
      super(message3, options);
      Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
  }

  class TokenProviderError extends ProviderError {
    name = "TokenProviderError";
    constructor(message3, options = true) {
      super(message3, options);
      Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
  }
  var chain = (...providers) => async () => {
    if (providers.length === 0) {
      throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
      try {
        const credentials = await provider();
        return credentials;
      } catch (err) {
        lastProviderError = err;
        if (err?.tryNextLink) {
          continue;
        }
        throw err;
      }
    }
    throw lastProviderError;
  };
  var fromStatic = (staticValue) => () => Promise.resolve(staticValue);
  var memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
      if (!pending) {
        pending = provider();
      }
      try {
        resolved = await pending;
        hasResult = true;
        isConstant = false;
      } finally {
        pending = undefined;
      }
      return resolved;
    };
    if (isExpired === undefined) {
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider();
        }
        return resolved;
      };
    }
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider();
      }
      if (isConstant) {
        return resolved;
      }
      if (requiresRefresh && !requiresRefresh(resolved)) {
        isConstant = true;
        return resolved;
      }
      if (isExpired(resolved)) {
        await coalesceProvider();
        return resolved;
      }
      return resolved;
    };
  };
  exports.CredentialsProviderError = CredentialsProviderError;
  exports.ProviderError = ProviderError;
  exports.TokenProviderError = TokenProviderError;
  exports.chain = chain;
  exports.fromStatic = fromStatic;
  exports.memoize = memoize;
});

// node_modules/@aws-sdk/core/dist-cjs/submodules/client/index.js
var require_client2 = __commonJS((exports) => {
  var state = {
    warningEmitted: false
  };
  var emitWarningIfUnsupportedVersion = (version2) => {
    if (version2 && !state.warningEmitted && parseInt(version2.substring(1, version2.indexOf("."))) < 20) {
      state.warningEmitted = true;
      process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js ${version2} in January 2026.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/c895JFp`);
    }
  };
  function setCredentialFeature(credentials, feature, value) {
    if (!credentials.$source) {
      credentials.$source = {};
    }
    credentials.$source[feature] = value;
    return credentials;
  }
  function setFeature(context, feature, value) {
    if (!context.__aws_sdk_context) {
      context.__aws_sdk_context = {
        features: {}
      };
    } else if (!context.__aws_sdk_context.features) {
      context.__aws_sdk_context.features = {};
    }
    context.__aws_sdk_context.features[feature] = value;
  }
  function setTokenFeature(token2, feature, value) {
    if (!token2.$source) {
      token2.$source = {};
    }
    token2.$source[feature] = value;
    return token2;
  }
  exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;
  exports.setCredentialFeature = setCredentialFeature;
  exports.setFeature = setFeature;
  exports.setTokenFeature = setTokenFeature;
  exports.state = state;
});

// node_modules/@smithy/signature-v4/dist-cjs/index.js
var require_dist_cjs19 = __commonJS((exports) => {
  var utilHexEncoding = require_dist_cjs14();
  var utilUtf8 = require_dist_cjs8();
  var isArrayBuffer = require_dist_cjs6();
  var protocolHttp = require_dist_cjs2();
  var utilMiddleware = require_dist_cjs4();
  var utilUriEscape = require_dist_cjs10();
  var ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
  var CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
  var AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
  var SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
  var EXPIRES_QUERY_PARAM = "X-Amz-Expires";
  var SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
  var TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
  var REGION_SET_PARAM = "X-Amz-Region-Set";
  var AUTH_HEADER = "authorization";
  var AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
  var DATE_HEADER = "date";
  var GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
  var SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
  var SHA256_HEADER = "x-amz-content-sha256";
  var TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
  var HOST_HEADER = "host";
  var ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: true,
    "cache-control": true,
    connection: true,
    expect: true,
    from: true,
    "keep-alive": true,
    "max-forwards": true,
    pragma: true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    "user-agent": true,
    "x-amzn-trace-id": true
  };
  var PROXY_HEADER_PATTERN = /^proxy-/;
  var SEC_HEADER_PATTERN = /^sec-/;
  var UNSIGNABLE_PATTERNS = [/^proxy-/i, /^sec-/i];
  var ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
  var ALGORITHM_IDENTIFIER_V4A = "AWS4-ECDSA-P256-SHA256";
  var EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
  var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
  var MAX_CACHE_SIZE = 50;
  var KEY_TYPE_IDENTIFIER = "aws4_request";
  var MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
  var signingKeyCache = {};
  var cacheQueue = [];
  var createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
  var getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
    const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
    const cacheKey = `${shortDate}:${region}:${service}:${utilHexEncoding.toHex(credsHash)}:${credentials.sessionToken}`;
    if (cacheKey in signingKeyCache) {
      return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while (cacheQueue.length > MAX_CACHE_SIZE) {
      delete signingKeyCache[cacheQueue.shift()];
    }
    let key = `AWS4${credentials.secretAccessKey}`;
    for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
      key = await hmac(sha256Constructor, key, signable);
    }
    return signingKeyCache[cacheKey] = key;
  };
  var clearCredentialCache = () => {
    cacheQueue.length = 0;
    Object.keys(signingKeyCache).forEach((cacheKey) => {
      delete signingKeyCache[cacheKey];
    });
  };
  var hmac = (ctor, secret, data) => {
    const hash = new ctor(secret);
    hash.update(utilUtf8.toUint8Array(data));
    return hash.digest();
  };
  var getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
    const canonical = {};
    for (const headerName of Object.keys(headers).sort()) {
      if (headers[headerName] == undefined) {
        continue;
      }
      const canonicalHeaderName = headerName.toLowerCase();
      if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
        if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
          continue;
        }
      }
      canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
    }
    return canonical;
  };
  var getPayloadHash = async ({ headers, body }, hashConstructor) => {
    for (const headerName of Object.keys(headers)) {
      if (headerName.toLowerCase() === SHA256_HEADER) {
        return headers[headerName];
      }
    }
    if (body == undefined) {
      return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer.isArrayBuffer(body)) {
      const hashCtor = new hashConstructor;
      hashCtor.update(utilUtf8.toUint8Array(body));
      return utilHexEncoding.toHex(await hashCtor.digest());
    }
    return UNSIGNED_PAYLOAD;
  };

  class HeaderFormatter {
    format(headers) {
      const chunks = [];
      for (const headerName of Object.keys(headers)) {
        const bytes = utilUtf8.fromUtf8(headerName);
        chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
      }
      const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
      let position = 0;
      for (const chunk of chunks) {
        out.set(chunk, position);
        position += chunk.byteLength;
      }
      return out;
    }
    formatHeaderValue(header) {
      switch (header.type) {
        case "boolean":
          return Uint8Array.from([header.value ? 0 : 1]);
        case "byte":
          return Uint8Array.from([2, header.value]);
        case "short":
          const shortView = new DataView(new ArrayBuffer(3));
          shortView.setUint8(0, 3);
          shortView.setInt16(1, header.value, false);
          return new Uint8Array(shortView.buffer);
        case "integer":
          const intView = new DataView(new ArrayBuffer(5));
          intView.setUint8(0, 4);
          intView.setInt32(1, header.value, false);
          return new Uint8Array(intView.buffer);
        case "long":
          const longBytes = new Uint8Array(9);
          longBytes[0] = 5;
          longBytes.set(header.value.bytes, 1);
          return longBytes;
        case "binary":
          const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
          binView.setUint8(0, 6);
          binView.setUint16(1, header.value.byteLength, false);
          const binBytes = new Uint8Array(binView.buffer);
          binBytes.set(header.value, 3);
          return binBytes;
        case "string":
          const utf8Bytes = utilUtf8.fromUtf8(header.value);
          const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
          strView.setUint8(0, 7);
          strView.setUint16(1, utf8Bytes.byteLength, false);
          const strBytes = new Uint8Array(strView.buffer);
          strBytes.set(utf8Bytes, 3);
          return strBytes;
        case "timestamp":
          const tsBytes = new Uint8Array(9);
          tsBytes[0] = 8;
          tsBytes.set(Int642.fromNumber(header.value.valueOf()).bytes, 1);
          return tsBytes;
        case "uuid":
          if (!UUID_PATTERN.test(header.value)) {
            throw new Error(`Invalid UUID received: ${header.value}`);
          }
          const uuidBytes = new Uint8Array(17);
          uuidBytes[0] = 9;
          uuidBytes.set(utilHexEncoding.fromHex(header.value.replace(/\-/g, "")), 1);
          return uuidBytes;
      }
    }
  }
  var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

  class Int642 {
    bytes;
    constructor(bytes) {
      this.bytes = bytes;
      if (bytes.byteLength !== 8) {
        throw new Error("Int64 buffers must be exactly 8 bytes");
      }
    }
    static fromNumber(number) {
      if (number > 9223372036854776000 || number < -9223372036854776000) {
        throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
      }
      const bytes = new Uint8Array(8);
      for (let i2 = 7, remaining = Math.abs(Math.round(number));i2 > -1 && remaining > 0; i2--, remaining /= 256) {
        bytes[i2] = remaining;
      }
      if (number < 0) {
        negate(bytes);
      }
      return new Int642(bytes);
    }
    valueOf() {
      const bytes = this.bytes.slice(0);
      const negative = bytes[0] & 128;
      if (negative) {
        negate(bytes);
      }
      return parseInt(utilHexEncoding.toHex(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
      return String(this.valueOf());
    }
  }
  function negate(bytes) {
    for (let i2 = 0;i2 < 8; i2++) {
      bytes[i2] ^= 255;
    }
    for (let i2 = 7;i2 > -1; i2--) {
      bytes[i2]++;
      if (bytes[i2] !== 0)
        break;
    }
  }
  var hasHeader = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
      if (soughtHeader === headerName.toLowerCase()) {
        return true;
      }
    }
    return false;
  };
  var moveHeadersToQuery = (request, options = {}) => {
    const { headers, query = {} } = protocolHttp.HttpRequest.clone(request);
    for (const name of Object.keys(headers)) {
      const lname = name.toLowerCase();
      if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname) || options.hoistableHeaders?.has(lname)) {
        query[name] = headers[name];
        delete headers[name];
      }
    }
    return {
      ...request,
      headers,
      query
    };
  };
  var prepareRequest = (request) => {
    request = protocolHttp.HttpRequest.clone(request);
    for (const headerName of Object.keys(request.headers)) {
      if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
        delete request.headers[headerName];
      }
    }
    return request;
  };
  var getCanonicalQuery = ({ query = {} }) => {
    const keys = [];
    const serialized = {};
    for (const key of Object.keys(query)) {
      if (key.toLowerCase() === SIGNATURE_HEADER) {
        continue;
      }
      const encodedKey = utilUriEscape.escapeUri(key);
      keys.push(encodedKey);
      const value = query[key];
      if (typeof value === "string") {
        serialized[encodedKey] = `${encodedKey}=${utilUriEscape.escapeUri(value)}`;
      } else if (Array.isArray(value)) {
        serialized[encodedKey] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${encodedKey}=${utilUriEscape.escapeUri(value2)}`]), []).sort().join("&");
      }
    }
    return keys.sort().map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
  };
  var iso8601 = (time) => toDate2(time).toISOString().replace(/\.\d{3}Z$/, "Z");
  var toDate2 = (time) => {
    if (typeof time === "number") {
      return new Date(time * 1000);
    }
    if (typeof time === "string") {
      if (Number(time)) {
        return new Date(Number(time) * 1000);
      }
      return new Date(time);
    }
    return time;
  };

  class SignatureV4Base {
    service;
    regionProvider;
    credentialProvider;
    sha256;
    uriEscapePath;
    applyChecksum;
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
      this.service = service;
      this.sha256 = sha256;
      this.uriEscapePath = uriEscapePath;
      this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
      this.regionProvider = utilMiddleware.normalizeProvider(region);
      this.credentialProvider = utilMiddleware.normalizeProvider(credentials);
    }
    createCanonicalRequest(request, canonicalHeaders, payloadHash) {
      const sortedHeaders = Object.keys(canonicalHeaders).sort();
      return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(`
`)}

${sortedHeaders.join(";")}
${payloadHash}`;
    }
    async createStringToSign(longDate, credentialScope, canonicalRequest, algorithmIdentifier) {
      const hash = new this.sha256;
      hash.update(utilUtf8.toUint8Array(canonicalRequest));
      const hashedRequest = await hash.digest();
      return `${algorithmIdentifier}
${longDate}
${credentialScope}
${utilHexEncoding.toHex(hashedRequest)}`;
    }
    getCanonicalPath({ path }) {
      if (this.uriEscapePath) {
        const normalizedPathSegments = [];
        for (const pathSegment of path.split("/")) {
          if (pathSegment?.length === 0)
            continue;
          if (pathSegment === ".")
            continue;
          if (pathSegment === "..") {
            normalizedPathSegments.pop();
          } else {
            normalizedPathSegments.push(pathSegment);
          }
        }
        const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
        const doubleEncoded = utilUriEscape.escapeUri(normalizedPath);
        return doubleEncoded.replace(/%2F/g, "/");
      }
      return path;
    }
    validateResolvedCredentials(credentials) {
      if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
        throw new Error("Resolved credential object is not valid");
      }
    }
    formatDate(now) {
      const longDate = iso8601(now).replace(/[\-:]/g, "");
      return {
        longDate,
        shortDate: longDate.slice(0, 8)
      };
    }
    getCanonicalHeaderList(headers) {
      return Object.keys(headers).sort().join(";");
    }
  }

  class SignatureV4 extends SignatureV4Base {
    headerFormatter = new HeaderFormatter;
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
      super({
        applyChecksum,
        credentials,
        region,
        service,
        sha256,
        uriEscapePath
      });
    }
    async presign(originalRequest, options = {}) {
      const { signingDate = new Date, expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, hoistableHeaders, signingRegion, signingService } = options;
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const { longDate, shortDate } = this.formatDate(signingDate);
      if (expiresIn > MAX_PRESIGNED_TTL) {
        return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
      }
      const scope = createScope(shortDate, region, signingService ?? this.service);
      const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders, hoistableHeaders });
      if (credentials.sessionToken) {
        request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
      }
      request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
      request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
      request.query[AMZ_DATE_QUERY_PARAM] = longDate;
      request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
      const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
      request.query[SIGNED_HEADERS_QUERY_PARAM] = this.getCanonicalHeaderList(canonicalHeaders);
      request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
      return request;
    }
    async sign(toSign, options) {
      if (typeof toSign === "string") {
        return this.signString(toSign, options);
      } else if (toSign.headers && toSign.payload) {
        return this.signEvent(toSign, options);
      } else if (toSign.message) {
        return this.signMessage(toSign, options);
      } else {
        return this.signRequest(toSign, options);
      }
    }
    async signEvent({ headers, payload }, { signingDate = new Date, priorSignature, signingRegion, signingService }) {
      const region = signingRegion ?? await this.regionProvider();
      const { shortDate, longDate } = this.formatDate(signingDate);
      const scope = createScope(shortDate, region, signingService ?? this.service);
      const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
      const hash = new this.sha256;
      hash.update(headers);
      const hashedHeaders = utilHexEncoding.toHex(await hash.digest());
      const stringToSign = [
        EVENT_ALGORITHM_IDENTIFIER,
        longDate,
        scope,
        priorSignature,
        hashedHeaders,
        hashedPayload
      ].join(`
`);
      return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
    }
    async signMessage(signableMessage, { signingDate = new Date, signingRegion, signingService }) {
      const promise = this.signEvent({
        headers: this.headerFormatter.format(signableMessage.message.headers),
        payload: signableMessage.message.body
      }, {
        signingDate,
        signingRegion,
        signingService,
        priorSignature: signableMessage.priorSignature
      });
      return promise.then((signature) => {
        return { message: signableMessage.message, signature };
      });
    }
    async signString(stringToSign, { signingDate = new Date, signingRegion, signingService } = {}) {
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const { shortDate } = this.formatDate(signingDate);
      const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
      hash.update(utilUtf8.toUint8Array(stringToSign));
      return utilHexEncoding.toHex(await hash.digest());
    }
    async signRequest(requestToSign, { signingDate = new Date, signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const request = prepareRequest(requestToSign);
      const { longDate, shortDate } = this.formatDate(signingDate);
      const scope = createScope(shortDate, region, signingService ?? this.service);
      request.headers[AMZ_DATE_HEADER] = longDate;
      if (credentials.sessionToken) {
        request.headers[TOKEN_HEADER] = credentials.sessionToken;
      }
      const payloadHash = await getPayloadHash(request, this.sha256);
      if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
        request.headers[SHA256_HEADER] = payloadHash;
      }
      const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
      const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
      request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} ` + `Credential=${credentials.accessKeyId}/${scope}, ` + `SignedHeaders=${this.getCanonicalHeaderList(canonicalHeaders)}, ` + `Signature=${signature}`;
      return request;
    }
    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
      const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest, ALGORITHM_IDENTIFIER);
      const hash = new this.sha256(await keyPromise);
      hash.update(utilUtf8.toUint8Array(stringToSign));
      return utilHexEncoding.toHex(await hash.digest());
    }
    getSigningKey(credentials, region, shortDate, service) {
      return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
    }
  }
  var signatureV4aContainer = {
    SignatureV4a: null
  };
  exports.ALGORITHM_IDENTIFIER = ALGORITHM_IDENTIFIER;
  exports.ALGORITHM_IDENTIFIER_V4A = ALGORITHM_IDENTIFIER_V4A;
  exports.ALGORITHM_QUERY_PARAM = ALGORITHM_QUERY_PARAM;
  exports.ALWAYS_UNSIGNABLE_HEADERS = ALWAYS_UNSIGNABLE_HEADERS;
  exports.AMZ_DATE_HEADER = AMZ_DATE_HEADER;
  exports.AMZ_DATE_QUERY_PARAM = AMZ_DATE_QUERY_PARAM;
  exports.AUTH_HEADER = AUTH_HEADER;
  exports.CREDENTIAL_QUERY_PARAM = CREDENTIAL_QUERY_PARAM;
  exports.DATE_HEADER = DATE_HEADER;
  exports.EVENT_ALGORITHM_IDENTIFIER = EVENT_ALGORITHM_IDENTIFIER;
  exports.EXPIRES_QUERY_PARAM = EXPIRES_QUERY_PARAM;
  exports.GENERATED_HEADERS = GENERATED_HEADERS;
  exports.HOST_HEADER = HOST_HEADER;
  exports.KEY_TYPE_IDENTIFIER = KEY_TYPE_IDENTIFIER;
  exports.MAX_CACHE_SIZE = MAX_CACHE_SIZE;
  exports.MAX_PRESIGNED_TTL = MAX_PRESIGNED_TTL;
  exports.PROXY_HEADER_PATTERN = PROXY_HEADER_PATTERN;
  exports.REGION_SET_PARAM = REGION_SET_PARAM;
  exports.SEC_HEADER_PATTERN = SEC_HEADER_PATTERN;
  exports.SHA256_HEADER = SHA256_HEADER;
  exports.SIGNATURE_HEADER = SIGNATURE_HEADER;
  exports.SIGNATURE_QUERY_PARAM = SIGNATURE_QUERY_PARAM;
  exports.SIGNED_HEADERS_QUERY_PARAM = SIGNED_HEADERS_QUERY_PARAM;
  exports.SignatureV4 = SignatureV4;
  exports.SignatureV4Base = SignatureV4Base;
  exports.TOKEN_HEADER = TOKEN_HEADER;
  exports.TOKEN_QUERY_PARAM = TOKEN_QUERY_PARAM;
  exports.UNSIGNABLE_PATTERNS = UNSIGNABLE_PATTERNS;
  exports.UNSIGNED_PAYLOAD = UNSIGNED_PAYLOAD;
  exports.clearCredentialCache = clearCredentialCache;
  exports.createScope = createScope;
  exports.getCanonicalHeaders = getCanonicalHeaders;
  exports.getCanonicalQuery = getCanonicalQuery;
  exports.getPayloadHash = getPayloadHash;
  exports.getSigningKey = getSigningKey;
  exports.hasHeader = hasHeader;
  exports.moveHeadersToQuery = moveHeadersToQuery;
  exports.prepareRequest = prepareRequest;
  exports.signatureV4aContainer = signatureV4aContainer;
});

// node_modules/@smithy/util-body-length-browser/dist-cjs/index.js
var require_dist_cjs20 = __commonJS((exports) => {
  var TEXT_ENCODER = typeof TextEncoder == "function" ? new TextEncoder : null;
  var calculateBodyLength = (body) => {
    if (typeof body === "string") {
      if (TEXT_ENCODER) {
        return TEXT_ENCODER.encode(body).byteLength;
      }
      let len = body.length;
      for (let i2 = len - 1;i2 >= 0; i2--) {
        const code = body.charCodeAt(i2);
        if (code > 127 && code <= 2047)
          len++;
        else if (code > 2047 && code <= 65535)
          len += 2;
        if (code >= 56320 && code <= 57343)
          i2--;
      }
      return len;
    } else if (typeof body.byteLength === "number") {
      return body.byteLength;
    } else if (typeof body.size === "number") {
      return body.size;
    }
    throw new Error(`Body Length computation failed for ${body}`);
  };
  exports.calculateBodyLength = calculateBodyLength;
});

// node_modules/@smithy/core/dist-cjs/submodules/cbor/index.js
var require_cbor = __commonJS((exports) => {
  var serde = require_serde();
  var utilUtf8 = require_dist_cjs8();
  var protocols = require_protocols();
  var protocolHttp = require_dist_cjs2();
  var utilBodyLengthBrowser = require_dist_cjs20();
  var schema = require_schema();
  var utilMiddleware = require_dist_cjs4();
  var utilBase64 = require_dist_cjs9();
  var majorUint64 = 0;
  var majorNegativeInt64 = 1;
  var majorUnstructuredByteString = 2;
  var majorUtf8String = 3;
  var majorList = 4;
  var majorMap = 5;
  var majorTag = 6;
  var majorSpecial = 7;
  var specialFalse = 20;
  var specialTrue = 21;
  var specialNull = 22;
  var specialUndefined = 23;
  var extendedOneByte = 24;
  var extendedFloat16 = 25;
  var extendedFloat32 = 26;
  var extendedFloat64 = 27;
  var minorIndefinite = 31;
  function alloc(size) {
    return typeof Buffer !== "undefined" ? Buffer.alloc(size) : new Uint8Array(size);
  }
  var tagSymbol = Symbol("@smithy/core/cbor::tagSymbol");
  function tag2(data2) {
    data2[tagSymbol] = true;
    return data2;
  }
  var USE_TEXT_DECODER = typeof TextDecoder !== "undefined";
  var USE_BUFFER$1 = typeof Buffer !== "undefined";
  var payload = alloc(0);
  var dataView$1 = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
  var textDecoder = USE_TEXT_DECODER ? new TextDecoder : null;
  var _offset = 0;
  function setPayload(bytes) {
    payload = bytes;
    dataView$1 = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
  }
  function decode2(at, to) {
    if (at >= to) {
      throw new Error("unexpected end of (decode) payload.");
    }
    const major = (payload[at] & 224) >> 5;
    const minor = payload[at] & 31;
    switch (major) {
      case majorUint64:
      case majorNegativeInt64:
      case majorTag:
        let unsignedInt;
        let offset2;
        if (minor < 24) {
          unsignedInt = minor;
          offset2 = 1;
        } else {
          switch (minor) {
            case extendedOneByte:
            case extendedFloat16:
            case extendedFloat32:
            case extendedFloat64:
              const countLength = minorValueToArgumentLength[minor];
              const countOffset = countLength + 1;
              offset2 = countOffset;
              if (to - at < countOffset) {
                throw new Error(`countLength ${countLength} greater than remaining buf len.`);
              }
              const countIndex = at + 1;
              if (countLength === 1) {
                unsignedInt = payload[countIndex];
              } else if (countLength === 2) {
                unsignedInt = dataView$1.getUint16(countIndex);
              } else if (countLength === 4) {
                unsignedInt = dataView$1.getUint32(countIndex);
              } else {
                unsignedInt = dataView$1.getBigUint64(countIndex);
              }
              break;
            default:
              throw new Error(`unexpected minor value ${minor}.`);
          }
        }
        if (major === majorUint64) {
          _offset = offset2;
          return castBigInt(unsignedInt);
        } else if (major === majorNegativeInt64) {
          let negativeInt;
          if (typeof unsignedInt === "bigint") {
            negativeInt = BigInt(-1) - unsignedInt;
          } else {
            negativeInt = -1 - unsignedInt;
          }
          _offset = offset2;
          return castBigInt(negativeInt);
        } else {
          if (minor === 2 || minor === 3) {
            const length = decodeCount(at + offset2, to);
            let b = BigInt(0);
            const start = at + offset2 + _offset;
            for (let i2 = start;i2 < start + length; ++i2) {
              b = b << BigInt(8) | BigInt(payload[i2]);
            }
            _offset = offset2 + _offset + length;
            return minor === 3 ? -b - BigInt(1) : b;
          } else if (minor === 4) {
            const decimalFraction = decode2(at + offset2, to);
            const [exponent, mantissa] = decimalFraction;
            const normalizer = mantissa < 0 ? -1 : 1;
            const mantissaStr = "0".repeat(Math.abs(exponent) + 1) + String(BigInt(normalizer) * BigInt(mantissa));
            let numericString;
            const sign = mantissa < 0 ? "-" : "";
            numericString = exponent === 0 ? mantissaStr : mantissaStr.slice(0, mantissaStr.length + exponent) + "." + mantissaStr.slice(exponent);
            numericString = numericString.replace(/^0+/g, "");
            if (numericString === "") {
              numericString = "0";
            }
            if (numericString[0] === ".") {
              numericString = "0" + numericString;
            }
            numericString = sign + numericString;
            _offset = offset2 + _offset;
            return serde.nv(numericString);
          } else {
            const value = decode2(at + offset2, to);
            const valueOffset = _offset;
            _offset = offset2 + valueOffset;
            return tag2({ tag: castBigInt(unsignedInt), value });
          }
        }
      case majorUtf8String:
      case majorMap:
      case majorList:
      case majorUnstructuredByteString:
        if (minor === minorIndefinite) {
          switch (major) {
            case majorUtf8String:
              return decodeUtf8StringIndefinite(at, to);
            case majorMap:
              return decodeMapIndefinite(at, to);
            case majorList:
              return decodeListIndefinite(at, to);
            case majorUnstructuredByteString:
              return decodeUnstructuredByteStringIndefinite(at, to);
          }
        } else {
          switch (major) {
            case majorUtf8String:
              return decodeUtf8String(at, to);
            case majorMap:
              return decodeMap(at, to);
            case majorList:
              return decodeList(at, to);
            case majorUnstructuredByteString:
              return decodeUnstructuredByteString(at, to);
          }
        }
      default:
        return decodeSpecial(at, to);
    }
  }
  function bytesToUtf8(bytes, at, to) {
    if (USE_BUFFER$1 && bytes.constructor?.name === "Buffer") {
      return bytes.toString("utf-8", at, to);
    }
    if (textDecoder) {
      return textDecoder.decode(bytes.subarray(at, to));
    }
    return utilUtf8.toUtf8(bytes.subarray(at, to));
  }
  function demote(bigInteger) {
    const num = Number(bigInteger);
    if (num < Number.MIN_SAFE_INTEGER || Number.MAX_SAFE_INTEGER < num) {
      console.warn(new Error(`@smithy/core/cbor - truncating BigInt(${bigInteger}) to ${num} with loss of precision.`));
    }
    return num;
  }
  var minorValueToArgumentLength = {
    [extendedOneByte]: 1,
    [extendedFloat16]: 2,
    [extendedFloat32]: 4,
    [extendedFloat64]: 8
  };
  function bytesToFloat16(a, b) {
    const sign = a >> 7;
    const exponent = (a & 124) >> 2;
    const fraction = (a & 3) << 8 | b;
    const scalar = sign === 0 ? 1 : -1;
    let exponentComponent;
    let summation;
    if (exponent === 0) {
      if (fraction === 0) {
        return 0;
      } else {
        exponentComponent = Math.pow(2, 1 - 15);
        summation = 0;
      }
    } else if (exponent === 31) {
      if (fraction === 0) {
        return scalar * Infinity;
      } else {
        return NaN;
      }
    } else {
      exponentComponent = Math.pow(2, exponent - 15);
      summation = 1;
    }
    summation += fraction / 1024;
    return scalar * (exponentComponent * summation);
  }
  function decodeCount(at, to) {
    const minor = payload[at] & 31;
    if (minor < 24) {
      _offset = 1;
      return minor;
    }
    if (minor === extendedOneByte || minor === extendedFloat16 || minor === extendedFloat32 || minor === extendedFloat64) {
      const countLength = minorValueToArgumentLength[minor];
      _offset = countLength + 1;
      if (to - at < _offset) {
        throw new Error(`countLength ${countLength} greater than remaining buf len.`);
      }
      const countIndex = at + 1;
      if (countLength === 1) {
        return payload[countIndex];
      } else if (countLength === 2) {
        return dataView$1.getUint16(countIndex);
      } else if (countLength === 4) {
        return dataView$1.getUint32(countIndex);
      }
      return demote(dataView$1.getBigUint64(countIndex));
    }
    throw new Error(`unexpected minor value ${minor}.`);
  }
  function decodeUtf8String(at, to) {
    const length = decodeCount(at, to);
    const offset2 = _offset;
    at += offset2;
    if (to - at < length) {
      throw new Error(`string len ${length} greater than remaining buf len.`);
    }
    const value = bytesToUtf8(payload, at, at + length);
    _offset = offset2 + length;
    return value;
  }
  function decodeUtf8StringIndefinite(at, to) {
    at += 1;
    const vector = [];
    for (const base = at;at < to; ) {
      if (payload[at] === 255) {
        const data2 = alloc(vector.length);
        data2.set(vector, 0);
        _offset = at - base + 2;
        return bytesToUtf8(data2, 0, data2.length);
      }
      const major = (payload[at] & 224) >> 5;
      const minor = payload[at] & 31;
      if (major !== majorUtf8String) {
        throw new Error(`unexpected major type ${major} in indefinite string.`);
      }
      if (minor === minorIndefinite) {
        throw new Error("nested indefinite string.");
      }
      const bytes = decodeUnstructuredByteString(at, to);
      const length = _offset;
      at += length;
      for (let i2 = 0;i2 < bytes.length; ++i2) {
        vector.push(bytes[i2]);
      }
    }
    throw new Error("expected break marker.");
  }
  function decodeUnstructuredByteString(at, to) {
    const length = decodeCount(at, to);
    const offset2 = _offset;
    at += offset2;
    if (to - at < length) {
      throw new Error(`unstructured byte string len ${length} greater than remaining buf len.`);
    }
    const value = payload.subarray(at, at + length);
    _offset = offset2 + length;
    return value;
  }
  function decodeUnstructuredByteStringIndefinite(at, to) {
    at += 1;
    const vector = [];
    for (const base = at;at < to; ) {
      if (payload[at] === 255) {
        const data2 = alloc(vector.length);
        data2.set(vector, 0);
        _offset = at - base + 2;
        return data2;
      }
      const major = (payload[at] & 224) >> 5;
      const minor = payload[at] & 31;
      if (major !== majorUnstructuredByteString) {
        throw new Error(`unexpected major type ${major} in indefinite string.`);
      }
      if (minor === minorIndefinite) {
        throw new Error("nested indefinite string.");
      }
      const bytes = decodeUnstructuredByteString(at, to);
      const length = _offset;
      at += length;
      for (let i2 = 0;i2 < bytes.length; ++i2) {
        vector.push(bytes[i2]);
      }
    }
    throw new Error("expected break marker.");
  }
  function decodeList(at, to) {
    const listDataLength = decodeCount(at, to);
    const offset2 = _offset;
    at += offset2;
    const base = at;
    const list = Array(listDataLength);
    for (let i2 = 0;i2 < listDataLength; ++i2) {
      const item = decode2(at, to);
      const itemOffset = _offset;
      list[i2] = item;
      at += itemOffset;
    }
    _offset = offset2 + (at - base);
    return list;
  }
  function decodeListIndefinite(at, to) {
    at += 1;
    const list = [];
    for (const base = at;at < to; ) {
      if (payload[at] === 255) {
        _offset = at - base + 2;
        return list;
      }
      const item = decode2(at, to);
      const n = _offset;
      at += n;
      list.push(item);
    }
    throw new Error("expected break marker.");
  }
  function decodeMap(at, to) {
    const mapDataLength = decodeCount(at, to);
    const offset2 = _offset;
    at += offset2;
    const base = at;
    const map = {};
    for (let i2 = 0;i2 < mapDataLength; ++i2) {
      if (at >= to) {
        throw new Error("unexpected end of map payload.");
      }
      const major = (payload[at] & 224) >> 5;
      if (major !== majorUtf8String) {
        throw new Error(`unexpected major type ${major} for map key at index ${at}.`);
      }
      const key = decode2(at, to);
      at += _offset;
      const value = decode2(at, to);
      at += _offset;
      map[key] = value;
    }
    _offset = offset2 + (at - base);
    return map;
  }
  function decodeMapIndefinite(at, to) {
    at += 1;
    const base = at;
    const map = {};
    for (;at < to; ) {
      if (at >= to) {
        throw new Error("unexpected end of map payload.");
      }
      if (payload[at] === 255) {
        _offset = at - base + 2;
        return map;
      }
      const major = (payload[at] & 224) >> 5;
      if (major !== majorUtf8String) {
        throw new Error(`unexpected major type ${major} for map key.`);
      }
      const key = decode2(at, to);
      at += _offset;
      const value = decode2(at, to);
      at += _offset;
      map[key] = value;
    }
    throw new Error("expected break marker.");
  }
  function decodeSpecial(at, to) {
    const minor = payload[at] & 31;
    switch (minor) {
      case specialTrue:
      case specialFalse:
        _offset = 1;
        return minor === specialTrue;
      case specialNull:
        _offset = 1;
        return null;
      case specialUndefined:
        _offset = 1;
        return null;
      case extendedFloat16:
        if (to - at < 3) {
          throw new Error("incomplete float16 at end of buf.");
        }
        _offset = 3;
        return bytesToFloat16(payload[at + 1], payload[at + 2]);
      case extendedFloat32:
        if (to - at < 5) {
          throw new Error("incomplete float32 at end of buf.");
        }
        _offset = 5;
        return dataView$1.getFloat32(at + 1);
      case extendedFloat64:
        if (to - at < 9) {
          throw new Error("incomplete float64 at end of buf.");
        }
        _offset = 9;
        return dataView$1.getFloat64(at + 1);
      default:
        throw new Error(`unexpected minor value ${minor}.`);
    }
  }
  function castBigInt(bigInt) {
    if (typeof bigInt === "number") {
      return bigInt;
    }
    const num = Number(bigInt);
    if (Number.MIN_SAFE_INTEGER <= num && num <= Number.MAX_SAFE_INTEGER) {
      return num;
    }
    return bigInt;
  }
  var USE_BUFFER = typeof Buffer !== "undefined";
  var initialSize = 2048;
  var data = alloc(initialSize);
  var dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
  var cursor = 0;
  function ensureSpace(bytes) {
    const remaining = data.byteLength - cursor;
    if (remaining < bytes) {
      if (cursor < 16000000) {
        resize(Math.max(data.byteLength * 4, data.byteLength + bytes));
      } else {
        resize(data.byteLength + bytes + 16000000);
      }
    }
  }
  function toUint8Array() {
    const out = alloc(cursor);
    out.set(data.subarray(0, cursor), 0);
    cursor = 0;
    return out;
  }
  function resize(size) {
    const old = data;
    data = alloc(size);
    if (old) {
      if (old.copy) {
        old.copy(data, 0, 0, old.byteLength);
      } else {
        data.set(old, 0);
      }
    }
    dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  function encodeHeader(major, value) {
    if (value < 24) {
      data[cursor++] = major << 5 | value;
    } else if (value < 1 << 8) {
      data[cursor++] = major << 5 | 24;
      data[cursor++] = value;
    } else if (value < 1 << 16) {
      data[cursor++] = major << 5 | extendedFloat16;
      dataView.setUint16(cursor, value);
      cursor += 2;
    } else if (value < 2 ** 32) {
      data[cursor++] = major << 5 | extendedFloat32;
      dataView.setUint32(cursor, value);
      cursor += 4;
    } else {
      data[cursor++] = major << 5 | extendedFloat64;
      dataView.setBigUint64(cursor, typeof value === "bigint" ? value : BigInt(value));
      cursor += 8;
    }
  }
  function encode2(_input) {
    const encodeStack = [_input];
    while (encodeStack.length) {
      const input = encodeStack.pop();
      ensureSpace(typeof input === "string" ? input.length * 4 : 64);
      if (typeof input === "string") {
        if (USE_BUFFER) {
          encodeHeader(majorUtf8String, Buffer.byteLength(input));
          cursor += data.write(input, cursor);
        } else {
          const bytes = utilUtf8.fromUtf8(input);
          encodeHeader(majorUtf8String, bytes.byteLength);
          data.set(bytes, cursor);
          cursor += bytes.byteLength;
        }
        continue;
      } else if (typeof input === "number") {
        if (Number.isInteger(input)) {
          const nonNegative = input >= 0;
          const major = nonNegative ? majorUint64 : majorNegativeInt64;
          const value = nonNegative ? input : -input - 1;
          if (value < 24) {
            data[cursor++] = major << 5 | value;
          } else if (value < 256) {
            data[cursor++] = major << 5 | 24;
            data[cursor++] = value;
          } else if (value < 65536) {
            data[cursor++] = major << 5 | extendedFloat16;
            data[cursor++] = value >> 8;
            data[cursor++] = value;
          } else if (value < 4294967296) {
            data[cursor++] = major << 5 | extendedFloat32;
            dataView.setUint32(cursor, value);
            cursor += 4;
          } else {
            data[cursor++] = major << 5 | extendedFloat64;
            dataView.setBigUint64(cursor, BigInt(value));
            cursor += 8;
          }
          continue;
        }
        data[cursor++] = majorSpecial << 5 | extendedFloat64;
        dataView.setFloat64(cursor, input);
        cursor += 8;
        continue;
      } else if (typeof input === "bigint") {
        const nonNegative = input >= 0;
        const major = nonNegative ? majorUint64 : majorNegativeInt64;
        const value = nonNegative ? input : -input - BigInt(1);
        const n = Number(value);
        if (n < 24) {
          data[cursor++] = major << 5 | n;
        } else if (n < 256) {
          data[cursor++] = major << 5 | 24;
          data[cursor++] = n;
        } else if (n < 65536) {
          data[cursor++] = major << 5 | extendedFloat16;
          data[cursor++] = n >> 8;
          data[cursor++] = n & 255;
        } else if (n < 4294967296) {
          data[cursor++] = major << 5 | extendedFloat32;
          dataView.setUint32(cursor, n);
          cursor += 4;
        } else if (value < BigInt("18446744073709551616")) {
          data[cursor++] = major << 5 | extendedFloat64;
          dataView.setBigUint64(cursor, value);
          cursor += 8;
        } else {
          const binaryBigInt = value.toString(2);
          const bigIntBytes = new Uint8Array(Math.ceil(binaryBigInt.length / 8));
          let b = value;
          let i2 = 0;
          while (bigIntBytes.byteLength - ++i2 >= 0) {
            bigIntBytes[bigIntBytes.byteLength - i2] = Number(b & BigInt(255));
            b >>= BigInt(8);
          }
          ensureSpace(bigIntBytes.byteLength * 2);
          data[cursor++] = nonNegative ? 194 : 195;
          if (USE_BUFFER) {
            encodeHeader(majorUnstructuredByteString, Buffer.byteLength(bigIntBytes));
          } else {
            encodeHeader(majorUnstructuredByteString, bigIntBytes.byteLength);
          }
          data.set(bigIntBytes, cursor);
          cursor += bigIntBytes.byteLength;
        }
        continue;
      } else if (input === null) {
        data[cursor++] = majorSpecial << 5 | specialNull;
        continue;
      } else if (typeof input === "boolean") {
        data[cursor++] = majorSpecial << 5 | (input ? specialTrue : specialFalse);
        continue;
      } else if (typeof input === "undefined") {
        throw new Error("@smithy/core/cbor: client may not serialize undefined value.");
      } else if (Array.isArray(input)) {
        for (let i2 = input.length - 1;i2 >= 0; --i2) {
          encodeStack.push(input[i2]);
        }
        encodeHeader(majorList, input.length);
        continue;
      } else if (typeof input.byteLength === "number") {
        ensureSpace(input.length * 2);
        encodeHeader(majorUnstructuredByteString, input.length);
        data.set(input, cursor);
        cursor += input.byteLength;
        continue;
      } else if (typeof input === "object") {
        if (input instanceof serde.NumericValue) {
          const decimalIndex = input.string.indexOf(".");
          const exponent = decimalIndex === -1 ? 0 : decimalIndex - input.string.length + 1;
          const mantissa = BigInt(input.string.replace(".", ""));
          data[cursor++] = 196;
          encodeStack.push(mantissa);
          encodeStack.push(exponent);
          encodeHeader(majorList, 2);
          continue;
        }
        if (input[tagSymbol]) {
          if ("tag" in input && "value" in input) {
            encodeStack.push(input.value);
            encodeHeader(majorTag, input.tag);
            continue;
          } else {
            throw new Error("tag encountered with missing fields, need 'tag' and 'value', found: " + JSON.stringify(input));
          }
        }
        const keys = Object.keys(input);
        for (let i2 = keys.length - 1;i2 >= 0; --i2) {
          const key = keys[i2];
          encodeStack.push(input[key]);
          encodeStack.push(key);
        }
        encodeHeader(majorMap, keys.length);
        continue;
      }
      throw new Error(`data type ${input?.constructor?.name ?? typeof input} not compatible for encoding.`);
    }
  }
  var cbor = {
    deserialize(payload2) {
      setPayload(payload2);
      return decode2(0, payload2.length);
    },
    serialize(input) {
      try {
        encode2(input);
        return toUint8Array();
      } catch (e) {
        toUint8Array();
        throw e;
      }
    },
    resizeEncodingBuffer(size) {
      resize(size);
    }
  };
  var parseCborBody = (streamBody, context) => {
    return protocols.collectBody(streamBody, context).then(async (bytes) => {
      if (bytes.length) {
        try {
          return cbor.deserialize(bytes);
        } catch (e) {
          Object.defineProperty(e, "$responseBodyText", {
            value: context.utf8Encoder(bytes)
          });
          throw e;
        }
      }
      return {};
    });
  };
  var dateToTag = (date) => {
    return tag2({
      tag: 1,
      value: date.getTime() / 1000
    });
  };
  var parseCborErrorBody = async (errorBody, context) => {
    const value = await parseCborBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
  };
  var loadSmithyRpcV2CborErrorCode = (output, data2) => {
    const sanitizeErrorCode = (rawValue) => {
      let cleanValue = rawValue;
      if (typeof cleanValue === "number") {
        cleanValue = cleanValue.toString();
      }
      if (cleanValue.indexOf(",") >= 0) {
        cleanValue = cleanValue.split(",")[0];
      }
      if (cleanValue.indexOf(":") >= 0) {
        cleanValue = cleanValue.split(":")[0];
      }
      if (cleanValue.indexOf("#") >= 0) {
        cleanValue = cleanValue.split("#")[1];
      }
      return cleanValue;
    };
    if (data2["__type"] !== undefined) {
      return sanitizeErrorCode(data2["__type"]);
    }
    const codeKey = Object.keys(data2).find((key) => key.toLowerCase() === "code");
    if (codeKey && data2[codeKey] !== undefined) {
      return sanitizeErrorCode(data2[codeKey]);
    }
  };
  var checkCborResponse = (response) => {
    if (String(response.headers["smithy-protocol"]).toLowerCase() !== "rpc-v2-cbor") {
      throw new Error("Malformed RPCv2 CBOR response, status: " + response.statusCode);
    }
  };
  var buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
      protocol,
      hostname,
      port,
      method: "POST",
      path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
      headers: {
        ...headers
      }
    };
    if (resolvedHostname !== undefined) {
      contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
      contents.body = body;
      try {
        contents.headers["content-length"] = String(utilBodyLengthBrowser.calculateBodyLength(body));
      } catch (e) {}
    }
    return new protocolHttp.HttpRequest(contents);
  };

  class CborCodec extends protocols.SerdeContext {
    createSerializer() {
      const serializer = new CborShapeSerializer;
      serializer.setSerdeContext(this.serdeContext);
      return serializer;
    }
    createDeserializer() {
      const deserializer = new CborShapeDeserializer;
      deserializer.setSerdeContext(this.serdeContext);
      return deserializer;
    }
  }

  class CborShapeSerializer extends protocols.SerdeContext {
    value;
    write(schema2, value) {
      this.value = this.serialize(schema2, value);
    }
    serialize(schema$1, source) {
      const ns = schema.NormalizedSchema.of(schema$1);
      if (source == null) {
        if (ns.isIdempotencyToken()) {
          return serde.generateIdempotencyToken();
        }
        return source;
      }
      if (ns.isBlobSchema()) {
        if (typeof source === "string") {
          return (this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(source);
        }
        return source;
      }
      if (ns.isTimestampSchema()) {
        if (typeof source === "number" || typeof source === "bigint") {
          return dateToTag(new Date(Number(source) / 1000 | 0));
        }
        return dateToTag(source);
      }
      if (typeof source === "function" || typeof source === "object") {
        const sourceObject = source;
        if (ns.isListSchema() && Array.isArray(sourceObject)) {
          const sparse = !!ns.getMergedTraits().sparse;
          const newArray = [];
          let i2 = 0;
          for (const item of sourceObject) {
            const value = this.serialize(ns.getValueSchema(), item);
            if (value != null || sparse) {
              newArray[i2++] = value;
            }
          }
          return newArray;
        }
        if (sourceObject instanceof Date) {
          return dateToTag(sourceObject);
        }
        const newObject = {};
        if (ns.isMapSchema()) {
          const sparse = !!ns.getMergedTraits().sparse;
          for (const key of Object.keys(sourceObject)) {
            const value = this.serialize(ns.getValueSchema(), sourceObject[key]);
            if (value != null || sparse) {
              newObject[key] = value;
            }
          }
        } else if (ns.isStructSchema()) {
          for (const [key, memberSchema] of ns.structIterator()) {
            const value = this.serialize(memberSchema, sourceObject[key]);
            if (value != null) {
              newObject[key] = value;
            }
          }
          const isUnion = ns.isUnionSchema();
          if (isUnion && Array.isArray(sourceObject.$unknown)) {
            const [k, v] = sourceObject.$unknown;
            newObject[k] = v;
          } else if (typeof sourceObject.__type === "string") {
            for (const [k, v] of Object.entries(sourceObject)) {
              if (!(k in newObject)) {
                newObject[k] = this.serialize(15, v);
              }
            }
          }
        } else if (ns.isDocumentSchema()) {
          for (const key of Object.keys(sourceObject)) {
            newObject[key] = this.serialize(ns.getValueSchema(), sourceObject[key]);
          }
        } else if (ns.isBigDecimalSchema()) {
          return sourceObject;
        }
        return newObject;
      }
      return source;
    }
    flush() {
      const buffer = cbor.serialize(this.value);
      this.value = undefined;
      return buffer;
    }
  }

  class CborShapeDeserializer extends protocols.SerdeContext {
    read(schema2, bytes) {
      const data2 = cbor.deserialize(bytes);
      return this.readValue(schema2, data2);
    }
    readValue(_schema, value) {
      const ns = schema.NormalizedSchema.of(_schema);
      if (ns.isTimestampSchema()) {
        if (typeof value === "number") {
          return serde._parseEpochTimestamp(value);
        }
        if (typeof value === "object") {
          if (value.tag === 1 && "value" in value) {
            return serde._parseEpochTimestamp(value.value);
          }
        }
      }
      if (ns.isBlobSchema()) {
        if (typeof value === "string") {
          return (this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(value);
        }
        return value;
      }
      if (typeof value === "undefined" || typeof value === "boolean" || typeof value === "number" || typeof value === "string" || typeof value === "bigint" || typeof value === "symbol") {
        return value;
      } else if (typeof value === "object") {
        if (value === null) {
          return null;
        }
        if ("byteLength" in value) {
          return value;
        }
        if (value instanceof Date) {
          return value;
        }
        if (ns.isDocumentSchema()) {
          return value;
        }
        if (ns.isListSchema()) {
          const newArray = [];
          const memberSchema = ns.getValueSchema();
          const sparse = !!ns.getMergedTraits().sparse;
          for (const item of value) {
            const itemValue = this.readValue(memberSchema, item);
            if (itemValue != null || sparse) {
              newArray.push(itemValue);
            }
          }
          return newArray;
        }
        const newObject = {};
        if (ns.isMapSchema()) {
          const sparse = !!ns.getMergedTraits().sparse;
          const targetSchema = ns.getValueSchema();
          for (const key of Object.keys(value)) {
            const itemValue = this.readValue(targetSchema, value[key]);
            if (itemValue != null || sparse) {
              newObject[key] = itemValue;
            }
          }
        } else if (ns.isStructSchema()) {
          const isUnion = ns.isUnionSchema();
          let keys;
          if (isUnion) {
            keys = new Set(Object.keys(value).filter((k) => k !== "__type"));
          }
          for (const [key, memberSchema] of ns.structIterator()) {
            if (isUnion) {
              keys.delete(key);
            }
            if (value[key] != null) {
              newObject[key] = this.readValue(memberSchema, value[key]);
            }
          }
          if (isUnion && keys?.size === 1 && Object.keys(newObject).length === 0) {
            const k = keys.values().next().value;
            newObject.$unknown = [k, value[k]];
          } else if (typeof value.__type === "string") {
            for (const [k, v] of Object.entries(value)) {
              if (!(k in newObject)) {
                newObject[k] = v;
              }
            }
          }
        } else if (value instanceof serde.NumericValue) {
          return value;
        }
        return newObject;
      } else {
        return value;
      }
    }
  }

  class SmithyRpcV2CborProtocol extends protocols.RpcProtocol {
    codec = new CborCodec;
    serializer = this.codec.createSerializer();
    deserializer = this.codec.createDeserializer();
    constructor({ defaultNamespace, errorTypeRegistries }) {
      super({ defaultNamespace, errorTypeRegistries });
    }
    getShapeId() {
      return "smithy.protocols#rpcv2Cbor";
    }
    getPayloadCodec() {
      return this.codec;
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      Object.assign(request.headers, {
        "content-type": this.getDefaultContentType(),
        "smithy-protocol": "rpc-v2-cbor",
        accept: this.getDefaultContentType()
      });
      if (schema.deref(operationSchema.input) === "unit") {
        delete request.body;
        delete request.headers["content-type"];
      } else {
        if (!request.body) {
          this.serializer.write(15, {});
          request.body = this.serializer.flush();
        }
        try {
          request.headers["content-length"] = String(request.body.byteLength);
        } catch (e) {}
      }
      const { service, operation } = utilMiddleware.getSmithyContext(context);
      const path = `/service/${service}/operation/${operation}`;
      if (request.path.endsWith("/")) {
        request.path += path.slice(1);
      } else {
        request.path += path;
      }
      return request;
    }
    async deserializeResponse(operationSchema, context, response) {
      return super.deserializeResponse(operationSchema, context, response);
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      const errorName = loadSmithyRpcV2CborErrorCode(response, dataObject) ?? "Unknown";
      const errorMetadata = {
        $metadata: metadata,
        $fault: response.statusCode <= 500 ? "client" : "server"
      };
      let namespace = this.options.defaultNamespace;
      if (errorName.includes("#")) {
        [namespace] = errorName.split("#");
      }
      const registry = this.compositeErrorRegistry;
      const nsRegistry = schema.TypeRegistry.for(namespace);
      registry.copyFrom(nsRegistry);
      let errorSchema;
      try {
        errorSchema = registry.getSchema(errorName);
      } catch (e) {
        if (dataObject.Message) {
          dataObject.message = dataObject.Message;
        }
        const syntheticRegistry = schema.TypeRegistry.for("smithy.ts.sdk.synthetic." + namespace);
        registry.copyFrom(syntheticRegistry);
        const baseExceptionSchema = registry.getBaseException();
        if (baseExceptionSchema) {
          const ErrorCtor2 = registry.getErrorCtor(baseExceptionSchema);
          throw Object.assign(new ErrorCtor2({ name: errorName }), errorMetadata, dataObject);
        }
        throw Object.assign(new Error(errorName), errorMetadata, dataObject);
      }
      const ns = schema.NormalizedSchema.of(errorSchema);
      const ErrorCtor = registry.getErrorCtor(errorSchema);
      const message3 = dataObject.message ?? dataObject.Message ?? "Unknown";
      const exception = new ErrorCtor(message3);
      const output = {};
      for (const [name, member] of ns.structIterator()) {
        output[name] = this.deserializer.readValue(member, dataObject[name]);
      }
      throw Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message: message3
      }, output);
    }
    getDefaultContentType() {
      return "application/cbor";
    }
  }
  exports.CborCodec = CborCodec;
  exports.CborShapeDeserializer = CborShapeDeserializer;
  exports.CborShapeSerializer = CborShapeSerializer;
  exports.SmithyRpcV2CborProtocol = SmithyRpcV2CborProtocol;
  exports.buildHttpRpcRequest = buildHttpRpcRequest;
  exports.cbor = cbor;
  exports.checkCborResponse = checkCborResponse;
  exports.dateToTag = dateToTag;
  exports.loadSmithyRpcV2CborErrorCode = loadSmithyRpcV2CborErrorCode;
  exports.parseCborBody = parseCborBody;
  exports.parseCborErrorBody = parseCborErrorBody;
  exports.tag = tag2;
  exports.tagSymbol = tagSymbol;
});

// node_modules/@smithy/middleware-stack/dist-cjs/index.js
var require_dist_cjs21 = __commonJS((exports) => {
  var getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
      _aliases.push(name);
    }
    if (aliases) {
      for (const alias of aliases) {
        _aliases.push(alias);
      }
    }
    return _aliases;
  };
  var getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
  };
  var constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set;
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] || priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        const aliases = getAllAliases(entry.name, entry.aliases);
        if (aliases.includes(toRemove)) {
          isRemoved = true;
          for (const alias of aliases) {
            entriesNameSet.delete(alias);
          }
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    };
    const removeByReference = (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        if (entry.middleware === toRemove) {
          isRemoved = true;
          for (const alias of getAllAliases(entry.name, entry.aliases)) {
            entriesNameSet.delete(alias);
          }
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    };
    const cloneTo = (toStack) => {
      absoluteEntries.forEach((entry) => {
        toStack.add(entry.middleware, { ...entry });
      });
      relativeEntries.forEach((entry) => {
        toStack.addRelativeTo(entry.middleware, { ...entry });
      });
      toStack.identifyOnResolve?.(stack.identifyOnResolve());
      return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
      const expandedMiddlewareList = [];
      from.before.forEach((entry) => {
        if (entry.before.length === 0 && entry.after.length === 0) {
          expandedMiddlewareList.push(entry);
        } else {
          expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
        }
      });
      expandedMiddlewareList.push(from);
      from.after.reverse().forEach((entry) => {
        if (entry.before.length === 0 && entry.after.length === 0) {
          expandedMiddlewareList.push(entry);
        } else {
          expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
        }
      });
      return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug3 = false) => {
      const normalizedAbsoluteEntries = [];
      const normalizedRelativeEntries = [];
      const normalizedEntriesNameMap = {};
      absoluteEntries.forEach((entry) => {
        const normalizedEntry = {
          ...entry,
          before: [],
          after: []
        };
        for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
          normalizedEntriesNameMap[alias] = normalizedEntry;
        }
        normalizedAbsoluteEntries.push(normalizedEntry);
      });
      relativeEntries.forEach((entry) => {
        const normalizedEntry = {
          ...entry,
          before: [],
          after: []
        };
        for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
          normalizedEntriesNameMap[alias] = normalizedEntry;
        }
        normalizedRelativeEntries.push(normalizedEntry);
      });
      normalizedRelativeEntries.forEach((entry) => {
        if (entry.toMiddleware) {
          const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
          if (toMiddleware === undefined) {
            if (debug3) {
              return;
            }
            throw new Error(`${entry.toMiddleware} is not found when adding ` + `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` + `middleware ${entry.relation} ${entry.toMiddleware}`);
          }
          if (entry.relation === "after") {
            toMiddleware.after.push(entry);
          }
          if (entry.relation === "before") {
            toMiddleware.before.push(entry);
          }
        }
      });
      const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
        wholeList.push(...expandedMiddlewareList);
        return wholeList;
      }, []);
      return mainChain;
    };
    const stack = {
      add: (middleware, options = {}) => {
        const { name, override, aliases: _aliases } = options;
        const entry = {
          step: "initialize",
          priority: "normal",
          middleware,
          ...options
        };
        const aliases = getAllAliases(name, _aliases);
        if (aliases.length > 0) {
          if (aliases.some((alias) => entriesNameSet.has(alias))) {
            if (!override)
              throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
            for (const alias of aliases) {
              const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a) => a === alias));
              if (toOverrideIndex === -1) {
                continue;
              }
              const toOverride = absoluteEntries[toOverrideIndex];
              if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` + `${toOverride.priority} priority in ${toOverride.step} step cannot ` + `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` + `${entry.priority} priority in ${entry.step} step.`);
              }
              absoluteEntries.splice(toOverrideIndex, 1);
            }
          }
          for (const alias of aliases) {
            entriesNameSet.add(alias);
          }
        }
        absoluteEntries.push(entry);
      },
      addRelativeTo: (middleware, options) => {
        const { name, override, aliases: _aliases } = options;
        const entry = {
          middleware,
          ...options
        };
        const aliases = getAllAliases(name, _aliases);
        if (aliases.length > 0) {
          if (aliases.some((alias) => entriesNameSet.has(alias))) {
            if (!override)
              throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
            for (const alias of aliases) {
              const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a) => a === alias));
              if (toOverrideIndex === -1) {
                continue;
              }
              const toOverride = relativeEntries[toOverrideIndex];
              if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` + `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` + `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` + `"${entry.toMiddleware}" middleware.`);
              }
              relativeEntries.splice(toOverrideIndex, 1);
            }
          }
          for (const alias of aliases) {
            entriesNameSet.add(alias);
          }
        }
        relativeEntries.push(entry);
      },
      clone: () => cloneTo(constructStack()),
      use: (plugin) => {
        plugin.applyToStack(stack);
      },
      remove: (toRemove) => {
        if (typeof toRemove === "string")
          return removeByName(toRemove);
        else
          return removeByReference(toRemove);
      },
      removeByTag: (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
          const { tags, name, aliases: _aliases } = entry;
          if (tags && tags.includes(toRemove)) {
            const aliases = getAllAliases(name, _aliases);
            for (const alias of aliases) {
              entriesNameSet.delete(alias);
            }
            isRemoved = true;
            return false;
          }
          return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      },
      concat: (from) => {
        const cloned = cloneTo(constructStack());
        cloned.use(from);
        cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
        return cloned;
      },
      applyToStack: cloneTo,
      identify: () => {
        return getMiddlewareList(true).map((mw) => {
          const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
          return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
        });
      },
      identifyOnResolve(toggle) {
        if (typeof toggle === "boolean")
          identifyOnResolve = toggle;
        return identifyOnResolve;
      },
      resolve: (handler, context) => {
        for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
          handler = middleware(handler, context);
        }
        if (identifyOnResolve) {
          console.log(stack.identify());
        }
        return handler;
      }
    };
    return stack;
  };
  var stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1
  };
  var priorityWeights = {
    high: 3,
    normal: 2,
    low: 1
  };
  exports.constructStack = constructStack;
});

// node_modules/@smithy/smithy-client/dist-cjs/index.js
var require_dist_cjs22 = __commonJS((exports) => {
  var middlewareStack = require_dist_cjs21();
  var protocols = require_protocols();
  var types = require_dist_cjs();
  var schema = require_schema();
  var serde = require_serde();

  class Client2 {
    config;
    middlewareStack = middlewareStack.constructStack();
    initConfig;
    handlers;
    constructor(config) {
      this.config = config;
      const { protocol, protocolSettings } = config;
      if (protocolSettings) {
        if (typeof protocol === "function") {
          config.protocol = new protocol(protocolSettings);
        }
      }
    }
    send(command, optionsOrCb, cb) {
      const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
      const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
      const useHandlerCache = options === undefined && this.config.cacheMiddleware === true;
      let handler;
      if (useHandlerCache) {
        if (!this.handlers) {
          this.handlers = new WeakMap;
        }
        const handlers = this.handlers;
        if (handlers.has(command.constructor)) {
          handler = handlers.get(command.constructor);
        } else {
          handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
          handlers.set(command.constructor, handler);
        }
      } else {
        delete this.handlers;
        handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
      }
      if (callback) {
        handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {});
      } else {
        return handler(command).then((result) => result.output);
      }
    }
    destroy() {
      this.config?.requestHandler?.destroy?.();
      delete this.handlers;
    }
  }
  var SENSITIVE_STRING$1 = "***SensitiveInformation***";
  function schemaLogFilter(schema$1, data) {
    if (data == null) {
      return data;
    }
    const ns = schema.NormalizedSchema.of(schema$1);
    if (ns.getMergedTraits().sensitive) {
      return SENSITIVE_STRING$1;
    }
    if (ns.isListSchema()) {
      const isSensitive = !!ns.getValueSchema().getMergedTraits().sensitive;
      if (isSensitive) {
        return SENSITIVE_STRING$1;
      }
    } else if (ns.isMapSchema()) {
      const isSensitive = !!ns.getKeySchema().getMergedTraits().sensitive || !!ns.getValueSchema().getMergedTraits().sensitive;
      if (isSensitive) {
        return SENSITIVE_STRING$1;
      }
    } else if (ns.isStructSchema() && typeof data === "object") {
      const object = data;
      const newObject = {};
      for (const [member, memberNs] of ns.structIterator()) {
        if (object[member] != null) {
          newObject[member] = schemaLogFilter(memberNs, object[member]);
        }
      }
      return newObject;
    }
    return data;
  }

  class Command {
    middlewareStack = middlewareStack.constructStack();
    schema;
    static classBuilder() {
      return new ClassBuilder;
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor }) {
      for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
        this.middlewareStack.use(mw);
      }
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog,
        outputFilterSensitiveLog,
        [types.SMITHY_CONTEXT_KEY]: {
          commandInstance: this,
          ...smithyContext
        },
        ...additionalContext
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
  }

  class ClassBuilder {
    _init = () => {};
    _ep = {};
    _middlewareFn = () => [];
    _commandName = "";
    _clientName = "";
    _additionalContext = {};
    _smithyContext = {};
    _inputFilterSensitiveLog = undefined;
    _outputFilterSensitiveLog = undefined;
    _serializer = null;
    _deserializer = null;
    _operationSchema;
    init(cb) {
      this._init = cb;
    }
    ep(endpointParameterInstructions) {
      this._ep = endpointParameterInstructions;
      return this;
    }
    m(middlewareSupplier) {
      this._middlewareFn = middlewareSupplier;
      return this;
    }
    s(service, operation, smithyContext = {}) {
      this._smithyContext = {
        service,
        operation,
        ...smithyContext
      };
      return this;
    }
    c(additionalContext = {}) {
      this._additionalContext = additionalContext;
      return this;
    }
    n(clientName, commandName) {
      this._clientName = clientName;
      this._commandName = commandName;
      return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
      this._inputFilterSensitiveLog = inputFilter;
      this._outputFilterSensitiveLog = outputFilter;
      return this;
    }
    ser(serializer) {
      this._serializer = serializer;
      return this;
    }
    de(deserializer) {
      this._deserializer = deserializer;
      return this;
    }
    sc(operation) {
      this._operationSchema = operation;
      this._smithyContext.operationSchema = operation;
      return this;
    }
    build() {
      const closure = this;
      let CommandRef;
      return CommandRef = class extends Command {
        input;
        static getEndpointParameterInstructions() {
          return closure._ep;
        }
        constructor(...[input]) {
          super();
          this.input = input ?? {};
          closure._init(this);
          this.schema = closure._operationSchema;
        }
        resolveMiddleware(stack, configuration, options) {
          const op = closure._operationSchema;
          const input = op?.[4] ?? op?.input;
          const output = op?.[5] ?? op?.output;
          return this.resolveMiddlewareWithContext(stack, configuration, options, {
            CommandCtor: CommandRef,
            middlewareFn: closure._middlewareFn,
            clientName: closure._clientName,
            commandName: closure._commandName,
            inputFilterSensitiveLog: closure._inputFilterSensitiveLog ?? (op ? schemaLogFilter.bind(null, input) : (_) => _),
            outputFilterSensitiveLog: closure._outputFilterSensitiveLog ?? (op ? schemaLogFilter.bind(null, output) : (_) => _),
            smithyContext: closure._smithyContext,
            additionalContext: closure._additionalContext
          });
        }
        serialize = closure._serializer;
        deserialize = closure._deserializer;
      };
    }
  }
  var SENSITIVE_STRING = "***SensitiveInformation***";
  var createAggregatedClient = (commands, Client3, options) => {
    for (const [command, CommandCtor] of Object.entries(commands)) {
      const methodImpl = async function(args, optionsOrCb, cb) {
        const command2 = new CommandCtor(args);
        if (typeof optionsOrCb === "function") {
          this.send(command2, optionsOrCb);
        } else if (typeof cb === "function") {
          if (typeof optionsOrCb !== "object")
            throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
          this.send(command2, optionsOrCb || {}, cb);
        } else {
          return this.send(command2, optionsOrCb);
        }
      };
      const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
      Client3.prototype[methodName] = methodImpl;
    }
    const { paginators = {}, waiters = {} } = options ?? {};
    for (const [paginatorName, paginatorFn] of Object.entries(paginators)) {
      if (Client3.prototype[paginatorName] === undefined) {
        Client3.prototype[paginatorName] = function(commandInput = {}, paginationConfiguration, ...rest) {
          return paginatorFn({
            ...paginationConfiguration,
            client: this
          }, commandInput, ...rest);
        };
      }
    }
    for (const [waiterName, waiterFn] of Object.entries(waiters)) {
      if (Client3.prototype[waiterName] === undefined) {
        Client3.prototype[waiterName] = async function(commandInput = {}, waiterConfiguration, ...rest) {
          let config = waiterConfiguration;
          if (typeof waiterConfiguration === "number") {
            config = {
              maxWaitTime: waiterConfiguration
            };
          }
          return waiterFn({
            ...config,
            client: this
          }, commandInput, ...rest);
        };
      }
    }
  };

  class ServiceException extends Error {
    $fault;
    $response;
    $retryable;
    $metadata;
    constructor(options) {
      super(options.message);
      Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype);
      this.name = options.name;
      this.$fault = options.$fault;
      this.$metadata = options.$metadata;
    }
    static isInstance(value) {
      if (!value)
        return false;
      const candidate = value;
      return ServiceException.prototype.isPrototypeOf(candidate) || Boolean(candidate.$fault) && Boolean(candidate.$metadata) && (candidate.$fault === "client" || candidate.$fault === "server");
    }
    static [Symbol.hasInstance](instance) {
      if (!instance)
        return false;
      const candidate = instance;
      if (this === ServiceException) {
        return ServiceException.isInstance(instance);
      }
      if (ServiceException.isInstance(instance)) {
        if (candidate.name && this.name) {
          return this.prototype.isPrototypeOf(instance) || candidate.name === this.name;
        }
        return this.prototype.isPrototypeOf(instance);
      }
      return false;
    }
  }
  var decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions).filter(([, v]) => v !== undefined).forEach(([k, v]) => {
      if (exception[k] == undefined || exception[k] === "") {
        exception[k] = v;
      }
    });
    const message3 = exception.message || exception.Message || "UnknownError";
    exception.message = message3;
    delete exception.Message;
    return exception;
  };
  var throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
      name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
      $fault: "client",
      $metadata
    });
    throw decorateServiceException(response, parsedBody);
  };
  var withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
      throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
  };
  var deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  });
  var loadConfigsForDefaultMode = (mode) => {
    switch (mode) {
      case "standard":
        return {
          retryMode: "standard",
          connectionTimeout: 3100
        };
      case "in-region":
        return {
          retryMode: "standard",
          connectionTimeout: 1100
        };
      case "cross-region":
        return {
          retryMode: "standard",
          connectionTimeout: 3100
        };
      case "mobile":
        return {
          retryMode: "standard",
          connectionTimeout: 30000
        };
      default:
        return {};
    }
  };
  var warningEmitted = false;
  var emitWarningIfUnsupportedVersion = (version2) => {
    if (version2 && !warningEmitted && parseInt(version2.substring(1, version2.indexOf("."))) < 16) {
      warningEmitted = true;
    }
  };
  var knownAlgorithms = Object.values(types.AlgorithmId);
  var getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in types.AlgorithmId) {
      const algorithmId = types.AlgorithmId[id];
      if (runtimeConfig[algorithmId] === undefined) {
        continue;
      }
      checksumAlgorithms.push({
        algorithmId: () => algorithmId,
        checksumConstructor: () => runtimeConfig[algorithmId]
      });
    }
    for (const [id, ChecksumCtor] of Object.entries(runtimeConfig.checksumAlgorithms ?? {})) {
      checksumAlgorithms.push({
        algorithmId: () => id,
        checksumConstructor: () => ChecksumCtor
      });
    }
    return {
      addChecksumAlgorithm(algo) {
        runtimeConfig.checksumAlgorithms = runtimeConfig.checksumAlgorithms ?? {};
        const id = algo.algorithmId();
        const ctor = algo.checksumConstructor();
        if (knownAlgorithms.includes(id)) {
          runtimeConfig.checksumAlgorithms[id.toUpperCase()] = ctor;
        } else {
          runtimeConfig.checksumAlgorithms[id] = ctor;
        }
        checksumAlgorithms.push(algo);
      },
      checksumAlgorithms() {
        return checksumAlgorithms;
      }
    };
  };
  var resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
      const id = checksumAlgorithm.algorithmId();
      if (knownAlgorithms.includes(id)) {
        runtimeConfig[id] = checksumAlgorithm.checksumConstructor();
      }
    });
    return runtimeConfig;
  };
  var getRetryConfiguration = (runtimeConfig) => {
    return {
      setRetryStrategy(retryStrategy) {
        runtimeConfig.retryStrategy = retryStrategy;
      },
      retryStrategy() {
        return runtimeConfig.retryStrategy;
      }
    };
  };
  var resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
  };
  var getDefaultExtensionConfiguration = (runtimeConfig) => {
    return Object.assign(getChecksumConfiguration(runtimeConfig), getRetryConfiguration(runtimeConfig));
  };
  var getDefaultClientConfiguration = getDefaultExtensionConfiguration;
  var resolveDefaultRuntimeConfig = (config) => {
    return Object.assign(resolveChecksumRuntimeConfig(config), resolveRetryRuntimeConfig(config));
  };
  var getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];
  var getValueFromTextNode = (obj) => {
    const textNodeName = "#text";
    for (const key in obj) {
      if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {
        obj[key] = obj[key][textNodeName];
      } else if (typeof obj[key] === "object" && obj[key] !== null) {
        obj[key] = getValueFromTextNode(obj[key]);
      }
    }
    return obj;
  };
  var isSerializableHeaderValue = (value) => {
    return value != null;
  };

  class NoOpLogger {
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
  }
  function map(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
      target = {};
      instructions = arg0;
    } else {
      target = arg0;
      if (typeof arg1 === "function") {
        filter = arg1;
        instructions = arg2;
        return mapWithFilter(target, filter, instructions);
      } else {
        instructions = arg1;
      }
    }
    for (const key of Object.keys(instructions)) {
      if (!Array.isArray(instructions[key])) {
        target[key] = instructions[key];
        continue;
      }
      applyInstruction(target, null, instructions, key);
    }
    return target;
  }
  var convertMap = (target) => {
    const output = {};
    for (const [k, v] of Object.entries(target || {})) {
      output[k] = [, v];
    }
    return output;
  };
  var take = (source, instructions) => {
    const out = {};
    for (const key in instructions) {
      applyInstruction(out, source, instructions, key);
    }
    return out;
  };
  var mapWithFilter = (target, filter, instructions) => {
    return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
      if (Array.isArray(value)) {
        _instructions[key] = value;
      } else {
        if (typeof value === "function") {
          _instructions[key] = [filter, value()];
        } else {
          _instructions[key] = [filter, value];
        }
      }
      return _instructions;
    }, {}));
  };
  var applyInstruction = (target, source, instructions, targetKey) => {
    if (source !== null) {
      let instruction = instructions[targetKey];
      if (typeof instruction === "function") {
        instruction = [, instruction];
      }
      const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
      if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
        target[targetKey] = valueFn(source[sourceKey]);
      }
      return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
      let _value;
      const defaultFilterPassed = filter === undefined && (_value = value()) != null;
      const customFilterPassed = typeof filter === "function" && !!filter(undefined) || typeof filter !== "function" && !!filter;
      if (defaultFilterPassed) {
        target[targetKey] = _value;
      } else if (customFilterPassed) {
        target[targetKey] = value();
      }
    } else {
      const defaultFilterPassed = filter === undefined && value != null;
      const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
      if (defaultFilterPassed || customFilterPassed) {
        target[targetKey] = value;
      }
    }
  };
  var nonNullish = (_) => _ != null;
  var pass = (_) => _;
  var serializeFloat = (value) => {
    if (value !== value) {
      return "NaN";
    }
    switch (value) {
      case Infinity:
        return "Infinity";
      case -Infinity:
        return "-Infinity";
      default:
        return value;
    }
  };
  var serializeDateTime = (date) => date.toISOString().replace(".000Z", "Z");
  var _json = (obj) => {
    if (obj == null) {
      return {};
    }
    if (Array.isArray(obj)) {
      return obj.filter((_) => _ != null).map(_json);
    }
    if (typeof obj === "object") {
      const target = {};
      for (const key of Object.keys(obj)) {
        if (obj[key] == null) {
          continue;
        }
        target[key] = _json(obj[key]);
      }
      return target;
    }
    return obj;
  };
  exports.collectBody = protocols.collectBody;
  exports.extendedEncodeURIComponent = protocols.extendedEncodeURIComponent;
  exports.resolvedPath = protocols.resolvedPath;
  exports.Client = Client2;
  exports.Command = Command;
  exports.NoOpLogger = NoOpLogger;
  exports.SENSITIVE_STRING = SENSITIVE_STRING;
  exports.ServiceException = ServiceException;
  exports._json = _json;
  exports.convertMap = convertMap;
  exports.createAggregatedClient = createAggregatedClient;
  exports.decorateServiceException = decorateServiceException;
  exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;
  exports.getArrayIfSingleItem = getArrayIfSingleItem;
  exports.getDefaultClientConfiguration = getDefaultClientConfiguration;
  exports.getDefaultExtensionConfiguration = getDefaultExtensionConfiguration;
  exports.getValueFromTextNode = getValueFromTextNode;
  exports.isSerializableHeaderValue = isSerializableHeaderValue;
  exports.loadConfigsForDefaultMode = loadConfigsForDefaultMode;
  exports.map = map;
  exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig;
  exports.serializeDateTime = serializeDateTime;
  exports.serializeFloat = serializeFloat;
  exports.take = take;
  exports.throwDefaultError = throwDefaultError;
  exports.withBaseException = withBaseException;
  Object.prototype.hasOwnProperty.call(serde, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: serde["__proto__"]
  });
  Object.keys(serde).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = serde[k];
  });
});

// node_modules/fast-xml-parser/lib/fxp.cjs
var require_fxp = __commonJS((exports, module) => {
  (() => {
    var t = { d: (e2, n2) => {
      for (var i3 in n2)
        t.o(n2, i3) && !t.o(e2, i3) && Object.defineProperty(e2, i3, { enumerable: true, get: n2[i3] });
    }, o: (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r: (t2) => {
      typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
    } }, e = {};
    t.r(e), t.d(e, { XMLBuilder: () => dt, XMLParser: () => it, XMLValidator: () => gt });
    const n = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", i2 = new RegExp("^[" + n + "][" + n + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
    function s(t2, e2) {
      const n2 = [];
      let i3 = e2.exec(t2);
      for (;i3; ) {
        const s2 = [];
        s2.startIndex = e2.lastIndex - i3[0].length;
        const r2 = i3.length;
        for (let t3 = 0;t3 < r2; t3++)
          s2.push(i3[t3]);
        n2.push(s2), i3 = e2.exec(t2);
      }
      return n2;
    }
    const r = function(t2) {
      return !(i2.exec(t2) == null);
    }, o = { allowBooleanAttributes: false, unpairedTags: [] };
    function a(t2, e2) {
      e2 = Object.assign({}, o, e2);
      const n2 = [];
      let i3 = false, s2 = false;
      t2[0] === "\uFEFF" && (t2 = t2.substr(1));
      for (let o2 = 0;o2 < t2.length; o2++)
        if (t2[o2] === "<" && t2[o2 + 1] === "?") {
          if (o2 += 2, o2 = u(t2, o2), o2.err)
            return o2;
        } else {
          if (t2[o2] !== "<") {
            if (l(t2[o2]))
              continue;
            return m("InvalidChar", "char '" + t2[o2] + "' is not expected.", b(t2, o2));
          }
          {
            let a2 = o2;
            if (o2++, t2[o2] === "!") {
              o2 = h(t2, o2);
              continue;
            }
            {
              let d2 = false;
              t2[o2] === "/" && (d2 = true, o2++);
              let p2 = "";
              for (;o2 < t2.length && t2[o2] !== ">" && t2[o2] !== " " && t2[o2] !== "\t" && t2[o2] !== `
` && t2[o2] !== "\r"; o2++)
                p2 += t2[o2];
              if (p2 = p2.trim(), p2[p2.length - 1] === "/" && (p2 = p2.substring(0, p2.length - 1), o2--), !r(p2)) {
                let e3;
                return e3 = p2.trim().length === 0 ? "Invalid space after '<'." : "Tag '" + p2 + "' is an invalid name.", m("InvalidTag", e3, b(t2, o2));
              }
              const c2 = f(t2, o2);
              if (c2 === false)
                return m("InvalidAttr", "Attributes for '" + p2 + "' have open quote.", b(t2, o2));
              let E2 = c2.value;
              if (o2 = c2.index, E2[E2.length - 1] === "/") {
                const n3 = o2 - E2.length;
                E2 = E2.substring(0, E2.length - 1);
                const s3 = g(E2, e2);
                if (s3 !== true)
                  return m(s3.err.code, s3.err.msg, b(t2, n3 + s3.err.line));
                i3 = true;
              } else if (d2) {
                if (!c2.tagClosed)
                  return m("InvalidTag", "Closing tag '" + p2 + "' doesn't have proper closing.", b(t2, o2));
                if (E2.trim().length > 0)
                  return m("InvalidTag", "Closing tag '" + p2 + "' can't have attributes or invalid starting.", b(t2, a2));
                if (n2.length === 0)
                  return m("InvalidTag", "Closing tag '" + p2 + "' has not been opened.", b(t2, a2));
                {
                  const e3 = n2.pop();
                  if (p2 !== e3.tagName) {
                    let n3 = b(t2, e3.tagStartPos);
                    return m("InvalidTag", "Expected closing tag '" + e3.tagName + "' (opened in line " + n3.line + ", col " + n3.col + ") instead of closing tag '" + p2 + "'.", b(t2, a2));
                  }
                  n2.length == 0 && (s2 = true);
                }
              } else {
                const r2 = g(E2, e2);
                if (r2 !== true)
                  return m(r2.err.code, r2.err.msg, b(t2, o2 - E2.length + r2.err.line));
                if (s2 === true)
                  return m("InvalidXml", "Multiple possible root nodes found.", b(t2, o2));
                e2.unpairedTags.indexOf(p2) !== -1 || n2.push({ tagName: p2, tagStartPos: a2 }), i3 = true;
              }
              for (o2++;o2 < t2.length; o2++)
                if (t2[o2] === "<") {
                  if (t2[o2 + 1] === "!") {
                    o2++, o2 = h(t2, o2);
                    continue;
                  }
                  if (t2[o2 + 1] !== "?")
                    break;
                  if (o2 = u(t2, ++o2), o2.err)
                    return o2;
                } else if (t2[o2] === "&") {
                  const e3 = x(t2, o2);
                  if (e3 == -1)
                    return m("InvalidChar", "char '&' is not expected.", b(t2, o2));
                  o2 = e3;
                } else if (s2 === true && !l(t2[o2]))
                  return m("InvalidXml", "Extra text at the end", b(t2, o2));
              t2[o2] === "<" && o2--;
            }
          }
        }
      return i3 ? n2.length == 1 ? m("InvalidTag", "Unclosed tag '" + n2[0].tagName + "'.", b(t2, n2[0].tagStartPos)) : !(n2.length > 0) || m("InvalidXml", "Invalid '" + JSON.stringify(n2.map((t3) => t3.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 }) : m("InvalidXml", "Start tag expected.", 1);
    }
    function l(t2) {
      return t2 === " " || t2 === "\t" || t2 === `
` || t2 === "\r";
    }
    function u(t2, e2) {
      const n2 = e2;
      for (;e2 < t2.length; e2++)
        if (t2[e2] != "?" && t2[e2] != " ")
          ;
        else {
          const i3 = t2.substr(n2, e2 - n2);
          if (e2 > 5 && i3 === "xml")
            return m("InvalidXml", "XML declaration allowed only at the start of the document.", b(t2, e2));
          if (t2[e2] == "?" && t2[e2 + 1] == ">") {
            e2++;
            break;
          }
        }
      return e2;
    }
    function h(t2, e2) {
      if (t2.length > e2 + 5 && t2[e2 + 1] === "-" && t2[e2 + 2] === "-") {
        for (e2 += 3;e2 < t2.length; e2++)
          if (t2[e2] === "-" && t2[e2 + 1] === "-" && t2[e2 + 2] === ">") {
            e2 += 2;
            break;
          }
      } else if (t2.length > e2 + 8 && t2[e2 + 1] === "D" && t2[e2 + 2] === "O" && t2[e2 + 3] === "C" && t2[e2 + 4] === "T" && t2[e2 + 5] === "Y" && t2[e2 + 6] === "P" && t2[e2 + 7] === "E") {
        let n2 = 1;
        for (e2 += 8;e2 < t2.length; e2++)
          if (t2[e2] === "<")
            n2++;
          else if (t2[e2] === ">" && (n2--, n2 === 0))
            break;
      } else if (t2.length > e2 + 9 && t2[e2 + 1] === "[" && t2[e2 + 2] === "C" && t2[e2 + 3] === "D" && t2[e2 + 4] === "A" && t2[e2 + 5] === "T" && t2[e2 + 6] === "A" && t2[e2 + 7] === "[") {
        for (e2 += 8;e2 < t2.length; e2++)
          if (t2[e2] === "]" && t2[e2 + 1] === "]" && t2[e2 + 2] === ">") {
            e2 += 2;
            break;
          }
      }
      return e2;
    }
    const d = '"', p = "'";
    function f(t2, e2) {
      let n2 = "", i3 = "", s2 = false;
      for (;e2 < t2.length; e2++) {
        if (t2[e2] === d || t2[e2] === p)
          i3 === "" ? i3 = t2[e2] : i3 !== t2[e2] || (i3 = "");
        else if (t2[e2] === ">" && i3 === "") {
          s2 = true;
          break;
        }
        n2 += t2[e2];
      }
      return i3 === "" && { value: n2, index: e2, tagClosed: s2 };
    }
    const c = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function g(t2, e2) {
      const n2 = s(t2, c), i3 = {};
      for (let t3 = 0;t3 < n2.length; t3++) {
        if (n2[t3][1].length === 0)
          return m("InvalidAttr", "Attribute '" + n2[t3][2] + "' has no space in starting.", N(n2[t3]));
        if (n2[t3][3] !== undefined && n2[t3][4] === undefined)
          return m("InvalidAttr", "Attribute '" + n2[t3][2] + "' is without value.", N(n2[t3]));
        if (n2[t3][3] === undefined && !e2.allowBooleanAttributes)
          return m("InvalidAttr", "boolean attribute '" + n2[t3][2] + "' is not allowed.", N(n2[t3]));
        const s2 = n2[t3][2];
        if (!E(s2))
          return m("InvalidAttr", "Attribute '" + s2 + "' is an invalid name.", N(n2[t3]));
        if (i3.hasOwnProperty(s2))
          return m("InvalidAttr", "Attribute '" + s2 + "' is repeated.", N(n2[t3]));
        i3[s2] = 1;
      }
      return true;
    }
    function x(t2, e2) {
      if (t2[++e2] === ";")
        return -1;
      if (t2[e2] === "#")
        return function(t3, e3) {
          let n3 = /\d/;
          for (t3[e3] === "x" && (e3++, n3 = /[\da-fA-F]/);e3 < t3.length; e3++) {
            if (t3[e3] === ";")
              return e3;
            if (!t3[e3].match(n3))
              break;
          }
          return -1;
        }(t2, ++e2);
      let n2 = 0;
      for (;e2 < t2.length; e2++, n2++)
        if (!(t2[e2].match(/\w/) && n2 < 20)) {
          if (t2[e2] === ";")
            break;
          return -1;
        }
      return e2;
    }
    function m(t2, e2, n2) {
      return { err: { code: t2, msg: e2, line: n2.line || n2, col: n2.col } };
    }
    function E(t2) {
      return r(t2);
    }
    function b(t2, e2) {
      const n2 = t2.substring(0, e2).split(/\r?\n/);
      return { line: n2.length, col: n2[n2.length - 1].length + 1 };
    }
    function N(t2) {
      return t2.startIndex + t2[1].length;
    }
    const y = { preserveOrder: false, attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, removeNSPrefix: false, allowBooleanAttributes: false, parseTagValue: true, parseAttributeValue: false, trimValues: true, cdataPropName: false, numberParseOptions: { hex: true, leadingZeros: true, eNotation: true }, tagValueProcessor: function(t2, e2) {
      return e2;
    }, attributeValueProcessor: function(t2, e2) {
      return e2;
    }, stopNodes: [], alwaysCreateTextNode: false, isArray: () => false, commentPropName: false, unpairedTags: [], processEntities: true, htmlEntities: false, ignoreDeclaration: false, ignorePiTags: false, transformTagName: false, transformAttributeName: false, updateTag: function(t2, e2, n2) {
      return t2;
    }, captureMetaData: false };
    function T(t2) {
      return typeof t2 == "boolean" ? { enabled: t2, maxEntitySize: 1e4, maxExpansionDepth: 10, maxTotalExpansions: 1000, maxExpandedLength: 1e5, allowedTags: null, tagFilter: null } : typeof t2 == "object" && t2 !== null ? { enabled: t2.enabled !== false, maxEntitySize: t2.maxEntitySize ?? 1e4, maxExpansionDepth: t2.maxExpansionDepth ?? 10, maxTotalExpansions: t2.maxTotalExpansions ?? 1000, maxExpandedLength: t2.maxExpandedLength ?? 1e5, allowedTags: t2.allowedTags ?? null, tagFilter: t2.tagFilter ?? null } : T(true);
    }
    const w = function(t2) {
      const e2 = Object.assign({}, y, t2);
      return e2.processEntities = T(e2.processEntities), e2;
    };
    let v;
    v = typeof Symbol != "function" ? "@@xmlMetadata" : Symbol("XML Node Metadata");

    class I {
      constructor(t2) {
        this.tagname = t2, this.child = [], this[":@"] = {};
      }
      add(t2, e2) {
        t2 === "__proto__" && (t2 = "#__proto__"), this.child.push({ [t2]: e2 });
      }
      addChild(t2, e2) {
        t2.tagname === "__proto__" && (t2.tagname = "#__proto__"), t2[":@"] && Object.keys(t2[":@"]).length > 0 ? this.child.push({ [t2.tagname]: t2.child, ":@": t2[":@"] }) : this.child.push({ [t2.tagname]: t2.child }), e2 !== undefined && (this.child[this.child.length - 1][v] = { startIndex: e2 });
      }
      static getMetaDataSymbol() {
        return v;
      }
    }

    class O {
      constructor(t2) {
        this.suppressValidationErr = !t2, this.options = t2;
      }
      readDocType(t2, e2) {
        const n2 = {};
        if (t2[e2 + 3] !== "O" || t2[e2 + 4] !== "C" || t2[e2 + 5] !== "T" || t2[e2 + 6] !== "Y" || t2[e2 + 7] !== "P" || t2[e2 + 8] !== "E")
          throw new Error("Invalid Tag instead of DOCTYPE");
        {
          e2 += 9;
          let i3 = 1, s2 = false, r2 = false, o2 = "";
          for (;e2 < t2.length; e2++)
            if (t2[e2] !== "<" || r2)
              if (t2[e2] === ">") {
                if (r2 ? t2[e2 - 1] === "-" && t2[e2 - 2] === "-" && (r2 = false, i3--) : i3--, i3 === 0)
                  break;
              } else
                t2[e2] === "[" ? s2 = true : o2 += t2[e2];
            else {
              if (s2 && A(t2, "!ENTITY", e2)) {
                let i4, s3;
                if (e2 += 7, [i4, s3, e2] = this.readEntityExp(t2, e2 + 1, this.suppressValidationErr), s3.indexOf("&") === -1) {
                  const t3 = i4.replace(/[.\-+*:]/g, "\\.");
                  n2[i4] = { regx: RegExp(`&${t3};`, "g"), val: s3 };
                }
              } else if (s2 && A(t2, "!ELEMENT", e2)) {
                e2 += 8;
                const { index: n3 } = this.readElementExp(t2, e2 + 1);
                e2 = n3;
              } else if (s2 && A(t2, "!ATTLIST", e2))
                e2 += 8;
              else if (s2 && A(t2, "!NOTATION", e2)) {
                e2 += 9;
                const { index: n3 } = this.readNotationExp(t2, e2 + 1, this.suppressValidationErr);
                e2 = n3;
              } else {
                if (!A(t2, "!--", e2))
                  throw new Error("Invalid DOCTYPE");
                r2 = true;
              }
              i3++, o2 = "";
            }
          if (i3 !== 0)
            throw new Error("Unclosed DOCTYPE");
        }
        return { entities: n2, i: e2 };
      }
      readEntityExp(t2, e2) {
        e2 = P(t2, e2);
        let n2 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]) && t2[e2] !== '"' && t2[e2] !== "'"; )
          n2 += t2[e2], e2++;
        if (S(n2), e2 = P(t2, e2), !this.suppressValidationErr) {
          if (t2.substring(e2, e2 + 6).toUpperCase() === "SYSTEM")
            throw new Error("External entities are not supported");
          if (t2[e2] === "%")
            throw new Error("Parameter entities are not supported");
        }
        let i3 = "";
        if ([e2, i3] = this.readIdentifierVal(t2, e2, "entity"), this.options.enabled !== false && this.options.maxEntitySize && i3.length > this.options.maxEntitySize)
          throw new Error(`Entity "${n2}" size (${i3.length}) exceeds maximum allowed size (${this.options.maxEntitySize})`);
        return [n2, i3, --e2];
      }
      readNotationExp(t2, e2) {
        e2 = P(t2, e2);
        let n2 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]); )
          n2 += t2[e2], e2++;
        !this.suppressValidationErr && S(n2), e2 = P(t2, e2);
        const i3 = t2.substring(e2, e2 + 6).toUpperCase();
        if (!this.suppressValidationErr && i3 !== "SYSTEM" && i3 !== "PUBLIC")
          throw new Error(`Expected SYSTEM or PUBLIC, found "${i3}"`);
        e2 += i3.length, e2 = P(t2, e2);
        let s2 = null, r2 = null;
        if (i3 === "PUBLIC")
          [e2, s2] = this.readIdentifierVal(t2, e2, "publicIdentifier"), t2[e2 = P(t2, e2)] !== '"' && t2[e2] !== "'" || ([e2, r2] = this.readIdentifierVal(t2, e2, "systemIdentifier"));
        else if (i3 === "SYSTEM" && ([e2, r2] = this.readIdentifierVal(t2, e2, "systemIdentifier"), !this.suppressValidationErr && !r2))
          throw new Error("Missing mandatory system identifier for SYSTEM notation");
        return { notationName: n2, publicIdentifier: s2, systemIdentifier: r2, index: --e2 };
      }
      readIdentifierVal(t2, e2, n2) {
        let i3 = "";
        const s2 = t2[e2];
        if (s2 !== '"' && s2 !== "'")
          throw new Error(`Expected quoted string, found "${s2}"`);
        for (e2++;e2 < t2.length && t2[e2] !== s2; )
          i3 += t2[e2], e2++;
        if (t2[e2] !== s2)
          throw new Error(`Unterminated ${n2} value`);
        return [++e2, i3];
      }
      readElementExp(t2, e2) {
        e2 = P(t2, e2);
        let n2 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]); )
          n2 += t2[e2], e2++;
        if (!this.suppressValidationErr && !r(n2))
          throw new Error(`Invalid element name: "${n2}"`);
        let i3 = "";
        if (t2[e2 = P(t2, e2)] === "E" && A(t2, "MPTY", e2))
          e2 += 4;
        else if (t2[e2] === "A" && A(t2, "NY", e2))
          e2 += 2;
        else if (t2[e2] === "(") {
          for (e2++;e2 < t2.length && t2[e2] !== ")"; )
            i3 += t2[e2], e2++;
          if (t2[e2] !== ")")
            throw new Error("Unterminated content model");
        } else if (!this.suppressValidationErr)
          throw new Error(`Invalid Element Expression, found "${t2[e2]}"`);
        return { elementName: n2, contentModel: i3.trim(), index: e2 };
      }
      readAttlistExp(t2, e2) {
        e2 = P(t2, e2);
        let n2 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]); )
          n2 += t2[e2], e2++;
        S(n2), e2 = P(t2, e2);
        let i3 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]); )
          i3 += t2[e2], e2++;
        if (!S(i3))
          throw new Error(`Invalid attribute name: "${i3}"`);
        e2 = P(t2, e2);
        let s2 = "";
        if (t2.substring(e2, e2 + 8).toUpperCase() === "NOTATION") {
          if (s2 = "NOTATION", t2[e2 = P(t2, e2 += 8)] !== "(")
            throw new Error(`Expected '(', found "${t2[e2]}"`);
          e2++;
          let n3 = [];
          for (;e2 < t2.length && t2[e2] !== ")"; ) {
            let i4 = "";
            for (;e2 < t2.length && t2[e2] !== "|" && t2[e2] !== ")"; )
              i4 += t2[e2], e2++;
            if (i4 = i4.trim(), !S(i4))
              throw new Error(`Invalid notation name: "${i4}"`);
            n3.push(i4), t2[e2] === "|" && (e2++, e2 = P(t2, e2));
          }
          if (t2[e2] !== ")")
            throw new Error("Unterminated list of notations");
          e2++, s2 += " (" + n3.join("|") + ")";
        } else {
          for (;e2 < t2.length && !/\s/.test(t2[e2]); )
            s2 += t2[e2], e2++;
          const n3 = ["CDATA", "ID", "IDREF", "IDREFS", "ENTITY", "ENTITIES", "NMTOKEN", "NMTOKENS"];
          if (!this.suppressValidationErr && !n3.includes(s2.toUpperCase()))
            throw new Error(`Invalid attribute type: "${s2}"`);
        }
        e2 = P(t2, e2);
        let r2 = "";
        return t2.substring(e2, e2 + 8).toUpperCase() === "#REQUIRED" ? (r2 = "#REQUIRED", e2 += 8) : t2.substring(e2, e2 + 7).toUpperCase() === "#IMPLIED" ? (r2 = "#IMPLIED", e2 += 7) : [e2, r2] = this.readIdentifierVal(t2, e2, "ATTLIST"), { elementName: n2, attributeName: i3, attributeType: s2, defaultValue: r2, index: e2 };
      }
    }
    const P = (t2, e2) => {
      for (;e2 < t2.length && /\s/.test(t2[e2]); )
        e2++;
      return e2;
    };
    function A(t2, e2, n2) {
      for (let i3 = 0;i3 < e2.length; i3++)
        if (e2[i3] !== t2[n2 + i3 + 1])
          return false;
      return true;
    }
    function S(t2) {
      if (r(t2))
        return t2;
      throw new Error(`Invalid entity name ${t2}`);
    }
    const C = /^[-+]?0x[a-fA-F0-9]+$/, $ = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, V = { hex: true, leadingZeros: true, decimalPoint: ".", eNotation: true };
    const D = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
    function L(t2) {
      return typeof t2 == "function" ? t2 : Array.isArray(t2) ? (e2) => {
        for (const n2 of t2) {
          if (typeof n2 == "string" && e2 === n2)
            return true;
          if (n2 instanceof RegExp && n2.test(e2))
            return true;
        }
      } : () => false;
    }

    class F {
      constructor(t2) {
        if (this.options = t2, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = { apos: { regex: /&(apos|#39|#x27);/g, val: "'" }, gt: { regex: /&(gt|#62|#x3E);/g, val: ">" }, lt: { regex: /&(lt|#60|#x3C);/g, val: "<" }, quot: { regex: /&(quot|#34|#x22);/g, val: '"' } }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = { space: { regex: /&(nbsp|#160);/g, val: " " }, cent: { regex: /&(cent|#162);/g, val: "" }, pound: { regex: /&(pound|#163);/g, val: "" }, yen: { regex: /&(yen|#165);/g, val: "" }, euro: { regex: /&(euro|#8364);/g, val: "" }, copyright: { regex: /&(copy|#169);/g, val: "" }, reg: { regex: /&(reg|#174);/g, val: "" }, inr: { regex: /&(inr|#8377);/g, val: "" }, num_dec: { regex: /&#([0-9]{1,7});/g, val: (t3, e2) => K(e2, 10, "&#") }, num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (t3, e2) => K(e2, 16, "&#x") } }, this.addExternalEntities = j, this.parseXml = B, this.parseTextData = M, this.resolveNameSpace = _, this.buildAttributesMap = U, this.isItStopNode = X, this.replaceEntitiesValue = Y, this.readStopNodeData = q, this.saveTextToParentTag = G, this.addChild = R, this.ignoreAttributesFn = L(this.options.ignoreAttributes), this.entityExpansionCount = 0, this.currentExpandedLength = 0, this.options.stopNodes && this.options.stopNodes.length > 0) {
          this.stopNodesExact = new Set, this.stopNodesWildcard = new Set;
          for (let t3 = 0;t3 < this.options.stopNodes.length; t3++) {
            const e2 = this.options.stopNodes[t3];
            typeof e2 == "string" && (e2.startsWith("*.") ? this.stopNodesWildcard.add(e2.substring(2)) : this.stopNodesExact.add(e2));
          }
        }
      }
    }
    function j(t2) {
      const e2 = Object.keys(t2);
      for (let n2 = 0;n2 < e2.length; n2++) {
        const i3 = e2[n2], s2 = i3.replace(/[.\-+*:]/g, "\\.");
        this.lastEntities[i3] = { regex: new RegExp("&" + s2 + ";", "g"), val: t2[i3] };
      }
    }
    function M(t2, e2, n2, i3, s2, r2, o2) {
      if (t2 !== undefined && (this.options.trimValues && !i3 && (t2 = t2.trim()), t2.length > 0)) {
        o2 || (t2 = this.replaceEntitiesValue(t2, e2, n2));
        const i4 = this.options.tagValueProcessor(e2, t2, n2, s2, r2);
        return i4 == null ? t2 : typeof i4 != typeof t2 || i4 !== t2 ? i4 : this.options.trimValues || t2.trim() === t2 ? Z(t2, this.options.parseTagValue, this.options.numberParseOptions) : t2;
      }
    }
    function _(t2) {
      if (this.options.removeNSPrefix) {
        const e2 = t2.split(":"), n2 = t2.charAt(0) === "/" ? "/" : "";
        if (e2[0] === "xmlns")
          return "";
        e2.length === 2 && (t2 = n2 + e2[1]);
      }
      return t2;
    }
    const k = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function U(t2, e2, n2) {
      if (this.options.ignoreAttributes !== true && typeof t2 == "string") {
        const i3 = s(t2, k), r2 = i3.length, o2 = {};
        for (let t3 = 0;t3 < r2; t3++) {
          const s2 = this.resolveNameSpace(i3[t3][1]);
          if (this.ignoreAttributesFn(s2, e2))
            continue;
          let r3 = i3[t3][4], a2 = this.options.attributeNamePrefix + s2;
          if (s2.length)
            if (this.options.transformAttributeName && (a2 = this.options.transformAttributeName(a2)), a2 === "__proto__" && (a2 = "#__proto__"), r3 !== undefined) {
              this.options.trimValues && (r3 = r3.trim()), r3 = this.replaceEntitiesValue(r3, n2, e2);
              const t4 = this.options.attributeValueProcessor(s2, r3, e2);
              o2[a2] = t4 == null ? r3 : typeof t4 != typeof r3 || t4 !== r3 ? t4 : Z(r3, this.options.parseAttributeValue, this.options.numberParseOptions);
            } else
              this.options.allowBooleanAttributes && (o2[a2] = true);
        }
        if (!Object.keys(o2).length)
          return;
        if (this.options.attributesGroupName) {
          const t3 = {};
          return t3[this.options.attributesGroupName] = o2, t3;
        }
        return o2;
      }
    }
    const B = function(t2) {
      t2 = t2.replace(/\r\n?/g, `
`);
      const e2 = new I("!xml");
      let n2 = e2, i3 = "", s2 = "";
      this.entityExpansionCount = 0, this.currentExpandedLength = 0;
      const r2 = new O(this.options.processEntities);
      for (let o2 = 0;o2 < t2.length; o2++)
        if (t2[o2] === "<")
          if (t2[o2 + 1] === "/") {
            const e3 = z(t2, ">", o2, "Closing Tag is not closed.");
            let r3 = t2.substring(o2 + 2, e3).trim();
            if (this.options.removeNSPrefix) {
              const t3 = r3.indexOf(":");
              t3 !== -1 && (r3 = r3.substr(t3 + 1));
            }
            this.options.transformTagName && (r3 = this.options.transformTagName(r3)), n2 && (i3 = this.saveTextToParentTag(i3, n2, s2));
            const a2 = s2.substring(s2.lastIndexOf(".") + 1);
            if (r3 && this.options.unpairedTags.indexOf(r3) !== -1)
              throw new Error(`Unpaired tag can not be used as closing tag: </${r3}>`);
            let l2 = 0;
            a2 && this.options.unpairedTags.indexOf(a2) !== -1 ? (l2 = s2.lastIndexOf(".", s2.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : l2 = s2.lastIndexOf("."), s2 = s2.substring(0, l2), n2 = this.tagsNodeStack.pop(), i3 = "", o2 = e3;
          } else if (t2[o2 + 1] === "?") {
            let e3 = W(t2, o2, false, "?>");
            if (!e3)
              throw new Error("Pi Tag is not closed.");
            if (i3 = this.saveTextToParentTag(i3, n2, s2), this.options.ignoreDeclaration && e3.tagName === "?xml" || this.options.ignorePiTags)
              ;
            else {
              const t3 = new I(e3.tagName);
              t3.add(this.options.textNodeName, ""), e3.tagName !== e3.tagExp && e3.attrExpPresent && (t3[":@"] = this.buildAttributesMap(e3.tagExp, s2, e3.tagName)), this.addChild(n2, t3, s2, o2);
            }
            o2 = e3.closeIndex + 1;
          } else if (t2.substr(o2 + 1, 3) === "!--") {
            const e3 = z(t2, "-->", o2 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const r3 = t2.substring(o2 + 4, e3 - 2);
              i3 = this.saveTextToParentTag(i3, n2, s2), n2.add(this.options.commentPropName, [{ [this.options.textNodeName]: r3 }]);
            }
            o2 = e3;
          } else if (t2.substr(o2 + 1, 2) === "!D") {
            const e3 = r2.readDocType(t2, o2);
            this.docTypeEntities = e3.entities, o2 = e3.i;
          } else if (t2.substr(o2 + 1, 2) === "![") {
            const e3 = z(t2, "]]>", o2, "CDATA is not closed.") - 2, r3 = t2.substring(o2 + 9, e3);
            i3 = this.saveTextToParentTag(i3, n2, s2);
            let a2 = this.parseTextData(r3, n2.tagname, s2, true, false, true, true);
            a2 == null && (a2 = ""), this.options.cdataPropName ? n2.add(this.options.cdataPropName, [{ [this.options.textNodeName]: r3 }]) : n2.add(this.options.textNodeName, a2), o2 = e3 + 2;
          } else {
            let r3 = W(t2, o2, this.options.removeNSPrefix), a2 = r3.tagName;
            const l2 = r3.rawTagName;
            let { tagExp: u2, attrExpPresent: h2, closeIndex: d2 } = r3;
            if (this.options.transformTagName) {
              const t3 = this.options.transformTagName(a2);
              u2 === a2 && (u2 = t3), a2 = t3;
            }
            n2 && i3 && n2.tagname !== "!xml" && (i3 = this.saveTextToParentTag(i3, n2, s2, false));
            const p2 = n2;
            p2 && this.options.unpairedTags.indexOf(p2.tagname) !== -1 && (n2 = this.tagsNodeStack.pop(), s2 = s2.substring(0, s2.lastIndexOf("."))), a2 !== e2.tagname && (s2 += s2 ? "." + a2 : a2);
            const f2 = o2;
            if (this.isItStopNode(this.stopNodesExact, this.stopNodesWildcard, s2, a2)) {
              let e3 = "";
              if (u2.length > 0 && u2.lastIndexOf("/") === u2.length - 1)
                a2[a2.length - 1] === "/" ? (a2 = a2.substr(0, a2.length - 1), s2 = s2.substr(0, s2.length - 1), u2 = a2) : u2 = u2.substr(0, u2.length - 1), o2 = r3.closeIndex;
              else if (this.options.unpairedTags.indexOf(a2) !== -1)
                o2 = r3.closeIndex;
              else {
                const n3 = this.readStopNodeData(t2, l2, d2 + 1);
                if (!n3)
                  throw new Error(`Unexpected end of ${l2}`);
                o2 = n3.i, e3 = n3.tagContent;
              }
              const i4 = new I(a2);
              a2 !== u2 && h2 && (i4[":@"] = this.buildAttributesMap(u2, s2, a2)), e3 && (e3 = this.parseTextData(e3, a2, s2, true, h2, true, true)), s2 = s2.substr(0, s2.lastIndexOf(".")), i4.add(this.options.textNodeName, e3), this.addChild(n2, i4, s2, f2);
            } else {
              if (u2.length > 0 && u2.lastIndexOf("/") === u2.length - 1) {
                if (a2[a2.length - 1] === "/" ? (a2 = a2.substr(0, a2.length - 1), s2 = s2.substr(0, s2.length - 1), u2 = a2) : u2 = u2.substr(0, u2.length - 1), this.options.transformTagName) {
                  const t4 = this.options.transformTagName(a2);
                  u2 === a2 && (u2 = t4), a2 = t4;
                }
                const t3 = new I(a2);
                a2 !== u2 && h2 && (t3[":@"] = this.buildAttributesMap(u2, s2, a2)), this.addChild(n2, t3, s2, f2), s2 = s2.substr(0, s2.lastIndexOf("."));
              } else {
                const t3 = new I(a2);
                this.tagsNodeStack.push(n2), a2 !== u2 && h2 && (t3[":@"] = this.buildAttributesMap(u2, s2, a2)), this.addChild(n2, t3, s2, f2), n2 = t3;
              }
              i3 = "", o2 = d2;
            }
          }
        else
          i3 += t2[o2];
      return e2.child;
    };
    function R(t2, e2, n2, i3) {
      this.options.captureMetaData || (i3 = undefined);
      const s2 = this.options.updateTag(e2.tagname, n2, e2[":@"]);
      s2 === false || (typeof s2 == "string" ? (e2.tagname = s2, t2.addChild(e2, i3)) : t2.addChild(e2, i3));
    }
    const Y = function(t2, e2, n2) {
      if (t2.indexOf("&") === -1)
        return t2;
      const i3 = this.options.processEntities;
      if (!i3.enabled)
        return t2;
      if (i3.allowedTags && !i3.allowedTags.includes(e2))
        return t2;
      if (i3.tagFilter && !i3.tagFilter(e2, n2))
        return t2;
      for (let e3 in this.docTypeEntities) {
        const n3 = this.docTypeEntities[e3], s2 = t2.match(n3.regx);
        if (s2) {
          if (this.entityExpansionCount += s2.length, i3.maxTotalExpansions && this.entityExpansionCount > i3.maxTotalExpansions)
            throw new Error(`Entity expansion limit exceeded: ${this.entityExpansionCount} > ${i3.maxTotalExpansions}`);
          const e4 = t2.length;
          if (t2 = t2.replace(n3.regx, n3.val), i3.maxExpandedLength && (this.currentExpandedLength += t2.length - e4, this.currentExpandedLength > i3.maxExpandedLength))
            throw new Error(`Total expanded content size exceeded: ${this.currentExpandedLength} > ${i3.maxExpandedLength}`);
        }
      }
      if (t2.indexOf("&") === -1)
        return t2;
      for (let e3 in this.lastEntities) {
        const n3 = this.lastEntities[e3];
        t2 = t2.replace(n3.regex, n3.val);
      }
      if (t2.indexOf("&") === -1)
        return t2;
      if (this.options.htmlEntities)
        for (let e3 in this.htmlEntities) {
          const n3 = this.htmlEntities[e3];
          t2 = t2.replace(n3.regex, n3.val);
        }
      return t2.replace(this.ampEntity.regex, this.ampEntity.val);
    };
    function G(t2, e2, n2, i3) {
      return t2 && (i3 === undefined && (i3 = e2.child.length === 0), (t2 = this.parseTextData(t2, e2.tagname, n2, false, !!e2[":@"] && Object.keys(e2[":@"]).length !== 0, i3)) !== undefined && t2 !== "" && e2.add(this.options.textNodeName, t2), t2 = ""), t2;
    }
    function X(t2, e2, n2, i3) {
      return !(!e2 || !e2.has(i3)) || !(!t2 || !t2.has(n2));
    }
    function z(t2, e2, n2, i3) {
      const s2 = t2.indexOf(e2, n2);
      if (s2 === -1)
        throw new Error(i3);
      return s2 + e2.length - 1;
    }
    function W(t2, e2, n2, i3 = ">") {
      const s2 = function(t3, e3, n3 = ">") {
        let i4, s3 = "";
        for (let r3 = e3;r3 < t3.length; r3++) {
          let e4 = t3[r3];
          if (i4)
            e4 === i4 && (i4 = "");
          else if (e4 === '"' || e4 === "'")
            i4 = e4;
          else if (e4 === n3[0]) {
            if (!n3[1])
              return { data: s3, index: r3 };
            if (t3[r3 + 1] === n3[1])
              return { data: s3, index: r3 };
          } else
            e4 === "\t" && (e4 = " ");
          s3 += e4;
        }
      }(t2, e2 + 1, i3);
      if (!s2)
        return;
      let r2 = s2.data;
      const o2 = s2.index, a2 = r2.search(/\s/);
      let l2 = r2, u2 = true;
      a2 !== -1 && (l2 = r2.substring(0, a2), r2 = r2.substring(a2 + 1).trimStart());
      const h2 = l2;
      if (n2) {
        const t3 = l2.indexOf(":");
        t3 !== -1 && (l2 = l2.substr(t3 + 1), u2 = l2 !== s2.data.substr(t3 + 1));
      }
      return { tagName: l2, tagExp: r2, closeIndex: o2, attrExpPresent: u2, rawTagName: h2 };
    }
    function q(t2, e2, n2) {
      const i3 = n2;
      let s2 = 1;
      for (;n2 < t2.length; n2++)
        if (t2[n2] === "<")
          if (t2[n2 + 1] === "/") {
            const r2 = z(t2, ">", n2, `${e2} is not closed`);
            if (t2.substring(n2 + 2, r2).trim() === e2 && (s2--, s2 === 0))
              return { tagContent: t2.substring(i3, n2), i: r2 };
            n2 = r2;
          } else if (t2[n2 + 1] === "?")
            n2 = z(t2, "?>", n2 + 1, "StopNode is not closed.");
          else if (t2.substr(n2 + 1, 3) === "!--")
            n2 = z(t2, "-->", n2 + 3, "StopNode is not closed.");
          else if (t2.substr(n2 + 1, 2) === "![")
            n2 = z(t2, "]]>", n2, "StopNode is not closed.") - 2;
          else {
            const i4 = W(t2, n2, ">");
            i4 && ((i4 && i4.tagName) === e2 && i4.tagExp[i4.tagExp.length - 1] !== "/" && s2++, n2 = i4.closeIndex);
          }
    }
    function Z(t2, e2, n2) {
      if (e2 && typeof t2 == "string") {
        const e3 = t2.trim();
        return e3 === "true" || e3 !== "false" && function(t3, e4 = {}) {
          if (e4 = Object.assign({}, V, e4), !t3 || typeof t3 != "string")
            return t3;
          let n3 = t3.trim();
          if (e4.skipLike !== undefined && e4.skipLike.test(n3))
            return t3;
          if (t3 === "0")
            return 0;
          if (e4.hex && C.test(n3))
            return function(t4) {
              if (parseInt)
                return parseInt(t4, 16);
              if (Number.parseInt)
                return Number.parseInt(t4, 16);
              if (window && window.parseInt)
                return window.parseInt(t4, 16);
              throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
            }(n3);
          if (n3.search(/.+[eE].+/) !== -1)
            return function(t4, e5, n4) {
              if (!n4.eNotation)
                return t4;
              const i4 = e5.match(D);
              if (i4) {
                let s2 = i4[1] || "";
                const r2 = i4[3].indexOf("e") === -1 ? "E" : "e", o2 = i4[2], a2 = s2 ? t4[o2.length + 1] === r2 : t4[o2.length] === r2;
                return o2.length > 1 && a2 ? t4 : o2.length !== 1 || !i4[3].startsWith(`.${r2}`) && i4[3][0] !== r2 ? n4.leadingZeros && !a2 ? (e5 = (i4[1] || "") + i4[3], Number(e5)) : t4 : Number(e5);
              }
              return t4;
            }(t3, n3, e4);
          {
            const s2 = $.exec(n3);
            if (s2) {
              const r2 = s2[1] || "", o2 = s2[2];
              let a2 = (i3 = s2[3]) && i3.indexOf(".") !== -1 ? ((i3 = i3.replace(/0+$/, "")) === "." ? i3 = "0" : i3[0] === "." ? i3 = "0" + i3 : i3[i3.length - 1] === "." && (i3 = i3.substring(0, i3.length - 1)), i3) : i3;
              const l2 = r2 ? t3[o2.length + 1] === "." : t3[o2.length] === ".";
              if (!e4.leadingZeros && (o2.length > 1 || o2.length === 1 && !l2))
                return t3;
              {
                const i4 = Number(n3), s3 = String(i4);
                if (i4 === 0 || i4 === -0)
                  return i4;
                if (s3.search(/[eE]/) !== -1)
                  return e4.eNotation ? i4 : t3;
                if (n3.indexOf(".") !== -1)
                  return s3 === "0" || s3 === a2 || s3 === `${r2}${a2}` ? i4 : t3;
                let l3 = o2 ? a2 : n3;
                return o2 ? l3 === s3 || r2 + l3 === s3 ? i4 : t3 : l3 === s3 || l3 === r2 + s3 ? i4 : t3;
              }
            }
            return t3;
          }
          var i3;
        }(t2, n2);
      }
      return t2 !== undefined ? t2 : "";
    }
    function K(t2, e2, n2) {
      const i3 = Number.parseInt(t2, e2);
      return i3 >= 0 && i3 <= 1114111 ? String.fromCodePoint(i3) : n2 + t2 + ";";
    }
    const Q = I.getMetaDataSymbol();
    function J(t2, e2) {
      return H(t2, e2);
    }
    function H(t2, e2, n2) {
      let i3;
      const s2 = {};
      for (let r2 = 0;r2 < t2.length; r2++) {
        const o2 = t2[r2], a2 = tt(o2);
        let l2 = "";
        if (l2 = n2 === undefined ? a2 : n2 + "." + a2, a2 === e2.textNodeName)
          i3 === undefined ? i3 = o2[a2] : i3 += "" + o2[a2];
        else {
          if (a2 === undefined)
            continue;
          if (o2[a2]) {
            let t3 = H(o2[a2], e2, l2);
            const n3 = nt(t3, e2);
            o2[Q] !== undefined && (t3[Q] = o2[Q]), o2[":@"] ? et(t3, o2[":@"], l2, e2) : Object.keys(t3).length !== 1 || t3[e2.textNodeName] === undefined || e2.alwaysCreateTextNode ? Object.keys(t3).length === 0 && (e2.alwaysCreateTextNode ? t3[e2.textNodeName] = "" : t3 = "") : t3 = t3[e2.textNodeName], s2[a2] !== undefined && s2.hasOwnProperty(a2) ? (Array.isArray(s2[a2]) || (s2[a2] = [s2[a2]]), s2[a2].push(t3)) : e2.isArray(a2, l2, n3) ? s2[a2] = [t3] : s2[a2] = t3;
          }
        }
      }
      return typeof i3 == "string" ? i3.length > 0 && (s2[e2.textNodeName] = i3) : i3 !== undefined && (s2[e2.textNodeName] = i3), s2;
    }
    function tt(t2) {
      const e2 = Object.keys(t2);
      for (let t3 = 0;t3 < e2.length; t3++) {
        const n2 = e2[t3];
        if (n2 !== ":@")
          return n2;
      }
    }
    function et(t2, e2, n2, i3) {
      if (e2) {
        const s2 = Object.keys(e2), r2 = s2.length;
        for (let o2 = 0;o2 < r2; o2++) {
          const r3 = s2[o2];
          i3.isArray(r3, n2 + "." + r3, true, true) ? t2[r3] = [e2[r3]] : t2[r3] = e2[r3];
        }
      }
    }
    function nt(t2, e2) {
      const { textNodeName: n2 } = e2, i3 = Object.keys(t2).length;
      return i3 === 0 || !(i3 !== 1 || !t2[n2] && typeof t2[n2] != "boolean" && t2[n2] !== 0);
    }

    class it {
      constructor(t2) {
        this.externalEntities = {}, this.options = w(t2);
      }
      parse(t2, e2) {
        if (typeof t2 != "string" && t2.toString)
          t2 = t2.toString();
        else if (typeof t2 != "string")
          throw new Error("XML data is accepted in String or Bytes[] form.");
        if (e2) {
          e2 === true && (e2 = {});
          const n3 = a(t2, e2);
          if (n3 !== true)
            throw Error(`${n3.err.msg}:${n3.err.line}:${n3.err.col}`);
        }
        const n2 = new F(this.options);
        n2.addExternalEntities(this.externalEntities);
        const i3 = n2.parseXml(t2);
        return this.options.preserveOrder || i3 === undefined ? i3 : J(i3, this.options);
      }
      addEntity(t2, e2) {
        if (e2.indexOf("&") !== -1)
          throw new Error("Entity value can't have '&'");
        if (t2.indexOf("&") !== -1 || t2.indexOf(";") !== -1)
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        if (e2 === "&")
          throw new Error("An entity with value '&' is not permitted");
        this.externalEntities[t2] = e2;
      }
      static getMetaDataSymbol() {
        return I.getMetaDataSymbol();
      }
    }
    function st(t2, e2) {
      let n2 = "";
      return e2.format && e2.indentBy.length > 0 && (n2 = `
`), rt(t2, e2, "", n2);
    }
    function rt(t2, e2, n2, i3) {
      let s2 = "", r2 = false;
      for (let o2 = 0;o2 < t2.length; o2++) {
        const a2 = t2[o2], l2 = ot(a2);
        if (l2 === undefined)
          continue;
        let u2 = "";
        if (u2 = n2.length === 0 ? l2 : `${n2}.${l2}`, l2 === e2.textNodeName) {
          let t3 = a2[l2];
          lt(u2, e2) || (t3 = e2.tagValueProcessor(l2, t3), t3 = ut(t3, e2)), r2 && (s2 += i3), s2 += t3, r2 = false;
          continue;
        }
        if (l2 === e2.cdataPropName) {
          r2 && (s2 += i3), s2 += `<![CDATA[${a2[l2][0][e2.textNodeName]}]]>`, r2 = false;
          continue;
        }
        if (l2 === e2.commentPropName) {
          s2 += i3 + `<!--${a2[l2][0][e2.textNodeName]}-->`, r2 = true;
          continue;
        }
        if (l2[0] === "?") {
          const t3 = at(a2[":@"], e2), n3 = l2 === "?xml" ? "" : i3;
          let o3 = a2[l2][0][e2.textNodeName];
          o3 = o3.length !== 0 ? " " + o3 : "", s2 += n3 + `<${l2}${o3}${t3}?>`, r2 = true;
          continue;
        }
        let h2 = i3;
        h2 !== "" && (h2 += e2.indentBy);
        const d2 = i3 + `<${l2}${at(a2[":@"], e2)}`, p2 = rt(a2[l2], e2, u2, h2);
        e2.unpairedTags.indexOf(l2) !== -1 ? e2.suppressUnpairedNode ? s2 += d2 + ">" : s2 += d2 + "/>" : p2 && p2.length !== 0 || !e2.suppressEmptyNode ? p2 && p2.endsWith(">") ? s2 += d2 + `>${p2}${i3}</${l2}>` : (s2 += d2 + ">", p2 && i3 !== "" && (p2.includes("/>") || p2.includes("</")) ? s2 += i3 + e2.indentBy + p2 + i3 : s2 += p2, s2 += `</${l2}>`) : s2 += d2 + "/>", r2 = true;
      }
      return s2;
    }
    function ot(t2) {
      const e2 = Object.keys(t2);
      for (let n2 = 0;n2 < e2.length; n2++) {
        const i3 = e2[n2];
        if (t2.hasOwnProperty(i3) && i3 !== ":@")
          return i3;
      }
    }
    function at(t2, e2) {
      let n2 = "";
      if (t2 && !e2.ignoreAttributes)
        for (let i3 in t2) {
          if (!t2.hasOwnProperty(i3))
            continue;
          let s2 = e2.attributeValueProcessor(i3, t2[i3]);
          s2 = ut(s2, e2), s2 === true && e2.suppressBooleanAttributes ? n2 += ` ${i3.substr(e2.attributeNamePrefix.length)}` : n2 += ` ${i3.substr(e2.attributeNamePrefix.length)}="${s2}"`;
        }
      return n2;
    }
    function lt(t2, e2) {
      let n2 = (t2 = t2.substr(0, t2.length - e2.textNodeName.length - 1)).substr(t2.lastIndexOf(".") + 1);
      for (let i3 in e2.stopNodes)
        if (e2.stopNodes[i3] === t2 || e2.stopNodes[i3] === "*." + n2)
          return true;
      return false;
    }
    function ut(t2, e2) {
      if (t2 && t2.length > 0 && e2.processEntities)
        for (let n2 = 0;n2 < e2.entities.length; n2++) {
          const i3 = e2.entities[n2];
          t2 = t2.replace(i3.regex, i3.val);
        }
      return t2;
    }
    const ht = { attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, cdataPropName: false, format: false, indentBy: "  ", suppressEmptyNode: false, suppressUnpairedNode: true, suppressBooleanAttributes: true, tagValueProcessor: function(t2, e2) {
      return e2;
    }, attributeValueProcessor: function(t2, e2) {
      return e2;
    }, preserveOrder: false, commentPropName: false, unpairedTags: [], entities: [{ regex: new RegExp("&", "g"), val: "&amp;" }, { regex: new RegExp(">", "g"), val: "&gt;" }, { regex: new RegExp("<", "g"), val: "&lt;" }, { regex: new RegExp("'", "g"), val: "&apos;" }, { regex: new RegExp('"', "g"), val: "&quot;" }], processEntities: true, stopNodes: [], oneListGroup: false };
    function dt(t2) {
      this.options = Object.assign({}, ht, t2), this.options.ignoreAttributes === true || this.options.attributesGroupName ? this.isAttribute = function() {
        return false;
      } : (this.ignoreAttributesFn = L(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = ct), this.processTextOrObjNode = pt, this.options.format ? (this.indentate = ft, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
        return "";
      }, this.tagEndChar = ">", this.newLine = "");
    }
    function pt(t2, e2, n2, i3) {
      const s2 = this.j2x(t2, n2 + 1, i3.concat(e2));
      return t2[this.options.textNodeName] !== undefined && Object.keys(t2).length === 1 ? this.buildTextValNode(t2[this.options.textNodeName], e2, s2.attrStr, n2) : this.buildObjectNode(s2.val, e2, s2.attrStr, n2);
    }
    function ft(t2) {
      return this.options.indentBy.repeat(t2);
    }
    function ct(t2) {
      return !(!t2.startsWith(this.options.attributeNamePrefix) || t2 === this.options.textNodeName) && t2.substr(this.attrPrefixLen);
    }
    dt.prototype.build = function(t2) {
      return this.options.preserveOrder ? st(t2, this.options) : (Array.isArray(t2) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (t2 = { [this.options.arrayNodeName]: t2 }), this.j2x(t2, 0, []).val);
    }, dt.prototype.j2x = function(t2, e2, n2) {
      let i3 = "", s2 = "";
      const r2 = n2.join(".");
      for (let o2 in t2)
        if (Object.prototype.hasOwnProperty.call(t2, o2))
          if (t2[o2] === undefined)
            this.isAttribute(o2) && (s2 += "");
          else if (t2[o2] === null)
            this.isAttribute(o2) || o2 === this.options.cdataPropName ? s2 += "" : o2[0] === "?" ? s2 += this.indentate(e2) + "<" + o2 + "?" + this.tagEndChar : s2 += this.indentate(e2) + "<" + o2 + "/" + this.tagEndChar;
          else if (t2[o2] instanceof Date)
            s2 += this.buildTextValNode(t2[o2], o2, "", e2);
          else if (typeof t2[o2] != "object") {
            const n3 = this.isAttribute(o2);
            if (n3 && !this.ignoreAttributesFn(n3, r2))
              i3 += this.buildAttrPairStr(n3, "" + t2[o2]);
            else if (!n3)
              if (o2 === this.options.textNodeName) {
                let e3 = this.options.tagValueProcessor(o2, "" + t2[o2]);
                s2 += this.replaceEntitiesValue(e3);
              } else
                s2 += this.buildTextValNode(t2[o2], o2, "", e2);
          } else if (Array.isArray(t2[o2])) {
            const i4 = t2[o2].length;
            let r3 = "", a2 = "";
            for (let l2 = 0;l2 < i4; l2++) {
              const i5 = t2[o2][l2];
              if (i5 === undefined)
                ;
              else if (i5 === null)
                o2[0] === "?" ? s2 += this.indentate(e2) + "<" + o2 + "?" + this.tagEndChar : s2 += this.indentate(e2) + "<" + o2 + "/" + this.tagEndChar;
              else if (typeof i5 == "object")
                if (this.options.oneListGroup) {
                  const t3 = this.j2x(i5, e2 + 1, n2.concat(o2));
                  r3 += t3.val, this.options.attributesGroupName && i5.hasOwnProperty(this.options.attributesGroupName) && (a2 += t3.attrStr);
                } else
                  r3 += this.processTextOrObjNode(i5, o2, e2, n2);
              else if (this.options.oneListGroup) {
                let t3 = this.options.tagValueProcessor(o2, i5);
                t3 = this.replaceEntitiesValue(t3), r3 += t3;
              } else
                r3 += this.buildTextValNode(i5, o2, "", e2);
            }
            this.options.oneListGroup && (r3 = this.buildObjectNode(r3, o2, a2, e2)), s2 += r3;
          } else if (this.options.attributesGroupName && o2 === this.options.attributesGroupName) {
            const e3 = Object.keys(t2[o2]), n3 = e3.length;
            for (let s3 = 0;s3 < n3; s3++)
              i3 += this.buildAttrPairStr(e3[s3], "" + t2[o2][e3[s3]]);
          } else
            s2 += this.processTextOrObjNode(t2[o2], o2, e2, n2);
      return { attrStr: i3, val: s2 };
    }, dt.prototype.buildAttrPairStr = function(t2, e2) {
      return e2 = this.options.attributeValueProcessor(t2, "" + e2), e2 = this.replaceEntitiesValue(e2), this.options.suppressBooleanAttributes && e2 === "true" ? " " + t2 : " " + t2 + '="' + e2 + '"';
    }, dt.prototype.buildObjectNode = function(t2, e2, n2, i3) {
      if (t2 === "")
        return e2[0] === "?" ? this.indentate(i3) + "<" + e2 + n2 + "?" + this.tagEndChar : this.indentate(i3) + "<" + e2 + n2 + this.closeTag(e2) + this.tagEndChar;
      {
        let s2 = "</" + e2 + this.tagEndChar, r2 = "";
        return e2[0] === "?" && (r2 = "?", s2 = ""), !n2 && n2 !== "" || t2.indexOf("<") !== -1 ? this.options.commentPropName !== false && e2 === this.options.commentPropName && r2.length === 0 ? this.indentate(i3) + `<!--${t2}-->` + this.newLine : this.indentate(i3) + "<" + e2 + n2 + r2 + this.tagEndChar + t2 + this.indentate(i3) + s2 : this.indentate(i3) + "<" + e2 + n2 + r2 + ">" + t2 + s2;
      }
    }, dt.prototype.closeTag = function(t2) {
      let e2 = "";
      return this.options.unpairedTags.indexOf(t2) !== -1 ? this.options.suppressUnpairedNode || (e2 = "/") : e2 = this.options.suppressEmptyNode ? "/" : `></${t2}`, e2;
    }, dt.prototype.buildTextValNode = function(t2, e2, n2, i3) {
      if (this.options.cdataPropName !== false && e2 === this.options.cdataPropName)
        return this.indentate(i3) + `<![CDATA[${t2}]]>` + this.newLine;
      if (this.options.commentPropName !== false && e2 === this.options.commentPropName)
        return this.indentate(i3) + `<!--${t2}-->` + this.newLine;
      if (e2[0] === "?")
        return this.indentate(i3) + "<" + e2 + n2 + "?" + this.tagEndChar;
      {
        let s2 = this.options.tagValueProcessor(e2, t2);
        return s2 = this.replaceEntitiesValue(s2), s2 === "" ? this.indentate(i3) + "<" + e2 + n2 + this.closeTag(e2) + this.tagEndChar : this.indentate(i3) + "<" + e2 + n2 + ">" + s2 + "</" + e2 + this.tagEndChar;
      }
    }, dt.prototype.replaceEntitiesValue = function(t2) {
      if (t2 && t2.length > 0 && this.options.processEntities)
        for (let e2 = 0;e2 < this.options.entities.length; e2++) {
          const n2 = this.options.entities[e2];
          t2 = t2.replace(n2.regex, n2.val);
        }
      return t2;
    };
    const gt = { validate: a };
    module.exports = e;
  })();
});

// node_modules/@aws-sdk/xml-builder/dist-cjs/xml-parser.js
var require_xml_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseXML = parseXML;
  var fast_xml_parser_1 = require_fxp();
  var parser = new fast_xml_parser_1.XMLParser({
    attributeNamePrefix: "",
    htmlEntities: true,
    ignoreAttributes: false,
    ignoreDeclaration: true,
    parseTagValue: false,
    trimValues: false,
    tagValueProcessor: (_, val) => val.trim() === "" && val.includes(`
`) ? "" : undefined
  });
  parser.addEntity("#xD", "\r");
  parser.addEntity("#10", `
`);
  function parseXML(xmlString) {
    return parser.parse(xmlString, true);
  }
});

// node_modules/@aws-sdk/xml-builder/dist-cjs/index.js
var require_dist_cjs23 = __commonJS((exports) => {
  var xmlParser = require_xml_parser();
  function escapeAttribute(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
  }
  function escapeElement(value) {
    return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#x0D;").replace(/\n/g, "&#x0A;").replace(/\u0085/g, "&#x85;").replace(/\u2028/, "&#x2028;");
  }

  class XmlText {
    value;
    constructor(value) {
      this.value = value;
    }
    toString() {
      return escapeElement("" + this.value);
    }
  }

  class XmlNode {
    name;
    children;
    attributes = {};
    static of(name, childText, withName) {
      const node = new XmlNode(name);
      if (childText !== undefined) {
        node.addChildNode(new XmlText(childText));
      }
      if (withName !== undefined) {
        node.withName(withName);
      }
      return node;
    }
    constructor(name, children = []) {
      this.name = name;
      this.children = children;
    }
    withName(name) {
      this.name = name;
      return this;
    }
    addAttribute(name, value) {
      this.attributes[name] = value;
      return this;
    }
    addChildNode(child) {
      this.children.push(child);
      return this;
    }
    removeAttribute(name) {
      delete this.attributes[name];
      return this;
    }
    n(name) {
      this.name = name;
      return this;
    }
    c(child) {
      this.children.push(child);
      return this;
    }
    a(name, value) {
      if (value != null) {
        this.attributes[name] = value;
      }
      return this;
    }
    cc(input, field, withName = field) {
      if (input[field] != null) {
        const node = XmlNode.of(field, input[field]).withName(withName);
        this.c(node);
      }
    }
    l(input, listName, memberName, valueProvider) {
      if (input[listName] != null) {
        const nodes = valueProvider();
        nodes.map((node) => {
          node.withName(memberName);
          this.c(node);
        });
      }
    }
    lc(input, listName, memberName, valueProvider) {
      if (input[listName] != null) {
        const nodes = valueProvider();
        const containerNode = new XmlNode(memberName);
        nodes.map((node) => {
          containerNode.c(node);
        });
        this.c(containerNode);
      }
    }
    toString() {
      const hasChildren = Boolean(this.children.length);
      let xmlText = `<${this.name}`;
      const attributes = this.attributes;
      for (const attributeName of Object.keys(attributes)) {
        const attribute = attributes[attributeName];
        if (attribute != null) {
          xmlText += ` ${attributeName}="${escapeAttribute("" + attribute)}"`;
        }
      }
      return xmlText += !hasChildren ? "/>" : `>${this.children.map((c) => c.toString()).join("")}</${this.name}>`;
    }
  }
  exports.parseXML = xmlParser.parseXML;
  exports.XmlNode = XmlNode;
  exports.XmlText = XmlText;
});

// node_modules/@aws-sdk/core/dist-cjs/index.js
var require_dist_cjs24 = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs2();
  var core = require_dist_cjs17();
  var propertyProvider = require_dist_cjs18();
  var client3 = require_client2();
  var signatureV4 = require_dist_cjs19();
  var cbor = require_cbor();
  var schema = require_schema();
  var smithyClient = require_dist_cjs22();
  var protocols = require_protocols();
  var serde = require_serde();
  var utilBase64 = require_dist_cjs9();
  var utilUtf8 = require_dist_cjs8();
  var xmlBuilder = require_dist_cjs23();
  var state = {
    warningEmitted: false
  };
  var emitWarningIfUnsupportedVersion = (version2) => {
    if (version2 && !state.warningEmitted && parseInt(version2.substring(1, version2.indexOf("."))) < 20) {
      state.warningEmitted = true;
      process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js ${version2} in January 2026.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/c895JFp`);
    }
  };
  function setCredentialFeature(credentials, feature, value) {
    if (!credentials.$source) {
      credentials.$source = {};
    }
    credentials.$source[feature] = value;
    return credentials;
  }
  function setFeature(context, feature, value) {
    if (!context.__aws_sdk_context) {
      context.__aws_sdk_context = {
        features: {}
      };
    } else if (!context.__aws_sdk_context.features) {
      context.__aws_sdk_context.features = {};
    }
    context.__aws_sdk_context.features[feature] = value;
  }
  function setTokenFeature(token2, feature, value) {
    if (!token2.$source) {
      token2.$source = {};
    }
    token2.$source[feature] = value;
    return token2;
  }
  var getDateHeader = (response) => protocolHttp.HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : undefined;
  var getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
  var isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 300000;
  var getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
    const clockTimeInMs = Date.parse(clockTime);
    if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
      return clockTimeInMs - Date.now();
    }
    return currentSystemClockOffset;
  };
  var throwSigningPropertyError = (name, property) => {
    if (!property) {
      throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
    }
    return property;
  };
  var validateSigningProperties = async (signingProperties) => {
    const context = throwSigningPropertyError("context", signingProperties.context);
    const config = throwSigningPropertyError("config", signingProperties.config);
    const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
    const signerFunction = throwSigningPropertyError("signer", config.signer);
    const signer = await signerFunction(authScheme);
    const signingRegion = signingProperties?.signingRegion;
    const signingRegionSet = signingProperties?.signingRegionSet;
    const signingName = signingProperties?.signingName;
    return {
      config,
      signer,
      signingRegion,
      signingRegionSet,
      signingName
    };
  };

  class AwsSdkSigV4Signer {
    async sign(httpRequest, identity, signingProperties) {
      if (!protocolHttp.HttpRequest.isInstance(httpRequest)) {
        throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
      }
      const validatedProps = await validateSigningProperties(signingProperties);
      const { config, signer } = validatedProps;
      let { signingRegion, signingName } = validatedProps;
      const handlerExecutionContext = signingProperties.context;
      if (handlerExecutionContext?.authSchemes?.length ?? 0 > 1) {
        const [first, second] = handlerExecutionContext.authSchemes;
        if (first?.name === "sigv4a" && second?.name === "sigv4") {
          signingRegion = second?.signingRegion ?? signingRegion;
          signingName = second?.signingName ?? signingName;
        }
      }
      const signedRequest = await signer.sign(httpRequest, {
        signingDate: getSkewCorrectedDate(config.systemClockOffset),
        signingRegion,
        signingService: signingName
      });
      return signedRequest;
    }
    errorHandler(signingProperties) {
      return (error) => {
        const serverTime = error.ServerTime ?? getDateHeader(error.$response);
        if (serverTime) {
          const config = throwSigningPropertyError("config", signingProperties.config);
          const initialSystemClockOffset = config.systemClockOffset;
          config.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config.systemClockOffset);
          const clockSkewCorrected = config.systemClockOffset !== initialSystemClockOffset;
          if (clockSkewCorrected && error.$metadata) {
            error.$metadata.clockSkewCorrected = true;
          }
        }
        throw error;
      };
    }
    successHandler(httpResponse, signingProperties) {
      const dateHeader = getDateHeader(httpResponse);
      if (dateHeader) {
        const config = throwSigningPropertyError("config", signingProperties.config);
        config.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config.systemClockOffset);
      }
    }
  }
  var AWSSDKSigV4Signer = AwsSdkSigV4Signer;

  class AwsSdkSigV4ASigner extends AwsSdkSigV4Signer {
    async sign(httpRequest, identity, signingProperties) {
      if (!protocolHttp.HttpRequest.isInstance(httpRequest)) {
        throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
      }
      const { config, signer, signingRegion, signingRegionSet, signingName } = await validateSigningProperties(signingProperties);
      const configResolvedSigningRegionSet = await config.sigv4aSigningRegionSet?.();
      const multiRegionOverride = (configResolvedSigningRegionSet ?? signingRegionSet ?? [signingRegion]).join(",");
      const signedRequest = await signer.sign(httpRequest, {
        signingDate: getSkewCorrectedDate(config.systemClockOffset),
        signingRegion: multiRegionOverride,
        signingService: signingName
      });
      return signedRequest;
    }
  }
  var getArrayForCommaSeparatedString = (str) => typeof str === "string" && str.length > 0 ? str.split(",").map((item) => item.trim()) : [];
  var getBearerTokenEnvKey = (signingName) => `AWS_BEARER_TOKEN_${signingName.replace(/[\s-]/g, "_").toUpperCase()}`;
  var NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY = "AWS_AUTH_SCHEME_PREFERENCE";
  var NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY = "auth_scheme_preference";
  var NODE_AUTH_SCHEME_PREFERENCE_OPTIONS = {
    environmentVariableSelector: (env, options) => {
      if (options?.signingName) {
        const bearerTokenKey = getBearerTokenEnvKey(options.signingName);
        if (bearerTokenKey in env)
          return ["httpBearerAuth"];
      }
      if (!(NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY in env))
        return;
      return getArrayForCommaSeparatedString(env[NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY]);
    },
    configFileSelector: (profile) => {
      if (!(NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY in profile))
        return;
      return getArrayForCommaSeparatedString(profile[NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY]);
    },
    default: []
  };
  var resolveAwsSdkSigV4AConfig = (config) => {
    config.sigv4aSigningRegionSet = core.normalizeProvider(config.sigv4aSigningRegionSet);
    return config;
  };
  var NODE_SIGV4A_CONFIG_OPTIONS = {
    environmentVariableSelector(env) {
      if (env.AWS_SIGV4A_SIGNING_REGION_SET) {
        return env.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((_) => _.trim());
      }
      throw new propertyProvider.ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
        tryNextLink: true
      });
    },
    configFileSelector(profile) {
      if (profile.sigv4a_signing_region_set) {
        return (profile.sigv4a_signing_region_set ?? "").split(",").map((_) => _.trim());
      }
      throw new propertyProvider.ProviderError("sigv4a_signing_region_set not set in profile.", {
        tryNextLink: true
      });
    },
    default: undefined
  };
  var resolveAwsSdkSigV4Config = (config) => {
    let inputCredentials = config.credentials;
    let isUserSupplied = !!config.credentials;
    let resolvedCredentials = undefined;
    Object.defineProperty(config, "credentials", {
      set(credentials) {
        if (credentials && credentials !== inputCredentials && credentials !== resolvedCredentials) {
          isUserSupplied = true;
        }
        inputCredentials = credentials;
        const memoizedProvider = normalizeCredentialProvider(config, {
          credentials: inputCredentials,
          credentialDefaultProvider: config.credentialDefaultProvider
        });
        const boundProvider = bindCallerConfig(config, memoizedProvider);
        if (isUserSupplied && !boundProvider.attributed) {
          const isCredentialObject = typeof inputCredentials === "object" && inputCredentials !== null;
          resolvedCredentials = async (options) => {
            const creds = await boundProvider(options);
            const attributedCreds = creds;
            if (isCredentialObject && (!attributedCreds.$source || Object.keys(attributedCreds.$source).length === 0)) {
              return client3.setCredentialFeature(attributedCreds, "CREDENTIALS_CODE", "e");
            }
            return attributedCreds;
          };
          resolvedCredentials.memoized = boundProvider.memoized;
          resolvedCredentials.configBound = boundProvider.configBound;
          resolvedCredentials.attributed = true;
        } else {
          resolvedCredentials = boundProvider;
        }
      },
      get() {
        return resolvedCredentials;
      },
      enumerable: true,
      configurable: true
    });
    config.credentials = inputCredentials;
    const { signingEscapePath = true, systemClockOffset = config.systemClockOffset || 0, sha256 } = config;
    let signer;
    if (config.signer) {
      signer = core.normalizeProvider(config.signer);
    } else if (config.regionInfoProvider) {
      signer = () => core.normalizeProvider(config.region)().then(async (region) => [
        await config.regionInfoProvider(region, {
          useFipsEndpoint: await config.useFipsEndpoint(),
          useDualstackEndpoint: await config.useDualstackEndpoint()
        }) || {},
        region
      ]).then(([regionInfo, region]) => {
        const { signingRegion, signingService } = regionInfo;
        config.signingRegion = config.signingRegion || signingRegion || region;
        config.signingName = config.signingName || signingService || config.serviceId;
        const params = {
          ...config,
          credentials: config.credentials,
          region: config.signingRegion,
          service: config.signingName,
          sha256,
          uriEscapePath: signingEscapePath
        };
        const SignerCtor = config.signerConstructor || signatureV4.SignatureV4;
        return new SignerCtor(params);
      });
    } else {
      signer = async (authScheme) => {
        authScheme = Object.assign({}, {
          name: "sigv4",
          signingName: config.signingName || config.defaultSigningName,
          signingRegion: await core.normalizeProvider(config.region)(),
          properties: {}
        }, authScheme);
        const signingRegion = authScheme.signingRegion;
        const signingService = authScheme.signingName;
        config.signingRegion = config.signingRegion || signingRegion;
        config.signingName = config.signingName || signingService || config.serviceId;
        const params = {
          ...config,
          credentials: config.credentials,
          region: config.signingRegion,
          service: config.signingName,
          sha256,
          uriEscapePath: signingEscapePath
        };
        const SignerCtor = config.signerConstructor || signatureV4.SignatureV4;
        return new SignerCtor(params);
      };
    }
    const resolvedConfig = Object.assign(config, {
      systemClockOffset,
      signingEscapePath,
      signer
    });
    return resolvedConfig;
  };
  var resolveAWSSDKSigV4Config = resolveAwsSdkSigV4Config;
  function normalizeCredentialProvider(config, { credentials, credentialDefaultProvider }) {
    let credentialsProvider;
    if (credentials) {
      if (!credentials?.memoized) {
        credentialsProvider = core.memoizeIdentityProvider(credentials, core.isIdentityExpired, core.doesIdentityRequireRefresh);
      } else {
        credentialsProvider = credentials;
      }
    } else {
      if (credentialDefaultProvider) {
        credentialsProvider = core.normalizeProvider(credentialDefaultProvider(Object.assign({}, config, {
          parentClientConfig: config
        })));
      } else {
        credentialsProvider = async () => {
          throw new Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.");
        };
      }
    }
    credentialsProvider.memoized = true;
    return credentialsProvider;
  }
  function bindCallerConfig(config, credentialsProvider) {
    if (credentialsProvider.configBound) {
      return credentialsProvider;
    }
    const fn = async (options) => credentialsProvider({ ...options, callerClientConfig: config });
    fn.memoized = credentialsProvider.memoized;
    fn.configBound = true;
    return fn;
  }

  class ProtocolLib {
    queryCompat;
    constructor(queryCompat = false) {
      this.queryCompat = queryCompat;
    }
    resolveRestContentType(defaultContentType, inputSchema) {
      const members = inputSchema.getMemberSchemas();
      const httpPayloadMember = Object.values(members).find((m) => {
        return !!m.getMergedTraits().httpPayload;
      });
      if (httpPayloadMember) {
        const mediaType = httpPayloadMember.getMergedTraits().mediaType;
        if (mediaType) {
          return mediaType;
        } else if (httpPayloadMember.isStringSchema()) {
          return "text/plain";
        } else if (httpPayloadMember.isBlobSchema()) {
          return "application/octet-stream";
        } else {
          return defaultContentType;
        }
      } else if (!inputSchema.isUnitSchema()) {
        const hasBody = Object.values(members).find((m) => {
          const { httpQuery, httpQueryParams, httpHeader, httpLabel, httpPrefixHeaders } = m.getMergedTraits();
          const noPrefixHeaders = httpPrefixHeaders === undefined;
          return !httpQuery && !httpQueryParams && !httpHeader && !httpLabel && noPrefixHeaders;
        });
        if (hasBody) {
          return defaultContentType;
        }
      }
    }
    async getErrorSchemaOrThrowBaseException(errorIdentifier, defaultNamespace, response, dataObject, metadata, getErrorSchema) {
      let namespace = defaultNamespace;
      let errorName = errorIdentifier;
      if (errorIdentifier.includes("#")) {
        [namespace, errorName] = errorIdentifier.split("#");
      }
      const errorMetadata = {
        $metadata: metadata,
        $fault: response.statusCode < 500 ? "client" : "server"
      };
      const registry = schema.TypeRegistry.for(namespace);
      try {
        const errorSchema = getErrorSchema?.(registry, errorName) ?? registry.getSchema(errorIdentifier);
        return { errorSchema, errorMetadata };
      } catch (e) {
        dataObject.message = dataObject.message ?? dataObject.Message ?? "UnknownError";
        const synthetic = schema.TypeRegistry.for("smithy.ts.sdk.synthetic." + namespace);
        const baseExceptionSchema = synthetic.getBaseException();
        if (baseExceptionSchema) {
          const ErrorCtor = synthetic.getErrorCtor(baseExceptionSchema) ?? Error;
          throw this.decorateServiceException(Object.assign(new ErrorCtor({ name: errorName }), errorMetadata), dataObject);
        }
        throw this.decorateServiceException(Object.assign(new Error(errorName), errorMetadata), dataObject);
      }
    }
    decorateServiceException(exception, additions = {}) {
      if (this.queryCompat) {
        const msg = exception.Message ?? additions.Message;
        const error = smithyClient.decorateServiceException(exception, additions);
        if (msg) {
          error.message = msg;
        }
        error.Error = {
          ...error.Error,
          Type: error.Error?.Type,
          Code: error.Error?.Code,
          Message: error.Error?.message ?? error.Error?.Message ?? msg
        };
        const reqId = error.$metadata.requestId;
        if (reqId) {
          error.RequestId = reqId;
        }
        return error;
      }
      return smithyClient.decorateServiceException(exception, additions);
    }
    setQueryCompatError(output, response) {
      const queryErrorHeader = response.headers?.["x-amzn-query-error"];
      if (output !== undefined && queryErrorHeader != null) {
        const [Code, Type] = queryErrorHeader.split(";");
        const entries = Object.entries(output);
        const Error2 = {
          Code,
          Type
        };
        Object.assign(output, Error2);
        for (const [k, v] of entries) {
          Error2[k === "message" ? "Message" : k] = v;
        }
        delete Error2.__type;
        output.Error = Error2;
      }
    }
    queryCompatOutput(queryCompatErrorData, errorData) {
      if (queryCompatErrorData.Error) {
        errorData.Error = queryCompatErrorData.Error;
      }
      if (queryCompatErrorData.Type) {
        errorData.Type = queryCompatErrorData.Type;
      }
      if (queryCompatErrorData.Code) {
        errorData.Code = queryCompatErrorData.Code;
      }
    }
    findQueryCompatibleError(registry, errorName) {
      try {
        return registry.getSchema(errorName);
      } catch (e) {
        return registry.find((schema$1) => schema.NormalizedSchema.of(schema$1).getMergedTraits().awsQueryError?.[0] === errorName);
      }
    }
  }

  class AwsSmithyRpcV2CborProtocol extends cbor.SmithyRpcV2CborProtocol {
    awsQueryCompatible;
    mixin;
    constructor({ defaultNamespace, awsQueryCompatible }) {
      super({ defaultNamespace });
      this.awsQueryCompatible = !!awsQueryCompatible;
      this.mixin = new ProtocolLib(this.awsQueryCompatible);
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      if (this.awsQueryCompatible) {
        request.headers["x-amzn-query-mode"] = "true";
      }
      return request;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      if (this.awsQueryCompatible) {
        this.mixin.setQueryCompatError(dataObject, response);
      }
      const errorName = (() => {
        const compatHeader = response.headers["x-amzn-query-error"];
        if (compatHeader && this.awsQueryCompatible) {
          return compatHeader.split(";")[0];
        }
        return cbor.loadSmithyRpcV2CborErrorCode(response, dataObject) ?? "Unknown";
      })();
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorName, this.options.defaultNamespace, response, dataObject, metadata, this.awsQueryCompatible ? this.mixin.findQueryCompatibleError : undefined);
      const ns = schema.NormalizedSchema.of(errorSchema);
      const message3 = dataObject.message ?? dataObject.Message ?? "Unknown";
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message3);
      const output = {};
      for (const [name, member] of ns.structIterator()) {
        if (dataObject[name] != null) {
          output[name] = this.deserializer.readValue(member, dataObject[name]);
        }
      }
      if (this.awsQueryCompatible) {
        this.mixin.queryCompatOutput(dataObject, output);
      }
      throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message: message3
      }, output), dataObject);
    }
  }
  var _toStr = (val) => {
    if (val == null) {
      return val;
    }
    if (typeof val === "number" || typeof val === "bigint") {
      const warning = new Error(`Received number ${val} where a string was expected.`);
      warning.name = "Warning";
      console.warn(warning);
      return String(val);
    }
    if (typeof val === "boolean") {
      const warning = new Error(`Received boolean ${val} where a string was expected.`);
      warning.name = "Warning";
      console.warn(warning);
      return String(val);
    }
    return val;
  };
  var _toBool = (val) => {
    if (val == null) {
      return val;
    }
    if (typeof val === "string") {
      const lowercase = val.toLowerCase();
      if (val !== "" && lowercase !== "false" && lowercase !== "true") {
        const warning = new Error(`Received string "${val}" where a boolean was expected.`);
        warning.name = "Warning";
        console.warn(warning);
      }
      return val !== "" && lowercase !== "false";
    }
    return val;
  };
  var _toNum = (val) => {
    if (val == null) {
      return val;
    }
    if (typeof val === "string") {
      const num = Number(val);
      if (num.toString() !== val) {
        const warning = new Error(`Received string "${val}" where a number was expected.`);
        warning.name = "Warning";
        console.warn(warning);
        return val;
      }
      return num;
    }
    return val;
  };

  class SerdeContextConfig {
    serdeContext;
    setSerdeContext(serdeContext) {
      this.serdeContext = serdeContext;
    }
  }

  class UnionSerde {
    from;
    to;
    keys;
    constructor(from, to) {
      this.from = from;
      this.to = to;
      this.keys = new Set(Object.keys(this.from).filter((k) => k !== "__type"));
    }
    mark(key) {
      this.keys.delete(key);
    }
    hasUnknown() {
      return this.keys.size === 1 && Object.keys(this.to).length === 0;
    }
    writeUnknown() {
      if (this.hasUnknown()) {
        const k = this.keys.values().next().value;
        const v = this.from[k];
        this.to.$unknown = [k, v];
      }
    }
  }
  function jsonReviver(key, value, context) {
    if (context?.source) {
      const numericString = context.source;
      if (typeof value === "number") {
        if (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER || numericString !== String(value)) {
          const isFractional = numericString.includes(".");
          if (isFractional) {
            return new serde.NumericValue(numericString, "bigDecimal");
          } else {
            return BigInt(numericString);
          }
        }
      }
    }
    return value;
  }
  var collectBodyString = (streamBody, context) => smithyClient.collectBody(streamBody, context).then((body) => (context?.utf8Encoder ?? utilUtf8.toUtf8)(body));
  var parseJsonBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      try {
        return JSON.parse(encoded);
      } catch (e) {
        if (e?.name === "SyntaxError") {
          Object.defineProperty(e, "$responseBodyText", {
            value: encoded
          });
        }
        throw e;
      }
    }
    return {};
  });
  var parseJsonErrorBody = async (errorBody, context) => {
    const value = await parseJsonBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
  };
  var loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
      let cleanValue = rawValue;
      if (typeof cleanValue === "number") {
        cleanValue = cleanValue.toString();
      }
      if (cleanValue.indexOf(",") >= 0) {
        cleanValue = cleanValue.split(",")[0];
      }
      if (cleanValue.indexOf(":") >= 0) {
        cleanValue = cleanValue.split(":")[0];
      }
      if (cleanValue.indexOf("#") >= 0) {
        cleanValue = cleanValue.split("#")[1];
      }
      return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
      return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data && typeof data === "object") {
      const codeKey = findKey(data, "code");
      if (codeKey && data[codeKey] !== undefined) {
        return sanitizeErrorCode(data[codeKey]);
      }
      if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
      }
    }
  };

  class JsonShapeDeserializer extends SerdeContextConfig {
    settings;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    async read(schema2, data) {
      return this._read(schema2, typeof data === "string" ? JSON.parse(data, jsonReviver) : await parseJsonBody(data, this.serdeContext));
    }
    readObject(schema2, data) {
      return this._read(schema2, data);
    }
    _read(schema$1, value) {
      const isObject2 = value !== null && typeof value === "object";
      const ns = schema.NormalizedSchema.of(schema$1);
      if (isObject2) {
        if (ns.isStructSchema()) {
          const record = value;
          const union = ns.isUnionSchema();
          const out = {};
          let nameMap = undefined;
          const { jsonName } = this.settings;
          if (jsonName) {
            nameMap = {};
          }
          let unionSerde;
          if (union) {
            unionSerde = new UnionSerde(record, out);
          }
          for (const [memberName, memberSchema] of ns.structIterator()) {
            let fromKey = memberName;
            if (jsonName) {
              fromKey = memberSchema.getMergedTraits().jsonName ?? fromKey;
              nameMap[fromKey] = memberName;
            }
            if (union) {
              unionSerde.mark(fromKey);
            }
            if (record[fromKey] != null) {
              out[memberName] = this._read(memberSchema, record[fromKey]);
            }
          }
          if (union) {
            unionSerde.writeUnknown();
          } else if (typeof record.__type === "string") {
            for (const [k, v] of Object.entries(record)) {
              const t = jsonName ? nameMap[k] ?? k : k;
              if (!(t in out)) {
                out[t] = v;
              }
            }
          }
          return out;
        }
        if (Array.isArray(value) && ns.isListSchema()) {
          const listMember = ns.getValueSchema();
          const out = [];
          const sparse = !!ns.getMergedTraits().sparse;
          for (const item of value) {
            if (sparse || item != null) {
              out.push(this._read(listMember, item));
            }
          }
          return out;
        }
        if (ns.isMapSchema()) {
          const mapMember = ns.getValueSchema();
          const out = {};
          const sparse = !!ns.getMergedTraits().sparse;
          for (const [_k, _v] of Object.entries(value)) {
            if (sparse || _v != null) {
              out[_k] = this._read(mapMember, _v);
            }
          }
          return out;
        }
      }
      if (ns.isBlobSchema() && typeof value === "string") {
        return utilBase64.fromBase64(value);
      }
      const mediaType = ns.getMergedTraits().mediaType;
      if (ns.isStringSchema() && typeof value === "string" && mediaType) {
        const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
        if (isJson) {
          return serde.LazyJsonString.from(value);
        }
        return value;
      }
      if (ns.isTimestampSchema() && value != null) {
        const format = protocols.determineTimestampFormat(ns, this.settings);
        switch (format) {
          case 5:
            return serde.parseRfc3339DateTimeWithOffset(value);
          case 6:
            return serde.parseRfc7231DateTime(value);
          case 7:
            return serde.parseEpochTimestamp(value);
          default:
            console.warn("Missing timestamp format, parsing value with Date constructor:", value);
            return new Date(value);
        }
      }
      if (ns.isBigIntegerSchema() && (typeof value === "number" || typeof value === "string")) {
        return BigInt(value);
      }
      if (ns.isBigDecimalSchema() && value != null) {
        if (value instanceof serde.NumericValue) {
          return value;
        }
        const untyped = value;
        if (untyped.type === "bigDecimal" && "string" in untyped) {
          return new serde.NumericValue(untyped.string, untyped.type);
        }
        return new serde.NumericValue(String(value), "bigDecimal");
      }
      if (ns.isNumericSchema() && typeof value === "string") {
        switch (value) {
          case "Infinity":
            return Infinity;
          case "-Infinity":
            return -Infinity;
          case "NaN":
            return NaN;
        }
        return value;
      }
      if (ns.isDocumentSchema()) {
        if (isObject2) {
          const out = Array.isArray(value) ? [] : {};
          for (const [k, v] of Object.entries(value)) {
            if (v instanceof serde.NumericValue) {
              out[k] = v;
            } else {
              out[k] = this._read(ns, v);
            }
          }
          return out;
        } else {
          return structuredClone(value);
        }
      }
      return value;
    }
  }
  var NUMERIC_CONTROL_CHAR = String.fromCharCode(925);

  class JsonReplacer {
    values = new Map;
    counter = 0;
    stage = 0;
    createReplacer() {
      if (this.stage === 1) {
        throw new Error("@aws-sdk/core/protocols - JsonReplacer already created.");
      }
      if (this.stage === 2) {
        throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
      }
      this.stage = 1;
      return (key, value) => {
        if (value instanceof serde.NumericValue) {
          const v = `${NUMERIC_CONTROL_CHAR + "nv" + this.counter++}_` + value.string;
          this.values.set(`"${v}"`, value.string);
          return v;
        }
        if (typeof value === "bigint") {
          const s = value.toString();
          const v = `${NUMERIC_CONTROL_CHAR + "b" + this.counter++}_` + s;
          this.values.set(`"${v}"`, s);
          return v;
        }
        return value;
      };
    }
    replaceInJson(json) {
      if (this.stage === 0) {
        throw new Error("@aws-sdk/core/protocols - JsonReplacer not created yet.");
      }
      if (this.stage === 2) {
        throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
      }
      this.stage = 2;
      if (this.counter === 0) {
        return json;
      }
      for (const [key, value] of this.values) {
        json = json.replace(key, value);
      }
      return json;
    }
  }

  class JsonShapeSerializer extends SerdeContextConfig {
    settings;
    buffer;
    useReplacer = false;
    rootSchema;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    write(schema$1, value) {
      this.rootSchema = schema.NormalizedSchema.of(schema$1);
      this.buffer = this._write(this.rootSchema, value);
    }
    writeDiscriminatedDocument(schema$1, value) {
      this.write(schema$1, value);
      if (typeof this.buffer === "object") {
        this.buffer.__type = schema.NormalizedSchema.of(schema$1).getName(true);
      }
    }
    flush() {
      const { rootSchema, useReplacer } = this;
      this.rootSchema = undefined;
      this.useReplacer = false;
      if (rootSchema?.isStructSchema() || rootSchema?.isDocumentSchema()) {
        if (!useReplacer) {
          return JSON.stringify(this.buffer);
        }
        const replacer = new JsonReplacer;
        return replacer.replaceInJson(JSON.stringify(this.buffer, replacer.createReplacer(), 0));
      }
      return this.buffer;
    }
    _write(schema$1, value, container) {
      const isObject2 = value !== null && typeof value === "object";
      const ns = schema.NormalizedSchema.of(schema$1);
      if (isObject2) {
        if (ns.isStructSchema()) {
          const record = value;
          const out = {};
          const { jsonName } = this.settings;
          let nameMap = undefined;
          if (jsonName) {
            nameMap = {};
          }
          for (const [memberName, memberSchema] of ns.structIterator()) {
            const serializableValue = this._write(memberSchema, record[memberName], ns);
            if (serializableValue !== undefined) {
              let targetKey = memberName;
              if (jsonName) {
                targetKey = memberSchema.getMergedTraits().jsonName ?? memberName;
                nameMap[memberName] = targetKey;
              }
              out[targetKey] = serializableValue;
            }
          }
          if (ns.isUnionSchema() && Object.keys(out).length === 0) {
            const { $unknown } = record;
            if (Array.isArray($unknown)) {
              const [k, v] = $unknown;
              out[k] = this._write(15, v);
            }
          } else if (typeof record.__type === "string") {
            for (const [k, v] of Object.entries(record)) {
              const targetKey = jsonName ? nameMap[k] ?? k : k;
              if (!(targetKey in out)) {
                out[targetKey] = this._write(15, v);
              }
            }
          }
          return out;
        }
        if (Array.isArray(value) && ns.isListSchema()) {
          const listMember = ns.getValueSchema();
          const out = [];
          const sparse = !!ns.getMergedTraits().sparse;
          for (const item of value) {
            if (sparse || item != null) {
              out.push(this._write(listMember, item));
            }
          }
          return out;
        }
        if (ns.isMapSchema()) {
          const mapMember = ns.getValueSchema();
          const out = {};
          const sparse = !!ns.getMergedTraits().sparse;
          for (const [_k, _v] of Object.entries(value)) {
            if (sparse || _v != null) {
              out[_k] = this._write(mapMember, _v);
            }
          }
          return out;
        }
        if (value instanceof Uint8Array && (ns.isBlobSchema() || ns.isDocumentSchema())) {
          if (ns === this.rootSchema) {
            return value;
          }
          return (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
        }
        if (value instanceof Date && (ns.isTimestampSchema() || ns.isDocumentSchema())) {
          const format = protocols.determineTimestampFormat(ns, this.settings);
          switch (format) {
            case 5:
              return value.toISOString().replace(".000Z", "Z");
            case 6:
              return serde.dateToUtcString(value);
            case 7:
              return value.getTime() / 1000;
            default:
              console.warn("Missing timestamp format, using epoch seconds", value);
              return value.getTime() / 1000;
          }
        }
        if (value instanceof serde.NumericValue) {
          this.useReplacer = true;
        }
      }
      if (value === null && container?.isStructSchema()) {
        return;
      }
      if (ns.isStringSchema()) {
        if (typeof value === "undefined" && ns.isIdempotencyToken()) {
          return serde.generateIdempotencyToken();
        }
        const mediaType = ns.getMergedTraits().mediaType;
        if (value != null && mediaType) {
          const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
          if (isJson) {
            return serde.LazyJsonString.from(value);
          }
        }
        return value;
      }
      if (typeof value === "number" && ns.isNumericSchema()) {
        if (Math.abs(value) === Infinity || isNaN(value)) {
          return String(value);
        }
        return value;
      }
      if (typeof value === "string" && ns.isBlobSchema()) {
        if (ns === this.rootSchema) {
          return value;
        }
        return (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
      }
      if (typeof value === "bigint") {
        this.useReplacer = true;
      }
      if (ns.isDocumentSchema()) {
        if (isObject2) {
          const out = Array.isArray(value) ? [] : {};
          for (const [k, v] of Object.entries(value)) {
            if (v instanceof serde.NumericValue) {
              this.useReplacer = true;
              out[k] = v;
            } else {
              out[k] = this._write(ns, v);
            }
          }
          return out;
        } else {
          return structuredClone(value);
        }
      }
      return value;
    }
  }

  class JsonCodec extends SerdeContextConfig {
    settings;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    createSerializer() {
      const serializer = new JsonShapeSerializer(this.settings);
      serializer.setSerdeContext(this.serdeContext);
      return serializer;
    }
    createDeserializer() {
      const deserializer = new JsonShapeDeserializer(this.settings);
      deserializer.setSerdeContext(this.serdeContext);
      return deserializer;
    }
  }

  class AwsJsonRpcProtocol extends protocols.RpcProtocol {
    serializer;
    deserializer;
    serviceTarget;
    codec;
    mixin;
    awsQueryCompatible;
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec }) {
      super({
        defaultNamespace
      });
      this.serviceTarget = serviceTarget;
      this.codec = jsonCodec ?? new JsonCodec({
        timestampFormat: {
          useTrait: true,
          default: 7
        },
        jsonName: false
      });
      this.serializer = this.codec.createSerializer();
      this.deserializer = this.codec.createDeserializer();
      this.awsQueryCompatible = !!awsQueryCompatible;
      this.mixin = new ProtocolLib(this.awsQueryCompatible);
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      if (!request.path.endsWith("/")) {
        request.path += "/";
      }
      Object.assign(request.headers, {
        "content-type": `application/x-amz-json-${this.getJsonRpcVersion()}`,
        "x-amz-target": `${this.serviceTarget}.${operationSchema.name}`
      });
      if (this.awsQueryCompatible) {
        request.headers["x-amzn-query-mode"] = "true";
      }
      if (schema.deref(operationSchema.input) === "unit" || !request.body) {
        request.body = "{}";
      }
      return request;
    }
    getPayloadCodec() {
      return this.codec;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      if (this.awsQueryCompatible) {
        this.mixin.setQueryCompatError(dataObject, response);
      }
      const errorIdentifier = loadRestJsonErrorCode(response, dataObject) ?? "Unknown";
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata, this.awsQueryCompatible ? this.mixin.findQueryCompatibleError : undefined);
      const ns = schema.NormalizedSchema.of(errorSchema);
      const message3 = dataObject.message ?? dataObject.Message ?? "Unknown";
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message3);
      const output = {};
      for (const [name, member] of ns.structIterator()) {
        if (dataObject[name] != null) {
          output[name] = this.codec.createDeserializer().readObject(member, dataObject[name]);
        }
      }
      if (this.awsQueryCompatible) {
        this.mixin.queryCompatOutput(dataObject, output);
      }
      throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message: message3
      }, output), dataObject);
    }
  }

  class AwsJson1_0Protocol extends AwsJsonRpcProtocol {
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec }) {
      super({
        defaultNamespace,
        serviceTarget,
        awsQueryCompatible,
        jsonCodec
      });
    }
    getShapeId() {
      return "aws.protocols#awsJson1_0";
    }
    getJsonRpcVersion() {
      return "1.0";
    }
    getDefaultContentType() {
      return "application/x-amz-json-1.0";
    }
  }

  class AwsJson1_1Protocol extends AwsJsonRpcProtocol {
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec }) {
      super({
        defaultNamespace,
        serviceTarget,
        awsQueryCompatible,
        jsonCodec
      });
    }
    getShapeId() {
      return "aws.protocols#awsJson1_1";
    }
    getJsonRpcVersion() {
      return "1.1";
    }
    getDefaultContentType() {
      return "application/x-amz-json-1.1";
    }
  }

  class AwsRestJsonProtocol extends protocols.HttpBindingProtocol {
    serializer;
    deserializer;
    codec;
    mixin = new ProtocolLib;
    constructor({ defaultNamespace }) {
      super({
        defaultNamespace
      });
      const settings = {
        timestampFormat: {
          useTrait: true,
          default: 7
        },
        httpBindings: true,
        jsonName: true
      };
      this.codec = new JsonCodec(settings);
      this.serializer = new protocols.HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);
      this.deserializer = new protocols.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);
    }
    getShapeId() {
      return "aws.protocols#restJson1";
    }
    getPayloadCodec() {
      return this.codec;
    }
    setSerdeContext(serdeContext) {
      this.codec.setSerdeContext(serdeContext);
      super.setSerdeContext(serdeContext);
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      const inputSchema = schema.NormalizedSchema.of(operationSchema.input);
      if (!request.headers["content-type"]) {
        const contentType = this.mixin.resolveRestContentType(this.getDefaultContentType(), inputSchema);
        if (contentType) {
          request.headers["content-type"] = contentType;
        }
      }
      if (request.body == null && request.headers["content-type"] === this.getDefaultContentType()) {
        request.body = "{}";
      }
      return request;
    }
    async deserializeResponse(operationSchema, context, response) {
      const output = await super.deserializeResponse(operationSchema, context, response);
      const outputSchema = schema.NormalizedSchema.of(operationSchema.output);
      for (const [name, member] of outputSchema.structIterator()) {
        if (member.getMemberTraits().httpPayload && !(name in output)) {
          output[name] = null;
        }
      }
      return output;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      const errorIdentifier = loadRestJsonErrorCode(response, dataObject) ?? "Unknown";
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata);
      const ns = schema.NormalizedSchema.of(errorSchema);
      const message3 = dataObject.message ?? dataObject.Message ?? "Unknown";
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message3);
      await this.deserializeHttpMessage(errorSchema, context, response, dataObject);
      const output = {};
      for (const [name, member] of ns.structIterator()) {
        const target = member.getMergedTraits().jsonName ?? name;
        output[name] = this.codec.createDeserializer().readObject(member, dataObject[target]);
      }
      throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message: message3
      }, output), dataObject);
    }
    getDefaultContentType() {
      return "application/json";
    }
  }
  var awsExpectUnion = (value) => {
    if (value == null) {
      return;
    }
    if (typeof value === "object" && "__type" in value) {
      delete value.__type;
    }
    return smithyClient.expectUnion(value);
  };

  class XmlShapeDeserializer extends SerdeContextConfig {
    settings;
    stringDeserializer;
    constructor(settings) {
      super();
      this.settings = settings;
      this.stringDeserializer = new protocols.FromStringShapeDeserializer(settings);
    }
    setSerdeContext(serdeContext) {
      this.serdeContext = serdeContext;
      this.stringDeserializer.setSerdeContext(serdeContext);
    }
    read(schema$1, bytes, key) {
      const ns = schema.NormalizedSchema.of(schema$1);
      const memberSchemas = ns.getMemberSchemas();
      const isEventPayload = ns.isStructSchema() && ns.isMemberSchema() && !!Object.values(memberSchemas).find((memberNs) => {
        return !!memberNs.getMemberTraits().eventPayload;
      });
      if (isEventPayload) {
        const output = {};
        const memberName = Object.keys(memberSchemas)[0];
        const eventMemberSchema = memberSchemas[memberName];
        if (eventMemberSchema.isBlobSchema()) {
          output[memberName] = bytes;
        } else {
          output[memberName] = this.read(memberSchemas[memberName], bytes);
        }
        return output;
      }
      const xmlString = (this.serdeContext?.utf8Encoder ?? utilUtf8.toUtf8)(bytes);
      const parsedObject = this.parseXml(xmlString);
      return this.readSchema(schema$1, key ? parsedObject[key] : parsedObject);
    }
    readSchema(_schema, value) {
      const ns = schema.NormalizedSchema.of(_schema);
      if (ns.isUnitSchema()) {
        return;
      }
      const traits = ns.getMergedTraits();
      if (ns.isListSchema() && !Array.isArray(value)) {
        return this.readSchema(ns, [value]);
      }
      if (value == null) {
        return value;
      }
      if (typeof value === "object") {
        const sparse = !!traits.sparse;
        const flat = !!traits.xmlFlattened;
        if (ns.isListSchema()) {
          const listValue = ns.getValueSchema();
          const buffer2 = [];
          const sourceKey = listValue.getMergedTraits().xmlName ?? "member";
          const source = flat ? value : (value[0] ?? value)[sourceKey];
          const sourceArray = Array.isArray(source) ? source : [source];
          for (const v of sourceArray) {
            if (v != null || sparse) {
              buffer2.push(this.readSchema(listValue, v));
            }
          }
          return buffer2;
        }
        const buffer = {};
        if (ns.isMapSchema()) {
          const keyNs = ns.getKeySchema();
          const memberNs = ns.getValueSchema();
          let entries;
          if (flat) {
            entries = Array.isArray(value) ? value : [value];
          } else {
            entries = Array.isArray(value.entry) ? value.entry : [value.entry];
          }
          const keyProperty = keyNs.getMergedTraits().xmlName ?? "key";
          const valueProperty = memberNs.getMergedTraits().xmlName ?? "value";
          for (const entry of entries) {
            const key = entry[keyProperty];
            const value2 = entry[valueProperty];
            if (value2 != null || sparse) {
              buffer[key] = this.readSchema(memberNs, value2);
            }
          }
          return buffer;
        }
        if (ns.isStructSchema()) {
          const union = ns.isUnionSchema();
          let unionSerde;
          if (union) {
            unionSerde = new UnionSerde(value, buffer);
          }
          for (const [memberName, memberSchema] of ns.structIterator()) {
            const memberTraits = memberSchema.getMergedTraits();
            const xmlObjectKey = !memberTraits.httpPayload ? memberSchema.getMemberTraits().xmlName ?? memberName : memberTraits.xmlName ?? memberSchema.getName();
            if (union) {
              unionSerde.mark(xmlObjectKey);
            }
            if (value[xmlObjectKey] != null) {
              buffer[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);
            }
          }
          if (union) {
            unionSerde.writeUnknown();
          }
          return buffer;
        }
        if (ns.isDocumentSchema()) {
          return value;
        }
        throw new Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${ns.getName(true)}`);
      }
      if (ns.isListSchema()) {
        return [];
      }
      if (ns.isMapSchema() || ns.isStructSchema()) {
        return {};
      }
      return this.stringDeserializer.read(ns, value);
    }
    parseXml(xml) {
      if (xml.length) {
        let parsedObj;
        try {
          parsedObj = xmlBuilder.parseXML(xml);
        } catch (e) {
          if (e && typeof e === "object") {
            Object.defineProperty(e, "$responseBodyText", {
              value: xml
            });
          }
          throw e;
        }
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
          parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
          delete parsedObjToReturn[textNodeName];
        }
        return smithyClient.getValueFromTextNode(parsedObjToReturn);
      }
      return {};
    }
  }

  class QueryShapeSerializer extends SerdeContextConfig {
    settings;
    buffer;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    write(schema$1, value, prefix = "") {
      if (this.buffer === undefined) {
        this.buffer = "";
      }
      const ns = schema.NormalizedSchema.of(schema$1);
      if (prefix && !prefix.endsWith(".")) {
        prefix += ".";
      }
      if (ns.isBlobSchema()) {
        if (typeof value === "string" || value instanceof Uint8Array) {
          this.writeKey(prefix);
          this.writeValue((this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value));
        }
      } else if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isStringSchema()) {
        if (value != null) {
          this.writeKey(prefix);
          this.writeValue(String(value));
        } else if (ns.isIdempotencyToken()) {
          this.writeKey(prefix);
          this.writeValue(serde.generateIdempotencyToken());
        }
      } else if (ns.isBigIntegerSchema()) {
        if (value != null) {
          this.writeKey(prefix);
          this.writeValue(String(value));
        }
      } else if (ns.isBigDecimalSchema()) {
        if (value != null) {
          this.writeKey(prefix);
          this.writeValue(value instanceof serde.NumericValue ? value.string : String(value));
        }
      } else if (ns.isTimestampSchema()) {
        if (value instanceof Date) {
          this.writeKey(prefix);
          const format = protocols.determineTimestampFormat(ns, this.settings);
          switch (format) {
            case 5:
              this.writeValue(value.toISOString().replace(".000Z", "Z"));
              break;
            case 6:
              this.writeValue(smithyClient.dateToUtcString(value));
              break;
            case 7:
              this.writeValue(String(value.getTime() / 1000));
              break;
          }
        }
      } else if (ns.isDocumentSchema()) {
        if (Array.isArray(value)) {
          this.write(64 | 15, value, prefix);
        } else if (value instanceof Date) {
          this.write(4, value, prefix);
        } else if (value instanceof Uint8Array) {
          this.write(21, value, prefix);
        } else if (value && typeof value === "object") {
          this.write(128 | 15, value, prefix);
        } else {
          this.writeKey(prefix);
          this.writeValue(String(value));
        }
      } else if (ns.isListSchema()) {
        if (Array.isArray(value)) {
          if (value.length === 0) {
            if (this.settings.serializeEmptyLists) {
              this.writeKey(prefix);
              this.writeValue("");
            }
          } else {
            const member = ns.getValueSchema();
            const flat = this.settings.flattenLists || ns.getMergedTraits().xmlFlattened;
            let i2 = 1;
            for (const item of value) {
              if (item == null) {
                continue;
              }
              const traits = member.getMergedTraits();
              const suffix = this.getKey("member", traits.xmlName, traits.ec2QueryName);
              const key = flat ? `${prefix}${i2}` : `${prefix}${suffix}.${i2}`;
              this.write(member, item, key);
              ++i2;
            }
          }
        }
      } else if (ns.isMapSchema()) {
        if (value && typeof value === "object") {
          const keySchema = ns.getKeySchema();
          const memberSchema = ns.getValueSchema();
          const flat = ns.getMergedTraits().xmlFlattened;
          let i2 = 1;
          for (const [k, v] of Object.entries(value)) {
            if (v == null) {
              continue;
            }
            const keyTraits = keySchema.getMergedTraits();
            const keySuffix = this.getKey("key", keyTraits.xmlName, keyTraits.ec2QueryName);
            const key = flat ? `${prefix}${i2}.${keySuffix}` : `${prefix}entry.${i2}.${keySuffix}`;
            const valTraits = memberSchema.getMergedTraits();
            const valueSuffix = this.getKey("value", valTraits.xmlName, valTraits.ec2QueryName);
            const valueKey = flat ? `${prefix}${i2}.${valueSuffix}` : `${prefix}entry.${i2}.${valueSuffix}`;
            this.write(keySchema, k, key);
            this.write(memberSchema, v, valueKey);
            ++i2;
          }
        }
      } else if (ns.isStructSchema()) {
        if (value && typeof value === "object") {
          let didWriteMember = false;
          for (const [memberName, member] of ns.structIterator()) {
            if (value[memberName] == null && !member.isIdempotencyToken()) {
              continue;
            }
            const traits = member.getMergedTraits();
            const suffix = this.getKey(memberName, traits.xmlName, traits.ec2QueryName, "struct");
            const key = `${prefix}${suffix}`;
            this.write(member, value[memberName], key);
            didWriteMember = true;
          }
          if (!didWriteMember && ns.isUnionSchema()) {
            const { $unknown } = value;
            if (Array.isArray($unknown)) {
              const [k, v] = $unknown;
              const key = `${prefix}${k}`;
              this.write(15, v, key);
            }
          }
        }
      } else if (ns.isUnitSchema())
        ;
      else {
        throw new Error(`@aws-sdk/core/protocols - QuerySerializer unrecognized schema type ${ns.getName(true)}`);
      }
    }
    flush() {
      if (this.buffer === undefined) {
        throw new Error("@aws-sdk/core/protocols - QuerySerializer cannot flush with nothing written to buffer.");
      }
      const str = this.buffer;
      delete this.buffer;
      return str;
    }
    getKey(memberName, xmlName, ec2QueryName, keySource) {
      const { ec2, capitalizeKeys } = this.settings;
      if (ec2 && ec2QueryName) {
        return ec2QueryName;
      }
      const key = xmlName ?? memberName;
      if (capitalizeKeys && keySource === "struct") {
        return key[0].toUpperCase() + key.slice(1);
      }
      return key;
    }
    writeKey(key) {
      if (key.endsWith(".")) {
        key = key.slice(0, key.length - 1);
      }
      this.buffer += `&${protocols.extendedEncodeURIComponent(key)}=`;
    }
    writeValue(value) {
      this.buffer += protocols.extendedEncodeURIComponent(value);
    }
  }

  class AwsQueryProtocol extends protocols.RpcProtocol {
    options;
    serializer;
    deserializer;
    mixin = new ProtocolLib;
    constructor(options) {
      super({
        defaultNamespace: options.defaultNamespace
      });
      this.options = options;
      const settings = {
        timestampFormat: {
          useTrait: true,
          default: 5
        },
        httpBindings: false,
        xmlNamespace: options.xmlNamespace,
        serviceNamespace: options.defaultNamespace,
        serializeEmptyLists: true
      };
      this.serializer = new QueryShapeSerializer(settings);
      this.deserializer = new XmlShapeDeserializer(settings);
    }
    getShapeId() {
      return "aws.protocols#awsQuery";
    }
    setSerdeContext(serdeContext) {
      this.serializer.setSerdeContext(serdeContext);
      this.deserializer.setSerdeContext(serdeContext);
    }
    getPayloadCodec() {
      throw new Error("AWSQuery protocol has no payload codec.");
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      if (!request.path.endsWith("/")) {
        request.path += "/";
      }
      Object.assign(request.headers, {
        "content-type": `application/x-www-form-urlencoded`
      });
      if (schema.deref(operationSchema.input) === "unit" || !request.body) {
        request.body = "";
      }
      const action = operationSchema.name.split("#")[1] ?? operationSchema.name;
      request.body = `Action=${action}&Version=${this.options.version}` + request.body;
      if (request.body.endsWith("&")) {
        request.body = request.body.slice(-1);
      }
      return request;
    }
    async deserializeResponse(operationSchema, context, response) {
      const deserializer = this.deserializer;
      const ns = schema.NormalizedSchema.of(operationSchema.output);
      const dataObject = {};
      if (response.statusCode >= 300) {
        const bytes2 = await protocols.collectBody(response.body, context);
        if (bytes2.byteLength > 0) {
          Object.assign(dataObject, await deserializer.read(15, bytes2));
        }
        await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));
      }
      for (const header in response.headers) {
        const value = response.headers[header];
        delete response.headers[header];
        response.headers[header.toLowerCase()] = value;
      }
      const shortName = operationSchema.name.split("#")[1] ?? operationSchema.name;
      const awsQueryResultKey = ns.isStructSchema() && this.useNestedResult() ? shortName + "Result" : undefined;
      const bytes = await protocols.collectBody(response.body, context);
      if (bytes.byteLength > 0) {
        Object.assign(dataObject, await deserializer.read(ns, bytes, awsQueryResultKey));
      }
      const output = {
        $metadata: this.deserializeMetadata(response),
        ...dataObject
      };
      return output;
    }
    useNestedResult() {
      return true;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      const errorIdentifier = this.loadQueryErrorCode(response, dataObject) ?? "Unknown";
      const errorData = this.loadQueryError(dataObject) ?? {};
      const message3 = this.loadQueryErrorMessage(dataObject);
      errorData.message = message3;
      errorData.Error = {
        Type: errorData.Type,
        Code: errorData.Code,
        Message: message3
      };
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, errorData, metadata, this.mixin.findQueryCompatibleError);
      const ns = schema.NormalizedSchema.of(errorSchema);
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message3);
      const output = {
        Type: errorData.Error.Type,
        Code: errorData.Error.Code,
        Error: errorData.Error
      };
      for (const [name, member] of ns.structIterator()) {
        const target = member.getMergedTraits().xmlName ?? name;
        const value = errorData[target] ?? dataObject[target];
        output[name] = this.deserializer.readSchema(member, value);
      }
      throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message: message3
      }, output), dataObject);
    }
    loadQueryErrorCode(output, data) {
      const code = (data.Errors?.[0]?.Error ?? data.Errors?.Error ?? data.Error)?.Code;
      if (code !== undefined) {
        return code;
      }
      if (output.statusCode == 404) {
        return "NotFound";
      }
    }
    loadQueryError(data) {
      return data.Errors?.[0]?.Error ?? data.Errors?.Error ?? data.Error;
    }
    loadQueryErrorMessage(data) {
      const errorData = this.loadQueryError(data);
      return errorData?.message ?? errorData?.Message ?? data.message ?? data.Message ?? "Unknown";
    }
    getDefaultContentType() {
      return "application/x-www-form-urlencoded";
    }
  }

  class AwsEc2QueryProtocol extends AwsQueryProtocol {
    options;
    constructor(options) {
      super(options);
      this.options = options;
      const ec2Settings = {
        capitalizeKeys: true,
        flattenLists: true,
        serializeEmptyLists: false,
        ec2: true
      };
      Object.assign(this.serializer.settings, ec2Settings);
    }
    useNestedResult() {
      return false;
    }
  }
  var parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      let parsedObj;
      try {
        parsedObj = xmlBuilder.parseXML(encoded);
      } catch (e) {
        if (e && typeof e === "object") {
          Object.defineProperty(e, "$responseBodyText", {
            value: encoded
          });
        }
        throw e;
      }
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return smithyClient.getValueFromTextNode(parsedObjToReturn);
    }
    return {};
  });
  var parseXmlErrorBody = async (errorBody, context) => {
    const value = await parseXmlBody(errorBody, context);
    if (value.Error) {
      value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
  };
  var loadRestXmlErrorCode = (output, data) => {
    if (data?.Error?.Code !== undefined) {
      return data.Error.Code;
    }
    if (data?.Code !== undefined) {
      return data.Code;
    }
    if (output.statusCode == 404) {
      return "NotFound";
    }
  };

  class XmlShapeSerializer extends SerdeContextConfig {
    settings;
    stringBuffer;
    byteBuffer;
    buffer;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    write(schema$1, value) {
      const ns = schema.NormalizedSchema.of(schema$1);
      if (ns.isStringSchema() && typeof value === "string") {
        this.stringBuffer = value;
      } else if (ns.isBlobSchema()) {
        this.byteBuffer = "byteLength" in value ? value : (this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(value);
      } else {
        this.buffer = this.writeStruct(ns, value, undefined);
        const traits = ns.getMergedTraits();
        if (traits.httpPayload && !traits.xmlName) {
          this.buffer.withName(ns.getName());
        }
      }
    }
    flush() {
      if (this.byteBuffer !== undefined) {
        const bytes = this.byteBuffer;
        delete this.byteBuffer;
        return bytes;
      }
      if (this.stringBuffer !== undefined) {
        const str = this.stringBuffer;
        delete this.stringBuffer;
        return str;
      }
      const buffer = this.buffer;
      if (this.settings.xmlNamespace) {
        if (!buffer?.attributes?.["xmlns"]) {
          buffer.addAttribute("xmlns", this.settings.xmlNamespace);
        }
      }
      delete this.buffer;
      return buffer.toString();
    }
    writeStruct(ns, value, parentXmlns) {
      const traits = ns.getMergedTraits();
      const name = ns.isMemberSchema() && !traits.httpPayload ? ns.getMemberTraits().xmlName ?? ns.getMemberName() : traits.xmlName ?? ns.getName();
      if (!name || !ns.isStructSchema()) {
        throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${ns.getName(true)}.`);
      }
      const structXmlNode = xmlBuilder.XmlNode.of(name);
      const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);
      for (const [memberName, memberSchema] of ns.structIterator()) {
        const val = value[memberName];
        if (val != null || memberSchema.isIdempotencyToken()) {
          if (memberSchema.getMergedTraits().xmlAttribute) {
            structXmlNode.addAttribute(memberSchema.getMergedTraits().xmlName ?? memberName, this.writeSimple(memberSchema, val));
            continue;
          }
          if (memberSchema.isListSchema()) {
            this.writeList(memberSchema, val, structXmlNode, xmlns);
          } else if (memberSchema.isMapSchema()) {
            this.writeMap(memberSchema, val, structXmlNode, xmlns);
          } else if (memberSchema.isStructSchema()) {
            structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));
          } else {
            const memberNode = xmlBuilder.XmlNode.of(memberSchema.getMergedTraits().xmlName ?? memberSchema.getMemberName());
            this.writeSimpleInto(memberSchema, val, memberNode, xmlns);
            structXmlNode.addChildNode(memberNode);
          }
        }
      }
      const { $unknown } = value;
      if ($unknown && ns.isUnionSchema() && Array.isArray($unknown) && Object.keys(value).length === 1) {
        const [k, v] = $unknown;
        const node = xmlBuilder.XmlNode.of(k);
        if (typeof v !== "string") {
          if (value instanceof xmlBuilder.XmlNode || value instanceof xmlBuilder.XmlText) {
            structXmlNode.addChildNode(value);
          } else {
            throw new Error(`@aws-sdk - $unknown union member in XML requires ` + `value of type string, @aws-sdk/xml-builder::XmlNode or XmlText.`);
          }
        }
        this.writeSimpleInto(0, v, node, xmlns);
        structXmlNode.addChildNode(node);
      }
      if (xmlns) {
        structXmlNode.addAttribute(xmlnsAttr, xmlns);
      }
      return structXmlNode;
    }
    writeList(listMember, array, container, parentXmlns) {
      if (!listMember.isMemberSchema()) {
        throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${listMember.getName(true)}`);
      }
      const listTraits = listMember.getMergedTraits();
      const listValueSchema = listMember.getValueSchema();
      const listValueTraits = listValueSchema.getMergedTraits();
      const sparse = !!listValueTraits.sparse;
      const flat = !!listTraits.xmlFlattened;
      const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);
      const writeItem = (container2, value) => {
        if (listValueSchema.isListSchema()) {
          this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container2, xmlns);
        } else if (listValueSchema.isMapSchema()) {
          this.writeMap(listValueSchema, value, container2, xmlns);
        } else if (listValueSchema.isStructSchema()) {
          const struct = this.writeStruct(listValueSchema, value, xmlns);
          container2.addChildNode(struct.withName(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? "member"));
        } else {
          const listItemNode = xmlBuilder.XmlNode.of(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? "member");
          this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);
          container2.addChildNode(listItemNode);
        }
      };
      if (flat) {
        for (const value of array) {
          if (sparse || value != null) {
            writeItem(container, value);
          }
        }
      } else {
        const listNode = xmlBuilder.XmlNode.of(listTraits.xmlName ?? listMember.getMemberName());
        if (xmlns) {
          listNode.addAttribute(xmlnsAttr, xmlns);
        }
        for (const value of array) {
          if (sparse || value != null) {
            writeItem(listNode, value);
          }
        }
        container.addChildNode(listNode);
      }
    }
    writeMap(mapMember, map, container, parentXmlns, containerIsMap = false) {
      if (!mapMember.isMemberSchema()) {
        throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${mapMember.getName(true)}`);
      }
      const mapTraits = mapMember.getMergedTraits();
      const mapKeySchema = mapMember.getKeySchema();
      const mapKeyTraits = mapKeySchema.getMergedTraits();
      const keyTag = mapKeyTraits.xmlName ?? "key";
      const mapValueSchema = mapMember.getValueSchema();
      const mapValueTraits = mapValueSchema.getMergedTraits();
      const valueTag = mapValueTraits.xmlName ?? "value";
      const sparse = !!mapValueTraits.sparse;
      const flat = !!mapTraits.xmlFlattened;
      const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);
      const addKeyValue = (entry, key, val) => {
        const keyNode = xmlBuilder.XmlNode.of(keyTag, key);
        const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);
        if (keyXmlns) {
          keyNode.addAttribute(keyXmlnsAttr, keyXmlns);
        }
        entry.addChildNode(keyNode);
        let valueNode = xmlBuilder.XmlNode.of(valueTag);
        if (mapValueSchema.isListSchema()) {
          this.writeList(mapValueSchema, val, valueNode, xmlns);
        } else if (mapValueSchema.isMapSchema()) {
          this.writeMap(mapValueSchema, val, valueNode, xmlns, true);
        } else if (mapValueSchema.isStructSchema()) {
          valueNode = this.writeStruct(mapValueSchema, val, xmlns);
        } else {
          this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);
        }
        entry.addChildNode(valueNode);
      };
      if (flat) {
        for (const [key, val] of Object.entries(map)) {
          if (sparse || val != null) {
            const entry = xmlBuilder.XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());
            addKeyValue(entry, key, val);
            container.addChildNode(entry);
          }
        }
      } else {
        let mapNode;
        if (!containerIsMap) {
          mapNode = xmlBuilder.XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());
          if (xmlns) {
            mapNode.addAttribute(xmlnsAttr, xmlns);
          }
          container.addChildNode(mapNode);
        }
        for (const [key, val] of Object.entries(map)) {
          if (sparse || val != null) {
            const entry = xmlBuilder.XmlNode.of("entry");
            addKeyValue(entry, key, val);
            (containerIsMap ? container : mapNode).addChildNode(entry);
          }
        }
      }
    }
    writeSimple(_schema, value) {
      if (value === null) {
        throw new Error("@aws-sdk/core/protocols - (XML serializer) cannot write null value.");
      }
      const ns = schema.NormalizedSchema.of(_schema);
      let nodeContents = null;
      if (value && typeof value === "object") {
        if (ns.isBlobSchema()) {
          nodeContents = (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
        } else if (ns.isTimestampSchema() && value instanceof Date) {
          const format = protocols.determineTimestampFormat(ns, this.settings);
          switch (format) {
            case 5:
              nodeContents = value.toISOString().replace(".000Z", "Z");
              break;
            case 6:
              nodeContents = smithyClient.dateToUtcString(value);
              break;
            case 7:
              nodeContents = String(value.getTime() / 1000);
              break;
            default:
              console.warn("Missing timestamp format, using http date", value);
              nodeContents = smithyClient.dateToUtcString(value);
              break;
          }
        } else if (ns.isBigDecimalSchema() && value) {
          if (value instanceof serde.NumericValue) {
            return value.string;
          }
          return String(value);
        } else if (ns.isMapSchema() || ns.isListSchema()) {
          throw new Error("@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.");
        } else {
          throw new Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${ns.getName(true)}`);
        }
      }
      if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isBigIntegerSchema() || ns.isBigDecimalSchema()) {
        nodeContents = String(value);
      }
      if (ns.isStringSchema()) {
        if (value === undefined && ns.isIdempotencyToken()) {
          nodeContents = serde.generateIdempotencyToken();
        } else {
          nodeContents = String(value);
        }
      }
      if (nodeContents === null) {
        throw new Error(`Unhandled schema-value pair ${ns.getName(true)}=${value}`);
      }
      return nodeContents;
    }
    writeSimpleInto(_schema, value, into, parentXmlns) {
      const nodeContents = this.writeSimple(_schema, value);
      const ns = schema.NormalizedSchema.of(_schema);
      const content = new xmlBuilder.XmlText(nodeContents);
      const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);
      if (xmlns) {
        into.addAttribute(xmlnsAttr, xmlns);
      }
      into.addChildNode(content);
    }
    getXmlnsAttribute(ns, parentXmlns) {
      const traits = ns.getMergedTraits();
      const [prefix, xmlns] = traits.xmlNamespace ?? [];
      if (xmlns && xmlns !== parentXmlns) {
        return [prefix ? `xmlns:${prefix}` : "xmlns", xmlns];
      }
      return [undefined, undefined];
    }
  }

  class XmlCodec extends SerdeContextConfig {
    settings;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    createSerializer() {
      const serializer = new XmlShapeSerializer(this.settings);
      serializer.setSerdeContext(this.serdeContext);
      return serializer;
    }
    createDeserializer() {
      const deserializer = new XmlShapeDeserializer(this.settings);
      deserializer.setSerdeContext(this.serdeContext);
      return deserializer;
    }
  }

  class AwsRestXmlProtocol extends protocols.HttpBindingProtocol {
    codec;
    serializer;
    deserializer;
    mixin = new ProtocolLib;
    constructor(options) {
      super(options);
      const settings = {
        timestampFormat: {
          useTrait: true,
          default: 5
        },
        httpBindings: true,
        xmlNamespace: options.xmlNamespace,
        serviceNamespace: options.defaultNamespace
      };
      this.codec = new XmlCodec(settings);
      this.serializer = new protocols.HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);
      this.deserializer = new protocols.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);
    }
    getPayloadCodec() {
      return this.codec;
    }
    getShapeId() {
      return "aws.protocols#restXml";
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      const inputSchema = schema.NormalizedSchema.of(operationSchema.input);
      if (!request.headers["content-type"]) {
        const contentType = this.mixin.resolveRestContentType(this.getDefaultContentType(), inputSchema);
        if (contentType) {
          request.headers["content-type"] = contentType;
        }
      }
      if (typeof request.body === "string" && request.headers["content-type"] === this.getDefaultContentType() && !request.body.startsWith("<?xml ") && !this.hasUnstructuredPayloadBinding(inputSchema)) {
        request.body = '<?xml version="1.0" encoding="UTF-8"?>' + request.body;
      }
      return request;
    }
    async deserializeResponse(operationSchema, context, response) {
      return super.deserializeResponse(operationSchema, context, response);
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      const errorIdentifier = loadRestXmlErrorCode(response, dataObject) ?? "Unknown";
      if (dataObject.Error && typeof dataObject.Error === "object") {
        for (const key of Object.keys(dataObject.Error)) {
          dataObject[key] = dataObject.Error[key];
          if (key.toLowerCase() === "message") {
            dataObject.message = dataObject.Error[key];
          }
        }
      }
      if (dataObject.RequestId && !metadata.requestId) {
        metadata.requestId = dataObject.RequestId;
      }
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata);
      const ns = schema.NormalizedSchema.of(errorSchema);
      const message3 = dataObject.Error?.message ?? dataObject.Error?.Message ?? dataObject.message ?? dataObject.Message ?? "Unknown";
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message3);
      await this.deserializeHttpMessage(errorSchema, context, response, dataObject);
      const output = {};
      for (const [name, member] of ns.structIterator()) {
        const target = member.getMergedTraits().xmlName ?? name;
        const value = dataObject.Error?.[target] ?? dataObject[target];
        output[name] = this.codec.createDeserializer().readSchema(member, value);
      }
      throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message: message3
      }, output), dataObject);
    }
    getDefaultContentType() {
      return "application/xml";
    }
    hasUnstructuredPayloadBinding(ns) {
      for (const [, member] of ns.structIterator()) {
        if (member.getMergedTraits().httpPayload) {
          return !(member.isStructSchema() || member.isMapSchema() || member.isListSchema());
        }
      }
      return false;
    }
  }
  exports.AWSSDKSigV4Signer = AWSSDKSigV4Signer;
  exports.AwsEc2QueryProtocol = AwsEc2QueryProtocol;
  exports.AwsJson1_0Protocol = AwsJson1_0Protocol;
  exports.AwsJson1_1Protocol = AwsJson1_1Protocol;
  exports.AwsJsonRpcProtocol = AwsJsonRpcProtocol;
  exports.AwsQueryProtocol = AwsQueryProtocol;
  exports.AwsRestJsonProtocol = AwsRestJsonProtocol;
  exports.AwsRestXmlProtocol = AwsRestXmlProtocol;
  exports.AwsSdkSigV4ASigner = AwsSdkSigV4ASigner;
  exports.AwsSdkSigV4Signer = AwsSdkSigV4Signer;
  exports.AwsSmithyRpcV2CborProtocol = AwsSmithyRpcV2CborProtocol;
  exports.JsonCodec = JsonCodec;
  exports.JsonShapeDeserializer = JsonShapeDeserializer;
  exports.JsonShapeSerializer = JsonShapeSerializer;
  exports.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS = NODE_AUTH_SCHEME_PREFERENCE_OPTIONS;
  exports.NODE_SIGV4A_CONFIG_OPTIONS = NODE_SIGV4A_CONFIG_OPTIONS;
  exports.XmlCodec = XmlCodec;
  exports.XmlShapeDeserializer = XmlShapeDeserializer;
  exports.XmlShapeSerializer = XmlShapeSerializer;
  exports._toBool = _toBool;
  exports._toNum = _toNum;
  exports._toStr = _toStr;
  exports.awsExpectUnion = awsExpectUnion;
  exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;
  exports.getBearerTokenEnvKey = getBearerTokenEnvKey;
  exports.loadRestJsonErrorCode = loadRestJsonErrorCode;
  exports.loadRestXmlErrorCode = loadRestXmlErrorCode;
  exports.parseJsonBody = parseJsonBody;
  exports.parseJsonErrorBody = parseJsonErrorBody;
  exports.parseXmlBody = parseXmlBody;
  exports.parseXmlErrorBody = parseXmlErrorBody;
  exports.resolveAWSSDKSigV4Config = resolveAWSSDKSigV4Config;
  exports.resolveAwsSdkSigV4AConfig = resolveAwsSdkSigV4AConfig;
  exports.resolveAwsSdkSigV4Config = resolveAwsSdkSigV4Config;
  exports.setCredentialFeature = setCredentialFeature;
  exports.setFeature = setFeature;
  exports.setTokenFeature = setTokenFeature;
  exports.state = state;
  exports.validateSigningProperties = validateSigningProperties;
});

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/node_modules/@smithy/util-buffer-from/node_modules/@smithy/is-array-buffer/dist-cjs/index.js
var require_dist_cjs25 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    isArrayBuffer: () => isArrayBuffer
  });
  module.exports = __toCommonJS(src_exports);
  var isArrayBuffer = /* @__PURE__ */ __name((arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]", "isArrayBuffer");
});

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/node_modules/@smithy/util-buffer-from/dist-cjs/index.js
var require_dist_cjs26 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    fromArrayBuffer: () => fromArrayBuffer,
    fromString: () => fromString
  });
  module.exports = __toCommonJS(src_exports);
  var import_is_array_buffer = require_dist_cjs25();
  var import_buffer = __require("buffer");
  var fromArrayBuffer = /* @__PURE__ */ __name((input, offset2 = 0, length = input.byteLength - offset2) => {
    if (!(0, import_is_array_buffer.isArrayBuffer)(input)) {
      throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return import_buffer.Buffer.from(input, offset2, length);
  }, "fromArrayBuffer");
  var fromString = /* @__PURE__ */ __name((input, encoding) => {
    if (typeof input !== "string") {
      throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? import_buffer.Buffer.from(input, encoding) : import_buffer.Buffer.from(input);
  }, "fromString");
});

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-cjs/index.js
var require_dist_cjs27 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    fromUtf8: () => fromUtf8,
    toUint8Array: () => toUint8Array,
    toUtf8: () => toUtf8
  });
  module.exports = __toCommonJS(src_exports);
  var import_util_buffer_from = require_dist_cjs26();
  var fromUtf8 = /* @__PURE__ */ __name((input) => {
    const buf = (0, import_util_buffer_from.fromString)(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }, "fromUtf8");
  var toUint8Array = /* @__PURE__ */ __name((data) => {
    if (typeof data === "string") {
      return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  }, "toUint8Array");
  var toUtf8 = /* @__PURE__ */ __name((input) => {
    if (typeof input === "string") {
      return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
      throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return (0, import_util_buffer_from.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
  }, "toUtf8");
});

// node_modules/@aws-crypto/util/build/main/convertToBuffer.js
var require_convertToBuffer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertToBuffer = undefined;
  var util_utf8_1 = require_dist_cjs27();
  var fromUtf8 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
    return Buffer.from(input, "utf8");
  } : util_utf8_1.fromUtf8;
  function convertToBuffer(data) {
    if (data instanceof Uint8Array)
      return data;
    if (typeof data === "string") {
      return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  }
  exports.convertToBuffer = convertToBuffer;
});

// node_modules/@aws-crypto/util/build/main/isEmptyData.js
var require_isEmptyData = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEmptyData = undefined;
  function isEmptyData(data) {
    if (typeof data === "string") {
      return data.length === 0;
    }
    return data.byteLength === 0;
  }
  exports.isEmptyData = isEmptyData;
});

// node_modules/@aws-crypto/util/build/main/numToUint8.js
var require_numToUint8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.numToUint8 = undefined;
  function numToUint8(num) {
    return new Uint8Array([
      (num & 4278190080) >> 24,
      (num & 16711680) >> 16,
      (num & 65280) >> 8,
      num & 255
    ]);
  }
  exports.numToUint8 = numToUint8;
});

// node_modules/@aws-crypto/util/build/main/uint32ArrayFrom.js
var require_uint32ArrayFrom = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uint32ArrayFrom = undefined;
  function uint32ArrayFrom(a_lookUpTable) {
    if (!Uint32Array.from) {
      var return_array = new Uint32Array(a_lookUpTable.length);
      var a_index = 0;
      while (a_index < a_lookUpTable.length) {
        return_array[a_index] = a_lookUpTable[a_index];
        a_index += 1;
      }
      return return_array;
    }
    return Uint32Array.from(a_lookUpTable);
  }
  exports.uint32ArrayFrom = uint32ArrayFrom;
});

// node_modules/@aws-crypto/util/build/main/index.js
var require_main = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = undefined;
  var convertToBuffer_1 = require_convertToBuffer();
  Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
    return convertToBuffer_1.convertToBuffer;
  } });
  var isEmptyData_1 = require_isEmptyData();
  Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
    return isEmptyData_1.isEmptyData;
  } });
  var numToUint8_1 = require_numToUint8();
  Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
    return numToUint8_1.numToUint8;
  } });
  var uint32ArrayFrom_1 = require_uint32ArrayFrom();
  Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
    return uint32ArrayFrom_1.uint32ArrayFrom;
  } });
});

// node_modules/@aws-crypto/crc32c/build/main/aws_crc32c.js
var require_aws_crc32c = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AwsCrc32c = undefined;
  var tslib_1 = require_tslib();
  var util_1 = require_main();
  var index_1 = require_main2();
  var AwsCrc32c = function() {
    function AwsCrc32c2() {
      this.crc32c = new index_1.Crc32c;
    }
    AwsCrc32c2.prototype.update = function(toHash) {
      if ((0, util_1.isEmptyData)(toHash))
        return;
      this.crc32c.update((0, util_1.convertToBuffer)(toHash));
    };
    AwsCrc32c2.prototype.digest = function() {
      return tslib_1.__awaiter(this, undefined, undefined, function() {
        return tslib_1.__generator(this, function(_a) {
          return [2, (0, util_1.numToUint8)(this.crc32c.digest())];
        });
      });
    };
    AwsCrc32c2.prototype.reset = function() {
      this.crc32c = new index_1.Crc32c;
    };
    return AwsCrc32c2;
  }();
  exports.AwsCrc32c = AwsCrc32c;
});

// node_modules/@aws-crypto/crc32c/build/main/index.js
var require_main2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AwsCrc32c = exports.Crc32c = exports.crc32c = undefined;
  var tslib_1 = require_tslib();
  var util_1 = require_main();
  function crc32c(data) {
    return new Crc32c().update(data).digest();
  }
  exports.crc32c = crc32c;
  var Crc32c = function() {
    function Crc32c2() {
      this.checksum = 4294967295;
    }
    Crc32c2.prototype.update = function(data) {
      var e_1, _a;
      try {
        for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next();!data_1_1.done; data_1_1 = data_1.next()) {
          var byte = data_1_1.value;
          this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a = data_1.return))
            _a.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return this;
    };
    Crc32c2.prototype.digest = function() {
      return (this.checksum ^ 4294967295) >>> 0;
    };
    return Crc32c2;
  }();
  exports.Crc32c = Crc32c;
  var a_lookupTable = [
    0,
    4067132163,
    3778769143,
    324072436,
    3348797215,
    904991772,
    648144872,
    3570033899,
    2329499855,
    2024987596,
    1809983544,
    2575936315,
    1296289744,
    3207089363,
    2893594407,
    1578318884,
    274646895,
    3795141740,
    4049975192,
    51262619,
    3619967088,
    632279923,
    922689671,
    3298075524,
    2592579488,
    1760304291,
    2075979607,
    2312596564,
    1562183871,
    2943781820,
    3156637768,
    1313733451,
    549293790,
    3537243613,
    3246849577,
    871202090,
    3878099393,
    357341890,
    102525238,
    4101499445,
    2858735121,
    1477399826,
    1264559846,
    3107202533,
    1845379342,
    2677391885,
    2361733625,
    2125378298,
    820201905,
    3263744690,
    3520608582,
    598981189,
    4151959214,
    85089709,
    373468761,
    3827903834,
    3124367742,
    1213305469,
    1526817161,
    2842354314,
    2107672161,
    2412447074,
    2627466902,
    1861252501,
    1098587580,
    3004210879,
    2688576843,
    1378610760,
    2262928035,
    1955203488,
    1742404180,
    2511436119,
    3416409459,
    969524848,
    714683780,
    3639785095,
    205050476,
    4266873199,
    3976438427,
    526918040,
    1361435347,
    2739821008,
    2954799652,
    1114974503,
    2529119692,
    1691668175,
    2005155131,
    2247081528,
    3690758684,
    697762079,
    986182379,
    3366744552,
    476452099,
    3993867776,
    4250756596,
    255256311,
    1640403810,
    2477592673,
    2164122517,
    1922457750,
    2791048317,
    1412925310,
    1197962378,
    3037525897,
    3944729517,
    427051182,
    170179418,
    4165941337,
    746937522,
    3740196785,
    3451792453,
    1070968646,
    1905808397,
    2213795598,
    2426610938,
    1657317369,
    3053634322,
    1147748369,
    1463399397,
    2773627110,
    4215344322,
    153784257,
    444234805,
    3893493558,
    1021025245,
    3467647198,
    3722505002,
    797665321,
    2197175160,
    1889384571,
    1674398607,
    2443626636,
    1164749927,
    3070701412,
    2757221520,
    1446797203,
    137323447,
    4198817972,
    3910406976,
    461344835,
    3484808360,
    1037989803,
    781091935,
    3705997148,
    2460548119,
    1623424788,
    1939049696,
    2180517859,
    1429367560,
    2807687179,
    3020495871,
    1180866812,
    410100952,
    3927582683,
    4182430767,
    186734380,
    3756733383,
    763408580,
    1053836080,
    3434856499,
    2722870694,
    1344288421,
    1131464017,
    2971354706,
    1708204729,
    2545590714,
    2229949006,
    1988219213,
    680717673,
    3673779818,
    3383336350,
    1002577565,
    4010310262,
    493091189,
    238226049,
    4233660802,
    2987750089,
    1082061258,
    1395524158,
    2705686845,
    1972364758,
    2279892693,
    2494862625,
    1725896226,
    952904198,
    3399985413,
    3656866545,
    731699698,
    4283874585,
    222117402,
    510512622,
    3959836397,
    3280807620,
    837199303,
    582374963,
    3504198960,
    68661723,
    4135334616,
    3844915500,
    390545967,
    1230274059,
    3141532936,
    2825850620,
    1510247935,
    2395924756,
    2091215383,
    1878366691,
    2644384480,
    3553878443,
    565732008,
    854102364,
    3229815391,
    340358836,
    3861050807,
    4117890627,
    119113024,
    1493875044,
    2875275879,
    3090270611,
    1247431312,
    2660249211,
    1828433272,
    2141937292,
    2378227087,
    3811616794,
    291187481,
    34330861,
    4032846830,
    615137029,
    3603020806,
    3314634738,
    939183345,
    1776939221,
    2609017814,
    2295496738,
    2058945313,
    2926798794,
    1545135305,
    1330124605,
    3173225534,
    4084100981,
    17165430,
    307568514,
    3762199681,
    888469610,
    3332340585,
    3587147933,
    665062302,
    2042050490,
    2346497209,
    2559330125,
    1793573966,
    3190661285,
    1279665062,
    1595330642,
    2910671697
  ];
  var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookupTable);
  var aws_crc32c_1 = require_aws_crc32c();
  Object.defineProperty(exports, "AwsCrc32c", { enumerable: true, get: function() {
    return aws_crc32c_1.AwsCrc32c;
  } });
});

// node_modules/@aws-sdk/crc64-nvme/dist-cjs/index.js
var require_dist_cjs28 = __commonJS((exports) => {
  var generateCRC64NVMETable = () => {
    const sliceLength = 8;
    const tables = new Array(sliceLength);
    for (let slice = 0;slice < sliceLength; slice++) {
      const table = new Array(512);
      for (let i2 = 0;i2 < 256; i2++) {
        let crc = BigInt(i2);
        for (let j = 0;j < 8 * (slice + 1); j++) {
          if (crc & 1n) {
            crc = crc >> 1n ^ 0x9a6c9329ac4bc9b5n;
          } else {
            crc = crc >> 1n;
          }
        }
        table[i2 * 2] = Number(crc >> 32n & 0xffffffffn);
        table[i2 * 2 + 1] = Number(crc & 0xffffffffn);
      }
      tables[slice] = new Uint32Array(table);
    }
    return tables;
  };
  var CRC64_NVME_REVERSED_TABLE;
  var t0;
  var t1;
  var t2;
  var t3;
  var t4;
  var t5;
  var t6;
  var t7;
  var ensureTablesInitialized = () => {
    if (!CRC64_NVME_REVERSED_TABLE) {
      CRC64_NVME_REVERSED_TABLE = generateCRC64NVMETable();
      [t0, t1, t2, t3, t4, t5, t6, t7] = CRC64_NVME_REVERSED_TABLE;
    }
  };

  class Crc64Nvme {
    c1 = 0;
    c2 = 0;
    constructor() {
      ensureTablesInitialized();
      this.reset();
    }
    update(data) {
      const len = data.length;
      let i2 = 0;
      let crc1 = this.c1;
      let crc2 = this.c2;
      while (i2 + 8 <= len) {
        const idx0 = ((crc2 ^ data[i2++]) & 255) << 1;
        const idx1 = ((crc2 >>> 8 ^ data[i2++]) & 255) << 1;
        const idx2 = ((crc2 >>> 16 ^ data[i2++]) & 255) << 1;
        const idx3 = ((crc2 >>> 24 ^ data[i2++]) & 255) << 1;
        const idx4 = ((crc1 ^ data[i2++]) & 255) << 1;
        const idx5 = ((crc1 >>> 8 ^ data[i2++]) & 255) << 1;
        const idx6 = ((crc1 >>> 16 ^ data[i2++]) & 255) << 1;
        const idx7 = ((crc1 >>> 24 ^ data[i2++]) & 255) << 1;
        crc1 = t7[idx0] ^ t6[idx1] ^ t5[idx2] ^ t4[idx3] ^ t3[idx4] ^ t2[idx5] ^ t1[idx6] ^ t0[idx7];
        crc2 = t7[idx0 + 1] ^ t6[idx1 + 1] ^ t5[idx2 + 1] ^ t4[idx3 + 1] ^ t3[idx4 + 1] ^ t2[idx5 + 1] ^ t1[idx6 + 1] ^ t0[idx7 + 1];
      }
      while (i2 < len) {
        const idx = ((crc2 ^ data[i2]) & 255) << 1;
        crc2 = (crc2 >>> 8 | (crc1 & 255) << 24) >>> 0;
        crc1 = crc1 >>> 8 ^ t0[idx];
        crc2 ^= t0[idx + 1];
        i2++;
      }
      this.c1 = crc1;
      this.c2 = crc2;
    }
    async digest() {
      const c1 = this.c1 ^ 4294967295;
      const c2 = this.c2 ^ 4294967295;
      return new Uint8Array([
        c1 >>> 24,
        c1 >>> 16 & 255,
        c1 >>> 8 & 255,
        c1 & 255,
        c2 >>> 24,
        c2 >>> 16 & 255,
        c2 >>> 8 & 255,
        c2 & 255
      ]);
    }
    reset() {
      this.c1 = 4294967295;
      this.c2 = 4294967295;
    }
  }
  var crc64NvmeCrtContainer = {
    CrtCrc64Nvme: null
  };
  exports.Crc64Nvme = Crc64Nvme;
  exports.crc64NvmeCrtContainer = crc64NvmeCrtContainer;
});

// node_modules/@aws-crypto/crc32/build/main/aws_crc32.js
var require_aws_crc32 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AwsCrc32 = undefined;
  var tslib_1 = require_tslib();
  var util_1 = require_main();
  var index_1 = require_main3();
  var AwsCrc32 = function() {
    function AwsCrc322() {
      this.crc32 = new index_1.Crc32;
    }
    AwsCrc322.prototype.update = function(toHash) {
      if ((0, util_1.isEmptyData)(toHash))
        return;
      this.crc32.update((0, util_1.convertToBuffer)(toHash));
    };
    AwsCrc322.prototype.digest = function() {
      return tslib_1.__awaiter(this, undefined, undefined, function() {
        return tslib_1.__generator(this, function(_a) {
          return [2, (0, util_1.numToUint8)(this.crc32.digest())];
        });
      });
    };
    AwsCrc322.prototype.reset = function() {
      this.crc32 = new index_1.Crc32;
    };
    return AwsCrc322;
  }();
  exports.AwsCrc32 = AwsCrc32;
});

// node_modules/@aws-crypto/crc32/build/main/index.js
var require_main3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AwsCrc32 = exports.Crc32 = exports.crc32 = undefined;
  var tslib_1 = require_tslib();
  var util_1 = require_main();
  function crc32(data) {
    return new Crc32().update(data).digest();
  }
  exports.crc32 = crc32;
  var Crc32 = function() {
    function Crc322() {
      this.checksum = 4294967295;
    }
    Crc322.prototype.update = function(data) {
      var e_1, _a;
      try {
        for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next();!data_1_1.done; data_1_1 = data_1.next()) {
          var byte = data_1_1.value;
          this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a = data_1.return))
            _a.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return this;
    };
    Crc322.prototype.digest = function() {
      return (this.checksum ^ 4294967295) >>> 0;
    };
    return Crc322;
  }();
  exports.Crc32 = Crc32;
  var a_lookUpTable = [
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918000,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ];
  var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
  var aws_crc32_1 = require_aws_crc32();
  Object.defineProperty(exports, "AwsCrc32", { enumerable: true, get: function() {
    return aws_crc32_1.AwsCrc32;
  } });
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/getCrc32ChecksumAlgorithmFunction.js
var require_getCrc32ChecksumAlgorithmFunction = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCrc32ChecksumAlgorithmFunction = undefined;
  var tslib_1 = require_tslib();
  var crc32_1 = require_main3();
  var util_1 = require_main();
  var zlib = tslib_1.__importStar(__require("zlib"));

  class NodeCrc32 {
    checksum = 0;
    update(data) {
      this.checksum = zlib.crc32(data, this.checksum);
    }
    async digest() {
      return (0, util_1.numToUint8)(this.checksum);
    }
    reset() {
      this.checksum = 0;
    }
  }
  var getCrc32ChecksumAlgorithmFunction = () => {
    if (typeof zlib.crc32 === "undefined") {
      return crc32_1.AwsCrc32;
    }
    return NodeCrc32;
  };
  exports.getCrc32ChecksumAlgorithmFunction = getCrc32ChecksumAlgorithmFunction;
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/index.js
var require_dist_cjs29 = __commonJS((exports) => {
  var core = require_dist_cjs24();
  var protocolHttp = require_dist_cjs2();
  var utilStream = require_dist_cjs15();
  var isArrayBuffer = require_dist_cjs6();
  var crc32c = require_main2();
  var crc64Nvme = require_dist_cjs28();
  var getCrc32ChecksumAlgorithmFunction = require_getCrc32ChecksumAlgorithmFunction();
  var utilUtf8 = require_dist_cjs8();
  var utilMiddleware = require_dist_cjs4();
  var RequestChecksumCalculation = {
    WHEN_SUPPORTED: "WHEN_SUPPORTED",
    WHEN_REQUIRED: "WHEN_REQUIRED"
  };
  var DEFAULT_REQUEST_CHECKSUM_CALCULATION = RequestChecksumCalculation.WHEN_SUPPORTED;
  var ResponseChecksumValidation = {
    WHEN_SUPPORTED: "WHEN_SUPPORTED",
    WHEN_REQUIRED: "WHEN_REQUIRED"
  };
  var DEFAULT_RESPONSE_CHECKSUM_VALIDATION = RequestChecksumCalculation.WHEN_SUPPORTED;
  exports.ChecksumAlgorithm = undefined;
  (function(ChecksumAlgorithm) {
    ChecksumAlgorithm["MD5"] = "MD5";
    ChecksumAlgorithm["CRC32"] = "CRC32";
    ChecksumAlgorithm["CRC32C"] = "CRC32C";
    ChecksumAlgorithm["CRC64NVME"] = "CRC64NVME";
    ChecksumAlgorithm["SHA1"] = "SHA1";
    ChecksumAlgorithm["SHA256"] = "SHA256";
  })(exports.ChecksumAlgorithm || (exports.ChecksumAlgorithm = {}));
  exports.ChecksumLocation = undefined;
  (function(ChecksumLocation) {
    ChecksumLocation["HEADER"] = "header";
    ChecksumLocation["TRAILER"] = "trailer";
  })(exports.ChecksumLocation || (exports.ChecksumLocation = {}));
  var DEFAULT_CHECKSUM_ALGORITHM = exports.ChecksumAlgorithm.CRC32;
  var SelectorType;
  (function(SelectorType2) {
    SelectorType2["ENV"] = "env";
    SelectorType2["CONFIG"] = "shared config entry";
  })(SelectorType || (SelectorType = {}));
  var stringUnionSelector = (obj, key, union, type) => {
    if (!(key in obj))
      return;
    const value = obj[key].toUpperCase();
    if (!Object.values(union).includes(value)) {
      throw new TypeError(`Cannot load ${type} '${key}'. Expected one of ${Object.values(union)}, got '${obj[key]}'.`);
    }
    return value;
  };
  var ENV_REQUEST_CHECKSUM_CALCULATION = "AWS_REQUEST_CHECKSUM_CALCULATION";
  var CONFIG_REQUEST_CHECKSUM_CALCULATION = "request_checksum_calculation";
  var NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => stringUnionSelector(env, ENV_REQUEST_CHECKSUM_CALCULATION, RequestChecksumCalculation, SelectorType.ENV),
    configFileSelector: (profile) => stringUnionSelector(profile, CONFIG_REQUEST_CHECKSUM_CALCULATION, RequestChecksumCalculation, SelectorType.CONFIG),
    default: DEFAULT_REQUEST_CHECKSUM_CALCULATION
  };
  var ENV_RESPONSE_CHECKSUM_VALIDATION = "AWS_RESPONSE_CHECKSUM_VALIDATION";
  var CONFIG_RESPONSE_CHECKSUM_VALIDATION = "response_checksum_validation";
  var NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => stringUnionSelector(env, ENV_RESPONSE_CHECKSUM_VALIDATION, ResponseChecksumValidation, SelectorType.ENV),
    configFileSelector: (profile) => stringUnionSelector(profile, CONFIG_RESPONSE_CHECKSUM_VALIDATION, ResponseChecksumValidation, SelectorType.CONFIG),
    default: DEFAULT_RESPONSE_CHECKSUM_VALIDATION
  };
  var CLIENT_SUPPORTED_ALGORITHMS = [
    exports.ChecksumAlgorithm.CRC32,
    exports.ChecksumAlgorithm.CRC32C,
    exports.ChecksumAlgorithm.CRC64NVME,
    exports.ChecksumAlgorithm.SHA1,
    exports.ChecksumAlgorithm.SHA256
  ];
  var PRIORITY_ORDER_ALGORITHMS = [
    exports.ChecksumAlgorithm.SHA256,
    exports.ChecksumAlgorithm.SHA1,
    exports.ChecksumAlgorithm.CRC32,
    exports.ChecksumAlgorithm.CRC32C,
    exports.ChecksumAlgorithm.CRC64NVME
  ];
  var getChecksumAlgorithmForRequest = (input, { requestChecksumRequired, requestAlgorithmMember, requestChecksumCalculation }) => {
    if (!requestAlgorithmMember) {
      return requestChecksumCalculation === RequestChecksumCalculation.WHEN_SUPPORTED || requestChecksumRequired ? DEFAULT_CHECKSUM_ALGORITHM : undefined;
    }
    if (!input[requestAlgorithmMember]) {
      return;
    }
    const checksumAlgorithm = input[requestAlgorithmMember];
    if (!CLIENT_SUPPORTED_ALGORITHMS.includes(checksumAlgorithm)) {
      throw new Error(`The checksum algorithm "${checksumAlgorithm}" is not supported by the client.` + ` Select one of ${CLIENT_SUPPORTED_ALGORITHMS}.`);
    }
    return checksumAlgorithm;
  };
  var getChecksumLocationName = (algorithm) => algorithm === exports.ChecksumAlgorithm.MD5 ? "content-md5" : `x-amz-checksum-${algorithm.toLowerCase()}`;
  var hasHeader = (header, headers) => {
    const soughtHeader = header.toLowerCase();
    for (const headerName of Object.keys(headers)) {
      if (soughtHeader === headerName.toLowerCase()) {
        return true;
      }
    }
    return false;
  };
  var hasHeaderWithPrefix = (headerPrefix, headers) => {
    const soughtHeaderPrefix = headerPrefix.toLowerCase();
    for (const headerName of Object.keys(headers)) {
      if (headerName.toLowerCase().startsWith(soughtHeaderPrefix)) {
        return true;
      }
    }
    return false;
  };
  var isStreaming = (body) => body !== undefined && typeof body !== "string" && !ArrayBuffer.isView(body) && !isArrayBuffer.isArrayBuffer(body);
  var selectChecksumAlgorithmFunction = (checksumAlgorithm, config) => {
    switch (checksumAlgorithm) {
      case exports.ChecksumAlgorithm.MD5:
        return config.md5;
      case exports.ChecksumAlgorithm.CRC32:
        return getCrc32ChecksumAlgorithmFunction.getCrc32ChecksumAlgorithmFunction();
      case exports.ChecksumAlgorithm.CRC32C:
        return crc32c.AwsCrc32c;
      case exports.ChecksumAlgorithm.CRC64NVME:
        if (typeof crc64Nvme.crc64NvmeCrtContainer.CrtCrc64Nvme !== "function") {
          return crc64Nvme.Crc64Nvme;
        }
        return crc64Nvme.crc64NvmeCrtContainer.CrtCrc64Nvme;
      case exports.ChecksumAlgorithm.SHA1:
        return config.sha1;
      case exports.ChecksumAlgorithm.SHA256:
        return config.sha256;
      default:
        throw new Error(`Unsupported checksum algorithm: ${checksumAlgorithm}`);
    }
  };
  var stringHasher = (checksumAlgorithmFn, body) => {
    const hash = new checksumAlgorithmFn;
    hash.update(utilUtf8.toUint8Array(body || ""));
    return hash.digest();
  };
  var flexibleChecksumsMiddlewareOptions = {
    name: "flexibleChecksumsMiddleware",
    step: "build",
    tags: ["BODY_CHECKSUM"],
    override: true
  };
  var flexibleChecksumsMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
    if (!protocolHttp.HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    if (hasHeaderWithPrefix("x-amz-checksum-", args.request.headers)) {
      return next(args);
    }
    const { request, input } = args;
    const { body: requestBody, headers } = request;
    const { base64Encoder, streamHasher } = config;
    const { requestChecksumRequired, requestAlgorithmMember } = middlewareConfig;
    const requestChecksumCalculation = await config.requestChecksumCalculation();
    const requestAlgorithmMemberName = requestAlgorithmMember?.name;
    const requestAlgorithmMemberHttpHeader = requestAlgorithmMember?.httpHeader;
    if (requestAlgorithmMemberName && !input[requestAlgorithmMemberName]) {
      if (requestChecksumCalculation === RequestChecksumCalculation.WHEN_SUPPORTED || requestChecksumRequired) {
        input[requestAlgorithmMemberName] = DEFAULT_CHECKSUM_ALGORITHM;
        if (requestAlgorithmMemberHttpHeader) {
          headers[requestAlgorithmMemberHttpHeader] = DEFAULT_CHECKSUM_ALGORITHM;
        }
      }
    }
    const checksumAlgorithm = getChecksumAlgorithmForRequest(input, {
      requestChecksumRequired,
      requestAlgorithmMember: requestAlgorithmMember?.name,
      requestChecksumCalculation
    });
    let updatedBody = requestBody;
    let updatedHeaders = headers;
    if (checksumAlgorithm) {
      switch (checksumAlgorithm) {
        case exports.ChecksumAlgorithm.CRC32:
          core.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC32", "U");
          break;
        case exports.ChecksumAlgorithm.CRC32C:
          core.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC32C", "V");
          break;
        case exports.ChecksumAlgorithm.CRC64NVME:
          core.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC64", "W");
          break;
        case exports.ChecksumAlgorithm.SHA1:
          core.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_SHA1", "X");
          break;
        case exports.ChecksumAlgorithm.SHA256:
          core.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_SHA256", "Y");
          break;
      }
      const checksumLocationName = getChecksumLocationName(checksumAlgorithm);
      const checksumAlgorithmFn = selectChecksumAlgorithmFunction(checksumAlgorithm, config);
      if (isStreaming(requestBody)) {
        const { getAwsChunkedEncodingStream, bodyLengthChecker } = config;
        updatedBody = getAwsChunkedEncodingStream(typeof config.requestStreamBufferSize === "number" && config.requestStreamBufferSize >= 8 * 1024 ? utilStream.createBufferedReadable(requestBody, config.requestStreamBufferSize, context.logger) : requestBody, {
          base64Encoder,
          bodyLengthChecker,
          checksumLocationName,
          checksumAlgorithmFn,
          streamHasher
        });
        updatedHeaders = {
          ...headers,
          "content-encoding": headers["content-encoding"] ? `${headers["content-encoding"]},aws-chunked` : "aws-chunked",
          "transfer-encoding": "chunked",
          "x-amz-decoded-content-length": headers["content-length"],
          "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
          "x-amz-trailer": checksumLocationName
        };
        delete updatedHeaders["content-length"];
      } else if (!hasHeader(checksumLocationName, headers)) {
        const rawChecksum = await stringHasher(checksumAlgorithmFn, requestBody);
        updatedHeaders = {
          ...headers,
          [checksumLocationName]: base64Encoder(rawChecksum)
        };
      }
    }
    try {
      const result = await next({
        ...args,
        request: {
          ...request,
          headers: updatedHeaders,
          body: updatedBody
        }
      });
      return result;
    } catch (e) {
      if (e instanceof Error && e.name === "InvalidChunkSizeError") {
        try {
          if (!e.message.endsWith(".")) {
            e.message += ".";
          }
          e.message += " Set [requestStreamBufferSize=number e.g. 65_536] in client constructor to instruct AWS SDK to buffer your input stream.";
        } catch (ignored) {}
      }
      throw e;
    }
  };
  var flexibleChecksumsInputMiddlewareOptions = {
    name: "flexibleChecksumsInputMiddleware",
    toMiddleware: "serializerMiddleware",
    relation: "before",
    tags: ["BODY_CHECKSUM"],
    override: true
  };
  var flexibleChecksumsInputMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
    const input = args.input;
    const { requestValidationModeMember } = middlewareConfig;
    const requestChecksumCalculation = await config.requestChecksumCalculation();
    const responseChecksumValidation = await config.responseChecksumValidation();
    switch (requestChecksumCalculation) {
      case RequestChecksumCalculation.WHEN_REQUIRED:
        core.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_WHEN_REQUIRED", "a");
        break;
      case RequestChecksumCalculation.WHEN_SUPPORTED:
        core.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_WHEN_SUPPORTED", "Z");
        break;
    }
    switch (responseChecksumValidation) {
      case ResponseChecksumValidation.WHEN_REQUIRED:
        core.setFeature(context, "FLEXIBLE_CHECKSUMS_RES_WHEN_REQUIRED", "c");
        break;
      case ResponseChecksumValidation.WHEN_SUPPORTED:
        core.setFeature(context, "FLEXIBLE_CHECKSUMS_RES_WHEN_SUPPORTED", "b");
        break;
    }
    if (requestValidationModeMember && !input[requestValidationModeMember]) {
      if (responseChecksumValidation === ResponseChecksumValidation.WHEN_SUPPORTED) {
        input[requestValidationModeMember] = "ENABLED";
      }
    }
    return next(args);
  };
  var getChecksumAlgorithmListForResponse = (responseAlgorithms = []) => {
    const validChecksumAlgorithms = [];
    for (const algorithm of PRIORITY_ORDER_ALGORITHMS) {
      if (!responseAlgorithms.includes(algorithm) || !CLIENT_SUPPORTED_ALGORITHMS.includes(algorithm)) {
        continue;
      }
      validChecksumAlgorithms.push(algorithm);
    }
    return validChecksumAlgorithms;
  };
  var isChecksumWithPartNumber = (checksum) => {
    const lastHyphenIndex = checksum.lastIndexOf("-");
    if (lastHyphenIndex !== -1) {
      const numberPart = checksum.slice(lastHyphenIndex + 1);
      if (!numberPart.startsWith("0")) {
        const number = parseInt(numberPart, 10);
        if (!isNaN(number) && number >= 1 && number <= 1e4) {
          return true;
        }
      }
    }
    return false;
  };
  var getChecksum = async (body, { checksumAlgorithmFn, base64Encoder }) => base64Encoder(await stringHasher(checksumAlgorithmFn, body));
  var validateChecksumFromResponse = async (response, { config, responseAlgorithms, logger }) => {
    const checksumAlgorithms = getChecksumAlgorithmListForResponse(responseAlgorithms);
    const { body: responseBody, headers: responseHeaders } = response;
    for (const algorithm of checksumAlgorithms) {
      const responseHeader = getChecksumLocationName(algorithm);
      const checksumFromResponse = responseHeaders[responseHeader];
      if (checksumFromResponse) {
        let checksumAlgorithmFn;
        try {
          checksumAlgorithmFn = selectChecksumAlgorithmFunction(algorithm, config);
        } catch (error) {
          if (algorithm === exports.ChecksumAlgorithm.CRC64NVME) {
            logger?.warn(`Skipping ${exports.ChecksumAlgorithm.CRC64NVME} checksum validation: ${error.message}`);
            continue;
          }
          throw error;
        }
        const { base64Encoder } = config;
        if (isStreaming(responseBody)) {
          response.body = utilStream.createChecksumStream({
            expectedChecksum: checksumFromResponse,
            checksumSourceLocation: responseHeader,
            checksum: new checksumAlgorithmFn,
            source: responseBody,
            base64Encoder
          });
          return;
        }
        const checksum = await getChecksum(responseBody, { checksumAlgorithmFn, base64Encoder });
        if (checksum === checksumFromResponse) {
          break;
        }
        throw new Error(`Checksum mismatch: expected "${checksum}" but received "${checksumFromResponse}"` + ` in response header "${responseHeader}".`);
      }
    }
  };
  var flexibleChecksumsResponseMiddlewareOptions = {
    name: "flexibleChecksumsResponseMiddleware",
    toMiddleware: "deserializerMiddleware",
    relation: "after",
    tags: ["BODY_CHECKSUM"],
    override: true
  };
  var flexibleChecksumsResponseMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
    if (!protocolHttp.HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    const input = args.input;
    const result = await next(args);
    const response = result.response;
    const { requestValidationModeMember, responseAlgorithms } = middlewareConfig;
    if (requestValidationModeMember && input[requestValidationModeMember] === "ENABLED") {
      const { clientName, commandName } = context;
      const isS3WholeObjectMultipartGetResponseChecksum = clientName === "S3Client" && commandName === "GetObjectCommand" && getChecksumAlgorithmListForResponse(responseAlgorithms).every((algorithm) => {
        const responseHeader = getChecksumLocationName(algorithm);
        const checksumFromResponse = response.headers[responseHeader];
        return !checksumFromResponse || isChecksumWithPartNumber(checksumFromResponse);
      });
      if (isS3WholeObjectMultipartGetResponseChecksum) {
        return result;
      }
      await validateChecksumFromResponse(response, {
        config,
        responseAlgorithms,
        logger: context.logger
      });
    }
    return result;
  };
  var getFlexibleChecksumsPlugin = (config, middlewareConfig) => ({
    applyToStack: (clientStack) => {
      clientStack.add(flexibleChecksumsMiddleware(config, middlewareConfig), flexibleChecksumsMiddlewareOptions);
      clientStack.addRelativeTo(flexibleChecksumsInputMiddleware(config, middlewareConfig), flexibleChecksumsInputMiddlewareOptions);
      clientStack.addRelativeTo(flexibleChecksumsResponseMiddleware(config, middlewareConfig), flexibleChecksumsResponseMiddlewareOptions);
    }
  });
  var resolveFlexibleChecksumsConfig = (input) => {
    const { requestChecksumCalculation, responseChecksumValidation, requestStreamBufferSize } = input;
    return Object.assign(input, {
      requestChecksumCalculation: utilMiddleware.normalizeProvider(requestChecksumCalculation ?? DEFAULT_REQUEST_CHECKSUM_CALCULATION),
      responseChecksumValidation: utilMiddleware.normalizeProvider(responseChecksumValidation ?? DEFAULT_RESPONSE_CHECKSUM_VALIDATION),
      requestStreamBufferSize: Number(requestStreamBufferSize ?? 0)
    });
  };
  exports.CONFIG_REQUEST_CHECKSUM_CALCULATION = CONFIG_REQUEST_CHECKSUM_CALCULATION;
  exports.CONFIG_RESPONSE_CHECKSUM_VALIDATION = CONFIG_RESPONSE_CHECKSUM_VALIDATION;
  exports.DEFAULT_CHECKSUM_ALGORITHM = DEFAULT_CHECKSUM_ALGORITHM;
  exports.DEFAULT_REQUEST_CHECKSUM_CALCULATION = DEFAULT_REQUEST_CHECKSUM_CALCULATION;
  exports.DEFAULT_RESPONSE_CHECKSUM_VALIDATION = DEFAULT_RESPONSE_CHECKSUM_VALIDATION;
  exports.ENV_REQUEST_CHECKSUM_CALCULATION = ENV_REQUEST_CHECKSUM_CALCULATION;
  exports.ENV_RESPONSE_CHECKSUM_VALIDATION = ENV_RESPONSE_CHECKSUM_VALIDATION;
  exports.NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS = NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS;
  exports.NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS = NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS;
  exports.RequestChecksumCalculation = RequestChecksumCalculation;
  exports.ResponseChecksumValidation = ResponseChecksumValidation;
  exports.flexibleChecksumsMiddleware = flexibleChecksumsMiddleware;
  exports.flexibleChecksumsMiddlewareOptions = flexibleChecksumsMiddlewareOptions;
  exports.getFlexibleChecksumsPlugin = getFlexibleChecksumsPlugin;
  exports.resolveFlexibleChecksumsConfig = resolveFlexibleChecksumsConfig;
});

// node_modules/@aws-sdk/middleware-host-header/dist-cjs/index.js
var require_dist_cjs30 = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs2();
  function resolveHostHeaderConfig(input) {
    return input;
  }
  var hostHeaderMiddleware = (options) => (next) => async (args) => {
    if (!protocolHttp.HttpRequest.isInstance(args.request))
      return next(args);
    const { request } = args;
    const { handlerProtocol = "" } = options.requestHandler.metadata || {};
    if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
      delete request.headers["host"];
      request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
    } else if (!request.headers["host"]) {
      let host = request.hostname;
      if (request.port != null)
        host += `:${request.port}`;
      request.headers["host"] = host;
    }
    return next(args);
  };
  var hostHeaderMiddlewareOptions = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: ["HOST"],
    override: true
  };
  var getHostHeaderPlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
    }
  });
  exports.getHostHeaderPlugin = getHostHeaderPlugin;
  exports.hostHeaderMiddleware = hostHeaderMiddleware;
  exports.hostHeaderMiddlewareOptions = hostHeaderMiddlewareOptions;
  exports.resolveHostHeaderConfig = resolveHostHeaderConfig;
});

// node_modules/@aws-sdk/middleware-logger/dist-cjs/index.js
var require_dist_cjs31 = __commonJS((exports) => {
  var loggerMiddleware = () => (next, context) => async (args) => {
    try {
      const response = await next(args);
      const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
      const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
      const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
      const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
      const { $metadata, ...outputWithoutMetadata } = response.output;
      logger?.info?.({
        clientName,
        commandName,
        input: inputFilterSensitiveLog(args.input),
        output: outputFilterSensitiveLog(outputWithoutMetadata),
        metadata: $metadata
      });
      return response;
    } catch (error) {
      const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
      const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
      const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
      logger?.error?.({
        clientName,
        commandName,
        input: inputFilterSensitiveLog(args.input),
        error,
        metadata: error.$metadata
      });
      throw error;
    }
  };
  var loggerMiddlewareOptions = {
    name: "loggerMiddleware",
    tags: ["LOGGER"],
    step: "initialize",
    override: true
  };
  var getLoggerPlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
    }
  });
  exports.getLoggerPlugin = getLoggerPlugin;
  exports.loggerMiddleware = loggerMiddleware;
  exports.loggerMiddlewareOptions = loggerMiddlewareOptions;
});

// node_modules/@aws/lambda-invoke-store/dist-cjs/invoke-store.js
var require_invoke_store = __commonJS((exports) => {
  var PROTECTED_KEYS = {
    REQUEST_ID: Symbol.for("_AWS_LAMBDA_REQUEST_ID"),
    X_RAY_TRACE_ID: Symbol.for("_AWS_LAMBDA_X_RAY_TRACE_ID"),
    TENANT_ID: Symbol.for("_AWS_LAMBDA_TENANT_ID")
  };
  var NO_GLOBAL_AWS_LAMBDA = ["true", "1"].includes(process.env?.AWS_LAMBDA_NODEJS_NO_GLOBAL_AWSLAMBDA ?? "");
  if (!NO_GLOBAL_AWS_LAMBDA) {
    globalThis.awslambda = globalThis.awslambda || {};
  }

  class InvokeStoreBase {
    static PROTECTED_KEYS = PROTECTED_KEYS;
    isProtectedKey(key) {
      return Object.values(PROTECTED_KEYS).includes(key);
    }
    getRequestId() {
      return this.get(PROTECTED_KEYS.REQUEST_ID) ?? "-";
    }
    getXRayTraceId() {
      return this.get(PROTECTED_KEYS.X_RAY_TRACE_ID);
    }
    getTenantId() {
      return this.get(PROTECTED_KEYS.TENANT_ID);
    }
  }

  class InvokeStoreSingle extends InvokeStoreBase {
    currentContext;
    getContext() {
      return this.currentContext;
    }
    hasContext() {
      return this.currentContext !== undefined;
    }
    get(key) {
      return this.currentContext?.[key];
    }
    set(key, value) {
      if (this.isProtectedKey(key)) {
        throw new Error(`Cannot modify protected Lambda context field: ${String(key)}`);
      }
      this.currentContext = this.currentContext || {};
      this.currentContext[key] = value;
    }
    run(context, fn) {
      this.currentContext = context;
      return fn();
    }
  }

  class InvokeStoreMulti extends InvokeStoreBase {
    als;
    static async create() {
      const instance = new InvokeStoreMulti;
      const asyncHooks = __require("node:async_hooks");
      instance.als = new asyncHooks.AsyncLocalStorage;
      return instance;
    }
    getContext() {
      return this.als.getStore();
    }
    hasContext() {
      return this.als.getStore() !== undefined;
    }
    get(key) {
      return this.als.getStore()?.[key];
    }
    set(key, value) {
      if (this.isProtectedKey(key)) {
        throw new Error(`Cannot modify protected Lambda context field: ${String(key)}`);
      }
      const store = this.als.getStore();
      if (!store) {
        throw new Error("No context available");
      }
      store[key] = value;
    }
    run(context, fn) {
      return this.als.run(context, fn);
    }
  }
  exports.InvokeStore = undefined;
  (function(InvokeStore) {
    let instance = null;
    async function getInstanceAsync() {
      if (!instance) {
        instance = (async () => {
          const isMulti = "AWS_LAMBDA_MAX_CONCURRENCY" in process.env;
          const newInstance = isMulti ? await InvokeStoreMulti.create() : new InvokeStoreSingle;
          if (!NO_GLOBAL_AWS_LAMBDA && globalThis.awslambda?.InvokeStore) {
            return globalThis.awslambda.InvokeStore;
          } else if (!NO_GLOBAL_AWS_LAMBDA && globalThis.awslambda) {
            globalThis.awslambda.InvokeStore = newInstance;
            return newInstance;
          } else {
            return newInstance;
          }
        })();
      }
      return instance;
    }
    InvokeStore.getInstanceAsync = getInstanceAsync;
    InvokeStore._testing = process.env.AWS_LAMBDA_BENCHMARK_MODE === "1" ? {
      reset: () => {
        instance = null;
        if (globalThis.awslambda?.InvokeStore) {
          delete globalThis.awslambda.InvokeStore;
        }
        globalThis.awslambda = { InvokeStore: undefined };
      }
    } : undefined;
  })(exports.InvokeStore || (exports.InvokeStore = {}));
  exports.InvokeStoreBase = InvokeStoreBase;
});

// node_modules/@aws-sdk/middleware-recursion-detection/dist-cjs/recursionDetectionMiddleware.js
var require_recursionDetectionMiddleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.recursionDetectionMiddleware = undefined;
  var lambda_invoke_store_1 = require_invoke_store();
  var protocol_http_1 = require_dist_cjs2();
  var TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
  var ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
  var ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
  var recursionDetectionMiddleware = () => (next) => async (args) => {
    const { request } = args;
    if (!protocol_http_1.HttpRequest.isInstance(request)) {
      return next(args);
    }
    const traceIdHeader = Object.keys(request.headers ?? {}).find((h) => h.toLowerCase() === TRACE_ID_HEADER_NAME.toLowerCase()) ?? TRACE_ID_HEADER_NAME;
    if (request.headers.hasOwnProperty(traceIdHeader)) {
      return next(args);
    }
    const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
    const traceIdFromEnv = process.env[ENV_TRACE_ID];
    const invokeStore = await lambda_invoke_store_1.InvokeStore.getInstanceAsync();
    const traceIdFromInvokeStore = invokeStore?.getXRayTraceId();
    const traceId = traceIdFromInvokeStore ?? traceIdFromEnv;
    const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
    if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
      request.headers[TRACE_ID_HEADER_NAME] = traceId;
    }
    return next({
      ...args,
      request
    });
  };
  exports.recursionDetectionMiddleware = recursionDetectionMiddleware;
});

// node_modules/@aws-sdk/middleware-recursion-detection/dist-cjs/index.js
var require_dist_cjs32 = __commonJS((exports) => {
  var recursionDetectionMiddleware = require_recursionDetectionMiddleware();
  var recursionDetectionMiddlewareOptions = {
    step: "build",
    tags: ["RECURSION_DETECTION"],
    name: "recursionDetectionMiddleware",
    override: true,
    priority: "low"
  };
  var getRecursionDetectionPlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(recursionDetectionMiddleware.recursionDetectionMiddleware(), recursionDetectionMiddlewareOptions);
    }
  });
  exports.getRecursionDetectionPlugin = getRecursionDetectionPlugin;
  Object.prototype.hasOwnProperty.call(recursionDetectionMiddleware, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: recursionDetectionMiddleware["__proto__"]
  });
  Object.keys(recursionDetectionMiddleware).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = recursionDetectionMiddleware[k];
  });
});

// node_modules/@aws-sdk/util-arn-parser/dist-cjs/index.js
var require_dist_cjs33 = __commonJS((exports) => {
  var validate = (str) => typeof str === "string" && str.indexOf("arn:") === 0 && str.split(":").length >= 6;
  var parse2 = (arn) => {
    const segments = arn.split(":");
    if (segments.length < 6 || segments[0] !== "arn")
      throw new Error("Malformed ARN");
    const [, partition2, service, region, accountId, ...resource] = segments;
    return {
      partition: partition2,
      service,
      region,
      accountId,
      resource: resource.join(":")
    };
  };
  var build = (arnObject) => {
    const { partition: partition2 = "aws", service, region, accountId, resource } = arnObject;
    if ([service, region, accountId, resource].some((segment) => typeof segment !== "string")) {
      throw new Error("Input ARN object is invalid");
    }
    return `arn:${partition2}:${service}:${region}:${accountId}:${resource}`;
  };
  exports.build = build;
  exports.parse = parse2;
  exports.validate = validate;
});

// node_modules/@smithy/util-config-provider/dist-cjs/index.js
var require_dist_cjs34 = __commonJS((exports) => {
  var booleanSelector = (obj, key, type) => {
    if (!(key in obj))
      return;
    if (obj[key] === "true")
      return true;
    if (obj[key] === "false")
      return false;
    throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
  };
  var numberSelector = (obj, key, type) => {
    if (!(key in obj))
      return;
    const numberValue = parseInt(obj[key], 10);
    if (Number.isNaN(numberValue)) {
      throw new TypeError(`Cannot load ${type} '${key}'. Expected number, got '${obj[key]}'.`);
    }
    return numberValue;
  };
  exports.SelectorType = undefined;
  (function(SelectorType) {
    SelectorType["ENV"] = "env";
    SelectorType["CONFIG"] = "shared config entry";
  })(exports.SelectorType || (exports.SelectorType = {}));
  exports.booleanSelector = booleanSelector;
  exports.numberSelector = numberSelector;
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-cjs/index.js
var require_dist_cjs35 = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs2();
  var smithyClient = require_dist_cjs22();
  var utilStream = require_dist_cjs15();
  var utilArnParser = require_dist_cjs33();
  var signatureV4 = require_dist_cjs19();
  var utilConfigProvider = require_dist_cjs34();
  var core = require_dist_cjs24();
  var core$1 = require_dist_cjs17();
  require_dist_cjs();
  var utilMiddleware = require_dist_cjs4();
  var CONTENT_LENGTH_HEADER = "content-length";
  var DECODED_CONTENT_LENGTH_HEADER = "x-amz-decoded-content-length";
  function checkContentLengthHeader() {
    return (next, context) => async (args) => {
      const { request } = args;
      if (protocolHttp.HttpRequest.isInstance(request)) {
        if (!(CONTENT_LENGTH_HEADER in request.headers) && !(DECODED_CONTENT_LENGTH_HEADER in request.headers)) {
          const message3 = `Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.`;
          if (typeof context?.logger?.warn === "function" && !(context.logger instanceof smithyClient.NoOpLogger)) {
            context.logger.warn(message3);
          } else {
            console.warn(message3);
          }
        }
      }
      return next({ ...args });
    };
  }
  var checkContentLengthHeaderMiddlewareOptions = {
    step: "finalizeRequest",
    tags: ["CHECK_CONTENT_LENGTH_HEADER"],
    name: "getCheckContentLengthHeaderPlugin",
    override: true
  };
  var getCheckContentLengthHeaderPlugin = (unused) => ({
    applyToStack: (clientStack) => {
      clientStack.add(checkContentLengthHeader(), checkContentLengthHeaderMiddlewareOptions);
    }
  });
  var regionRedirectEndpointMiddleware = (config) => {
    return (next, context) => async (args) => {
      const originalRegion = await config.region();
      const regionProviderRef = config.region;
      let unlock = () => {};
      if (context.__s3RegionRedirect) {
        Object.defineProperty(config, "region", {
          writable: false,
          value: async () => {
            return context.__s3RegionRedirect;
          }
        });
        unlock = () => Object.defineProperty(config, "region", {
          writable: true,
          value: regionProviderRef
        });
      }
      try {
        const result = await next(args);
        if (context.__s3RegionRedirect) {
          unlock();
          const region = await config.region();
          if (originalRegion !== region) {
            throw new Error("Region was not restored following S3 region redirect.");
          }
        }
        return result;
      } catch (e) {
        unlock();
        throw e;
      }
    };
  };
  var regionRedirectEndpointMiddlewareOptions = {
    tags: ["REGION_REDIRECT", "S3"],
    name: "regionRedirectEndpointMiddleware",
    override: true,
    relation: "before",
    toMiddleware: "endpointV2Middleware"
  };
  function regionRedirectMiddleware(clientConfig) {
    return (next, context) => async (args) => {
      try {
        return await next(args);
      } catch (err) {
        if (clientConfig.followRegionRedirects) {
          const statusCode = err?.$metadata?.httpStatusCode;
          const isHeadBucket = context.commandName === "HeadBucketCommand";
          const bucketRegionHeader = err?.$response?.headers?.["x-amz-bucket-region"];
          if (bucketRegionHeader) {
            if (statusCode === 301 || statusCode === 400 && (err?.name === "IllegalLocationConstraintException" || isHeadBucket)) {
              try {
                const actualRegion = bucketRegionHeader;
                context.logger?.debug(`Redirecting from ${await clientConfig.region()} to ${actualRegion}`);
                context.__s3RegionRedirect = actualRegion;
              } catch (e) {
                throw new Error("Region redirect failed: " + e);
              }
              return next(args);
            }
          }
        }
        throw err;
      }
    };
  }
  var regionRedirectMiddlewareOptions = {
    step: "initialize",
    tags: ["REGION_REDIRECT", "S3"],
    name: "regionRedirectMiddleware",
    override: true
  };
  var getRegionRedirectMiddlewarePlugin = (clientConfig) => ({
    applyToStack: (clientStack) => {
      clientStack.add(regionRedirectMiddleware(clientConfig), regionRedirectMiddlewareOptions);
      clientStack.addRelativeTo(regionRedirectEndpointMiddleware(clientConfig), regionRedirectEndpointMiddlewareOptions);
    }
  });
  var s3ExpiresMiddleware = (config) => {
    return (next, context) => async (args) => {
      const result = await next(args);
      const { response } = result;
      if (protocolHttp.HttpResponse.isInstance(response)) {
        if (response.headers.expires) {
          response.headers.expiresstring = response.headers.expires;
          try {
            smithyClient.parseRfc7231DateTime(response.headers.expires);
          } catch (e) {
            context.logger?.warn(`AWS SDK Warning for ${context.clientName}::${context.commandName} response parsing (${response.headers.expires}): ${e}`);
            delete response.headers.expires;
          }
        }
      }
      return result;
    };
  };
  var s3ExpiresMiddlewareOptions = {
    tags: ["S3"],
    name: "s3ExpiresMiddleware",
    override: true,
    relation: "after",
    toMiddleware: "deserializerMiddleware"
  };
  var getS3ExpiresMiddlewarePlugin = (clientConfig) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(s3ExpiresMiddleware(), s3ExpiresMiddlewareOptions);
    }
  });

  class S3ExpressIdentityCache {
    data;
    lastPurgeTime = Date.now();
    static EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 30000;
    constructor(data = {}) {
      this.data = data;
    }
    get(key) {
      const entry = this.data[key];
      if (!entry) {
        return;
      }
      return entry;
    }
    set(key, entry) {
      this.data[key] = entry;
      return entry;
    }
    delete(key) {
      delete this.data[key];
    }
    async purgeExpired() {
      const now = Date.now();
      if (this.lastPurgeTime + S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > now) {
        return;
      }
      for (const key in this.data) {
        const entry = this.data[key];
        if (!entry.isRefreshing) {
          const credential = await entry.identity;
          if (credential.expiration) {
            if (credential.expiration.getTime() < now) {
              delete this.data[key];
            }
          }
        }
      }
    }
  }

  class S3ExpressIdentityCacheEntry {
    _identity;
    isRefreshing;
    accessed;
    constructor(_identity, isRefreshing = false, accessed = Date.now()) {
      this._identity = _identity;
      this.isRefreshing = isRefreshing;
      this.accessed = accessed;
    }
    get identity() {
      this.accessed = Date.now();
      return this._identity;
    }
  }

  class S3ExpressIdentityProviderImpl {
    createSessionFn;
    cache;
    static REFRESH_WINDOW_MS = 60000;
    constructor(createSessionFn, cache2 = new S3ExpressIdentityCache) {
      this.createSessionFn = createSessionFn;
      this.cache = cache2;
    }
    async getS3ExpressIdentity(awsIdentity, identityProperties) {
      const key = identityProperties.Bucket;
      const { cache: cache2 } = this;
      const entry = cache2.get(key);
      if (entry) {
        return entry.identity.then((identity) => {
          const isExpired = (identity.expiration?.getTime() ?? 0) < Date.now();
          if (isExpired) {
            return cache2.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
          }
          const isExpiringSoon = (identity.expiration?.getTime() ?? 0) < Date.now() + S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;
          if (isExpiringSoon && !entry.isRefreshing) {
            entry.isRefreshing = true;
            this.getIdentity(key).then((id) => {
              cache2.set(key, new S3ExpressIdentityCacheEntry(Promise.resolve(id)));
            });
          }
          return identity;
        });
      }
      return cache2.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
    }
    async getIdentity(key) {
      await this.cache.purgeExpired().catch((error) => {
        console.warn(`Error while clearing expired entries in S3ExpressIdentityCache: 
` + error);
      });
      const session2 = await this.createSessionFn(key);
      if (!session2.Credentials?.AccessKeyId || !session2.Credentials?.SecretAccessKey) {
        throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
      }
      const identity = {
        accessKeyId: session2.Credentials.AccessKeyId,
        secretAccessKey: session2.Credentials.SecretAccessKey,
        sessionToken: session2.Credentials.SessionToken,
        expiration: session2.Credentials.Expiration ? new Date(session2.Credentials.Expiration) : undefined
      };
      return identity;
    }
  }
  var S3_EXPRESS_BUCKET_TYPE = "Directory";
  var S3_EXPRESS_BACKEND = "S3Express";
  var S3_EXPRESS_AUTH_SCHEME = "sigv4-s3express";
  var SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
  var SESSION_TOKEN_HEADER = SESSION_TOKEN_QUERY_PARAM.toLowerCase();
  var NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME = "AWS_S3_DISABLE_EXPRESS_SESSION_AUTH";
  var NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME = "s3_disable_express_session_auth";
  var NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS = {
    environmentVariableSelector: (env) => utilConfigProvider.booleanSelector(env, NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME, utilConfigProvider.SelectorType.ENV),
    configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME, utilConfigProvider.SelectorType.CONFIG),
    default: false
  };

  class SignatureV4S3Express extends signatureV4.SignatureV4 {
    async signWithCredentials(requestToSign, credentials, options) {
      const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
      requestToSign.headers[SESSION_TOKEN_HEADER] = credentials.sessionToken;
      const privateAccess = this;
      setSingleOverride(privateAccess, credentialsWithoutSessionToken);
      return privateAccess.signRequest(requestToSign, options ?? {});
    }
    async presignWithCredentials(requestToSign, credentials, options) {
      const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
      delete requestToSign.headers[SESSION_TOKEN_HEADER];
      requestToSign.headers[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
      requestToSign.query = requestToSign.query ?? {};
      requestToSign.query[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
      const privateAccess = this;
      setSingleOverride(privateAccess, credentialsWithoutSessionToken);
      return this.presign(requestToSign, options);
    }
  }
  function getCredentialsWithoutSessionToken(credentials) {
    const credentialsWithoutSessionToken = {
      accessKeyId: credentials.accessKeyId,
      secretAccessKey: credentials.secretAccessKey,
      expiration: credentials.expiration
    };
    return credentialsWithoutSessionToken;
  }
  function setSingleOverride(privateAccess, credentialsWithoutSessionToken) {
    const id = setTimeout(() => {
      throw new Error("SignatureV4S3Express credential override was created but not called.");
    }, 10);
    const currentCredentialProvider = privateAccess.credentialProvider;
    const overrideCredentialsProviderOnce = () => {
      clearTimeout(id);
      privateAccess.credentialProvider = currentCredentialProvider;
      return Promise.resolve(credentialsWithoutSessionToken);
    };
    privateAccess.credentialProvider = overrideCredentialsProviderOnce;
  }
  var s3ExpressMiddleware = (options) => {
    return (next, context) => async (args) => {
      if (context.endpointV2) {
        const endpoint = context.endpointV2;
        const isS3ExpressAuth = endpoint.properties?.authSchemes?.[0]?.name === S3_EXPRESS_AUTH_SCHEME;
        const isS3ExpressBucket = endpoint.properties?.backend === S3_EXPRESS_BACKEND || endpoint.properties?.bucketType === S3_EXPRESS_BUCKET_TYPE;
        if (isS3ExpressBucket) {
          core.setFeature(context, "S3_EXPRESS_BUCKET", "J");
          context.isS3ExpressBucket = true;
        }
        if (isS3ExpressAuth) {
          const requestBucket = args.input.Bucket;
          if (requestBucket) {
            const s3ExpressIdentity = await options.s3ExpressIdentityProvider.getS3ExpressIdentity(await options.credentials(), {
              Bucket: requestBucket
            });
            context.s3ExpressIdentity = s3ExpressIdentity;
            if (protocolHttp.HttpRequest.isInstance(args.request) && s3ExpressIdentity.sessionToken) {
              args.request.headers[SESSION_TOKEN_HEADER] = s3ExpressIdentity.sessionToken;
            }
          }
        }
      }
      return next(args);
    };
  };
  var s3ExpressMiddlewareOptions = {
    name: "s3ExpressMiddleware",
    step: "build",
    tags: ["S3", "S3_EXPRESS"],
    override: true
  };
  var getS3ExpressPlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(s3ExpressMiddleware(options), s3ExpressMiddlewareOptions);
    }
  });
  var signS3Express = async (s3ExpressIdentity, signingOptions, request, sigV4MultiRegionSigner) => {
    const signedRequest = await sigV4MultiRegionSigner.signWithCredentials(request, s3ExpressIdentity, {});
    if (signedRequest.headers["X-Amz-Security-Token"] || signedRequest.headers["x-amz-security-token"]) {
      throw new Error("X-Amz-Security-Token must not be set for s3-express requests.");
    }
    return signedRequest;
  };
  var defaultErrorHandler = (signingProperties) => (error) => {
    throw error;
  };
  var defaultSuccessHandler = (httpResponse, signingProperties) => {};
  var s3ExpressHttpSigningMiddlewareOptions = core$1.httpSigningMiddlewareOptions;
  var s3ExpressHttpSigningMiddleware = (config) => (next, context) => async (args) => {
    if (!protocolHttp.HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    const smithyContext = utilMiddleware.getSmithyContext(context);
    const scheme = smithyContext.selectedHttpAuthScheme;
    if (!scheme) {
      throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
    }
    const { httpAuthOption: { signingProperties = {} }, identity, signer } = scheme;
    let request;
    if (context.s3ExpressIdentity) {
      request = await signS3Express(context.s3ExpressIdentity, signingProperties, args.request, await config.signer());
    } else {
      request = await signer.sign(args.request, identity, signingProperties);
    }
    const output = await next({
      ...args,
      request
    }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
    (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
    return output;
  };
  var getS3ExpressHttpSigningPlugin = (config) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(s3ExpressHttpSigningMiddleware(config), core$1.httpSigningMiddlewareOptions);
    }
  });
  var resolveS3Config = (input, { session: session2 }) => {
    const [s3ClientProvider, CreateSessionCommandCtor] = session2;
    const { forcePathStyle, useAccelerateEndpoint, disableMultiregionAccessPoints, followRegionRedirects, s3ExpressIdentityProvider, bucketEndpoint, expectContinueHeader } = input;
    return Object.assign(input, {
      forcePathStyle: forcePathStyle ?? false,
      useAccelerateEndpoint: useAccelerateEndpoint ?? false,
      disableMultiregionAccessPoints: disableMultiregionAccessPoints ?? false,
      followRegionRedirects: followRegionRedirects ?? false,
      s3ExpressIdentityProvider: s3ExpressIdentityProvider ?? new S3ExpressIdentityProviderImpl(async (key) => s3ClientProvider().send(new CreateSessionCommandCtor({
        Bucket: key
      }))),
      bucketEndpoint: bucketEndpoint ?? false,
      expectContinueHeader: expectContinueHeader ?? 2097152
    });
  };
  var THROW_IF_EMPTY_BODY = {
    CopyObjectCommand: true,
    UploadPartCopyCommand: true,
    CompleteMultipartUploadCommand: true
  };
  var MAX_BYTES_TO_INSPECT = 3000;
  var throw200ExceptionsMiddleware = (config) => (next, context) => async (args) => {
    const result = await next(args);
    const { response } = result;
    if (!protocolHttp.HttpResponse.isInstance(response)) {
      return result;
    }
    const { statusCode, body: sourceBody } = response;
    if (statusCode < 200 || statusCode >= 300) {
      return result;
    }
    const isSplittableStream = typeof sourceBody?.stream === "function" || typeof sourceBody?.pipe === "function" || typeof sourceBody?.tee === "function";
    if (!isSplittableStream) {
      return result;
    }
    let bodyCopy = sourceBody;
    let body = sourceBody;
    if (sourceBody && typeof sourceBody === "object" && !(sourceBody instanceof Uint8Array)) {
      [bodyCopy, body] = await utilStream.splitStream(sourceBody);
    }
    response.body = body;
    const bodyBytes = await collectBody(bodyCopy, {
      streamCollector: async (stream3) => {
        return utilStream.headStream(stream3, MAX_BYTES_TO_INSPECT);
      }
    });
    if (typeof bodyCopy?.destroy === "function") {
      bodyCopy.destroy();
    }
    const bodyStringTail = config.utf8Encoder(bodyBytes.subarray(bodyBytes.length - 16));
    if (bodyBytes.length === 0 && THROW_IF_EMPTY_BODY[context.commandName]) {
      const err = new Error("S3 aborted request");
      err.name = "InternalError";
      throw err;
    }
    if (bodyStringTail && bodyStringTail.endsWith("</Error>")) {
      response.statusCode = 400;
    }
    return result;
  };
  var collectBody = (streamBody = new Uint8Array, context) => {
    if (streamBody instanceof Uint8Array) {
      return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array);
  };
  var throw200ExceptionsMiddlewareOptions = {
    relation: "after",
    toMiddleware: "deserializerMiddleware",
    tags: ["THROW_200_EXCEPTIONS", "S3"],
    name: "throw200ExceptionsMiddleware",
    override: true
  };
  var getThrow200ExceptionsPlugin = (config) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(throw200ExceptionsMiddleware(config), throw200ExceptionsMiddlewareOptions);
    }
  });
  function bucketEndpointMiddleware(options) {
    return (next, context) => async (args) => {
      if (options.bucketEndpoint) {
        const endpoint = context.endpointV2;
        if (endpoint) {
          const bucket = args.input.Bucket;
          if (typeof bucket === "string") {
            try {
              const bucketEndpointUrl = new URL(bucket);
              context.endpointV2 = {
                ...endpoint,
                url: bucketEndpointUrl
              };
            } catch (e) {
              const warning = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${bucket} could not be parsed as URL.`;
              if (context.logger?.constructor?.name === "NoOpLogger") {
                console.warn(warning);
              } else {
                context.logger?.warn?.(warning);
              }
              throw e;
            }
          }
        }
      }
      return next(args);
    };
  }
  var bucketEndpointMiddlewareOptions = {
    name: "bucketEndpointMiddleware",
    override: true,
    relation: "after",
    toMiddleware: "endpointV2Middleware"
  };
  function validateBucketNameMiddleware({ bucketEndpoint }) {
    return (next) => async (args) => {
      const { input: { Bucket } } = args;
      if (!bucketEndpoint && typeof Bucket === "string" && !utilArnParser.validate(Bucket) && Bucket.indexOf("/") >= 0) {
        const err = new Error(`Bucket name shouldn't contain '/', received '${Bucket}'`);
        err.name = "InvalidBucketName";
        throw err;
      }
      return next({ ...args });
    };
  }
  var validateBucketNameMiddlewareOptions = {
    step: "initialize",
    tags: ["VALIDATE_BUCKET_NAME"],
    name: "validateBucketNameMiddleware",
    override: true
  };
  var getValidateBucketNamePlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(validateBucketNameMiddleware(options), validateBucketNameMiddlewareOptions);
      clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);
    }
  });
  exports.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS = NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS;
  exports.S3ExpressIdentityCache = S3ExpressIdentityCache;
  exports.S3ExpressIdentityCacheEntry = S3ExpressIdentityCacheEntry;
  exports.S3ExpressIdentityProviderImpl = S3ExpressIdentityProviderImpl;
  exports.SignatureV4S3Express = SignatureV4S3Express;
  exports.checkContentLengthHeader = checkContentLengthHeader;
  exports.checkContentLengthHeaderMiddlewareOptions = checkContentLengthHeaderMiddlewareOptions;
  exports.getCheckContentLengthHeaderPlugin = getCheckContentLengthHeaderPlugin;
  exports.getRegionRedirectMiddlewarePlugin = getRegionRedirectMiddlewarePlugin;
  exports.getS3ExpiresMiddlewarePlugin = getS3ExpiresMiddlewarePlugin;
  exports.getS3ExpressHttpSigningPlugin = getS3ExpressHttpSigningPlugin;
  exports.getS3ExpressPlugin = getS3ExpressPlugin;
  exports.getThrow200ExceptionsPlugin = getThrow200ExceptionsPlugin;
  exports.getValidateBucketNamePlugin = getValidateBucketNamePlugin;
  exports.regionRedirectEndpointMiddleware = regionRedirectEndpointMiddleware;
  exports.regionRedirectEndpointMiddlewareOptions = regionRedirectEndpointMiddlewareOptions;
  exports.regionRedirectMiddleware = regionRedirectMiddleware;
  exports.regionRedirectMiddlewareOptions = regionRedirectMiddlewareOptions;
  exports.resolveS3Config = resolveS3Config;
  exports.s3ExpiresMiddleware = s3ExpiresMiddleware;
  exports.s3ExpiresMiddlewareOptions = s3ExpiresMiddlewareOptions;
  exports.s3ExpressHttpSigningMiddleware = s3ExpressHttpSigningMiddleware;
  exports.s3ExpressHttpSigningMiddlewareOptions = s3ExpressHttpSigningMiddlewareOptions;
  exports.s3ExpressMiddleware = s3ExpressMiddleware;
  exports.s3ExpressMiddlewareOptions = s3ExpressMiddlewareOptions;
  exports.throw200ExceptionsMiddleware = throw200ExceptionsMiddleware;
  exports.throw200ExceptionsMiddlewareOptions = throw200ExceptionsMiddlewareOptions;
  exports.validateBucketNameMiddleware = validateBucketNameMiddleware;
  exports.validateBucketNameMiddlewareOptions = validateBucketNameMiddlewareOptions;
});

// node_modules/@smithy/util-endpoints/dist-cjs/index.js
var require_dist_cjs36 = __commonJS((exports) => {
  var types = require_dist_cjs();

  class EndpointCache {
    capacity;
    data = new Map;
    parameters = [];
    constructor({ size, params }) {
      this.capacity = size ?? 50;
      if (params) {
        this.parameters = params;
      }
    }
    get(endpointParams, resolver) {
      const key = this.hash(endpointParams);
      if (key === false) {
        return resolver();
      }
      if (!this.data.has(key)) {
        if (this.data.size > this.capacity + 10) {
          const keys = this.data.keys();
          let i2 = 0;
          while (true) {
            const { value, done } = keys.next();
            this.data.delete(value);
            if (done || ++i2 > 10) {
              break;
            }
          }
        }
        this.data.set(key, resolver());
      }
      return this.data.get(key);
    }
    size() {
      return this.data.size;
    }
    hash(endpointParams) {
      let buffer = "";
      const { parameters } = this;
      if (parameters.length === 0) {
        return false;
      }
      for (const param of parameters) {
        const val = String(endpointParams[param] ?? "");
        if (val.includes("|;")) {
          return false;
        }
        buffer += val + "|;";
      }
      return buffer;
    }
  }
  var IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
  var isIpAddress = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");
  var VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
  var isValidHostLabel = (value, allowSubDomains = false) => {
    if (!allowSubDomains) {
      return VALID_HOST_LABEL_REGEX.test(value);
    }
    const labels = value.split(".");
    for (const label of labels) {
      if (!isValidHostLabel(label)) {
        return false;
      }
    }
    return true;
  };
  var customEndpointFunctions = {};
  var debugId = "endpoints";
  function toDebugString(input) {
    if (typeof input !== "object" || input == null) {
      return input;
    }
    if ("ref" in input) {
      return `$${toDebugString(input.ref)}`;
    }
    if ("fn" in input) {
      return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
    }
    return JSON.stringify(input, null, 2);
  }

  class EndpointError extends Error {
    constructor(message3) {
      super(message3);
      this.name = "EndpointError";
    }
  }
  var booleanEquals = (value1, value2) => value1 === value2;
  var getAttrPathList = (path) => {
    const parts = path.split(".");
    const pathList = [];
    for (const part of parts) {
      const squareBracketIndex = part.indexOf("[");
      if (squareBracketIndex !== -1) {
        if (part.indexOf("]") !== part.length - 1) {
          throw new EndpointError(`Path: '${path}' does not end with ']'`);
        }
        const arrayIndex = part.slice(squareBracketIndex + 1, -1);
        if (Number.isNaN(parseInt(arrayIndex))) {
          throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
        }
        if (squareBracketIndex !== 0) {
          pathList.push(part.slice(0, squareBracketIndex));
        }
        pathList.push(arrayIndex);
      } else {
        pathList.push(part);
      }
    }
    return pathList;
  };
  var getAttr = (value, path) => getAttrPathList(path).reduce((acc, index) => {
    if (typeof acc !== "object") {
      throw new EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
    } else if (Array.isArray(acc)) {
      return acc[parseInt(index)];
    }
    return acc[index];
  }, value);
  var isSet = (value) => value != null;
  var not = (value) => !value;
  var DEFAULT_PORTS = {
    [types.EndpointURLScheme.HTTP]: 80,
    [types.EndpointURLScheme.HTTPS]: 443
  };
  var parseURL = (value) => {
    const whatwgURL = (() => {
      try {
        if (value instanceof URL) {
          return value;
        }
        if (typeof value === "object" && "hostname" in value) {
          const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
          const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
          url.search = Object.entries(query).map(([k, v]) => `${k}=${v}`).join("&");
          return url;
        }
        return new URL(value);
      } catch (error) {
        return null;
      }
    })();
    if (!whatwgURL) {
      console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
      return null;
    }
    const urlString = whatwgURL.href;
    const { host, hostname, pathname, protocol, search } = whatwgURL;
    if (search) {
      return null;
    }
    const scheme = protocol.slice(0, -1);
    if (!Object.values(types.EndpointURLScheme).includes(scheme)) {
      return null;
    }
    const isIp = isIpAddress(hostname);
    const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
    const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
    return {
      scheme,
      authority,
      path: pathname,
      normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
      isIp
    };
  };
  var stringEquals = (value1, value2) => value1 === value2;
  var substring = (input, start, stop, reverse) => {
    if (start >= stop || input.length < stop || /[^\u0000-\u007f]/.test(input)) {
      return null;
    }
    if (!reverse) {
      return input.substring(start, stop);
    }
    return input.substring(input.length - stop, input.length - start);
  };
  var uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
  var endpointFunctions = {
    booleanEquals,
    getAttr,
    isSet,
    isValidHostLabel,
    not,
    parseURL,
    stringEquals,
    substring,
    uriEncode
  };
  var evaluateTemplate = (template, options) => {
    const evaluatedTemplateArr = [];
    const templateContext = {
      ...options.endpointParams,
      ...options.referenceRecord
    };
    let currentIndex = 0;
    while (currentIndex < template.length) {
      const openingBraceIndex = template.indexOf("{", currentIndex);
      if (openingBraceIndex === -1) {
        evaluatedTemplateArr.push(template.slice(currentIndex));
        break;
      }
      evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
      const closingBraceIndex = template.indexOf("}", openingBraceIndex);
      if (closingBraceIndex === -1) {
        evaluatedTemplateArr.push(template.slice(openingBraceIndex));
        break;
      }
      if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
        evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
        currentIndex = closingBraceIndex + 2;
      }
      const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
      if (parameterName.includes("#")) {
        const [refName, attrName] = parameterName.split("#");
        evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
      } else {
        evaluatedTemplateArr.push(templateContext[parameterName]);
      }
      currentIndex = closingBraceIndex + 1;
    }
    return evaluatedTemplateArr.join("");
  };
  var getReferenceValue = ({ ref }, options) => {
    const referenceRecord = {
      ...options.endpointParams,
      ...options.referenceRecord
    };
    return referenceRecord[ref];
  };
  var evaluateExpression = (obj, keyName, options) => {
    if (typeof obj === "string") {
      return evaluateTemplate(obj, options);
    } else if (obj["fn"]) {
      return group$2.callFunction(obj, options);
    } else if (obj["ref"]) {
      return getReferenceValue(obj, options);
    }
    throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
  };
  var callFunction = ({ fn, argv }, options) => {
    const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : group$2.evaluateExpression(arg, "arg", options));
    const fnSegments = fn.split(".");
    if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
      return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
    }
    return endpointFunctions[fn](...evaluatedArgs);
  };
  var group$2 = {
    evaluateExpression,
    callFunction
  };
  var evaluateCondition = ({ assign, ...fnArgs }, options) => {
    if (assign && assign in options.referenceRecord) {
      throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
    }
    const value = callFunction(fnArgs, options);
    options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
    return {
      result: value === "" ? true : !!value,
      ...assign != null && { toAssign: { name: assign, value } }
    };
  };
  var evaluateConditions = (conditions = [], options) => {
    const conditionsReferenceRecord = {};
    for (const condition of conditions) {
      const { result, toAssign } = evaluateCondition(condition, {
        ...options,
        referenceRecord: {
          ...options.referenceRecord,
          ...conditionsReferenceRecord
        }
      });
      if (!result) {
        return { result };
      }
      if (toAssign) {
        conditionsReferenceRecord[toAssign.name] = toAssign.value;
        options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
      }
    }
    return { result: true, referenceRecord: conditionsReferenceRecord };
  };
  var getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
    ...acc,
    [headerKey]: headerVal.map((headerValEntry) => {
      const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
      if (typeof processedExpr !== "string") {
        throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
      }
      return processedExpr;
    })
  }), {});
  var getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
    ...acc,
    [propertyKey]: group$1.getEndpointProperty(propertyVal, options)
  }), {});
  var getEndpointProperty = (property, options) => {
    if (Array.isArray(property)) {
      return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
    }
    switch (typeof property) {
      case "string":
        return evaluateTemplate(property, options);
      case "object":
        if (property === null) {
          throw new EndpointError(`Unexpected endpoint property: ${property}`);
        }
        return group$1.getEndpointProperties(property, options);
      case "boolean":
        return property;
      default:
        throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
    }
  };
  var group$1 = {
    getEndpointProperty,
    getEndpointProperties
  };
  var getEndpointUrl = (endpointUrl, options) => {
    const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
    if (typeof expression === "string") {
      try {
        return new URL(expression);
      } catch (error) {
        console.error(`Failed to construct URL with ${expression}`, error);
        throw error;
      }
    }
    throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
  };
  var evaluateEndpointRule = (endpointRule, options) => {
    const { conditions, endpoint } = endpointRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
      return;
    }
    const endpointRuleOptions = {
      ...options,
      referenceRecord: { ...options.referenceRecord, ...referenceRecord }
    };
    const { url, properties, headers } = endpoint;
    options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
    return {
      ...headers != null && {
        headers: getEndpointHeaders(headers, endpointRuleOptions)
      },
      ...properties != null && {
        properties: getEndpointProperties(properties, endpointRuleOptions)
      },
      url: getEndpointUrl(url, endpointRuleOptions)
    };
  };
  var evaluateErrorRule = (errorRule, options) => {
    const { conditions, error } = errorRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
      return;
    }
    throw new EndpointError(evaluateExpression(error, "Error", {
      ...options,
      referenceRecord: { ...options.referenceRecord, ...referenceRecord }
    }));
  };
  var evaluateRules = (rules, options) => {
    for (const rule of rules) {
      if (rule.type === "endpoint") {
        const endpointOrUndefined = evaluateEndpointRule(rule, options);
        if (endpointOrUndefined) {
          return endpointOrUndefined;
        }
      } else if (rule.type === "error") {
        evaluateErrorRule(rule, options);
      } else if (rule.type === "tree") {
        const endpointOrUndefined = group.evaluateTreeRule(rule, options);
        if (endpointOrUndefined) {
          return endpointOrUndefined;
        }
      } else {
        throw new EndpointError(`Unknown endpoint rule: ${rule}`);
      }
    }
    throw new EndpointError(`Rules evaluation failed`);
  };
  var evaluateTreeRule = (treeRule, options) => {
    const { conditions, rules } = treeRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
      return;
    }
    return group.evaluateRules(rules, {
      ...options,
      referenceRecord: { ...options.referenceRecord, ...referenceRecord }
    });
  };
  var group = {
    evaluateRules,
    evaluateTreeRule
  };
  var resolveEndpoint = (ruleSetObject, options) => {
    const { endpointParams, logger } = options;
    const { parameters, rules } = ruleSetObject;
    options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
    const paramsWithDefault = Object.entries(parameters).filter(([, v]) => v.default != null).map(([k, v]) => [k, v.default]);
    if (paramsWithDefault.length > 0) {
      for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
        endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
      }
    }
    const requiredParams = Object.entries(parameters).filter(([, v]) => v.required).map(([k]) => k);
    for (const requiredParam of requiredParams) {
      if (endpointParams[requiredParam] == null) {
        throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
      }
    }
    const endpoint = evaluateRules(rules, { endpointParams, logger, referenceRecord: {} });
    options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
    return endpoint;
  };
  exports.EndpointCache = EndpointCache;
  exports.EndpointError = EndpointError;
  exports.customEndpointFunctions = customEndpointFunctions;
  exports.isIpAddress = isIpAddress;
  exports.isValidHostLabel = isValidHostLabel;
  exports.resolveEndpoint = resolveEndpoint;
});

// node_modules/@smithy/querystring-parser/dist-cjs/index.js
var require_dist_cjs37 = __commonJS((exports) => {
  function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
      for (const pair of querystring.split("&")) {
        let [key, value = null] = pair.split("=");
        key = decodeURIComponent(key);
        if (value) {
          value = decodeURIComponent(value);
        }
        if (!(key in query)) {
          query[key] = value;
        } else if (Array.isArray(query[key])) {
          query[key].push(value);
        } else {
          query[key] = [query[key], value];
        }
      }
    }
    return query;
  }
  exports.parseQueryString = parseQueryString;
});

// node_modules/@smithy/url-parser/dist-cjs/index.js
var require_dist_cjs38 = __commonJS((exports) => {
  var querystringParser = require_dist_cjs37();
  var parseUrl = (url) => {
    if (typeof url === "string") {
      return parseUrl(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
      query = querystringParser.parseQueryString(search);
    }
    return {
      hostname,
      port: port ? parseInt(port) : undefined,
      protocol,
      path: pathname,
      query
    };
  };
  exports.parseUrl = parseUrl;
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/index.js
var require_dist_cjs39 = __commonJS((exports) => {
  var utilEndpoints = require_dist_cjs36();
  var urlParser = require_dist_cjs38();
  var isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
    if (allowSubDomains) {
      for (const label of value.split(".")) {
        if (!isVirtualHostableS3Bucket(label)) {
          return false;
        }
      }
      return true;
    }
    if (!utilEndpoints.isValidHostLabel(value)) {
      return false;
    }
    if (value.length < 3 || value.length > 63) {
      return false;
    }
    if (value !== value.toLowerCase()) {
      return false;
    }
    if (utilEndpoints.isIpAddress(value)) {
      return false;
    }
    return true;
  };
  var ARN_DELIMITER = ":";
  var RESOURCE_DELIMITER = "/";
  var parseArn = (value) => {
    const segments = value.split(ARN_DELIMITER);
    if (segments.length < 6)
      return null;
    const [arn, partition3, service, region, accountId, ...resourcePath] = segments;
    if (arn !== "arn" || partition3 === "" || service === "" || resourcePath.join(ARN_DELIMITER) === "")
      return null;
    const resourceId = resourcePath.map((resource) => resource.split(RESOURCE_DELIMITER)).flat();
    return {
      partition: partition3,
      service,
      region,
      accountId,
      resourceId
    };
  };
  var partitions = [
    {
      id: "aws",
      outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-east-1",
        name: "aws",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
      regions: {
        "af-south-1": {
          description: "Africa (Cape Town)"
        },
        "ap-east-1": {
          description: "Asia Pacific (Hong Kong)"
        },
        "ap-east-2": {
          description: "Asia Pacific (Taipei)"
        },
        "ap-northeast-1": {
          description: "Asia Pacific (Tokyo)"
        },
        "ap-northeast-2": {
          description: "Asia Pacific (Seoul)"
        },
        "ap-northeast-3": {
          description: "Asia Pacific (Osaka)"
        },
        "ap-south-1": {
          description: "Asia Pacific (Mumbai)"
        },
        "ap-south-2": {
          description: "Asia Pacific (Hyderabad)"
        },
        "ap-southeast-1": {
          description: "Asia Pacific (Singapore)"
        },
        "ap-southeast-2": {
          description: "Asia Pacific (Sydney)"
        },
        "ap-southeast-3": {
          description: "Asia Pacific (Jakarta)"
        },
        "ap-southeast-4": {
          description: "Asia Pacific (Melbourne)"
        },
        "ap-southeast-5": {
          description: "Asia Pacific (Malaysia)"
        },
        "ap-southeast-6": {
          description: "Asia Pacific (New Zealand)"
        },
        "ap-southeast-7": {
          description: "Asia Pacific (Thailand)"
        },
        "aws-global": {
          description: "aws global region"
        },
        "ca-central-1": {
          description: "Canada (Central)"
        },
        "ca-west-1": {
          description: "Canada West (Calgary)"
        },
        "eu-central-1": {
          description: "Europe (Frankfurt)"
        },
        "eu-central-2": {
          description: "Europe (Zurich)"
        },
        "eu-north-1": {
          description: "Europe (Stockholm)"
        },
        "eu-south-1": {
          description: "Europe (Milan)"
        },
        "eu-south-2": {
          description: "Europe (Spain)"
        },
        "eu-west-1": {
          description: "Europe (Ireland)"
        },
        "eu-west-2": {
          description: "Europe (London)"
        },
        "eu-west-3": {
          description: "Europe (Paris)"
        },
        "il-central-1": {
          description: "Israel (Tel Aviv)"
        },
        "me-central-1": {
          description: "Middle East (UAE)"
        },
        "me-south-1": {
          description: "Middle East (Bahrain)"
        },
        "mx-central-1": {
          description: "Mexico (Central)"
        },
        "sa-east-1": {
          description: "South America (Sao Paulo)"
        },
        "us-east-1": {
          description: "US East (N. Virginia)"
        },
        "us-east-2": {
          description: "US East (Ohio)"
        },
        "us-west-1": {
          description: "US West (N. California)"
        },
        "us-west-2": {
          description: "US West (Oregon)"
        }
      }
    },
    {
      id: "aws-cn",
      outputs: {
        dnsSuffix: "amazonaws.com.cn",
        dualStackDnsSuffix: "api.amazonwebservices.com.cn",
        implicitGlobalRegion: "cn-northwest-1",
        name: "aws-cn",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^cn\\-\\w+\\-\\d+$",
      regions: {
        "aws-cn-global": {
          description: "aws-cn global region"
        },
        "cn-north-1": {
          description: "China (Beijing)"
        },
        "cn-northwest-1": {
          description: "China (Ningxia)"
        }
      }
    },
    {
      id: "aws-eusc",
      outputs: {
        dnsSuffix: "amazonaws.eu",
        dualStackDnsSuffix: "api.amazonwebservices.eu",
        implicitGlobalRegion: "eusc-de-east-1",
        name: "aws-eusc",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
      regions: {
        "eusc-de-east-1": {
          description: "AWS European Sovereign Cloud (Germany)"
        }
      }
    },
    {
      id: "aws-iso",
      outputs: {
        dnsSuffix: "c2s.ic.gov",
        dualStackDnsSuffix: "api.aws.ic.gov",
        implicitGlobalRegion: "us-iso-east-1",
        name: "aws-iso",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-global": {
          description: "aws-iso global region"
        },
        "us-iso-east-1": {
          description: "US ISO East"
        },
        "us-iso-west-1": {
          description: "US ISO WEST"
        }
      }
    },
    {
      id: "aws-iso-b",
      outputs: {
        dnsSuffix: "sc2s.sgov.gov",
        dualStackDnsSuffix: "api.aws.scloud",
        implicitGlobalRegion: "us-isob-east-1",
        name: "aws-iso-b",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-b-global": {
          description: "aws-iso-b global region"
        },
        "us-isob-east-1": {
          description: "US ISOB East (Ohio)"
        },
        "us-isob-west-1": {
          description: "US ISOB West"
        }
      }
    },
    {
      id: "aws-iso-e",
      outputs: {
        dnsSuffix: "cloud.adc-e.uk",
        dualStackDnsSuffix: "api.cloud-aws.adc-e.uk",
        implicitGlobalRegion: "eu-isoe-west-1",
        name: "aws-iso-e",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-e-global": {
          description: "aws-iso-e global region"
        },
        "eu-isoe-west-1": {
          description: "EU ISOE West"
        }
      }
    },
    {
      id: "aws-iso-f",
      outputs: {
        dnsSuffix: "csp.hci.ic.gov",
        dualStackDnsSuffix: "api.aws.hci.ic.gov",
        implicitGlobalRegion: "us-isof-south-1",
        name: "aws-iso-f",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-f-global": {
          description: "aws-iso-f global region"
        },
        "us-isof-east-1": {
          description: "US ISOF EAST"
        },
        "us-isof-south-1": {
          description: "US ISOF SOUTH"
        }
      }
    },
    {
      id: "aws-us-gov",
      outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-gov-west-1",
        name: "aws-us-gov",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
      regions: {
        "aws-us-gov-global": {
          description: "aws-us-gov global region"
        },
        "us-gov-east-1": {
          description: "AWS GovCloud (US-East)"
        },
        "us-gov-west-1": {
          description: "AWS GovCloud (US-West)"
        }
      }
    }
  ];
  var version2 = "1.1";
  var partitionsInfo = {
    partitions,
    version: version2
  };
  var selectedPartitionsInfo = partitionsInfo;
  var selectedUserAgentPrefix = "";
  var partition2 = (value) => {
    const { partitions: partitions2 } = selectedPartitionsInfo;
    for (const partition3 of partitions2) {
      const { regions, outputs } = partition3;
      for (const [region, regionData] of Object.entries(regions)) {
        if (region === value) {
          return {
            ...outputs,
            ...regionData
          };
        }
      }
    }
    for (const partition3 of partitions2) {
      const { regionRegex, outputs } = partition3;
      if (new RegExp(regionRegex).test(value)) {
        return {
          ...outputs
        };
      }
    }
    const DEFAULT_PARTITION = partitions2.find((partition3) => partition3.id === "aws");
    if (!DEFAULT_PARTITION) {
      throw new Error("Provided region was not found in the partition array or regex," + " and default partition with id 'aws' doesn't exist.");
    }
    return {
      ...DEFAULT_PARTITION.outputs
    };
  };
  var setPartitionInfo = (partitionsInfo2, userAgentPrefix = "") => {
    selectedPartitionsInfo = partitionsInfo2;
    selectedUserAgentPrefix = userAgentPrefix;
  };
  var useDefaultPartitionInfo = () => {
    setPartitionInfo(partitionsInfo, "");
  };
  var getUserAgentPrefix = () => selectedUserAgentPrefix;
  var awsEndpointFunctions = {
    isVirtualHostableS3Bucket,
    parseArn,
    partition: partition2
  };
  utilEndpoints.customEndpointFunctions.aws = awsEndpointFunctions;
  var resolveDefaultAwsRegionalEndpointsConfig = (input) => {
    if (typeof input.endpointProvider !== "function") {
      throw new Error("@aws-sdk/util-endpoint - endpointProvider and endpoint missing in config for this client.");
    }
    const { endpoint } = input;
    if (endpoint === undefined) {
      input.endpoint = async () => {
        return toEndpointV1(input.endpointProvider({
          Region: typeof input.region === "function" ? await input.region() : input.region,
          UseDualStack: typeof input.useDualstackEndpoint === "function" ? await input.useDualstackEndpoint() : input.useDualstackEndpoint,
          UseFIPS: typeof input.useFipsEndpoint === "function" ? await input.useFipsEndpoint() : input.useFipsEndpoint,
          Endpoint: undefined
        }, { logger: input.logger }));
      };
    }
    return input;
  };
  var toEndpointV1 = (endpoint) => urlParser.parseUrl(endpoint.url);
  exports.EndpointError = utilEndpoints.EndpointError;
  exports.isIpAddress = utilEndpoints.isIpAddress;
  exports.resolveEndpoint = utilEndpoints.resolveEndpoint;
  exports.awsEndpointFunctions = awsEndpointFunctions;
  exports.getUserAgentPrefix = getUserAgentPrefix;
  exports.partition = partition2;
  exports.resolveDefaultAwsRegionalEndpointsConfig = resolveDefaultAwsRegionalEndpointsConfig;
  exports.setPartitionInfo = setPartitionInfo;
  exports.toEndpointV1 = toEndpointV1;
  exports.useDefaultPartitionInfo = useDefaultPartitionInfo;
});

// node_modules/@aws-sdk/middleware-user-agent/dist-cjs/index.js
var require_dist_cjs40 = __commonJS((exports) => {
  var core = require_dist_cjs17();
  var utilEndpoints = require_dist_cjs39();
  var protocolHttp = require_dist_cjs2();
  var core$1 = require_dist_cjs24();
  var DEFAULT_UA_APP_ID = undefined;
  function isValidUserAgentAppId(appId) {
    if (appId === undefined) {
      return true;
    }
    return typeof appId === "string" && appId.length <= 50;
  }
  function resolveUserAgentConfig(input) {
    const normalizedAppIdProvider = core.normalizeProvider(input.userAgentAppId ?? DEFAULT_UA_APP_ID);
    const { customUserAgent } = input;
    return Object.assign(input, {
      customUserAgent: typeof customUserAgent === "string" ? [[customUserAgent]] : customUserAgent,
      userAgentAppId: async () => {
        const appId = await normalizedAppIdProvider();
        if (!isValidUserAgentAppId(appId)) {
          const logger = input.logger?.constructor?.name === "NoOpLogger" || !input.logger ? console : input.logger;
          if (typeof appId !== "string") {
            logger?.warn("userAgentAppId must be a string or undefined.");
          } else if (appId.length > 50) {
            logger?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.");
          }
        }
        return appId;
      }
    });
  }
  var ACCOUNT_ID_ENDPOINT_REGEX = /\d{12}\.ddb/;
  async function checkFeatures(context, config, args) {
    const request = args.request;
    if (request?.headers?.["smithy-protocol"] === "rpc-v2-cbor") {
      core$1.setFeature(context, "PROTOCOL_RPC_V2_CBOR", "M");
    }
    if (typeof config.retryStrategy === "function") {
      const retryStrategy = await config.retryStrategy();
      if (typeof retryStrategy.acquireInitialRetryToken === "function") {
        if (retryStrategy.constructor?.name?.includes("Adaptive")) {
          core$1.setFeature(context, "RETRY_MODE_ADAPTIVE", "F");
        } else {
          core$1.setFeature(context, "RETRY_MODE_STANDARD", "E");
        }
      } else {
        core$1.setFeature(context, "RETRY_MODE_LEGACY", "D");
      }
    }
    if (typeof config.accountIdEndpointMode === "function") {
      const endpointV2 = context.endpointV2;
      if (String(endpointV2?.url?.hostname).match(ACCOUNT_ID_ENDPOINT_REGEX)) {
        core$1.setFeature(context, "ACCOUNT_ID_ENDPOINT", "O");
      }
      switch (await config.accountIdEndpointMode?.()) {
        case "disabled":
          core$1.setFeature(context, "ACCOUNT_ID_MODE_DISABLED", "Q");
          break;
        case "preferred":
          core$1.setFeature(context, "ACCOUNT_ID_MODE_PREFERRED", "P");
          break;
        case "required":
          core$1.setFeature(context, "ACCOUNT_ID_MODE_REQUIRED", "R");
          break;
      }
    }
    const identity = context.__smithy_context?.selectedHttpAuthScheme?.identity;
    if (identity?.$source) {
      const credentials = identity;
      if (credentials.accountId) {
        core$1.setFeature(context, "RESOLVED_ACCOUNT_ID", "T");
      }
      for (const [key, value] of Object.entries(credentials.$source ?? {})) {
        core$1.setFeature(context, key, value);
      }
    }
  }
  var USER_AGENT2 = "user-agent";
  var X_AMZ_USER_AGENT = "x-amz-user-agent";
  var SPACE = " ";
  var UA_NAME_SEPARATOR = "/";
  var UA_NAME_ESCAPE_REGEX = /[^!$%&'*+\-.^_`|~\w]/g;
  var UA_VALUE_ESCAPE_REGEX = /[^!$%&'*+\-.^_`|~\w#]/g;
  var UA_ESCAPE_CHAR = "-";
  var BYTE_LIMIT = 1024;
  function encodeFeatures(features) {
    let buffer = "";
    for (const key in features) {
      const val = features[key];
      if (buffer.length + val.length + 1 <= BYTE_LIMIT) {
        if (buffer.length) {
          buffer += "," + val;
        } else {
          buffer += val;
        }
        continue;
      }
      break;
    }
    return buffer;
  }
  var userAgentMiddleware = (options) => (next, context) => async (args) => {
    const { request } = args;
    if (!protocolHttp.HttpRequest.isInstance(request)) {
      return next(args);
    }
    const { headers } = request;
    const userAgent2 = context?.userAgent?.map(escapeUserAgent) || [];
    const defaultUserAgent2 = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
    await checkFeatures(context, options, args);
    const awsContext = context;
    defaultUserAgent2.push(`m/${encodeFeatures(Object.assign({}, context.__smithy_context?.features, awsContext.__aws_sdk_context?.features))}`);
    const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
    const appId = await options.userAgentAppId();
    if (appId) {
      defaultUserAgent2.push(escapeUserAgent([`app`, `${appId}`]));
    }
    const prefix = utilEndpoints.getUserAgentPrefix();
    const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent2, ...userAgent2, ...customUserAgent]).join(SPACE);
    const normalUAValue = [
      ...defaultUserAgent2.filter((section) => section.startsWith("aws-sdk-")),
      ...customUserAgent
    ].join(SPACE);
    if (options.runtime !== "browser") {
      if (normalUAValue) {
        headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT2]} ${normalUAValue}` : normalUAValue;
      }
      headers[USER_AGENT2] = sdkUserAgentValue;
    } else {
      headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
    }
    return next({
      ...args,
      request
    });
  };
  var escapeUserAgent = (userAgentPair) => {
    const name = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
    const version2 = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
    const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
    const prefix = name.substring(0, prefixSeparatorIndex);
    let uaName = name.substring(prefixSeparatorIndex + 1);
    if (prefix === "api") {
      uaName = uaName.toLowerCase();
    }
    return [prefix, uaName, version2].filter((item) => item && item.length > 0).reduce((acc, item, index) => {
      switch (index) {
        case 0:
          return item;
        case 1:
          return `${acc}/${item}`;
        default:
          return `${acc}#${item}`;
      }
    }, "");
  };
  var getUserAgentMiddlewareOptions = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: ["SET_USER_AGENT", "USER_AGENT"],
    override: true
  };
  var getUserAgentPlugin = (config) => ({
    applyToStack: (clientStack) => {
      clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
    }
  });
  exports.DEFAULT_UA_APP_ID = DEFAULT_UA_APP_ID;
  exports.getUserAgentMiddlewareOptions = getUserAgentMiddlewareOptions;
  exports.getUserAgentPlugin = getUserAgentPlugin;
  exports.resolveUserAgentConfig = resolveUserAgentConfig;
  exports.userAgentMiddleware = userAgentMiddleware;
});

// node_modules/@smithy/config-resolver/dist-cjs/index.js
var require_dist_cjs41 = __commonJS((exports) => {
  var utilConfigProvider = require_dist_cjs34();
  var utilMiddleware = require_dist_cjs4();
  var utilEndpoints = require_dist_cjs36();
  var ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
  var CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
  var DEFAULT_USE_DUALSTACK_ENDPOINT = false;
  var NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => utilConfigProvider.booleanSelector(env, ENV_USE_DUALSTACK_ENDPOINT, utilConfigProvider.SelectorType.ENV),
    configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, CONFIG_USE_DUALSTACK_ENDPOINT, utilConfigProvider.SelectorType.CONFIG),
    default: false
  };
  var ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
  var CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
  var DEFAULT_USE_FIPS_ENDPOINT = false;
  var NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => utilConfigProvider.booleanSelector(env, ENV_USE_FIPS_ENDPOINT, utilConfigProvider.SelectorType.ENV),
    configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, CONFIG_USE_FIPS_ENDPOINT, utilConfigProvider.SelectorType.CONFIG),
    default: false
  };
  var resolveCustomEndpointsConfig = (input) => {
    const { tls, endpoint, urlParser, useDualstackEndpoint } = input;
    return Object.assign(input, {
      tls: tls ?? true,
      endpoint: utilMiddleware.normalizeProvider(typeof endpoint === "string" ? urlParser(endpoint) : endpoint),
      isCustomEndpoint: true,
      useDualstackEndpoint: utilMiddleware.normalizeProvider(useDualstackEndpoint ?? false)
    });
  };
  var getEndpointFromRegion = async (input) => {
    const { tls = true } = input;
    const region = await input.region();
    const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
    if (!dnsHostRegex.test(region)) {
      throw new Error("Invalid region in client config");
    }
    const useDualstackEndpoint = await input.useDualstackEndpoint();
    const useFipsEndpoint = await input.useFipsEndpoint();
    const { hostname } = await input.regionInfoProvider(region, { useDualstackEndpoint, useFipsEndpoint }) ?? {};
    if (!hostname) {
      throw new Error("Cannot resolve hostname from client config");
    }
    return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
  };
  var resolveEndpointsConfig = (input) => {
    const useDualstackEndpoint = utilMiddleware.normalizeProvider(input.useDualstackEndpoint ?? false);
    const { endpoint, useFipsEndpoint, urlParser, tls } = input;
    return Object.assign(input, {
      tls: tls ?? true,
      endpoint: endpoint ? utilMiddleware.normalizeProvider(typeof endpoint === "string" ? urlParser(endpoint) : endpoint) : () => getEndpointFromRegion({ ...input, useDualstackEndpoint, useFipsEndpoint }),
      isCustomEndpoint: !!endpoint,
      useDualstackEndpoint
    });
  };
  var REGION_ENV_NAME = "AWS_REGION";
  var REGION_INI_NAME = "region";
  var NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[REGION_ENV_NAME],
    configFileSelector: (profile) => profile[REGION_INI_NAME],
    default: () => {
      throw new Error("Region is missing");
    }
  };
  var NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials"
  };
  var validRegions = new Set;
  var checkRegion = (region, check = utilEndpoints.isValidHostLabel) => {
    if (!validRegions.has(region) && !check(region)) {
      if (region === "*") {
        console.warn(`@smithy/config-resolver WARN - Please use the caller region instead of "*". See "sigv4a" in https://github.com/aws/aws-sdk-js-v3/blob/main/supplemental-docs/CLIENTS.md.`);
      } else {
        throw new Error(`Region not accepted: region="${region}" is not a valid hostname component.`);
      }
    } else {
      validRegions.add(region);
    }
  };
  var isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
  var getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
  var resolveRegionConfig = (input) => {
    const { region, useFipsEndpoint } = input;
    if (!region) {
      throw new Error("Region is missing");
    }
    return Object.assign(input, {
      region: async () => {
        const providedRegion = typeof region === "function" ? await region() : region;
        const realRegion = getRealRegion(providedRegion);
        checkRegion(realRegion);
        return realRegion;
      },
      useFipsEndpoint: async () => {
        const providedRegion = typeof region === "string" ? region : await region();
        if (isFipsRegion(providedRegion)) {
          return true;
        }
        return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
      }
    });
  };
  var getHostnameFromVariants = (variants = [], { useFipsEndpoint, useDualstackEndpoint }) => variants.find(({ tags }) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))?.hostname;
  var getResolvedHostname = (resolvedRegion, { regionHostname, partitionHostname }) => regionHostname ? regionHostname : partitionHostname ? partitionHostname.replace("{region}", resolvedRegion) : undefined;
  var getResolvedPartition = (region, { partitionHash }) => Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region)) ?? "aws";
  var getResolvedSigningRegion = (hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {
    if (signingRegion) {
      return signingRegion;
    } else if (useFipsEndpoint) {
      const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
      const regionRegexmatchArray = hostname.match(regionRegexJs);
      if (regionRegexmatchArray) {
        return regionRegexmatchArray[0].slice(1, -1);
      }
    }
  };
  var getRegionInfo = (region, { useFipsEndpoint = false, useDualstackEndpoint = false, signingService, regionHash, partitionHash }) => {
    const partition2 = getResolvedPartition(region, { partitionHash });
    const resolvedRegion = region in regionHash ? region : partitionHash[partition2]?.endpoint ?? region;
    const hostnameOptions = { useFipsEndpoint, useDualstackEndpoint };
    const regionHostname = getHostnameFromVariants(regionHash[resolvedRegion]?.variants, hostnameOptions);
    const partitionHostname = getHostnameFromVariants(partitionHash[partition2]?.variants, hostnameOptions);
    const hostname = getResolvedHostname(resolvedRegion, { regionHostname, partitionHostname });
    if (hostname === undefined) {
      throw new Error(`Endpoint resolution failed for: ${{ resolvedRegion, useFipsEndpoint, useDualstackEndpoint }}`);
    }
    const signingRegion = getResolvedSigningRegion(hostname, {
      signingRegion: regionHash[resolvedRegion]?.signingRegion,
      regionRegex: partitionHash[partition2].regionRegex,
      useFipsEndpoint
    });
    return {
      partition: partition2,
      signingService,
      hostname,
      ...signingRegion && { signingRegion },
      ...regionHash[resolvedRegion]?.signingService && {
        signingService: regionHash[resolvedRegion].signingService
      }
    };
  };
  exports.CONFIG_USE_DUALSTACK_ENDPOINT = CONFIG_USE_DUALSTACK_ENDPOINT;
  exports.CONFIG_USE_FIPS_ENDPOINT = CONFIG_USE_FIPS_ENDPOINT;
  exports.DEFAULT_USE_DUALSTACK_ENDPOINT = DEFAULT_USE_DUALSTACK_ENDPOINT;
  exports.DEFAULT_USE_FIPS_ENDPOINT = DEFAULT_USE_FIPS_ENDPOINT;
  exports.ENV_USE_DUALSTACK_ENDPOINT = ENV_USE_DUALSTACK_ENDPOINT;
  exports.ENV_USE_FIPS_ENDPOINT = ENV_USE_FIPS_ENDPOINT;
  exports.NODE_REGION_CONFIG_FILE_OPTIONS = NODE_REGION_CONFIG_FILE_OPTIONS;
  exports.NODE_REGION_CONFIG_OPTIONS = NODE_REGION_CONFIG_OPTIONS;
  exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS;
  exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS;
  exports.REGION_ENV_NAME = REGION_ENV_NAME;
  exports.REGION_INI_NAME = REGION_INI_NAME;
  exports.getRegionInfo = getRegionInfo;
  exports.resolveCustomEndpointsConfig = resolveCustomEndpointsConfig;
  exports.resolveEndpointsConfig = resolveEndpointsConfig;
  exports.resolveRegionConfig = resolveRegionConfig;
});

// node_modules/@smithy/eventstream-serde-config-resolver/dist-cjs/index.js
var require_dist_cjs42 = __commonJS((exports) => {
  var resolveEventStreamSerdeConfig = (input) => Object.assign(input, {
    eventStreamMarshaller: input.eventStreamSerdeProvider(input)
  });
  exports.resolveEventStreamSerdeConfig = resolveEventStreamSerdeConfig;
});

// node_modules/@smithy/middleware-content-length/dist-cjs/index.js
var require_dist_cjs43 = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs2();
  var CONTENT_LENGTH_HEADER = "content-length";
  function contentLengthMiddleware(bodyLengthChecker) {
    return (next) => async (args) => {
      const request = args.request;
      if (protocolHttp.HttpRequest.isInstance(request)) {
        const { body, headers } = request;
        if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) {
          try {
            const length = bodyLengthChecker(body);
            request.headers = {
              ...request.headers,
              [CONTENT_LENGTH_HEADER]: String(length)
            };
          } catch (error) {}
        }
      }
      return next({
        ...args,
        request
      });
    };
  }
  var contentLengthMiddlewareOptions = {
    step: "build",
    tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
    name: "contentLengthMiddleware",
    override: true
  };
  var getContentLengthPlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
    }
  });
  exports.contentLengthMiddleware = contentLengthMiddleware;
  exports.contentLengthMiddlewareOptions = contentLengthMiddlewareOptions;
  exports.getContentLengthPlugin = getContentLengthPlugin;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getHomeDir.js
var require_getHomeDir = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHomeDir = undefined;
  var os_1 = __require("os");
  var path_1 = __require("path");
  var homeDirCache = {};
  var getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
      return `${process.geteuid()}`;
    }
    return "DEFAULT";
  };
  var getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${path_1.sep}` } = process.env;
    if (HOME)
      return HOME;
    if (USERPROFILE)
      return USERPROFILE;
    if (HOMEPATH)
      return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
      homeDirCache[homeDirCacheKey] = (0, os_1.homedir)();
    return homeDirCache[homeDirCacheKey];
  };
  exports.getHomeDir = getHomeDir;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFilepath.js
var require_getSSOTokenFilepath = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSSOTokenFilepath = undefined;
  var crypto_1 = __require("crypto");
  var path_1 = __require("path");
  var getHomeDir_1 = require_getHomeDir();
  var getSSOTokenFilepath = (id) => {
    const hasher = (0, crypto_1.createHash)("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "sso", "cache", `${cacheName}.json`);
  };
  exports.getSSOTokenFilepath = getSSOTokenFilepath;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFromFile.js
var require_getSSOTokenFromFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSSOTokenFromFile = exports.tokenIntercept = undefined;
  var promises_1 = __require("fs/promises");
  var getSSOTokenFilepath_1 = require_getSSOTokenFilepath();
  exports.tokenIntercept = {};
  var getSSOTokenFromFile = async (id) => {
    if (exports.tokenIntercept[id]) {
      return exports.tokenIntercept[id];
    }
    const ssoTokenFilepath = (0, getSSOTokenFilepath_1.getSSOTokenFilepath)(id);
    const ssoTokenText = await (0, promises_1.readFile)(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
  };
  exports.getSSOTokenFromFile = getSSOTokenFromFile;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/readFile.js
var require_readFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readFile = exports.fileIntercept = exports.filePromises = undefined;
  var promises_1 = __require("node:fs/promises");
  exports.filePromises = {};
  exports.fileIntercept = {};
  var readFile = (path, options) => {
    if (exports.fileIntercept[path] !== undefined) {
      return exports.fileIntercept[path];
    }
    if (!exports.filePromises[path] || options?.ignoreCache) {
      exports.filePromises[path] = (0, promises_1.readFile)(path, "utf8");
    }
    return exports.filePromises[path];
  };
  exports.readFile = readFile;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/index.js
var require_dist_cjs44 = __commonJS((exports) => {
  var getHomeDir = require_getHomeDir();
  var getSSOTokenFilepath = require_getSSOTokenFilepath();
  var getSSOTokenFromFile = require_getSSOTokenFromFile();
  var path = __require("path");
  var types = require_dist_cjs();
  var readFile = require_readFile();
  var ENV_PROFILE = "AWS_PROFILE";
  var DEFAULT_PROFILE = "default";
  var getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;
  var CONFIG_PREFIX_SEPARATOR = ".";
  var getConfigData = (data) => Object.entries(data).filter(([key]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
      return false;
    }
    return Object.values(types.IniSectionType).includes(key.substring(0, indexOfSeparator));
  }).reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === types.IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
  }, {
    ...data.default && { default: data.default }
  });
  var ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
  var getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || path.join(getHomeDir.getHomeDir(), ".aws", "config");
  var ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
  var getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || path.join(getHomeDir.getHomeDir(), ".aws", "credentials");
  var prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
  var profileNameBlockList = ["__proto__", "profile __proto__"];
  var parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
      const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
      const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
      if (isSection) {
        currentSection = undefined;
        currentSubSection = undefined;
        const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
        const matches = prefixKeyRegex.exec(sectionName);
        if (matches) {
          const [, prefix, , name] = matches;
          if (Object.values(types.IniSectionType).includes(prefix)) {
            currentSection = [prefix, name].join(CONFIG_PREFIX_SEPARATOR);
          }
        } else {
          currentSection = sectionName;
        }
        if (profileNameBlockList.includes(sectionName)) {
          throw new Error(`Found invalid profile name "${sectionName}"`);
        }
      } else if (currentSection) {
        const indexOfEqualsSign = trimmedLine.indexOf("=");
        if (![0, -1].includes(indexOfEqualsSign)) {
          const [name, value] = [
            trimmedLine.substring(0, indexOfEqualsSign).trim(),
            trimmedLine.substring(indexOfEqualsSign + 1).trim()
          ];
          if (value === "") {
            currentSubSection = name;
          } else {
            if (currentSubSection && iniLine.trimStart() === iniLine) {
              currentSubSection = undefined;
            }
            map[currentSection] = map[currentSection] || {};
            const key = currentSubSection ? [currentSubSection, name].join(CONFIG_PREFIX_SEPARATOR) : name;
            map[currentSection][key] = value;
          }
        }
      }
    }
    return map;
  };
  var swallowError$1 = () => ({});
  var loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init;
    const homeDir = getHomeDir.getHomeDir();
    const relativeHomeDirPrefix = "~/";
    let resolvedFilepath = filepath;
    if (filepath.startsWith(relativeHomeDirPrefix)) {
      resolvedFilepath = path.join(homeDir, filepath.slice(2));
    }
    let resolvedConfigFilepath = configFilepath;
    if (configFilepath.startsWith(relativeHomeDirPrefix)) {
      resolvedConfigFilepath = path.join(homeDir, configFilepath.slice(2));
    }
    const parsedFiles = await Promise.all([
      readFile.readFile(resolvedConfigFilepath, {
        ignoreCache: init.ignoreCache
      }).then(parseIni).then(getConfigData).catch(swallowError$1),
      readFile.readFile(resolvedFilepath, {
        ignoreCache: init.ignoreCache
      }).then(parseIni).catch(swallowError$1)
    ]);
    return {
      configFile: parsedFiles[0],
      credentialsFile: parsedFiles[1]
    };
  };
  var getSsoSessionData = (data) => Object.entries(data).filter(([key]) => key.startsWith(types.IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR)).reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});
  var swallowError = () => ({});
  var loadSsoSessionData = async (init = {}) => readFile.readFile(init.configFilepath ?? getConfigFilepath()).then(parseIni).then(getSsoSessionData).catch(swallowError);
  var mergeConfigFiles = (...files) => {
    const merged = {};
    for (const file of files) {
      for (const [key, values] of Object.entries(file)) {
        if (merged[key] !== undefined) {
          Object.assign(merged[key], values);
        } else {
          merged[key] = values;
        }
      }
    }
    return merged;
  };
  var parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
  };
  var externalDataInterceptor = {
    getFileRecord() {
      return readFile.fileIntercept;
    },
    interceptFile(path2, contents) {
      readFile.fileIntercept[path2] = Promise.resolve(contents);
    },
    getTokenRecord() {
      return getSSOTokenFromFile.tokenIntercept;
    },
    interceptToken(id, contents) {
      getSSOTokenFromFile.tokenIntercept[id] = contents;
    }
  };
  exports.getSSOTokenFromFile = getSSOTokenFromFile.getSSOTokenFromFile;
  exports.readFile = readFile.readFile;
  exports.CONFIG_PREFIX_SEPARATOR = CONFIG_PREFIX_SEPARATOR;
  exports.DEFAULT_PROFILE = DEFAULT_PROFILE;
  exports.ENV_PROFILE = ENV_PROFILE;
  exports.externalDataInterceptor = externalDataInterceptor;
  exports.getProfileName = getProfileName;
  exports.loadSharedConfigFiles = loadSharedConfigFiles;
  exports.loadSsoSessionData = loadSsoSessionData;
  exports.parseKnownFiles = parseKnownFiles;
  Object.prototype.hasOwnProperty.call(getHomeDir, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: getHomeDir["__proto__"]
  });
  Object.keys(getHomeDir).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = getHomeDir[k];
  });
  Object.prototype.hasOwnProperty.call(getSSOTokenFilepath, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: getSSOTokenFilepath["__proto__"]
  });
  Object.keys(getSSOTokenFilepath).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = getSSOTokenFilepath[k];
  });
});

// node_modules/@smithy/node-config-provider/dist-cjs/index.js
var require_dist_cjs45 = __commonJS((exports) => {
  var propertyProvider = require_dist_cjs18();
  var sharedIniFileLoader = require_dist_cjs44();
  function getSelectorName(functionString) {
    try {
      const constants = new Set(Array.from(functionString.match(/([A-Z_]){3,}/g) ?? []));
      constants.delete("CONFIG");
      constants.delete("CONFIG_PREFIX_SEPARATOR");
      constants.delete("ENV");
      return [...constants].join(", ");
    } catch (e) {
      return functionString;
    }
  }
  var fromEnv = (envVarSelector, options) => async () => {
    try {
      const config = envVarSelector(process.env, options);
      if (config === undefined) {
        throw new Error;
      }
      return config;
    } catch (e) {
      throw new propertyProvider.CredentialsProviderError(e.message || `Not found in ENV: ${getSelectorName(envVarSelector.toString())}`, { logger: options?.logger });
    }
  };
  var fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = sharedIniFileLoader.getProfileName(init);
    const { configFile, credentialsFile } = await sharedIniFileLoader.loadSharedConfigFiles(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config" ? { ...profileFromCredentials, ...profileFromConfig } : { ...profileFromConfig, ...profileFromCredentials };
    try {
      const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
      const configValue = configSelector(mergedProfile, cfgFile);
      if (configValue === undefined) {
        throw new Error;
      }
      return configValue;
    } catch (e) {
      throw new propertyProvider.CredentialsProviderError(e.message || `Not found in config files w/ profile [${profile}]: ${getSelectorName(configSelector.toString())}`, { logger: init.logger });
    }
  };
  var isFunction = (func) => typeof func === "function";
  var fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : propertyProvider.fromStatic(defaultValue);
  var loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => {
    const { signingName, logger } = configuration;
    const envOptions = { signingName, logger };
    return propertyProvider.memoize(propertyProvider.chain(fromEnv(environmentVariableSelector, envOptions), fromSharedConfigFiles(configFileSelector, configuration), fromStatic(defaultValue)));
  };
  exports.loadConfig = loadConfig;
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointUrlConfig.js
var require_getEndpointUrlConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEndpointUrlConfig = undefined;
  var shared_ini_file_loader_1 = require_dist_cjs44();
  var ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
  var CONFIG_ENDPOINT_URL = "endpoint_url";
  var getEndpointUrlConfig = (serviceId) => ({
    environmentVariableSelector: (env) => {
      const serviceSuffixParts = serviceId.split(" ").map((w) => w.toUpperCase());
      const serviceEndpointUrl = env[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
      if (serviceEndpointUrl)
        return serviceEndpointUrl;
      const endpointUrl = env[ENV_ENDPOINT_URL];
      if (endpointUrl)
        return endpointUrl;
      return;
    },
    configFileSelector: (profile, config) => {
      if (config && profile.services) {
        const servicesSection = config[["services", profile.services].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
        if (servicesSection) {
          const servicePrefixParts = serviceId.split(" ").map((w) => w.toLowerCase());
          const endpointUrl2 = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
          if (endpointUrl2)
            return endpointUrl2;
        }
      }
      const endpointUrl = profile[CONFIG_ENDPOINT_URL];
      if (endpointUrl)
        return endpointUrl;
      return;
    },
    default: undefined
  });
  exports.getEndpointUrlConfig = getEndpointUrlConfig;
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointFromConfig.js
var require_getEndpointFromConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEndpointFromConfig = undefined;
  var node_config_provider_1 = require_dist_cjs45();
  var getEndpointUrlConfig_1 = require_getEndpointUrlConfig();
  var getEndpointFromConfig = async (serviceId) => (0, node_config_provider_1.loadConfig)((0, getEndpointUrlConfig_1.getEndpointUrlConfig)(serviceId ?? ""))();
  exports.getEndpointFromConfig = getEndpointFromConfig;
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/index.js
var require_dist_cjs46 = __commonJS((exports) => {
  var getEndpointFromConfig = require_getEndpointFromConfig();
  var urlParser = require_dist_cjs38();
  var core = require_dist_cjs17();
  var utilMiddleware = require_dist_cjs4();
  var middlewareSerde = require_dist_cjs5();
  var resolveParamsForS3 = async (endpointParams) => {
    const bucket = endpointParams?.Bucket || "";
    if (typeof endpointParams.Bucket === "string") {
      endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if (isArnBucketName(bucket)) {
      if (endpointParams.ForcePathStyle === true) {
        throw new Error("Path-style addressing cannot be used with ARN buckets");
      }
    } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
      endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
      endpointParams.disableMultiRegionAccessPoints = true;
      endpointParams.DisableMRAP = true;
    }
    return endpointParams;
  };
  var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
  var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
  var DOTS_PATTERN = /\.\./;
  var isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
  var isArnBucketName = (bucketName) => {
    const [arn, partition2, service, , , bucket] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = Boolean(isArn && partition2 && service && bucket);
    if (isArn && !isValidArn) {
      throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return isValidArn;
  };
  var createConfigValueProvider = (configKey, canonicalEndpointParamKey, config, isClientContextParam = false) => {
    const configProvider = async () => {
      let configValue;
      if (isClientContextParam) {
        const clientContextParams = config.clientContextParams;
        const nestedValue = clientContextParams?.[configKey];
        configValue = nestedValue ?? config[configKey] ?? config[canonicalEndpointParamKey];
      } else {
        configValue = config[configKey] ?? config[canonicalEndpointParamKey];
      }
      if (typeof configValue === "function") {
        return configValue();
      }
      return configValue;
    };
    if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
      return async () => {
        const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
        const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
        return configValue;
      };
    }
    if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") {
      return async () => {
        const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
        const configValue = credentials?.accountId ?? credentials?.AccountId;
        return configValue;
      };
    }
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
      return async () => {
        if (config.isCustomEndpoint === false) {
          return;
        }
        const endpoint = await configProvider();
        if (endpoint && typeof endpoint === "object") {
          if ("url" in endpoint) {
            return endpoint.url.href;
          }
          if ("hostname" in endpoint) {
            const { protocol, hostname, port, path } = endpoint;
            return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
          }
        }
        return endpoint;
      };
    }
    return configProvider;
  };
  var toEndpointV1 = (endpoint) => {
    if (typeof endpoint === "object") {
      if ("url" in endpoint) {
        return urlParser.parseUrl(endpoint.url);
      }
      return endpoint;
    }
    return urlParser.parseUrl(endpoint);
  };
  var getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.isCustomEndpoint) {
      let endpointFromConfig;
      if (clientConfig.serviceConfiguredEndpoint) {
        endpointFromConfig = await clientConfig.serviceConfiguredEndpoint();
      } else {
        endpointFromConfig = await getEndpointFromConfig.getEndpointFromConfig(clientConfig.serviceId);
      }
      if (endpointFromConfig) {
        clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
        clientConfig.isCustomEndpoint = true;
      }
    }
    const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
      throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
  };
  var resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    const endpointParams = {};
    const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
    for (const [name, instruction] of Object.entries(instructions)) {
      switch (instruction.type) {
        case "staticContextParams":
          endpointParams[name] = instruction.value;
          break;
        case "contextParams":
          endpointParams[name] = commandInput[instruction.name];
          break;
        case "clientContextParams":
        case "builtInParams":
          endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig, instruction.type !== "builtInParams")();
          break;
        case "operationContextParams":
          endpointParams[name] = instruction.get(commandInput);
          break;
        default:
          throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
      }
    }
    if (Object.keys(instructions).length === 0) {
      Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
      await resolveParamsForS3(endpointParams);
    }
    return endpointParams;
  };
  var endpointMiddleware = ({ config, instructions }) => {
    return (next, context) => async (args) => {
      if (config.isCustomEndpoint) {
        core.setFeature(context, "ENDPOINT_OVERRIDE", "N");
      }
      const endpoint = await getEndpointFromInstructions(args.input, {
        getEndpointParameterInstructions() {
          return instructions;
        }
      }, { ...config }, context);
      context.endpointV2 = endpoint;
      context.authSchemes = endpoint.properties?.authSchemes;
      const authScheme = context.authSchemes?.[0];
      if (authScheme) {
        context["signing_region"] = authScheme.signingRegion;
        context["signing_service"] = authScheme.signingName;
        const smithyContext = utilMiddleware.getSmithyContext(context);
        const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
        if (httpAuthOption) {
          httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
            signing_region: authScheme.signingRegion,
            signingRegion: authScheme.signingRegion,
            signing_service: authScheme.signingName,
            signingName: authScheme.signingName,
            signingRegionSet: authScheme.signingRegionSet
          }, authScheme.properties);
        }
      }
      return next({
        ...args
      });
    };
  };
  var endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: middlewareSerde.serializerMiddlewareOption.name
  };
  var getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(endpointMiddleware({
        config,
        instructions
      }), endpointMiddlewareOptions);
    }
  });
  var resolveEndpointConfig = (input) => {
    const tls = input.tls ?? true;
    const { endpoint, useDualstackEndpoint, useFipsEndpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await utilMiddleware.normalizeProvider(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    const resolvedConfig = Object.assign(input, {
      endpoint: customEndpointProvider,
      tls,
      isCustomEndpoint,
      useDualstackEndpoint: utilMiddleware.normalizeProvider(useDualstackEndpoint ?? false),
      useFipsEndpoint: utilMiddleware.normalizeProvider(useFipsEndpoint ?? false)
    });
    let configuredEndpointPromise = undefined;
    resolvedConfig.serviceConfiguredEndpoint = async () => {
      if (input.serviceId && !configuredEndpointPromise) {
        configuredEndpointPromise = getEndpointFromConfig.getEndpointFromConfig(input.serviceId);
      }
      return configuredEndpointPromise;
    };
    return resolvedConfig;
  };
  var resolveEndpointRequiredConfig = (input) => {
    const { endpoint } = input;
    if (endpoint === undefined) {
      input.endpoint = async () => {
        throw new Error("@smithy/middleware-endpoint: (default endpointRuleSet) endpoint is not set - you must configure an endpoint.");
      };
    }
    return input;
  };
  exports.endpointMiddleware = endpointMiddleware;
  exports.endpointMiddlewareOptions = endpointMiddlewareOptions;
  exports.getEndpointFromInstructions = getEndpointFromInstructions;
  exports.getEndpointPlugin = getEndpointPlugin;
  exports.resolveEndpointConfig = resolveEndpointConfig;
  exports.resolveEndpointRequiredConfig = resolveEndpointRequiredConfig;
  exports.resolveParams = resolveParams;
  exports.toEndpointV1 = toEndpointV1;
});

// node_modules/@smithy/service-error-classification/dist-cjs/index.js
var require_dist_cjs47 = __commonJS((exports) => {
  var CLOCK_SKEW_ERROR_CODES = [
    "AuthFailure",
    "InvalidSignatureException",
    "RequestExpired",
    "RequestInTheFuture",
    "RequestTimeTooSkewed",
    "SignatureDoesNotMatch"
  ];
  var THROTTLING_ERROR_CODES = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
    "TransactionInProgressException"
  ];
  var TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
  var TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
  var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
  var NODEJS_NETWORK_ERROR_CODES = ["EHOSTUNREACH", "ENETUNREACH", "ENOTFOUND"];
  var isRetryableByTrait = (error) => error?.$retryable !== undefined;
  var isClockSkewError = (error) => CLOCK_SKEW_ERROR_CODES.includes(error.name);
  var isClockSkewCorrectedError = (error) => error.$metadata?.clockSkewCorrected;
  var isBrowserNetworkError = (error) => {
    const errorMessages = new Set([
      "Failed to fetch",
      "NetworkError when attempting to fetch resource",
      "The Internet connection appears to be offline",
      "Load failed",
      "Network request failed"
    ]);
    const isValid = error && error instanceof TypeError;
    if (!isValid) {
      return false;
    }
    return errorMessages.has(error.message);
  };
  var isThrottlingError = (error) => error.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error.name) || error.$retryable?.throttling == true;
  var isTransientError = (error, depth = 0) => isRetryableByTrait(error) || isClockSkewCorrectedError(error) || TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") || NODEJS_NETWORK_ERROR_CODES.includes(error?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0) || isBrowserNetworkError(error) || error.cause !== undefined && depth <= 10 && isTransientError(error.cause, depth + 1);
  var isServerError = (error) => {
    if (error.$metadata?.httpStatusCode !== undefined) {
      const statusCode = error.$metadata.httpStatusCode;
      if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
        return true;
      }
      return false;
    }
    return false;
  };
  exports.isBrowserNetworkError = isBrowserNetworkError;
  exports.isClockSkewCorrectedError = isClockSkewCorrectedError;
  exports.isClockSkewError = isClockSkewError;
  exports.isRetryableByTrait = isRetryableByTrait;
  exports.isServerError = isServerError;
  exports.isThrottlingError = isThrottlingError;
  exports.isTransientError = isTransientError;
});

// node_modules/@smithy/util-retry/dist-cjs/index.js
var require_dist_cjs48 = __commonJS((exports) => {
  var serviceErrorClassification = require_dist_cjs47();
  exports.RETRY_MODES = undefined;
  (function(RETRY_MODES) {
    RETRY_MODES["STANDARD"] = "standard";
    RETRY_MODES["ADAPTIVE"] = "adaptive";
  })(exports.RETRY_MODES || (exports.RETRY_MODES = {}));
  var DEFAULT_MAX_ATTEMPTS = 3;
  var DEFAULT_RETRY_MODE = exports.RETRY_MODES.STANDARD;

  class DefaultRateLimiter {
    static setTimeoutFn = setTimeout;
    beta;
    minCapacity;
    minFillRate;
    scaleConstant;
    smooth;
    currentCapacity = 0;
    enabled = false;
    lastMaxRate = 0;
    measuredTxRate = 0;
    requestCount = 0;
    fillRate;
    lastThrottleTime;
    lastTimestamp = 0;
    lastTxRateBucket;
    maxCapacity;
    timeWindow = 0;
    constructor(options) {
      this.beta = options?.beta ?? 0.7;
      this.minCapacity = options?.minCapacity ?? 1;
      this.minFillRate = options?.minFillRate ?? 0.5;
      this.scaleConstant = options?.scaleConstant ?? 0.4;
      this.smooth = options?.smooth ?? 0.8;
      const currentTimeInSeconds = this.getCurrentTimeInSeconds();
      this.lastThrottleTime = currentTimeInSeconds;
      this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
      this.fillRate = this.minFillRate;
      this.maxCapacity = this.minCapacity;
    }
    getCurrentTimeInSeconds() {
      return Date.now() / 1000;
    }
    async getSendToken() {
      return this.acquireTokenBucket(1);
    }
    async acquireTokenBucket(amount) {
      if (!this.enabled) {
        return;
      }
      this.refillTokenBucket();
      if (amount > this.currentCapacity) {
        const delay = (amount - this.currentCapacity) / this.fillRate * 1000;
        await new Promise((resolve) => DefaultRateLimiter.setTimeoutFn(resolve, delay));
      }
      this.currentCapacity = this.currentCapacity - amount;
    }
    refillTokenBucket() {
      const timestamp = this.getCurrentTimeInSeconds();
      if (!this.lastTimestamp) {
        this.lastTimestamp = timestamp;
        return;
      }
      const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
      this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
      this.lastTimestamp = timestamp;
    }
    updateClientSendingRate(response) {
      let calculatedRate;
      this.updateMeasuredRate();
      if (serviceErrorClassification.isThrottlingError(response)) {
        const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
        this.lastMaxRate = rateToUse;
        this.calculateTimeWindow();
        this.lastThrottleTime = this.getCurrentTimeInSeconds();
        calculatedRate = this.cubicThrottle(rateToUse);
        this.enableTokenBucket();
      } else {
        this.calculateTimeWindow();
        calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
      }
      const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
      this.updateTokenBucketRate(newRate);
    }
    calculateTimeWindow() {
      this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
    }
    cubicThrottle(rateToUse) {
      return this.getPrecise(rateToUse * this.beta);
    }
    cubicSuccess(timestamp) {
      return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
    }
    enableTokenBucket() {
      this.enabled = true;
    }
    updateTokenBucketRate(newRate) {
      this.refillTokenBucket();
      this.fillRate = Math.max(newRate, this.minFillRate);
      this.maxCapacity = Math.max(newRate, this.minCapacity);
      this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
    }
    updateMeasuredRate() {
      const t = this.getCurrentTimeInSeconds();
      const timeBucket = Math.floor(t * 2) / 2;
      this.requestCount++;
      if (timeBucket > this.lastTxRateBucket) {
        const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
        this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
        this.requestCount = 0;
        this.lastTxRateBucket = timeBucket;
      }
    }
    getPrecise(num) {
      return parseFloat(num.toFixed(8));
    }
  }
  var DEFAULT_RETRY_DELAY_BASE = 100;
  var MAXIMUM_RETRY_DELAY = 20 * 1000;
  var THROTTLING_RETRY_DELAY_BASE = 500;
  var INITIAL_RETRY_TOKENS = 500;
  var RETRY_COST = 5;
  var TIMEOUT_RETRY_COST = 10;
  var NO_RETRY_INCREMENT = 1;
  var INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
  var REQUEST_HEADER = "amz-sdk-request";
  var getDefaultRetryBackoffStrategy = () => {
    let delayBase = DEFAULT_RETRY_DELAY_BASE;
    const computeNextBackoffDelay = (attempts) => {
      return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
    };
    const setDelayBase = (delay) => {
      delayBase = delay;
    };
    return {
      computeNextBackoffDelay,
      setDelayBase
    };
  };
  var createDefaultRetryToken = ({ retryDelay, retryCount, retryCost }) => {
    const getRetryCount = () => retryCount;
    const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
    const getRetryCost = () => retryCost;
    return {
      getRetryCount,
      getRetryDelay,
      getRetryCost
    };
  };

  class StandardRetryStrategy {
    maxAttempts;
    mode = exports.RETRY_MODES.STANDARD;
    capacity = INITIAL_RETRY_TOKENS;
    retryBackoffStrategy = getDefaultRetryBackoffStrategy();
    maxAttemptsProvider;
    constructor(maxAttempts) {
      this.maxAttempts = maxAttempts;
      this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
    }
    async acquireInitialRetryToken(retryTokenScope) {
      return createDefaultRetryToken({
        retryDelay: DEFAULT_RETRY_DELAY_BASE,
        retryCount: 0
      });
    }
    async refreshRetryTokenForRetry(token2, errorInfo) {
      const maxAttempts = await this.getMaxAttempts();
      if (this.shouldRetry(token2, errorInfo, maxAttempts)) {
        const errorType = errorInfo.errorType;
        this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
        const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token2.getRetryCount());
        const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
        const capacityCost = this.getCapacityCost(errorType);
        this.capacity -= capacityCost;
        return createDefaultRetryToken({
          retryDelay,
          retryCount: token2.getRetryCount() + 1,
          retryCost: capacityCost
        });
      }
      throw new Error("No retry token available");
    }
    recordSuccess(token2) {
      this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token2.getRetryCost() ?? NO_RETRY_INCREMENT));
    }
    getCapacity() {
      return this.capacity;
    }
    async getMaxAttempts() {
      try {
        return await this.maxAttemptsProvider();
      } catch (error) {
        console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
        return DEFAULT_MAX_ATTEMPTS;
      }
    }
    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
      const attempts = tokenToRenew.getRetryCount() + 1;
      return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
    }
    getCapacityCost(errorType) {
      return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
    }
    isRetryableError(errorType) {
      return errorType === "THROTTLING" || errorType === "TRANSIENT";
    }
  }

  class AdaptiveRetryStrategy {
    maxAttemptsProvider;
    rateLimiter;
    standardRetryStrategy;
    mode = exports.RETRY_MODES.ADAPTIVE;
    constructor(maxAttemptsProvider, options) {
      this.maxAttemptsProvider = maxAttemptsProvider;
      const { rateLimiter } = options ?? {};
      this.rateLimiter = rateLimiter ?? new DefaultRateLimiter;
      this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
    }
    async acquireInitialRetryToken(retryTokenScope) {
      await this.rateLimiter.getSendToken();
      return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
      this.rateLimiter.updateClientSendingRate(errorInfo);
      return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
    }
    recordSuccess(token2) {
      this.rateLimiter.updateClientSendingRate({});
      this.standardRetryStrategy.recordSuccess(token2);
    }
  }

  class ConfiguredRetryStrategy extends StandardRetryStrategy {
    computeNextBackoffDelay;
    constructor(maxAttempts, computeNextBackoffDelay = DEFAULT_RETRY_DELAY_BASE) {
      super(typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts);
      if (typeof computeNextBackoffDelay === "number") {
        this.computeNextBackoffDelay = () => computeNextBackoffDelay;
      } else {
        this.computeNextBackoffDelay = computeNextBackoffDelay;
      }
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
      const token2 = await super.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
      token2.getRetryDelay = () => this.computeNextBackoffDelay(token2.getRetryCount());
      return token2;
    }
  }
  exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;
  exports.ConfiguredRetryStrategy = ConfiguredRetryStrategy;
  exports.DEFAULT_MAX_ATTEMPTS = DEFAULT_MAX_ATTEMPTS;
  exports.DEFAULT_RETRY_DELAY_BASE = DEFAULT_RETRY_DELAY_BASE;
  exports.DEFAULT_RETRY_MODE = DEFAULT_RETRY_MODE;
  exports.DefaultRateLimiter = DefaultRateLimiter;
  exports.INITIAL_RETRY_TOKENS = INITIAL_RETRY_TOKENS;
  exports.INVOCATION_ID_HEADER = INVOCATION_ID_HEADER;
  exports.MAXIMUM_RETRY_DELAY = MAXIMUM_RETRY_DELAY;
  exports.NO_RETRY_INCREMENT = NO_RETRY_INCREMENT;
  exports.REQUEST_HEADER = REQUEST_HEADER;
  exports.RETRY_COST = RETRY_COST;
  exports.StandardRetryStrategy = StandardRetryStrategy;
  exports.THROTTLING_RETRY_DELAY_BASE = THROTTLING_RETRY_DELAY_BASE;
  exports.TIMEOUT_RETRY_COST = TIMEOUT_RETRY_COST;
});

// node_modules/@smithy/middleware-retry/dist-cjs/isStreamingPayload/isStreamingPayload.js
var require_isStreamingPayload = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isStreamingPayload = undefined;
  var stream_1 = __require("stream");
  var isStreamingPayload = (request) => request?.body instanceof stream_1.Readable || typeof ReadableStream !== "undefined" && request?.body instanceof ReadableStream;
  exports.isStreamingPayload = isStreamingPayload;
});

// node_modules/@smithy/middleware-retry/dist-cjs/index.js
var require_dist_cjs49 = __commonJS((exports) => {
  var utilRetry = require_dist_cjs48();
  var protocolHttp = require_dist_cjs2();
  var serviceErrorClassification = require_dist_cjs47();
  var uuid = require_dist_cjs16();
  var utilMiddleware = require_dist_cjs4();
  var smithyClient = require_dist_cjs22();
  var isStreamingPayload = require_isStreamingPayload();
  var getDefaultRetryQuota = (initialRetryTokens, options) => {
    const MAX_CAPACITY = initialRetryTokens;
    const noRetryIncrement = utilRetry.NO_RETRY_INCREMENT;
    const retryCost = utilRetry.RETRY_COST;
    const timeoutRetryCost = utilRetry.TIMEOUT_RETRY_COST;
    let availableCapacity = initialRetryTokens;
    const getCapacityAmount = (error) => error.name === "TimeoutError" ? timeoutRetryCost : retryCost;
    const hasRetryTokens = (error) => getCapacityAmount(error) <= availableCapacity;
    const retrieveRetryTokens = (error) => {
      if (!hasRetryTokens(error)) {
        throw new Error("No retry token available");
      }
      const capacityAmount = getCapacityAmount(error);
      availableCapacity -= capacityAmount;
      return capacityAmount;
    };
    const releaseRetryTokens = (capacityReleaseAmount) => {
      availableCapacity += capacityReleaseAmount ?? noRetryIncrement;
      availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
    };
    return Object.freeze({
      hasRetryTokens,
      retrieveRetryTokens,
      releaseRetryTokens
    });
  };
  var defaultDelayDecider = (delayBase, attempts) => Math.floor(Math.min(utilRetry.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
  var defaultRetryDecider = (error) => {
    if (!error) {
      return false;
    }
    return serviceErrorClassification.isRetryableByTrait(error) || serviceErrorClassification.isClockSkewError(error) || serviceErrorClassification.isThrottlingError(error) || serviceErrorClassification.isTransientError(error);
  };
  var asSdkError = (error) => {
    if (error instanceof Error)
      return error;
    if (error instanceof Object)
      return Object.assign(new Error, error);
    if (typeof error === "string")
      return new Error(error);
    return new Error(`AWS SDK error wrapper for ${error}`);
  };

  class StandardRetryStrategy {
    maxAttemptsProvider;
    retryDecider;
    delayDecider;
    retryQuota;
    mode = utilRetry.RETRY_MODES.STANDARD;
    constructor(maxAttemptsProvider, options) {
      this.maxAttemptsProvider = maxAttemptsProvider;
      this.retryDecider = options?.retryDecider ?? defaultRetryDecider;
      this.delayDecider = options?.delayDecider ?? defaultDelayDecider;
      this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(utilRetry.INITIAL_RETRY_TOKENS);
    }
    shouldRetry(error, attempts, maxAttempts) {
      return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);
    }
    async getMaxAttempts() {
      let maxAttempts;
      try {
        maxAttempts = await this.maxAttemptsProvider();
      } catch (error) {
        maxAttempts = utilRetry.DEFAULT_MAX_ATTEMPTS;
      }
      return maxAttempts;
    }
    async retry(next, args, options) {
      let retryTokenAmount;
      let attempts = 0;
      let totalDelay = 0;
      const maxAttempts = await this.getMaxAttempts();
      const { request } = args;
      if (protocolHttp.HttpRequest.isInstance(request)) {
        request.headers[utilRetry.INVOCATION_ID_HEADER] = uuid.v4();
      }
      while (true) {
        try {
          if (protocolHttp.HttpRequest.isInstance(request)) {
            request.headers[utilRetry.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
          }
          if (options?.beforeRequest) {
            await options.beforeRequest();
          }
          const { response, output } = await next(args);
          if (options?.afterRequest) {
            options.afterRequest(response);
          }
          this.retryQuota.releaseRetryTokens(retryTokenAmount);
          output.$metadata.attempts = attempts + 1;
          output.$metadata.totalRetryDelay = totalDelay;
          return { response, output };
        } catch (e) {
          const err = asSdkError(e);
          attempts++;
          if (this.shouldRetry(err, attempts, maxAttempts)) {
            retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);
            const delayFromDecider = this.delayDecider(serviceErrorClassification.isThrottlingError(err) ? utilRetry.THROTTLING_RETRY_DELAY_BASE : utilRetry.DEFAULT_RETRY_DELAY_BASE, attempts);
            const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);
            const delay = Math.max(delayFromResponse || 0, delayFromDecider);
            totalDelay += delay;
            await new Promise((resolve) => setTimeout(resolve, delay));
            continue;
          }
          if (!err.$metadata) {
            err.$metadata = {};
          }
          err.$metadata.attempts = attempts;
          err.$metadata.totalRetryDelay = totalDelay;
          throw err;
        }
      }
    }
  }
  var getDelayFromRetryAfterHeader = (response) => {
    if (!protocolHttp.HttpResponse.isInstance(response))
      return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
      return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
      return retryAfterSeconds * 1000;
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate.getTime() - Date.now();
  };

  class AdaptiveRetryStrategy extends StandardRetryStrategy {
    rateLimiter;
    constructor(maxAttemptsProvider, options) {
      const { rateLimiter, ...superOptions } = options ?? {};
      super(maxAttemptsProvider, superOptions);
      this.rateLimiter = rateLimiter ?? new utilRetry.DefaultRateLimiter;
      this.mode = utilRetry.RETRY_MODES.ADAPTIVE;
    }
    async retry(next, args) {
      return super.retry(next, args, {
        beforeRequest: async () => {
          return this.rateLimiter.getSendToken();
        },
        afterRequest: (response) => {
          this.rateLimiter.updateClientSendingRate(response);
        }
      });
    }
  }
  var ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
  var CONFIG_MAX_ATTEMPTS = "max_attempts";
  var NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
      const value = env[ENV_MAX_ATTEMPTS];
      if (!value)
        return;
      const maxAttempt = parseInt(value);
      if (Number.isNaN(maxAttempt)) {
        throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
      }
      return maxAttempt;
    },
    configFileSelector: (profile) => {
      const value = profile[CONFIG_MAX_ATTEMPTS];
      if (!value)
        return;
      const maxAttempt = parseInt(value);
      if (Number.isNaN(maxAttempt)) {
        throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
      }
      return maxAttempt;
    },
    default: utilRetry.DEFAULT_MAX_ATTEMPTS
  };
  var resolveRetryConfig = (input) => {
    const { retryStrategy, retryMode: _retryMode, maxAttempts: _maxAttempts } = input;
    const maxAttempts = utilMiddleware.normalizeProvider(_maxAttempts ?? utilRetry.DEFAULT_MAX_ATTEMPTS);
    return Object.assign(input, {
      maxAttempts,
      retryStrategy: async () => {
        if (retryStrategy) {
          return retryStrategy;
        }
        const retryMode = await utilMiddleware.normalizeProvider(_retryMode)();
        if (retryMode === utilRetry.RETRY_MODES.ADAPTIVE) {
          return new utilRetry.AdaptiveRetryStrategy(maxAttempts);
        }
        return new utilRetry.StandardRetryStrategy(maxAttempts);
      }
    });
  };
  var ENV_RETRY_MODE = "AWS_RETRY_MODE";
  var CONFIG_RETRY_MODE = "retry_mode";
  var NODE_RETRY_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[ENV_RETRY_MODE],
    configFileSelector: (profile) => profile[CONFIG_RETRY_MODE],
    default: utilRetry.DEFAULT_RETRY_MODE
  };
  var omitRetryHeadersMiddleware = () => (next) => async (args) => {
    const { request } = args;
    if (protocolHttp.HttpRequest.isInstance(request)) {
      delete request.headers[utilRetry.INVOCATION_ID_HEADER];
      delete request.headers[utilRetry.REQUEST_HEADER];
    }
    return next(args);
  };
  var omitRetryHeadersMiddlewareOptions = {
    name: "omitRetryHeadersMiddleware",
    tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
    relation: "before",
    toMiddleware: "awsAuthMiddleware",
    override: true
  };
  var getOmitRetryHeadersPlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(omitRetryHeadersMiddleware(), omitRetryHeadersMiddlewareOptions);
    }
  });
  var retryMiddleware = (options) => (next, context) => async (args) => {
    let retryStrategy = await options.retryStrategy();
    const maxAttempts = await options.maxAttempts();
    if (isRetryStrategyV2(retryStrategy)) {
      retryStrategy = retryStrategy;
      let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
      let lastError = new Error;
      let attempts = 0;
      let totalRetryDelay = 0;
      const { request } = args;
      const isRequest = protocolHttp.HttpRequest.isInstance(request);
      if (isRequest) {
        request.headers[utilRetry.INVOCATION_ID_HEADER] = uuid.v4();
      }
      while (true) {
        try {
          if (isRequest) {
            request.headers[utilRetry.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
          }
          const { response, output } = await next(args);
          retryStrategy.recordSuccess(retryToken);
          output.$metadata.attempts = attempts + 1;
          output.$metadata.totalRetryDelay = totalRetryDelay;
          return { response, output };
        } catch (e) {
          const retryErrorInfo = getRetryErrorInfo(e);
          lastError = asSdkError(e);
          if (isRequest && isStreamingPayload.isStreamingPayload(request)) {
            (context.logger instanceof smithyClient.NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
            throw lastError;
          }
          try {
            retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
          } catch (refreshError) {
            if (!lastError.$metadata) {
              lastError.$metadata = {};
            }
            lastError.$metadata.attempts = attempts + 1;
            lastError.$metadata.totalRetryDelay = totalRetryDelay;
            throw lastError;
          }
          attempts = retryToken.getRetryCount();
          const delay = retryToken.getRetryDelay();
          totalRetryDelay += delay;
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    } else {
      retryStrategy = retryStrategy;
      if (retryStrategy?.mode)
        context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
      return retryStrategy.retry(next, args);
    }
  };
  var isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
  var getRetryErrorInfo = (error) => {
    const errorInfo = {
      error,
      errorType: getRetryErrorType(error)
    };
    const retryAfterHint = getRetryAfterHint(error.$response);
    if (retryAfterHint) {
      errorInfo.retryAfterHint = retryAfterHint;
    }
    return errorInfo;
  };
  var getRetryErrorType = (error) => {
    if (serviceErrorClassification.isThrottlingError(error))
      return "THROTTLING";
    if (serviceErrorClassification.isTransientError(error))
      return "TRANSIENT";
    if (serviceErrorClassification.isServerError(error))
      return "SERVER_ERROR";
    return "CLIENT_ERROR";
  };
  var retryMiddlewareOptions = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: true
  };
  var getRetryPlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
    }
  });
  var getRetryAfterHint = (response) => {
    if (!protocolHttp.HttpResponse.isInstance(response))
      return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
      return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
      return new Date(retryAfterSeconds * 1000);
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate;
  };
  exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;
  exports.CONFIG_MAX_ATTEMPTS = CONFIG_MAX_ATTEMPTS;
  exports.CONFIG_RETRY_MODE = CONFIG_RETRY_MODE;
  exports.ENV_MAX_ATTEMPTS = ENV_MAX_ATTEMPTS;
  exports.ENV_RETRY_MODE = ENV_RETRY_MODE;
  exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = NODE_MAX_ATTEMPT_CONFIG_OPTIONS;
  exports.NODE_RETRY_MODE_CONFIG_OPTIONS = NODE_RETRY_MODE_CONFIG_OPTIONS;
  exports.StandardRetryStrategy = StandardRetryStrategy;
  exports.defaultDelayDecider = defaultDelayDecider;
  exports.defaultRetryDecider = defaultRetryDecider;
  exports.getOmitRetryHeadersPlugin = getOmitRetryHeadersPlugin;
  exports.getRetryAfterHint = getRetryAfterHint;
  exports.getRetryPlugin = getRetryPlugin;
  exports.omitRetryHeadersMiddleware = omitRetryHeadersMiddleware;
  exports.omitRetryHeadersMiddlewareOptions = omitRetryHeadersMiddlewareOptions;
  exports.resolveRetryConfig = resolveRetryConfig;
  exports.retryMiddleware = retryMiddleware;
  exports.retryMiddlewareOptions = retryMiddlewareOptions;
});

// node_modules/@aws-sdk/signature-v4-multi-region/dist-cjs/index.js
var require_dist_cjs50 = __commonJS((exports) => {
  var middlewareSdkS3 = require_dist_cjs35();
  var signatureV4 = require_dist_cjs19();
  var signatureV4CrtContainer = {
    CrtSignerV4: null
  };

  class SignatureV4MultiRegion {
    sigv4aSigner;
    sigv4Signer;
    signerOptions;
    static sigv4aDependency() {
      if (typeof signatureV4CrtContainer.CrtSignerV4 === "function") {
        return "crt";
      } else if (typeof signatureV4.signatureV4aContainer.SignatureV4a === "function") {
        return "js";
      }
      return "none";
    }
    constructor(options) {
      this.sigv4Signer = new middlewareSdkS3.SignatureV4S3Express(options);
      this.signerOptions = options;
    }
    async sign(requestToSign, options = {}) {
      if (options.signingRegion === "*") {
        return this.getSigv4aSigner().sign(requestToSign, options);
      }
      return this.sigv4Signer.sign(requestToSign, options);
    }
    async signWithCredentials(requestToSign, credentials, options = {}) {
      if (options.signingRegion === "*") {
        const signer = this.getSigv4aSigner();
        const CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
        if (CrtSignerV4 && signer instanceof CrtSignerV4) {
          return signer.signWithCredentials(requestToSign, credentials, options);
        } else {
          throw new Error(`signWithCredentials with signingRegion '*' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. ` + `Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. ` + `You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] ` + `or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. ` + `For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`);
        }
      }
      return this.sigv4Signer.signWithCredentials(requestToSign, credentials, options);
    }
    async presign(originalRequest, options = {}) {
      if (options.signingRegion === "*") {
        const signer = this.getSigv4aSigner();
        const CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
        if (CrtSignerV4 && signer instanceof CrtSignerV4) {
          return signer.presign(originalRequest, options);
        } else {
          throw new Error(`presign with signingRegion '*' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. ` + `Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. ` + `You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] ` + `or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. ` + `For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`);
        }
      }
      return this.sigv4Signer.presign(originalRequest, options);
    }
    async presignWithCredentials(originalRequest, credentials, options = {}) {
      if (options.signingRegion === "*") {
        throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
      }
      return this.sigv4Signer.presignWithCredentials(originalRequest, credentials, options);
    }
    getSigv4aSigner() {
      if (!this.sigv4aSigner) {
        const CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
        const JsSigV4aSigner = signatureV4.signatureV4aContainer.SignatureV4a;
        if (this.signerOptions.runtime === "node") {
          if (!CrtSignerV4 && !JsSigV4aSigner) {
            throw new Error("Neither CRT nor JS SigV4a implementation is available. " + "Please load either @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a. " + "For more information please go to " + "https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt");
          }
          if (CrtSignerV4 && typeof CrtSignerV4 === "function") {
            this.sigv4aSigner = new CrtSignerV4({
              ...this.signerOptions,
              signingAlgorithm: 1
            });
          } else if (JsSigV4aSigner && typeof JsSigV4aSigner === "function") {
            this.sigv4aSigner = new JsSigV4aSigner({
              ...this.signerOptions
            });
          } else {
            throw new Error("Available SigV4a implementation is not a valid constructor. " + "Please ensure you've properly imported @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a." + "For more information please go to " + "https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt");
          }
        } else {
          if (!JsSigV4aSigner || typeof JsSigV4aSigner !== "function") {
            throw new Error("JS SigV4a implementation is not available or not a valid constructor. " + "Please check whether you have installed the @aws-sdk/signature-v4a package explicitly. The CRT implementation is not available for browsers. " + "You must also register the package by calling [require('@aws-sdk/signature-v4a');] " + "or an ESM equivalent such as [import '@aws-sdk/signature-v4a';]. " + "For more information please go to " + "https://github.com/aws/aws-sdk-js-v3#using-javascript-non-crt-implementation-of-sigv4a");
          }
          this.sigv4aSigner = new JsSigV4aSigner({
            ...this.signerOptions
          });
        }
      }
      return this.sigv4aSigner;
    }
  }
  exports.SignatureV4MultiRegion = SignatureV4MultiRegion;
  exports.signatureV4CrtContainer = signatureV4CrtContainer;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/endpoint/ruleset.js
var require_ruleset = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ruleSet = undefined;
  var cs = "required";
  var ct = "type";
  var cu = "rules";
  var cv = "conditions";
  var cw = "fn";
  var cx = "argv";
  var cy = "ref";
  var cz = "assign";
  var cA = "url";
  var cB = "properties";
  var cC = "backend";
  var cD = "authSchemes";
  var cE = "disableDoubleEncoding";
  var cF = "signingName";
  var cG = "signingRegion";
  var cH = "headers";
  var cI = "signingRegionSet";
  var a = 6;
  var b = false;
  var c = true;
  var d = "isSet";
  var e = "booleanEquals";
  var f = "error";
  var g = "aws.partition";
  var h = "stringEquals";
  var i2 = "getAttr";
  var j = "name";
  var k = "substring";
  var l = "bucketSuffix";
  var m = "parseURL";
  var n = "endpoint";
  var o = "tree";
  var p = "aws.isVirtualHostableS3Bucket";
  var q = "{url#scheme}://{Bucket}.{url#authority}{url#path}";
  var r = "not";
  var s = "accessPointSuffix";
  var t = "{url#scheme}://{url#authority}{url#path}";
  var u = "hardwareType";
  var v = "regionPrefix";
  var w = "bucketAliasSuffix";
  var x = "outpostId";
  var y = "isValidHostLabel";
  var z = "sigv4a";
  var A = "s3-outposts";
  var B = "s3";
  var C = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}";
  var D = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}";
  var E = "https://{Bucket}.s3.{partitionResult#dnsSuffix}";
  var F = "aws.parseArn";
  var G = "bucketArn";
  var H = "arnType";
  var I = "";
  var J = "s3-object-lambda";
  var K = "accesspoint";
  var L = "accessPointName";
  var M = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}";
  var N = "mrapPartition";
  var O = "outpostType";
  var P = "arnPrefix";
  var Q = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}";
  var R = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}";
  var S = "https://s3.{partitionResult#dnsSuffix}";
  var T = { [cs]: false, [ct]: "string" };
  var U = { [cs]: true, default: false, [ct]: "boolean" };
  var V = { [cs]: false, [ct]: "boolean" };
  var W = { [cw]: e, [cx]: [{ [cy]: "Accelerate" }, true] };
  var X = { [cw]: e, [cx]: [{ [cy]: "UseFIPS" }, true] };
  var Y = { [cw]: e, [cx]: [{ [cy]: "UseDualStack" }, true] };
  var Z = { [cw]: d, [cx]: [{ [cy]: "Endpoint" }] };
  var aa = { [cw]: g, [cx]: [{ [cy]: "Region" }], [cz]: "partitionResult" };
  var ab = { [cw]: h, [cx]: [{ [cw]: i2, [cx]: [{ [cy]: "partitionResult" }, j] }, "aws-cn"] };
  var ac = { [cw]: d, [cx]: [{ [cy]: "Bucket" }] };
  var ad = { [cy]: "Bucket" };
  var ae = { [cv]: [W], [f]: "S3Express does not support S3 Accelerate.", [ct]: f };
  var af = { [cv]: [Z, { [cw]: m, [cx]: [{ [cy]: "Endpoint" }], [cz]: "url" }], [cu]: [{ [cv]: [{ [cw]: d, [cx]: [{ [cy]: "DisableS3ExpressSessionAuth" }] }, { [cw]: e, [cx]: [{ [cy]: "DisableS3ExpressSessionAuth" }, true] }], [cu]: [{ [cv]: [{ [cw]: e, [cx]: [{ [cw]: i2, [cx]: [{ [cy]: "url" }, "isIp"] }, true] }], [cu]: [{ [cv]: [{ [cw]: "uriEncode", [cx]: [ad], [cz]: "uri_encoded_bucket" }], [cu]: [{ [n]: { [cA]: "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }], [ct]: o }], [ct]: o }, { [cv]: [{ [cw]: p, [cx]: [ad, false] }], [cu]: [{ [n]: { [cA]: q, [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }], [ct]: o }, { [f]: "S3Express bucket name is not a valid virtual hostable name.", [ct]: f }], [ct]: o }, { [cv]: [{ [cw]: e, [cx]: [{ [cw]: i2, [cx]: [{ [cy]: "url" }, "isIp"] }, true] }], [cu]: [{ [cv]: [{ [cw]: "uriEncode", [cx]: [ad], [cz]: "uri_encoded_bucket" }], [cu]: [{ [n]: { [cA]: "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }], [ct]: o }], [ct]: o }, { [cv]: [{ [cw]: p, [cx]: [ad, false] }], [cu]: [{ [n]: { [cA]: q, [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }], [ct]: o }, { [f]: "S3Express bucket name is not a valid virtual hostable name.", [ct]: f }], [ct]: o };
  var ag = { [cw]: m, [cx]: [{ [cy]: "Endpoint" }], [cz]: "url" };
  var ah = { [cw]: e, [cx]: [{ [cw]: i2, [cx]: [{ [cy]: "url" }, "isIp"] }, true] };
  var ai = { [cy]: "url" };
  var aj = { [cw]: "uriEncode", [cx]: [ad], [cz]: "uri_encoded_bucket" };
  var ak = { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: "s3express", [cG]: "{Region}" }] };
  var al = {};
  var am = { [cw]: p, [cx]: [ad, false] };
  var an = { [f]: "S3Express bucket name is not a valid virtual hostable name.", [ct]: f };
  var ao = { [cw]: d, [cx]: [{ [cy]: "UseS3ExpressControlEndpoint" }] };
  var ap = { [cw]: e, [cx]: [{ [cy]: "UseS3ExpressControlEndpoint" }, true] };
  var aq = { [cw]: r, [cx]: [Z] };
  var ar = { [cw]: e, [cx]: [{ [cy]: "UseDualStack" }, false] };
  var as = { [cw]: e, [cx]: [{ [cy]: "UseFIPS" }, false] };
  var at = { [f]: "Unrecognized S3Express bucket name format.", [ct]: f };
  var au = { [cw]: r, [cx]: [ac] };
  var av = { [cy]: u };
  var aw = { [cv]: [aq], [f]: "Expected a endpoint to be specified but no endpoint was found", [ct]: f };
  var ax = { [cD]: [{ [cE]: true, [j]: z, [cF]: A, [cI]: ["*"] }, { [cE]: true, [j]: "sigv4", [cF]: A, [cG]: "{Region}" }] };
  var ay = { [cw]: e, [cx]: [{ [cy]: "ForcePathStyle" }, false] };
  var az = { [cy]: "ForcePathStyle" };
  var aA = { [cw]: e, [cx]: [{ [cy]: "Accelerate" }, false] };
  var aB = { [cw]: h, [cx]: [{ [cy]: "Region" }, "aws-global"] };
  var aC = { [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: B, [cG]: "us-east-1" }] };
  var aD = { [cw]: r, [cx]: [aB] };
  var aE = { [cw]: e, [cx]: [{ [cy]: "UseGlobalEndpoint" }, true] };
  var aF = { [cA]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: B, [cG]: "{Region}" }] }, [cH]: {} };
  var aG = { [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: B, [cG]: "{Region}" }] };
  var aH = { [cw]: e, [cx]: [{ [cy]: "UseGlobalEndpoint" }, false] };
  var aI = { [cA]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
  var aJ = { [cA]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
  var aK = { [cA]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
  var aL = { [cw]: e, [cx]: [{ [cw]: i2, [cx]: [ai, "isIp"] }, false] };
  var aM = { [cA]: C, [cB]: aG, [cH]: {} };
  var aN = { [cA]: q, [cB]: aG, [cH]: {} };
  var aO = { [n]: aN, [ct]: n };
  var aP = { [cA]: D, [cB]: aG, [cH]: {} };
  var aQ = { [cA]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
  var aR = { [f]: "Invalid region: region was not a valid DNS name.", [ct]: f };
  var aS = { [cy]: G };
  var aT = { [cy]: H };
  var aU = { [cw]: i2, [cx]: [aS, "service"] };
  var aV = { [cy]: L };
  var aW = { [cv]: [Y], [f]: "S3 Object Lambda does not support Dual-stack", [ct]: f };
  var aX = { [cv]: [W], [f]: "S3 Object Lambda does not support S3 Accelerate", [ct]: f };
  var aY = { [cv]: [{ [cw]: d, [cx]: [{ [cy]: "DisableAccessPoints" }] }, { [cw]: e, [cx]: [{ [cy]: "DisableAccessPoints" }, true] }], [f]: "Access points are not supported for this operation", [ct]: f };
  var aZ = { [cv]: [{ [cw]: d, [cx]: [{ [cy]: "UseArnRegion" }] }, { [cw]: e, [cx]: [{ [cy]: "UseArnRegion" }, false] }, { [cw]: r, [cx]: [{ [cw]: h, [cx]: [{ [cw]: i2, [cx]: [aS, "region"] }, "{Region}"] }] }], [f]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [ct]: f };
  var ba = { [cw]: i2, [cx]: [{ [cy]: "bucketPartition" }, j] };
  var bb = { [cw]: i2, [cx]: [aS, "accountId"] };
  var bc = { [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: J, [cG]: "{bucketArn#region}" }] };
  var bd = { [f]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [ct]: f };
  var be = { [f]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [ct]: f };
  var bf = { [f]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [ct]: f };
  var bg = { [f]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [ct]: f };
  var bh = { [f]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [ct]: f };
  var bi = { [f]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [ct]: f };
  var bj = { [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: B, [cG]: "{bucketArn#region}" }] };
  var bk = { [cD]: [{ [cE]: true, [j]: z, [cF]: A, [cI]: ["*"] }, { [cE]: true, [j]: "sigv4", [cF]: A, [cG]: "{bucketArn#region}" }] };
  var bl = { [cw]: F, [cx]: [ad] };
  var bm = { [cA]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aG, [cH]: {} };
  var bn = { [cA]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aG, [cH]: {} };
  var bo = { [cA]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aG, [cH]: {} };
  var bp = { [cA]: Q, [cB]: aG, [cH]: {} };
  var bq = { [cA]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aG, [cH]: {} };
  var br = { [cy]: "UseObjectLambdaEndpoint" };
  var bs = { [cD]: [{ [cE]: true, [j]: "sigv4", [cF]: J, [cG]: "{Region}" }] };
  var bt = { [cA]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
  var bu = { [cA]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
  var bv = { [cA]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
  var bw = { [cA]: t, [cB]: aG, [cH]: {} };
  var bx = { [cA]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
  var by = [{ [cy]: "Region" }];
  var bz = [{ [cy]: "Endpoint" }];
  var bA = [ad];
  var bB = [W];
  var bC = [Z, ag];
  var bD = [{ [cw]: d, [cx]: [{ [cy]: "DisableS3ExpressSessionAuth" }] }, { [cw]: e, [cx]: [{ [cy]: "DisableS3ExpressSessionAuth" }, true] }];
  var bE = [aj];
  var bF = [am];
  var bG = [aa];
  var bH = [X, Y];
  var bI = [X, ar];
  var bJ = [as, Y];
  var bK = [as, ar];
  var bL = [{ [cw]: k, [cx]: [ad, 6, 14, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 14, 16, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bM = [{ [cv]: [X, Y], [n]: { [cA]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: {} }, [ct]: n }, { [cv]: bI, [n]: { [cA]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: {} }, [ct]: n }, { [cv]: bJ, [n]: { [cA]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: {} }, [ct]: n }, { [cv]: bK, [n]: { [cA]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: {} }, [ct]: n }];
  var bN = [{ [cw]: k, [cx]: [ad, 6, 15, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 15, 17, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bO = [{ [cw]: k, [cx]: [ad, 6, 19, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 19, 21, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bP = [{ [cw]: k, [cx]: [ad, 6, 20, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 20, 22, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bQ = [{ [cw]: k, [cx]: [ad, 6, 26, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 26, 28, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bR = [{ [cv]: [X, Y], [n]: { [cA]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }, { [cv]: bI, [n]: { [cA]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }, { [cv]: bJ, [n]: { [cA]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }, { [cv]: bK, [n]: { [cA]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n }];
  var bS = [ad, 0, 7, true];
  var bT = [{ [cw]: k, [cx]: [ad, 7, 15, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 15, 17, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bU = [{ [cw]: k, [cx]: [ad, 7, 16, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 16, 18, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bV = [{ [cw]: k, [cx]: [ad, 7, 20, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 20, 22, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bW = [{ [cw]: k, [cx]: [ad, 7, 21, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 21, 23, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bX = [{ [cw]: k, [cx]: [ad, 7, 27, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k, [cx]: [ad, 27, 29, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bY = [ac];
  var bZ = [{ [cw]: y, [cx]: [{ [cy]: x }, false] }];
  var ca = [{ [cw]: h, [cx]: [{ [cy]: v }, "beta"] }];
  var cb = ["*"];
  var cc = [{ [cw]: y, [cx]: [{ [cy]: "Region" }, false] }];
  var cd = [{ [cw]: h, [cx]: [{ [cy]: "Region" }, "us-east-1"] }];
  var ce = [{ [cw]: h, [cx]: [aT, K] }];
  var cf = [{ [cw]: i2, [cx]: [aS, "resourceId[1]"], [cz]: L }, { [cw]: r, [cx]: [{ [cw]: h, [cx]: [aV, I] }] }];
  var cg = [aS, "resourceId[1]"];
  var ch = [Y];
  var ci = [{ [cw]: r, [cx]: [{ [cw]: h, [cx]: [{ [cw]: i2, [cx]: [aS, "region"] }, I] }] }];
  var cj = [{ [cw]: r, [cx]: [{ [cw]: d, [cx]: [{ [cw]: i2, [cx]: [aS, "resourceId[2]"] }] }] }];
  var ck = [aS, "resourceId[2]"];
  var cl = [{ [cw]: g, [cx]: [{ [cw]: i2, [cx]: [aS, "region"] }], [cz]: "bucketPartition" }];
  var cm = [{ [cw]: h, [cx]: [ba, { [cw]: i2, [cx]: [{ [cy]: "partitionResult" }, j] }] }];
  var cn = [{ [cw]: y, [cx]: [{ [cw]: i2, [cx]: [aS, "region"] }, true] }];
  var co = [{ [cw]: y, [cx]: [bb, false] }];
  var cp = [{ [cw]: y, [cx]: [aV, false] }];
  var cq = [X];
  var cr = [{ [cw]: y, [cx]: [{ [cy]: "Region" }, true] }];
  var _data = { version: "1.0", parameters: { Bucket: T, Region: T, UseFIPS: U, UseDualStack: U, Endpoint: T, ForcePathStyle: U, Accelerate: U, UseGlobalEndpoint: U, UseObjectLambdaEndpoint: V, Key: T, Prefix: T, CopySource: T, DisableAccessPoints: V, DisableMultiRegionAccessPoints: U, UseArnRegion: V, UseS3ExpressControlEndpoint: V, DisableS3ExpressSessionAuth: V }, [cu]: [{ [cv]: [{ [cw]: d, [cx]: by }], [cu]: [{ [cv]: [W, X], error: "Accelerate cannot be used with FIPS", [ct]: f }, { [cv]: [Y, Z], error: "Cannot set dual-stack in combination with a custom endpoint.", [ct]: f }, { [cv]: [Z, X], error: "A custom endpoint cannot be combined with FIPS", [ct]: f }, { [cv]: [Z, W], error: "A custom endpoint cannot be combined with S3 Accelerate", [ct]: f }, { [cv]: [X, aa, ab], error: "Partition does not support FIPS", [ct]: f }, { [cv]: [ac, { [cw]: k, [cx]: [ad, 0, a, c], [cz]: l }, { [cw]: h, [cx]: [{ [cy]: l }, "--x-s3"] }], [cu]: [ae, af, { [cv]: [ao, ap], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: [aj, aq], [cu]: [{ [cv]: bH, endpoint: { [cA]: "https://s3express-control-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: ak, [cH]: al }, [ct]: n }, { [cv]: bI, endpoint: { [cA]: "https://s3express-control-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: ak, [cH]: al }, [ct]: n }, { [cv]: bJ, endpoint: { [cA]: "https://s3express-control.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: ak, [cH]: al }, [ct]: n }, { [cv]: bK, endpoint: { [cA]: "https://s3express-control.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: ak, [cH]: al }, [ct]: n }], [ct]: o }], [ct]: o }], [ct]: o }, { [cv]: bF, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: bD, [cu]: [{ [cv]: bL, [cu]: bM, [ct]: o }, { [cv]: bN, [cu]: bM, [ct]: o }, { [cv]: bO, [cu]: bM, [ct]: o }, { [cv]: bP, [cu]: bM, [ct]: o }, { [cv]: bQ, [cu]: bM, [ct]: o }, at], [ct]: o }, { [cv]: bL, [cu]: bR, [ct]: o }, { [cv]: bN, [cu]: bR, [ct]: o }, { [cv]: bO, [cu]: bR, [ct]: o }, { [cv]: bP, [cu]: bR, [ct]: o }, { [cv]: bQ, [cu]: bR, [ct]: o }, at], [ct]: o }], [ct]: o }, an], [ct]: o }, { [cv]: [ac, { [cw]: k, [cx]: bS, [cz]: s }, { [cw]: h, [cx]: [{ [cy]: s }, "--xa-s3"] }], [cu]: [ae, af, { [cv]: bF, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: bD, [cu]: [{ [cv]: bT, [cu]: bM, [ct]: o }, { [cv]: bU, [cu]: bM, [ct]: o }, { [cv]: bV, [cu]: bM, [ct]: o }, { [cv]: bW, [cu]: bM, [ct]: o }, { [cv]: bX, [cu]: bM, [ct]: o }, at], [ct]: o }, { [cv]: bT, [cu]: bR, [ct]: o }, { [cv]: bU, [cu]: bR, [ct]: o }, { [cv]: bV, [cu]: bR, [ct]: o }, { [cv]: bW, [cu]: bR, [ct]: o }, { [cv]: bX, [cu]: bR, [ct]: o }, at], [ct]: o }], [ct]: o }, an], [ct]: o }, { [cv]: [au, ao, ap], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: bC, endpoint: { [cA]: t, [cB]: ak, [cH]: al }, [ct]: n }, { [cv]: bH, endpoint: { [cA]: "https://s3express-control-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: al }, [ct]: n }, { [cv]: bI, endpoint: { [cA]: "https://s3express-control-fips.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: al }, [ct]: n }, { [cv]: bJ, endpoint: { [cA]: "https://s3express-control.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: al }, [ct]: n }, { [cv]: bK, endpoint: { [cA]: "https://s3express-control.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: al }, [ct]: n }], [ct]: o }], [ct]: o }, { [cv]: [ac, { [cw]: k, [cx]: [ad, 49, 50, c], [cz]: u }, { [cw]: k, [cx]: [ad, 8, 12, c], [cz]: v }, { [cw]: k, [cx]: bS, [cz]: w }, { [cw]: k, [cx]: [ad, 32, 49, c], [cz]: x }, { [cw]: g, [cx]: by, [cz]: "regionPartition" }, { [cw]: h, [cx]: [{ [cy]: w }, "--op-s3"] }], [cu]: [{ [cv]: bZ, [cu]: [{ [cv]: bF, [cu]: [{ [cv]: [{ [cw]: h, [cx]: [av, "e"] }], [cu]: [{ [cv]: ca, [cu]: [aw, { [cv]: bC, endpoint: { [cA]: "https://{Bucket}.ec2.{url#authority}", [cB]: ax, [cH]: al }, [ct]: n }], [ct]: o }, { endpoint: { [cA]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cB]: ax, [cH]: al }, [ct]: n }], [ct]: o }, { [cv]: [{ [cw]: h, [cx]: [av, "o"] }], [cu]: [{ [cv]: ca, [cu]: [aw, { [cv]: bC, endpoint: { [cA]: "https://{Bucket}.op-{outpostId}.{url#authority}", [cB]: ax, [cH]: al }, [ct]: n }], [ct]: o }, { endpoint: { [cA]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cB]: ax, [cH]: al }, [ct]: n }], [ct]: o }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [ct]: f }], [ct]: o }, { error: "Invalid Outposts Bucket alias - it must be a valid bucket name.", [ct]: f }], [ct]: o }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [ct]: f }], [ct]: o }, { [cv]: bY, [cu]: [{ [cv]: [Z, { [cw]: r, [cx]: [{ [cw]: d, [cx]: [{ [cw]: m, [cx]: bz }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [ct]: f }, { [cv]: [ay, am], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cc, [cu]: [{ [cv]: [W, ab], error: "S3 Accelerate cannot be used in this region", [ct]: f }, { [cv]: [Y, X, aA, aq, aB], endpoint: { [cA]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [Y, X, aA, aq, aD, aE], [cu]: [{ endpoint: aF, [ct]: n }], [ct]: o }, { [cv]: [Y, X, aA, aq, aD, aH], endpoint: aF, [ct]: n }, { [cv]: [ar, X, aA, aq, aB], endpoint: { [cA]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, X, aA, aq, aD, aE], [cu]: [{ endpoint: aI, [ct]: n }], [ct]: o }, { [cv]: [ar, X, aA, aq, aD, aH], endpoint: aI, [ct]: n }, { [cv]: [Y, as, W, aq, aB], endpoint: { [cA]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [Y, as, W, aq, aD, aE], [cu]: [{ endpoint: aJ, [ct]: n }], [ct]: o }, { [cv]: [Y, as, W, aq, aD, aH], endpoint: aJ, [ct]: n }, { [cv]: [Y, as, aA, aq, aB], endpoint: { [cA]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [Y, as, aA, aq, aD, aE], [cu]: [{ endpoint: aK, [ct]: n }], [ct]: o }, { [cv]: [Y, as, aA, aq, aD, aH], endpoint: aK, [ct]: n }, { [cv]: [ar, as, aA, Z, ag, ah, aB], endpoint: { [cA]: C, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, as, aA, Z, ag, aL, aB], endpoint: { [cA]: q, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, as, aA, Z, ag, ah, aD, aE], [cu]: [{ [cv]: cd, endpoint: aM, [ct]: n }, { endpoint: aM, [ct]: n }], [ct]: o }, { [cv]: [ar, as, aA, Z, ag, aL, aD, aE], [cu]: [{ [cv]: cd, endpoint: aN, [ct]: n }, aO], [ct]: o }, { [cv]: [ar, as, aA, Z, ag, ah, aD, aH], endpoint: aM, [ct]: n }, { [cv]: [ar, as, aA, Z, ag, aL, aD, aH], endpoint: aN, [ct]: n }, { [cv]: [ar, as, W, aq, aB], endpoint: { [cA]: D, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, as, W, aq, aD, aE], [cu]: [{ [cv]: cd, endpoint: aP, [ct]: n }, { endpoint: aP, [ct]: n }], [ct]: o }, { [cv]: [ar, as, W, aq, aD, aH], endpoint: aP, [ct]: n }, { [cv]: [ar, as, aA, aq, aB], endpoint: { [cA]: E, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, as, aA, aq, aD, aE], [cu]: [{ [cv]: cd, endpoint: { [cA]: E, [cB]: aG, [cH]: al }, [ct]: n }, { endpoint: aQ, [ct]: n }], [ct]: o }, { [cv]: [ar, as, aA, aq, aD, aH], endpoint: aQ, [ct]: n }], [ct]: o }, aR], [ct]: o }], [ct]: o }, { [cv]: [Z, ag, { [cw]: h, [cx]: [{ [cw]: i2, [cx]: [ai, "scheme"] }, "http"] }, { [cw]: p, [cx]: [ad, c] }, ay, as, ar, aA], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cc, [cu]: [aO], [ct]: o }, aR], [ct]: o }], [ct]: o }, { [cv]: [ay, { [cw]: F, [cx]: bA, [cz]: G }], [cu]: [{ [cv]: [{ [cw]: i2, [cx]: [aS, "resourceId[0]"], [cz]: H }, { [cw]: r, [cx]: [{ [cw]: h, [cx]: [aT, I] }] }], [cu]: [{ [cv]: [{ [cw]: h, [cx]: [aU, J] }], [cu]: [{ [cv]: ce, [cu]: [{ [cv]: cf, [cu]: [aW, aX, { [cv]: ci, [cu]: [aY, { [cv]: cj, [cu]: [aZ, { [cv]: cl, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cm, [cu]: [{ [cv]: cn, [cu]: [{ [cv]: [{ [cw]: h, [cx]: [bb, I] }], error: "Invalid ARN: Missing account id", [ct]: f }, { [cv]: co, [cu]: [{ [cv]: cp, [cu]: [{ [cv]: bC, endpoint: { [cA]: M, [cB]: bc, [cH]: al }, [ct]: n }, { [cv]: cq, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bc, [cH]: al }, [ct]: n }, { endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bc, [cH]: al }, [ct]: n }], [ct]: o }, bd], [ct]: o }, be], [ct]: o }, bf], [ct]: o }, bg], [ct]: o }], [ct]: o }], [ct]: o }, bh], [ct]: o }, { error: "Invalid ARN: bucket ARN is missing a region", [ct]: f }], [ct]: o }, bi], [ct]: o }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [ct]: f }], [ct]: o }, { [cv]: ce, [cu]: [{ [cv]: cf, [cu]: [{ [cv]: ci, [cu]: [{ [cv]: ce, [cu]: [{ [cv]: ci, [cu]: [aY, { [cv]: cj, [cu]: [aZ, { [cv]: cl, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: [{ [cw]: h, [cx]: [ba, "{partitionResult#name}"] }], [cu]: [{ [cv]: cn, [cu]: [{ [cv]: [{ [cw]: h, [cx]: [aU, B] }], [cu]: [{ [cv]: co, [cu]: [{ [cv]: cp, [cu]: [{ [cv]: bB, error: "Access Points do not support S3 Accelerate", [ct]: f }, { [cv]: bH, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bj, [cH]: al }, [ct]: n }, { [cv]: bI, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bj, [cH]: al }, [ct]: n }, { [cv]: bJ, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bj, [cH]: al }, [ct]: n }, { [cv]: [as, ar, Z, ag], endpoint: { [cA]: M, [cB]: bj, [cH]: al }, [ct]: n }, { [cv]: bK, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bj, [cH]: al }, [ct]: n }], [ct]: o }, bd], [ct]: o }, be], [ct]: o }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [ct]: f }], [ct]: o }, bf], [ct]: o }, bg], [ct]: o }], [ct]: o }], [ct]: o }, bh], [ct]: o }], [ct]: o }], [ct]: o }, { [cv]: [{ [cw]: y, [cx]: [aV, c] }], [cu]: [{ [cv]: ch, error: "S3 MRAP does not support dual-stack", [ct]: f }, { [cv]: cq, error: "S3 MRAP does not support FIPS", [ct]: f }, { [cv]: bB, error: "S3 MRAP does not support S3 Accelerate", [ct]: f }, { [cv]: [{ [cw]: e, [cx]: [{ [cy]: "DisableMultiRegionAccessPoints" }, c] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [ct]: f }, { [cv]: [{ [cw]: g, [cx]: by, [cz]: N }], [cu]: [{ [cv]: [{ [cw]: h, [cx]: [{ [cw]: i2, [cx]: [{ [cy]: N }, j] }, { [cw]: i2, [cx]: [aS, "partition"] }] }], [cu]: [{ endpoint: { [cA]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [cB]: { [cD]: [{ [cE]: c, name: z, [cF]: B, [cI]: cb }] }, [cH]: al }, [ct]: n }], [ct]: o }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [ct]: f }], [ct]: o }], [ct]: o }, { error: "Invalid Access Point Name", [ct]: f }], [ct]: o }, bi], [ct]: o }, { [cv]: [{ [cw]: h, [cx]: [aU, A] }], [cu]: [{ [cv]: ch, error: "S3 Outposts does not support Dual-stack", [ct]: f }, { [cv]: cq, error: "S3 Outposts does not support FIPS", [ct]: f }, { [cv]: bB, error: "S3 Outposts does not support S3 Accelerate", [ct]: f }, { [cv]: [{ [cw]: d, [cx]: [{ [cw]: i2, [cx]: [aS, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [ct]: f }, { [cv]: [{ [cw]: i2, [cx]: cg, [cz]: x }], [cu]: [{ [cv]: bZ, [cu]: [aZ, { [cv]: cl, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cm, [cu]: [{ [cv]: cn, [cu]: [{ [cv]: co, [cu]: [{ [cv]: [{ [cw]: i2, [cx]: ck, [cz]: O }], [cu]: [{ [cv]: [{ [cw]: i2, [cx]: [aS, "resourceId[3]"], [cz]: L }], [cu]: [{ [cv]: [{ [cw]: h, [cx]: [{ [cy]: O }, K] }], [cu]: [{ [cv]: bC, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [cB]: bk, [cH]: al }, [ct]: n }, { endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bk, [cH]: al }, [ct]: n }], [ct]: o }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [ct]: f }], [ct]: o }, { error: "Invalid ARN: expected an access point name", [ct]: f }], [ct]: o }, { error: "Invalid ARN: Expected a 4-component resource", [ct]: f }], [ct]: o }, be], [ct]: o }, bf], [ct]: o }, bg], [ct]: o }], [ct]: o }], [ct]: o }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [ct]: f }], [ct]: o }, { error: "Invalid ARN: The Outpost Id was not set", [ct]: f }], [ct]: o }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [ct]: f }], [ct]: o }, { error: "Invalid ARN: No ARN type specified", [ct]: f }], [ct]: o }, { [cv]: [{ [cw]: k, [cx]: [ad, 0, 4, b], [cz]: P }, { [cw]: h, [cx]: [{ [cy]: P }, "arn:"] }, { [cw]: r, [cx]: [{ [cw]: d, [cx]: [bl] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [ct]: f }, { [cv]: [{ [cw]: e, [cx]: [az, c] }, bl], error: "Path-style addressing cannot be used with ARN buckets", [ct]: f }, { [cv]: bE, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: [aA], [cu]: [{ [cv]: [Y, aq, X, aB], endpoint: { [cA]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [Y, aq, X, aD, aE], [cu]: [{ endpoint: bm, [ct]: n }], [ct]: o }, { [cv]: [Y, aq, X, aD, aH], endpoint: bm, [ct]: n }, { [cv]: [ar, aq, X, aB], endpoint: { [cA]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, aq, X, aD, aE], [cu]: [{ endpoint: bn, [ct]: n }], [ct]: o }, { [cv]: [ar, aq, X, aD, aH], endpoint: bn, [ct]: n }, { [cv]: [Y, aq, as, aB], endpoint: { [cA]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [Y, aq, as, aD, aE], [cu]: [{ endpoint: bo, [ct]: n }], [ct]: o }, { [cv]: [Y, aq, as, aD, aH], endpoint: bo, [ct]: n }, { [cv]: [ar, Z, ag, as, aB], endpoint: { [cA]: Q, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, Z, ag, as, aD, aE], [cu]: [{ [cv]: cd, endpoint: bp, [ct]: n }, { endpoint: bp, [ct]: n }], [ct]: o }, { [cv]: [ar, Z, ag, as, aD, aH], endpoint: bp, [ct]: n }, { [cv]: [ar, aq, as, aB], endpoint: { [cA]: R, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [ar, aq, as, aD, aE], [cu]: [{ [cv]: cd, endpoint: { [cA]: R, [cB]: aG, [cH]: al }, [ct]: n }, { endpoint: bq, [ct]: n }], [ct]: o }, { [cv]: [ar, aq, as, aD, aH], endpoint: bq, [ct]: n }], [ct]: o }, { error: "Path-style addressing cannot be used with S3 Accelerate", [ct]: f }], [ct]: o }], [ct]: o }], [ct]: o }, { [cv]: [{ [cw]: d, [cx]: [br] }, { [cw]: e, [cx]: [br, c] }], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cr, [cu]: [aW, aX, { [cv]: bC, endpoint: { [cA]: t, [cB]: bs, [cH]: al }, [ct]: n }, { [cv]: cq, endpoint: { [cA]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [cB]: bs, [cH]: al }, [ct]: n }, { endpoint: { [cA]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [cB]: bs, [cH]: al }, [ct]: n }], [ct]: o }, aR], [ct]: o }], [ct]: o }, { [cv]: [au], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cr, [cu]: [{ [cv]: [X, Y, aq, aB], endpoint: { [cA]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [X, Y, aq, aD, aE], [cu]: [{ endpoint: bt, [ct]: n }], [ct]: o }, { [cv]: [X, Y, aq, aD, aH], endpoint: bt, [ct]: n }, { [cv]: [X, ar, aq, aB], endpoint: { [cA]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [X, ar, aq, aD, aE], [cu]: [{ endpoint: bu, [ct]: n }], [ct]: o }, { [cv]: [X, ar, aq, aD, aH], endpoint: bu, [ct]: n }, { [cv]: [as, Y, aq, aB], endpoint: { [cA]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [as, Y, aq, aD, aE], [cu]: [{ endpoint: bv, [ct]: n }], [ct]: o }, { [cv]: [as, Y, aq, aD, aH], endpoint: bv, [ct]: n }, { [cv]: [as, ar, Z, ag, aB], endpoint: { [cA]: t, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [as, ar, Z, ag, aD, aE], [cu]: [{ [cv]: cd, endpoint: bw, [ct]: n }, { endpoint: bw, [ct]: n }], [ct]: o }, { [cv]: [as, ar, Z, ag, aD, aH], endpoint: bw, [ct]: n }, { [cv]: [as, ar, aq, aB], endpoint: { [cA]: S, [cB]: aC, [cH]: al }, [ct]: n }, { [cv]: [as, ar, aq, aD, aE], [cu]: [{ [cv]: cd, endpoint: { [cA]: S, [cB]: aG, [cH]: al }, [ct]: n }, { endpoint: bx, [ct]: n }], [ct]: o }, { [cv]: [as, ar, aq, aD, aH], endpoint: bx, [ct]: n }], [ct]: o }, aR], [ct]: o }], [ct]: o }], [ct]: o }, { error: "A region must be set when sending requests to S3.", [ct]: f }] };
  exports.ruleSet = _data;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/endpoint/endpointResolver.js
var require_endpointResolver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultEndpointResolver = undefined;
  var util_endpoints_1 = require_dist_cjs39();
  var util_endpoints_2 = require_dist_cjs36();
  var ruleset_1 = require_ruleset();
  var cache2 = new util_endpoints_2.EndpointCache({
    size: 50,
    params: [
      "Accelerate",
      "Bucket",
      "DisableAccessPoints",
      "DisableMultiRegionAccessPoints",
      "DisableS3ExpressSessionAuth",
      "Endpoint",
      "ForcePathStyle",
      "Region",
      "UseArnRegion",
      "UseDualStack",
      "UseFIPS",
      "UseGlobalEndpoint",
      "UseObjectLambdaEndpoint",
      "UseS3ExpressControlEndpoint"
    ]
  });
  var defaultEndpointResolver = (endpointParams, context = {}) => {
    return cache2.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
      endpointParams,
      logger: context.logger
    }));
  };
  exports.defaultEndpointResolver = defaultEndpointResolver;
  util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveHttpAuthSchemeConfig = exports.defaultS3HttpAuthSchemeProvider = exports.defaultS3HttpAuthSchemeParametersProvider = undefined;
  var core_1 = require_dist_cjs24();
  var signature_v4_multi_region_1 = require_dist_cjs50();
  var middleware_endpoint_1 = require_dist_cjs46();
  var util_middleware_1 = require_dist_cjs4();
  var endpointResolver_1 = require_endpointResolver();
  var createEndpointRuleSetHttpAuthSchemeParametersProvider = (defaultHttpAuthSchemeParametersProvider) => async (config, context, input) => {
    if (!input) {
      throw new Error("Could not find `input` for `defaultEndpointRuleSetHttpAuthSchemeParametersProvider`");
    }
    const defaultParameters = await defaultHttpAuthSchemeParametersProvider(config, context, input);
    const instructionsFn = (0, util_middleware_1.getSmithyContext)(context)?.commandInstance?.constructor?.getEndpointParameterInstructions;
    if (!instructionsFn) {
      throw new Error(`getEndpointParameterInstructions() is not defined on '${context.commandName}'`);
    }
    const endpointParameters = await (0, middleware_endpoint_1.resolveParams)(input, { getEndpointParameterInstructions: instructionsFn }, config);
    return Object.assign(defaultParameters, endpointParameters);
  };
  var _defaultS3HttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
      operation: (0, util_middleware_1.getSmithyContext)(context).operation,
      region: await (0, util_middleware_1.normalizeProvider)(config.region)() || (() => {
        throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
      })()
    };
  };
  exports.defaultS3HttpAuthSchemeParametersProvider = createEndpointRuleSetHttpAuthSchemeParametersProvider(_defaultS3HttpAuthSchemeParametersProvider);
  function createAwsAuthSigv4HttpAuthOption(authParameters) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "s3",
        region: authParameters.region
      },
      propertiesExtractor: (config, context) => ({
        signingProperties: {
          config,
          context
        }
      })
    };
  }
  function createAwsAuthSigv4aHttpAuthOption(authParameters) {
    return {
      schemeId: "aws.auth#sigv4a",
      signingProperties: {
        name: "s3",
        region: authParameters.region
      },
      propertiesExtractor: (config, context) => ({
        signingProperties: {
          config,
          context
        }
      })
    };
  }
  var createEndpointRuleSetHttpAuthSchemeProvider = (defaultEndpointResolver, defaultHttpAuthSchemeResolver, createHttpAuthOptionFunctions) => {
    const endpointRuleSetHttpAuthSchemeProvider = (authParameters) => {
      const endpoint = defaultEndpointResolver(authParameters);
      const authSchemes = endpoint.properties?.authSchemes;
      if (!authSchemes) {
        return defaultHttpAuthSchemeResolver(authParameters);
      }
      const options = [];
      for (const scheme of authSchemes) {
        const { name: resolvedName, properties = {}, ...rest } = scheme;
        const name = resolvedName.toLowerCase();
        if (resolvedName !== name) {
          console.warn(`HttpAuthScheme has been normalized with lowercasing: '${resolvedName}' to '${name}'`);
        }
        let schemeId;
        if (name === "sigv4a") {
          schemeId = "aws.auth#sigv4a";
          const sigv4Present = authSchemes.find((s) => {
            const name2 = s.name.toLowerCase();
            return name2 !== "sigv4a" && name2.startsWith("sigv4");
          });
          if (signature_v4_multi_region_1.SignatureV4MultiRegion.sigv4aDependency() === "none" && sigv4Present) {
            continue;
          }
        } else if (name.startsWith("sigv4")) {
          schemeId = "aws.auth#sigv4";
        } else {
          throw new Error(`Unknown HttpAuthScheme found in '@smithy.rules#endpointRuleSet': '${name}'`);
        }
        const createOption = createHttpAuthOptionFunctions[schemeId];
        if (!createOption) {
          throw new Error(`Could not find HttpAuthOption create function for '${schemeId}'`);
        }
        const option = createOption(authParameters);
        option.schemeId = schemeId;
        option.signingProperties = { ...option.signingProperties || {}, ...rest, ...properties };
        options.push(option);
      }
      return options;
    };
    return endpointRuleSetHttpAuthSchemeProvider;
  };
  var _defaultS3HttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
      default: {
        options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
        options.push(createAwsAuthSigv4aHttpAuthOption(authParameters));
      }
    }
    return options;
  };
  exports.defaultS3HttpAuthSchemeProvider = createEndpointRuleSetHttpAuthSchemeProvider(endpointResolver_1.defaultEndpointResolver, _defaultS3HttpAuthSchemeProvider, {
    "aws.auth#sigv4": createAwsAuthSigv4HttpAuthOption,
    "aws.auth#sigv4a": createAwsAuthSigv4aHttpAuthOption
  });
  var resolveHttpAuthSchemeConfig = (config) => {
    const config_0 = (0, core_1.resolveAwsSdkSigV4Config)(config);
    const config_1 = (0, core_1.resolveAwsSdkSigV4AConfig)(config_0);
    return Object.assign(config_1, {
      authSchemePreference: (0, util_middleware_1.normalizeProvider)(config.authSchemePreference ?? [])
    });
  };
  exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/models/S3ServiceException.js
var require_S3ServiceException = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.S3ServiceException = exports.__ServiceException = undefined;
  var smithy_client_1 = require_dist_cjs22();
  Object.defineProperty(exports, "__ServiceException", { enumerable: true, get: function() {
    return smithy_client_1.ServiceException;
  } });

  class S3ServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, S3ServiceException.prototype);
    }
  }
  exports.S3ServiceException = S3ServiceException;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/models/errors.js
var require_errors5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ObjectAlreadyInActiveTierError = exports.IdempotencyParameterMismatch = exports.TooManyParts = exports.InvalidWriteOffset = exports.InvalidRequest = exports.EncryptionTypeMismatch = exports.NotFound = exports.NoSuchKey = exports.InvalidObjectState = exports.NoSuchBucket = exports.BucketAlreadyOwnedByYou = exports.BucketAlreadyExists = exports.ObjectNotInActiveTierError = exports.AccessDenied = exports.NoSuchUpload = undefined;
  var S3ServiceException_1 = require_S3ServiceException();

  class NoSuchUpload extends S3ServiceException_1.S3ServiceException {
    name = "NoSuchUpload";
    $fault = "client";
    constructor(opts) {
      super({
        name: "NoSuchUpload",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, NoSuchUpload.prototype);
    }
  }
  exports.NoSuchUpload = NoSuchUpload;

  class AccessDenied extends S3ServiceException_1.S3ServiceException {
    name = "AccessDenied";
    $fault = "client";
    constructor(opts) {
      super({
        name: "AccessDenied",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, AccessDenied.prototype);
    }
  }
  exports.AccessDenied = AccessDenied;

  class ObjectNotInActiveTierError extends S3ServiceException_1.S3ServiceException {
    name = "ObjectNotInActiveTierError";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ObjectNotInActiveTierError",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ObjectNotInActiveTierError.prototype);
    }
  }
  exports.ObjectNotInActiveTierError = ObjectNotInActiveTierError;

  class BucketAlreadyExists extends S3ServiceException_1.S3ServiceException {
    name = "BucketAlreadyExists";
    $fault = "client";
    constructor(opts) {
      super({
        name: "BucketAlreadyExists",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, BucketAlreadyExists.prototype);
    }
  }
  exports.BucketAlreadyExists = BucketAlreadyExists;

  class BucketAlreadyOwnedByYou extends S3ServiceException_1.S3ServiceException {
    name = "BucketAlreadyOwnedByYou";
    $fault = "client";
    constructor(opts) {
      super({
        name: "BucketAlreadyOwnedByYou",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, BucketAlreadyOwnedByYou.prototype);
    }
  }
  exports.BucketAlreadyOwnedByYou = BucketAlreadyOwnedByYou;

  class NoSuchBucket extends S3ServiceException_1.S3ServiceException {
    name = "NoSuchBucket";
    $fault = "client";
    constructor(opts) {
      super({
        name: "NoSuchBucket",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, NoSuchBucket.prototype);
    }
  }
  exports.NoSuchBucket = NoSuchBucket;

  class InvalidObjectState extends S3ServiceException_1.S3ServiceException {
    name = "InvalidObjectState";
    $fault = "client";
    StorageClass;
    AccessTier;
    constructor(opts) {
      super({
        name: "InvalidObjectState",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidObjectState.prototype);
      this.StorageClass = opts.StorageClass;
      this.AccessTier = opts.AccessTier;
    }
  }
  exports.InvalidObjectState = InvalidObjectState;

  class NoSuchKey extends S3ServiceException_1.S3ServiceException {
    name = "NoSuchKey";
    $fault = "client";
    constructor(opts) {
      super({
        name: "NoSuchKey",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, NoSuchKey.prototype);
    }
  }
  exports.NoSuchKey = NoSuchKey;

  class NotFound extends S3ServiceException_1.S3ServiceException {
    name = "NotFound";
    $fault = "client";
    constructor(opts) {
      super({
        name: "NotFound",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, NotFound.prototype);
    }
  }
  exports.NotFound = NotFound;

  class EncryptionTypeMismatch extends S3ServiceException_1.S3ServiceException {
    name = "EncryptionTypeMismatch";
    $fault = "client";
    constructor(opts) {
      super({
        name: "EncryptionTypeMismatch",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, EncryptionTypeMismatch.prototype);
    }
  }
  exports.EncryptionTypeMismatch = EncryptionTypeMismatch;

  class InvalidRequest extends S3ServiceException_1.S3ServiceException {
    name = "InvalidRequest";
    $fault = "client";
    constructor(opts) {
      super({
        name: "InvalidRequest",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidRequest.prototype);
    }
  }
  exports.InvalidRequest = InvalidRequest;

  class InvalidWriteOffset extends S3ServiceException_1.S3ServiceException {
    name = "InvalidWriteOffset";
    $fault = "client";
    constructor(opts) {
      super({
        name: "InvalidWriteOffset",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidWriteOffset.prototype);
    }
  }
  exports.InvalidWriteOffset = InvalidWriteOffset;

  class TooManyParts extends S3ServiceException_1.S3ServiceException {
    name = "TooManyParts";
    $fault = "client";
    constructor(opts) {
      super({
        name: "TooManyParts",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, TooManyParts.prototype);
    }
  }
  exports.TooManyParts = TooManyParts;

  class IdempotencyParameterMismatch extends S3ServiceException_1.S3ServiceException {
    name = "IdempotencyParameterMismatch";
    $fault = "client";
    constructor(opts) {
      super({
        name: "IdempotencyParameterMismatch",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, IdempotencyParameterMismatch.prototype);
    }
  }
  exports.IdempotencyParameterMismatch = IdempotencyParameterMismatch;

  class ObjectAlreadyInActiveTierError extends S3ServiceException_1.S3ServiceException {
    name = "ObjectAlreadyInActiveTierError";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ObjectAlreadyInActiveTierError",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ObjectAlreadyInActiveTierError.prototype);
    }
  }
  exports.ObjectAlreadyInActiveTierError = ObjectAlreadyInActiveTierError;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/schemas/schemas_0.js
var require_schemas_0 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateBucketMetadataTableConfigurationRequest$ = exports.CreateBucketMetadataConfigurationRequest$ = exports.CreateBucketConfiguration$ = exports.CORSRule$ = exports.CORSConfiguration$ = exports.CopyPartResult$ = exports.CopyObjectResult$ = exports.CopyObjectRequest$ = exports.CopyObjectOutput$ = exports.ContinuationEvent$ = exports.Condition$ = exports.CompleteMultipartUploadRequest$ = exports.CompleteMultipartUploadOutput$ = exports.CompletedPart$ = exports.CompletedMultipartUpload$ = exports.CommonPrefix$ = exports.Checksum$ = exports.BucketLoggingStatus$ = exports.BucketLifecycleConfiguration$ = exports.BucketInfo$ = exports.Bucket$ = exports.BlockedEncryptionTypes$ = exports.AnalyticsS3BucketDestination$ = exports.AnalyticsExportDestination$ = exports.AnalyticsConfiguration$ = exports.AnalyticsAndOperator$ = exports.AccessControlTranslation$ = exports.AccessControlPolicy$ = exports.AccelerateConfiguration$ = exports.AbortMultipartUploadRequest$ = exports.AbortMultipartUploadOutput$ = exports.AbortIncompleteMultipartUpload$ = exports.AbacStatus$ = exports.errorTypeRegistries = exports.TooManyParts$ = exports.ObjectNotInActiveTierError$ = exports.ObjectAlreadyInActiveTierError$ = exports.NotFound$ = exports.NoSuchUpload$ = exports.NoSuchKey$ = exports.NoSuchBucket$ = exports.InvalidWriteOffset$ = exports.InvalidRequest$ = exports.InvalidObjectState$ = exports.IdempotencyParameterMismatch$ = exports.EncryptionTypeMismatch$ = exports.BucketAlreadyOwnedByYou$ = exports.BucketAlreadyExists$ = exports.AccessDenied$ = exports.S3ServiceException$ = undefined;
  exports.GetBucketAccelerateConfigurationRequest$ = exports.GetBucketAccelerateConfigurationOutput$ = exports.GetBucketAbacRequest$ = exports.GetBucketAbacOutput$ = exports.FilterRule$ = exports.ExistingObjectReplication$ = exports.EventBridgeConfiguration$ = exports.ErrorDocument$ = exports.ErrorDetails$ = exports._Error$ = exports.EndEvent$ = exports.EncryptionConfiguration$ = exports.Encryption$ = exports.DestinationResult$ = exports.Destination$ = exports.DeletePublicAccessBlockRequest$ = exports.DeleteObjectTaggingRequest$ = exports.DeleteObjectTaggingOutput$ = exports.DeleteObjectsRequest$ = exports.DeleteObjectsOutput$ = exports.DeleteObjectRequest$ = exports.DeleteObjectOutput$ = exports.DeleteMarkerReplication$ = exports.DeleteMarkerEntry$ = exports.DeletedObject$ = exports.DeleteBucketWebsiteRequest$ = exports.DeleteBucketTaggingRequest$ = exports.DeleteBucketRequest$ = exports.DeleteBucketReplicationRequest$ = exports.DeleteBucketPolicyRequest$ = exports.DeleteBucketOwnershipControlsRequest$ = exports.DeleteBucketMetricsConfigurationRequest$ = exports.DeleteBucketMetadataTableConfigurationRequest$ = exports.DeleteBucketMetadataConfigurationRequest$ = exports.DeleteBucketLifecycleRequest$ = exports.DeleteBucketInventoryConfigurationRequest$ = exports.DeleteBucketIntelligentTieringConfigurationRequest$ = exports.DeleteBucketEncryptionRequest$ = exports.DeleteBucketCorsRequest$ = exports.DeleteBucketAnalyticsConfigurationRequest$ = exports.Delete$ = exports.DefaultRetention$ = exports.CSVOutput$ = exports.CSVInput$ = exports.CreateSessionRequest$ = exports.CreateSessionOutput$ = exports.CreateMultipartUploadRequest$ = exports.CreateMultipartUploadOutput$ = exports.CreateBucketRequest$ = exports.CreateBucketOutput$ = undefined;
  exports.GetObjectLegalHoldRequest$ = exports.GetObjectLegalHoldOutput$ = exports.GetObjectAttributesRequest$ = exports.GetObjectAttributesParts$ = exports.GetObjectAttributesOutput$ = exports.GetObjectAclRequest$ = exports.GetObjectAclOutput$ = exports.GetBucketWebsiteRequest$ = exports.GetBucketWebsiteOutput$ = exports.GetBucketVersioningRequest$ = exports.GetBucketVersioningOutput$ = exports.GetBucketTaggingRequest$ = exports.GetBucketTaggingOutput$ = exports.GetBucketRequestPaymentRequest$ = exports.GetBucketRequestPaymentOutput$ = exports.GetBucketReplicationRequest$ = exports.GetBucketReplicationOutput$ = exports.GetBucketPolicyStatusRequest$ = exports.GetBucketPolicyStatusOutput$ = exports.GetBucketPolicyRequest$ = exports.GetBucketPolicyOutput$ = exports.GetBucketOwnershipControlsRequest$ = exports.GetBucketOwnershipControlsOutput$ = exports.GetBucketNotificationConfigurationRequest$ = exports.GetBucketMetricsConfigurationRequest$ = exports.GetBucketMetricsConfigurationOutput$ = exports.GetBucketMetadataTableConfigurationResult$ = exports.GetBucketMetadataTableConfigurationRequest$ = exports.GetBucketMetadataTableConfigurationOutput$ = exports.GetBucketMetadataConfigurationResult$ = exports.GetBucketMetadataConfigurationRequest$ = exports.GetBucketMetadataConfigurationOutput$ = exports.GetBucketLoggingRequest$ = exports.GetBucketLoggingOutput$ = exports.GetBucketLocationRequest$ = exports.GetBucketLocationOutput$ = exports.GetBucketLifecycleConfigurationRequest$ = exports.GetBucketLifecycleConfigurationOutput$ = exports.GetBucketInventoryConfigurationRequest$ = exports.GetBucketInventoryConfigurationOutput$ = exports.GetBucketIntelligentTieringConfigurationRequest$ = exports.GetBucketIntelligentTieringConfigurationOutput$ = exports.GetBucketEncryptionRequest$ = exports.GetBucketEncryptionOutput$ = exports.GetBucketCorsRequest$ = exports.GetBucketCorsOutput$ = exports.GetBucketAnalyticsConfigurationRequest$ = exports.GetBucketAnalyticsConfigurationOutput$ = exports.GetBucketAclRequest$ = exports.GetBucketAclOutput$ = undefined;
  exports.ListBucketInventoryConfigurationsRequest$ = exports.ListBucketInventoryConfigurationsOutput$ = exports.ListBucketIntelligentTieringConfigurationsRequest$ = exports.ListBucketIntelligentTieringConfigurationsOutput$ = exports.ListBucketAnalyticsConfigurationsRequest$ = exports.ListBucketAnalyticsConfigurationsOutput$ = exports.LifecycleRuleFilter$ = exports.LifecycleRuleAndOperator$ = exports.LifecycleRule$ = exports.LifecycleExpiration$ = exports.LambdaFunctionConfiguration$ = exports.JSONOutput$ = exports.JSONInput$ = exports.JournalTableConfigurationUpdates$ = exports.JournalTableConfigurationResult$ = exports.JournalTableConfiguration$ = exports.InventoryTableConfigurationUpdates$ = exports.InventoryTableConfigurationResult$ = exports.InventoryTableConfiguration$ = exports.InventorySchedule$ = exports.InventoryS3BucketDestination$ = exports.InventoryFilter$ = exports.InventoryEncryption$ = exports.InventoryDestination$ = exports.InventoryConfiguration$ = exports.IntelligentTieringFilter$ = exports.IntelligentTieringConfiguration$ = exports.IntelligentTieringAndOperator$ = exports.InputSerialization$ = exports.Initiator$ = exports.IndexDocument$ = exports.HeadObjectRequest$ = exports.HeadObjectOutput$ = exports.HeadBucketRequest$ = exports.HeadBucketOutput$ = exports.Grantee$ = exports.Grant$ = exports.GlacierJobParameters$ = exports.GetPublicAccessBlockRequest$ = exports.GetPublicAccessBlockOutput$ = exports.GetObjectTorrentRequest$ = exports.GetObjectTorrentOutput$ = exports.GetObjectTaggingRequest$ = exports.GetObjectTaggingOutput$ = exports.GetObjectRetentionRequest$ = exports.GetObjectRetentionOutput$ = exports.GetObjectRequest$ = exports.GetObjectOutput$ = exports.GetObjectLockConfigurationRequest$ = exports.GetObjectLockConfigurationOutput$ = undefined;
  exports.Progress$ = exports.PolicyStatus$ = exports.PartitionedPrefix$ = exports.Part$ = exports.ParquetInput$ = exports.OwnershipControlsRule$ = exports.OwnershipControls$ = exports.Owner$ = exports.OutputSerialization$ = exports.OutputLocation$ = exports.ObjectVersion$ = exports.ObjectPart$ = exports.ObjectLockRule$ = exports.ObjectLockRetention$ = exports.ObjectLockLegalHold$ = exports.ObjectLockConfiguration$ = exports.ObjectIdentifier$ = exports._Object$ = exports.NotificationConfigurationFilter$ = exports.NotificationConfiguration$ = exports.NoncurrentVersionTransition$ = exports.NoncurrentVersionExpiration$ = exports.MultipartUpload$ = exports.MetricsConfiguration$ = exports.MetricsAndOperator$ = exports.Metrics$ = exports.MetadataTableEncryptionConfiguration$ = exports.MetadataTableConfigurationResult$ = exports.MetadataTableConfiguration$ = exports.MetadataEntry$ = exports.MetadataConfigurationResult$ = exports.MetadataConfiguration$ = exports.LoggingEnabled$ = exports.LocationInfo$ = exports.ListPartsRequest$ = exports.ListPartsOutput$ = exports.ListObjectVersionsRequest$ = exports.ListObjectVersionsOutput$ = exports.ListObjectsV2Request$ = exports.ListObjectsV2Output$ = exports.ListObjectsRequest$ = exports.ListObjectsOutput$ = exports.ListMultipartUploadsRequest$ = exports.ListMultipartUploadsOutput$ = exports.ListDirectoryBucketsRequest$ = exports.ListDirectoryBucketsOutput$ = exports.ListBucketsRequest$ = exports.ListBucketsOutput$ = exports.ListBucketMetricsConfigurationsRequest$ = exports.ListBucketMetricsConfigurationsOutput$ = undefined;
  exports.RequestPaymentConfiguration$ = exports.ReplicationTimeValue$ = exports.ReplicationTime$ = exports.ReplicationRuleFilter$ = exports.ReplicationRuleAndOperator$ = exports.ReplicationRule$ = exports.ReplicationConfiguration$ = exports.ReplicaModifications$ = exports.RenameObjectRequest$ = exports.RenameObjectOutput$ = exports.RedirectAllRequestsTo$ = exports.Redirect$ = exports.RecordsEvent$ = exports.RecordExpiration$ = exports.QueueConfiguration$ = exports.PutPublicAccessBlockRequest$ = exports.PutObjectTaggingRequest$ = exports.PutObjectTaggingOutput$ = exports.PutObjectRetentionRequest$ = exports.PutObjectRetentionOutput$ = exports.PutObjectRequest$ = exports.PutObjectOutput$ = exports.PutObjectLockConfigurationRequest$ = exports.PutObjectLockConfigurationOutput$ = exports.PutObjectLegalHoldRequest$ = exports.PutObjectLegalHoldOutput$ = exports.PutObjectAclRequest$ = exports.PutObjectAclOutput$ = exports.PutBucketWebsiteRequest$ = exports.PutBucketVersioningRequest$ = exports.PutBucketTaggingRequest$ = exports.PutBucketRequestPaymentRequest$ = exports.PutBucketReplicationRequest$ = exports.PutBucketPolicyRequest$ = exports.PutBucketOwnershipControlsRequest$ = exports.PutBucketNotificationConfigurationRequest$ = exports.PutBucketMetricsConfigurationRequest$ = exports.PutBucketLoggingRequest$ = exports.PutBucketLifecycleConfigurationRequest$ = exports.PutBucketLifecycleConfigurationOutput$ = exports.PutBucketInventoryConfigurationRequest$ = exports.PutBucketIntelligentTieringConfigurationRequest$ = exports.PutBucketEncryptionRequest$ = exports.PutBucketCorsRequest$ = exports.PutBucketAnalyticsConfigurationRequest$ = exports.PutBucketAclRequest$ = exports.PutBucketAccelerateConfigurationRequest$ = exports.PutBucketAbacRequest$ = exports.PublicAccessBlockConfiguration$ = exports.ProgressEvent$ = undefined;
  exports.SelectObjectContentEventStream$ = exports.ObjectEncryption$ = exports.MetricsFilter$ = exports.AnalyticsFilter$ = exports.WriteGetObjectResponseRequest$ = exports.WebsiteConfiguration$ = exports.VersioningConfiguration$ = exports.UploadPartRequest$ = exports.UploadPartOutput$ = exports.UploadPartCopyRequest$ = exports.UploadPartCopyOutput$ = exports.UpdateObjectEncryptionResponse$ = exports.UpdateObjectEncryptionRequest$ = exports.UpdateBucketMetadataJournalTableConfigurationRequest$ = exports.UpdateBucketMetadataInventoryTableConfigurationRequest$ = exports.Transition$ = exports.TopicConfiguration$ = exports.Tiering$ = exports.TargetObjectKeyFormat$ = exports.TargetGrant$ = exports.Tagging$ = exports.Tag$ = exports.StorageClassAnalysisDataExport$ = exports.StorageClassAnalysis$ = exports.StatsEvent$ = exports.Stats$ = exports.SSES3$ = exports.SSEKMSEncryption$ = exports.SseKmsEncryptedObjects$ = exports.SSEKMS$ = exports.SourceSelectionCriteria$ = exports.SimplePrefix$ = exports.SessionCredentials$ = exports.ServerSideEncryptionRule$ = exports.ServerSideEncryptionConfiguration$ = exports.ServerSideEncryptionByDefault$ = exports.SelectParameters$ = exports.SelectObjectContentRequest$ = exports.SelectObjectContentOutput$ = exports.ScanRange$ = exports.S3TablesDestinationResult$ = exports.S3TablesDestination$ = exports.S3Location$ = exports.S3KeyFilter$ = exports.RoutingRule$ = exports.RestoreStatus$ = exports.RestoreRequest$ = exports.RestoreObjectRequest$ = exports.RestoreObjectOutput$ = exports.RequestProgress$ = undefined;
  exports.GetBucketWebsite$ = exports.GetBucketVersioning$ = exports.GetBucketTagging$ = exports.GetBucketRequestPayment$ = exports.GetBucketReplication$ = exports.GetBucketPolicyStatus$ = exports.GetBucketPolicy$ = exports.GetBucketOwnershipControls$ = exports.GetBucketNotificationConfiguration$ = exports.GetBucketMetricsConfiguration$ = exports.GetBucketMetadataTableConfiguration$ = exports.GetBucketMetadataConfiguration$ = exports.GetBucketLogging$ = exports.GetBucketLocation$ = exports.GetBucketLifecycleConfiguration$ = exports.GetBucketInventoryConfiguration$ = exports.GetBucketIntelligentTieringConfiguration$ = exports.GetBucketEncryption$ = exports.GetBucketCors$ = exports.GetBucketAnalyticsConfiguration$ = exports.GetBucketAcl$ = exports.GetBucketAccelerateConfiguration$ = exports.GetBucketAbac$ = exports.DeletePublicAccessBlock$ = exports.DeleteObjectTagging$ = exports.DeleteObjects$ = exports.DeleteObject$ = exports.DeleteBucketWebsite$ = exports.DeleteBucketTagging$ = exports.DeleteBucketReplication$ = exports.DeleteBucketPolicy$ = exports.DeleteBucketOwnershipControls$ = exports.DeleteBucketMetricsConfiguration$ = exports.DeleteBucketMetadataTableConfiguration$ = exports.DeleteBucketMetadataConfiguration$ = exports.DeleteBucketLifecycle$ = exports.DeleteBucketInventoryConfiguration$ = exports.DeleteBucketIntelligentTieringConfiguration$ = exports.DeleteBucketEncryption$ = exports.DeleteBucketCors$ = exports.DeleteBucketAnalyticsConfiguration$ = exports.DeleteBucket$ = exports.CreateSession$ = exports.CreateMultipartUpload$ = exports.CreateBucketMetadataTableConfiguration$ = exports.CreateBucketMetadataConfiguration$ = exports.CreateBucket$ = exports.CopyObject$ = exports.CompleteMultipartUpload$ = exports.AbortMultipartUpload$ = undefined;
  exports.RestoreObject$ = exports.RenameObject$ = exports.PutPublicAccessBlock$ = exports.PutObjectTagging$ = exports.PutObjectRetention$ = exports.PutObjectLockConfiguration$ = exports.PutObjectLegalHold$ = exports.PutObjectAcl$ = exports.PutObject$ = exports.PutBucketWebsite$ = exports.PutBucketVersioning$ = exports.PutBucketTagging$ = exports.PutBucketRequestPayment$ = exports.PutBucketReplication$ = exports.PutBucketPolicy$ = exports.PutBucketOwnershipControls$ = exports.PutBucketNotificationConfiguration$ = exports.PutBucketMetricsConfiguration$ = exports.PutBucketLogging$ = exports.PutBucketLifecycleConfiguration$ = exports.PutBucketInventoryConfiguration$ = exports.PutBucketIntelligentTieringConfiguration$ = exports.PutBucketEncryption$ = exports.PutBucketCors$ = exports.PutBucketAnalyticsConfiguration$ = exports.PutBucketAcl$ = exports.PutBucketAccelerateConfiguration$ = exports.PutBucketAbac$ = exports.ListParts$ = exports.ListObjectVersions$ = exports.ListObjectsV2$ = exports.ListObjects$ = exports.ListMultipartUploads$ = exports.ListDirectoryBuckets$ = exports.ListBuckets$ = exports.ListBucketMetricsConfigurations$ = exports.ListBucketInventoryConfigurations$ = exports.ListBucketIntelligentTieringConfigurations$ = exports.ListBucketAnalyticsConfigurations$ = exports.HeadObject$ = exports.HeadBucket$ = exports.GetPublicAccessBlock$ = exports.GetObjectTorrent$ = exports.GetObjectTagging$ = exports.GetObjectRetention$ = exports.GetObjectLockConfiguration$ = exports.GetObjectLegalHold$ = exports.GetObjectAttributes$ = exports.GetObjectAcl$ = exports.GetObject$ = undefined;
  exports.WriteGetObjectResponse$ = exports.UploadPartCopy$ = exports.UploadPart$ = exports.UpdateObjectEncryption$ = exports.UpdateBucketMetadataJournalTableConfiguration$ = exports.UpdateBucketMetadataInventoryTableConfiguration$ = exports.SelectObjectContent$ = undefined;
  var _A = "Account";
  var _AAO = "AnalyticsAndOperator";
  var _AC = "AccelerateConfiguration";
  var _ACL = "AccessControlList";
  var _ACL_ = "ACL";
  var _ACLn = "AnalyticsConfigurationList";
  var _ACP = "AccessControlPolicy";
  var _ACT = "AccessControlTranslation";
  var _ACn = "AnalyticsConfiguration";
  var _AD = "AccessDenied";
  var _ADb = "AbortDate";
  var _AED = "AnalyticsExportDestination";
  var _AF = "AnalyticsFilter";
  var _AH = "AllowedHeaders";
  var _AHl = "AllowedHeader";
  var _AI = "AccountId";
  var _AIMU = "AbortIncompleteMultipartUpload";
  var _AKI = "AccessKeyId";
  var _AM = "AllowedMethods";
  var _AMU = "AbortMultipartUpload";
  var _AMUO = "AbortMultipartUploadOutput";
  var _AMUR = "AbortMultipartUploadRequest";
  var _AMl = "AllowedMethod";
  var _AO = "AllowedOrigins";
  var _AOl = "AllowedOrigin";
  var _APA = "AccessPointAlias";
  var _APAc = "AccessPointArn";
  var _AQRD = "AllowQuotedRecordDelimiter";
  var _AR = "AcceptRanges";
  var _ARI = "AbortRuleId";
  var _AS = "AbacStatus";
  var _ASBD = "AnalyticsS3BucketDestination";
  var _ASSEBD = "ApplyServerSideEncryptionByDefault";
  var _ASr = "ArchiveStatus";
  var _AT = "AccessTier";
  var _An = "And";
  var _B = "Bucket";
  var _BA = "BucketArn";
  var _BAE = "BucketAlreadyExists";
  var _BAI = "BucketAccountId";
  var _BAOBY = "BucketAlreadyOwnedByYou";
  var _BET = "BlockedEncryptionTypes";
  var _BGR = "BypassGovernanceRetention";
  var _BI = "BucketInfo";
  var _BKE = "BucketKeyEnabled";
  var _BLC = "BucketLifecycleConfiguration";
  var _BLN = "BucketLocationName";
  var _BLS = "BucketLoggingStatus";
  var _BLT = "BucketLocationType";
  var _BN = "BucketName";
  var _BP = "BytesProcessed";
  var _BPA = "BlockPublicAcls";
  var _BPP = "BlockPublicPolicy";
  var _BR = "BucketRegion";
  var _BRy = "BytesReturned";
  var _BS = "BytesScanned";
  var _Bo = "Body";
  var _Bu = "Buckets";
  var _C = "Checksum";
  var _CA = "ChecksumAlgorithm";
  var _CACL = "CannedACL";
  var _CB = "CreateBucket";
  var _CBC = "CreateBucketConfiguration";
  var _CBMC = "CreateBucketMetadataConfiguration";
  var _CBMCR = "CreateBucketMetadataConfigurationRequest";
  var _CBMTC = "CreateBucketMetadataTableConfiguration";
  var _CBMTCR = "CreateBucketMetadataTableConfigurationRequest";
  var _CBO = "CreateBucketOutput";
  var _CBR = "CreateBucketRequest";
  var _CC = "CacheControl";
  var _CCRC = "ChecksumCRC32";
  var _CCRCC = "ChecksumCRC32C";
  var _CCRCNVME = "ChecksumCRC64NVME";
  var _CC_ = "Cache-Control";
  var _CD = "CreationDate";
  var _CD_ = "Content-Disposition";
  var _CDo = "ContentDisposition";
  var _CE = "ContinuationEvent";
  var _CE_ = "Content-Encoding";
  var _CEo = "ContentEncoding";
  var _CF = "CloudFunction";
  var _CFC = "CloudFunctionConfiguration";
  var _CL = "ContentLanguage";
  var _CL_ = "Content-Language";
  var _CL__ = "Content-Length";
  var _CLo = "ContentLength";
  var _CM = "Content-MD5";
  var _CMD = "ContentMD5";
  var _CMU = "CompletedMultipartUpload";
  var _CMUO = "CompleteMultipartUploadOutput";
  var _CMUOr = "CreateMultipartUploadOutput";
  var _CMUR = "CompleteMultipartUploadResult";
  var _CMURo = "CompleteMultipartUploadRequest";
  var _CMURr = "CreateMultipartUploadRequest";
  var _CMUo = "CompleteMultipartUpload";
  var _CMUr = "CreateMultipartUpload";
  var _CMh = "ChecksumMode";
  var _CO = "CopyObject";
  var _COO = "CopyObjectOutput";
  var _COR = "CopyObjectResult";
  var _CORSC = "CORSConfiguration";
  var _CORSR = "CORSRules";
  var _CORSRu = "CORSRule";
  var _CORo = "CopyObjectRequest";
  var _CP = "CommonPrefix";
  var _CPL = "CommonPrefixList";
  var _CPLo = "CompletedPartList";
  var _CPR = "CopyPartResult";
  var _CPo = "CompletedPart";
  var _CPom = "CommonPrefixes";
  var _CR = "ContentRange";
  var _CRSBA = "ConfirmRemoveSelfBucketAccess";
  var _CR_ = "Content-Range";
  var _CS = "CopySource";
  var _CSHA = "ChecksumSHA1";
  var _CSHAh = "ChecksumSHA256";
  var _CSIM = "CopySourceIfMatch";
  var _CSIMS = "CopySourceIfModifiedSince";
  var _CSINM = "CopySourceIfNoneMatch";
  var _CSIUS = "CopySourceIfUnmodifiedSince";
  var _CSO = "CreateSessionOutput";
  var _CSR = "CreateSessionResult";
  var _CSRo = "CopySourceRange";
  var _CSRr = "CreateSessionRequest";
  var _CSSSECA = "CopySourceSSECustomerAlgorithm";
  var _CSSSECK = "CopySourceSSECustomerKey";
  var _CSSSECKMD = "CopySourceSSECustomerKeyMD5";
  var _CSV = "CSV";
  var _CSVI = "CopySourceVersionId";
  var _CSVIn = "CSVInput";
  var _CSVO = "CSVOutput";
  var _CSo = "ConfigurationState";
  var _CSr = "CreateSession";
  var _CT = "ChecksumType";
  var _CT_ = "Content-Type";
  var _CTl = "ClientToken";
  var _CTo = "ContentType";
  var _CTom = "CompressionType";
  var _CTon = "ContinuationToken";
  var _Co = "Condition";
  var _Cod = "Code";
  var _Com = "Comments";
  var _Con = "Contents";
  var _Cont = "Cont";
  var _Cr = "Credentials";
  var _D = "Days";
  var _DAI = "DaysAfterInitiation";
  var _DB = "DeleteBucket";
  var _DBAC = "DeleteBucketAnalyticsConfiguration";
  var _DBACR = "DeleteBucketAnalyticsConfigurationRequest";
  var _DBC = "DeleteBucketCors";
  var _DBCR = "DeleteBucketCorsRequest";
  var _DBE = "DeleteBucketEncryption";
  var _DBER = "DeleteBucketEncryptionRequest";
  var _DBIC = "DeleteBucketInventoryConfiguration";
  var _DBICR = "DeleteBucketInventoryConfigurationRequest";
  var _DBITC = "DeleteBucketIntelligentTieringConfiguration";
  var _DBITCR = "DeleteBucketIntelligentTieringConfigurationRequest";
  var _DBL = "DeleteBucketLifecycle";
  var _DBLR = "DeleteBucketLifecycleRequest";
  var _DBMC = "DeleteBucketMetadataConfiguration";
  var _DBMCR = "DeleteBucketMetadataConfigurationRequest";
  var _DBMCRe = "DeleteBucketMetricsConfigurationRequest";
  var _DBMCe = "DeleteBucketMetricsConfiguration";
  var _DBMTC = "DeleteBucketMetadataTableConfiguration";
  var _DBMTCR = "DeleteBucketMetadataTableConfigurationRequest";
  var _DBOC = "DeleteBucketOwnershipControls";
  var _DBOCR = "DeleteBucketOwnershipControlsRequest";
  var _DBP = "DeleteBucketPolicy";
  var _DBPR = "DeleteBucketPolicyRequest";
  var _DBR = "DeleteBucketRequest";
  var _DBRR = "DeleteBucketReplicationRequest";
  var _DBRe = "DeleteBucketReplication";
  var _DBT = "DeleteBucketTagging";
  var _DBTR = "DeleteBucketTaggingRequest";
  var _DBW = "DeleteBucketWebsite";
  var _DBWR = "DeleteBucketWebsiteRequest";
  var _DE = "DataExport";
  var _DIM = "DestinationIfMatch";
  var _DIMS = "DestinationIfModifiedSince";
  var _DINM = "DestinationIfNoneMatch";
  var _DIUS = "DestinationIfUnmodifiedSince";
  var _DM = "DeleteMarker";
  var _DME = "DeleteMarkerEntry";
  var _DMR = "DeleteMarkerReplication";
  var _DMVI = "DeleteMarkerVersionId";
  var _DMe = "DeleteMarkers";
  var _DN = "DisplayName";
  var _DO = "DeletedObject";
  var _DOO = "DeleteObjectOutput";
  var _DOOe = "DeleteObjectsOutput";
  var _DOR = "DeleteObjectRequest";
  var _DORe = "DeleteObjectsRequest";
  var _DOT = "DeleteObjectTagging";
  var _DOTO = "DeleteObjectTaggingOutput";
  var _DOTR = "DeleteObjectTaggingRequest";
  var _DOe = "DeletedObjects";
  var _DOel = "DeleteObject";
  var _DOele = "DeleteObjects";
  var _DPAB = "DeletePublicAccessBlock";
  var _DPABR = "DeletePublicAccessBlockRequest";
  var _DR = "DataRedundancy";
  var _DRe = "DefaultRetention";
  var _DRel = "DeleteResult";
  var _DRes = "DestinationResult";
  var _Da = "Date";
  var _De = "Delete";
  var _Del = "Deleted";
  var _Deli = "Delimiter";
  var _Des = "Destination";
  var _Desc = "Description";
  var _Det = "Details";
  var _E = "Expiration";
  var _EA = "EmailAddress";
  var _EBC = "EventBridgeConfiguration";
  var _EBO = "ExpectedBucketOwner";
  var _EC = "EncryptionConfiguration";
  var _ECr = "ErrorCode";
  var _ED = "ErrorDetails";
  var _EDr = "ErrorDocument";
  var _EE = "EndEvent";
  var _EH = "ExposeHeaders";
  var _EHx = "ExposeHeader";
  var _EM = "ErrorMessage";
  var _EODM = "ExpiredObjectDeleteMarker";
  var _EOR = "ExistingObjectReplication";
  var _ES = "ExpiresString";
  var _ESBO = "ExpectedSourceBucketOwner";
  var _ET = "EncryptionType";
  var _ETL = "EncryptionTypeList";
  var _ETM = "EncryptionTypeMismatch";
  var _ETa = "ETag";
  var _ETn = "EncodingType";
  var _ETv = "EventThreshold";
  var _ETx = "ExpressionType";
  var _En = "Encryption";
  var _Ena = "Enabled";
  var _End = "End";
  var _Er = "Errors";
  var _Err = "Error";
  var _Ev = "Events";
  var _Eve = "Event";
  var _Ex = "Expires";
  var _Exp = "Expression";
  var _F = "Filter";
  var _FD = "FieldDelimiter";
  var _FHI = "FileHeaderInfo";
  var _FO = "FetchOwner";
  var _FR = "FilterRule";
  var _FRL = "FilterRuleList";
  var _FRi = "FilterRules";
  var _Fi = "Field";
  var _Fo = "Format";
  var _Fr = "Frequency";
  var _G = "Grants";
  var _GBA = "GetBucketAbac";
  var _GBAC = "GetBucketAccelerateConfiguration";
  var _GBACO = "GetBucketAccelerateConfigurationOutput";
  var _GBACOe = "GetBucketAnalyticsConfigurationOutput";
  var _GBACR = "GetBucketAccelerateConfigurationRequest";
  var _GBACRe = "GetBucketAnalyticsConfigurationRequest";
  var _GBACe = "GetBucketAnalyticsConfiguration";
  var _GBAO = "GetBucketAbacOutput";
  var _GBAOe = "GetBucketAclOutput";
  var _GBAR = "GetBucketAbacRequest";
  var _GBARe = "GetBucketAclRequest";
  var _GBAe = "GetBucketAcl";
  var _GBC = "GetBucketCors";
  var _GBCO = "GetBucketCorsOutput";
  var _GBCR = "GetBucketCorsRequest";
  var _GBE = "GetBucketEncryption";
  var _GBEO = "GetBucketEncryptionOutput";
  var _GBER = "GetBucketEncryptionRequest";
  var _GBIC = "GetBucketInventoryConfiguration";
  var _GBICO = "GetBucketInventoryConfigurationOutput";
  var _GBICR = "GetBucketInventoryConfigurationRequest";
  var _GBITC = "GetBucketIntelligentTieringConfiguration";
  var _GBITCO = "GetBucketIntelligentTieringConfigurationOutput";
  var _GBITCR = "GetBucketIntelligentTieringConfigurationRequest";
  var _GBL = "GetBucketLocation";
  var _GBLC = "GetBucketLifecycleConfiguration";
  var _GBLCO = "GetBucketLifecycleConfigurationOutput";
  var _GBLCR = "GetBucketLifecycleConfigurationRequest";
  var _GBLO = "GetBucketLocationOutput";
  var _GBLOe = "GetBucketLoggingOutput";
  var _GBLR = "GetBucketLocationRequest";
  var _GBLRe = "GetBucketLoggingRequest";
  var _GBLe = "GetBucketLogging";
  var _GBMC = "GetBucketMetadataConfiguration";
  var _GBMCO = "GetBucketMetadataConfigurationOutput";
  var _GBMCOe = "GetBucketMetricsConfigurationOutput";
  var _GBMCR = "GetBucketMetadataConfigurationResult";
  var _GBMCRe = "GetBucketMetadataConfigurationRequest";
  var _GBMCRet = "GetBucketMetricsConfigurationRequest";
  var _GBMCe = "GetBucketMetricsConfiguration";
  var _GBMTC = "GetBucketMetadataTableConfiguration";
  var _GBMTCO = "GetBucketMetadataTableConfigurationOutput";
  var _GBMTCR = "GetBucketMetadataTableConfigurationResult";
  var _GBMTCRe = "GetBucketMetadataTableConfigurationRequest";
  var _GBNC = "GetBucketNotificationConfiguration";
  var _GBNCR = "GetBucketNotificationConfigurationRequest";
  var _GBOC = "GetBucketOwnershipControls";
  var _GBOCO = "GetBucketOwnershipControlsOutput";
  var _GBOCR = "GetBucketOwnershipControlsRequest";
  var _GBP = "GetBucketPolicy";
  var _GBPO = "GetBucketPolicyOutput";
  var _GBPR = "GetBucketPolicyRequest";
  var _GBPS = "GetBucketPolicyStatus";
  var _GBPSO = "GetBucketPolicyStatusOutput";
  var _GBPSR = "GetBucketPolicyStatusRequest";
  var _GBR = "GetBucketReplication";
  var _GBRO = "GetBucketReplicationOutput";
  var _GBRP = "GetBucketRequestPayment";
  var _GBRPO = "GetBucketRequestPaymentOutput";
  var _GBRPR = "GetBucketRequestPaymentRequest";
  var _GBRR = "GetBucketReplicationRequest";
  var _GBT = "GetBucketTagging";
  var _GBTO = "GetBucketTaggingOutput";
  var _GBTR = "GetBucketTaggingRequest";
  var _GBV = "GetBucketVersioning";
  var _GBVO = "GetBucketVersioningOutput";
  var _GBVR = "GetBucketVersioningRequest";
  var _GBW = "GetBucketWebsite";
  var _GBWO = "GetBucketWebsiteOutput";
  var _GBWR = "GetBucketWebsiteRequest";
  var _GFC = "GrantFullControl";
  var _GJP = "GlacierJobParameters";
  var _GO = "GetObject";
  var _GOA = "GetObjectAcl";
  var _GOAO = "GetObjectAclOutput";
  var _GOAOe = "GetObjectAttributesOutput";
  var _GOAP = "GetObjectAttributesParts";
  var _GOAR = "GetObjectAclRequest";
  var _GOARe = "GetObjectAttributesResponse";
  var _GOARet = "GetObjectAttributesRequest";
  var _GOAe = "GetObjectAttributes";
  var _GOLC = "GetObjectLockConfiguration";
  var _GOLCO = "GetObjectLockConfigurationOutput";
  var _GOLCR = "GetObjectLockConfigurationRequest";
  var _GOLH = "GetObjectLegalHold";
  var _GOLHO = "GetObjectLegalHoldOutput";
  var _GOLHR = "GetObjectLegalHoldRequest";
  var _GOO = "GetObjectOutput";
  var _GOR = "GetObjectRequest";
  var _GORO = "GetObjectRetentionOutput";
  var _GORR = "GetObjectRetentionRequest";
  var _GORe = "GetObjectRetention";
  var _GOT = "GetObjectTagging";
  var _GOTO = "GetObjectTaggingOutput";
  var _GOTOe = "GetObjectTorrentOutput";
  var _GOTR = "GetObjectTaggingRequest";
  var _GOTRe = "GetObjectTorrentRequest";
  var _GOTe = "GetObjectTorrent";
  var _GPAB = "GetPublicAccessBlock";
  var _GPABO = "GetPublicAccessBlockOutput";
  var _GPABR = "GetPublicAccessBlockRequest";
  var _GR = "GrantRead";
  var _GRACP = "GrantReadACP";
  var _GW = "GrantWrite";
  var _GWACP = "GrantWriteACP";
  var _Gr = "Grant";
  var _Gra = "Grantee";
  var _HB = "HeadBucket";
  var _HBO = "HeadBucketOutput";
  var _HBR = "HeadBucketRequest";
  var _HECRE = "HttpErrorCodeReturnedEquals";
  var _HN = "HostName";
  var _HO = "HeadObject";
  var _HOO = "HeadObjectOutput";
  var _HOR = "HeadObjectRequest";
  var _HRC = "HttpRedirectCode";
  var _I = "Id";
  var _IC = "InventoryConfiguration";
  var _ICL = "InventoryConfigurationList";
  var _ID = "ID";
  var _IDn = "IndexDocument";
  var _IDnv = "InventoryDestination";
  var _IE = "IsEnabled";
  var _IEn = "InventoryEncryption";
  var _IF = "InventoryFilter";
  var _IL = "IsLatest";
  var _IM = "IfMatch";
  var _IMIT = "IfMatchInitiatedTime";
  var _IMLMT = "IfMatchLastModifiedTime";
  var _IMS = "IfMatchSize";
  var _IMS_ = "If-Modified-Since";
  var _IMSf = "IfModifiedSince";
  var _IMUR = "InitiateMultipartUploadResult";
  var _IM_ = "If-Match";
  var _INM = "IfNoneMatch";
  var _INM_ = "If-None-Match";
  var _IOF = "InventoryOptionalFields";
  var _IOS = "InvalidObjectState";
  var _IOV = "IncludedObjectVersions";
  var _IP = "IsPublic";
  var _IPA = "IgnorePublicAcls";
  var _IPM = "IdempotencyParameterMismatch";
  var _IR = "InvalidRequest";
  var _IRIP = "IsRestoreInProgress";
  var _IS = "InputSerialization";
  var _ISBD = "InventoryS3BucketDestination";
  var _ISn = "InventorySchedule";
  var _IT = "IsTruncated";
  var _ITAO = "IntelligentTieringAndOperator";
  var _ITC = "IntelligentTieringConfiguration";
  var _ITCL = "IntelligentTieringConfigurationList";
  var _ITCR = "InventoryTableConfigurationResult";
  var _ITCU = "InventoryTableConfigurationUpdates";
  var _ITCn = "InventoryTableConfiguration";
  var _ITF = "IntelligentTieringFilter";
  var _IUS = "IfUnmodifiedSince";
  var _IUS_ = "If-Unmodified-Since";
  var _IWO = "InvalidWriteOffset";
  var _In = "Initiator";
  var _Ini = "Initiated";
  var _JSON = "JSON";
  var _JSONI = "JSONInput";
  var _JSONO = "JSONOutput";
  var _JTC = "JournalTableConfiguration";
  var _JTCR = "JournalTableConfigurationResult";
  var _JTCU = "JournalTableConfigurationUpdates";
  var _K = "Key";
  var _KC = "KeyCount";
  var _KI = "KeyId";
  var _KKA = "KmsKeyArn";
  var _KM = "KeyMarker";
  var _KMSC = "KMSContext";
  var _KMSKA = "KMSKeyArn";
  var _KMSKI = "KMSKeyId";
  var _KMSMKID = "KMSMasterKeyID";
  var _KPE = "KeyPrefixEquals";
  var _L = "Location";
  var _LAMBR = "ListAllMyBucketsResult";
  var _LAMDBR = "ListAllMyDirectoryBucketsResult";
  var _LB = "ListBuckets";
  var _LBAC = "ListBucketAnalyticsConfigurations";
  var _LBACO = "ListBucketAnalyticsConfigurationsOutput";
  var _LBACR = "ListBucketAnalyticsConfigurationResult";
  var _LBACRi = "ListBucketAnalyticsConfigurationsRequest";
  var _LBIC = "ListBucketInventoryConfigurations";
  var _LBICO = "ListBucketInventoryConfigurationsOutput";
  var _LBICR = "ListBucketInventoryConfigurationsRequest";
  var _LBITC = "ListBucketIntelligentTieringConfigurations";
  var _LBITCO = "ListBucketIntelligentTieringConfigurationsOutput";
  var _LBITCR = "ListBucketIntelligentTieringConfigurationsRequest";
  var _LBMC = "ListBucketMetricsConfigurations";
  var _LBMCO = "ListBucketMetricsConfigurationsOutput";
  var _LBMCR = "ListBucketMetricsConfigurationsRequest";
  var _LBO = "ListBucketsOutput";
  var _LBR = "ListBucketsRequest";
  var _LBRi = "ListBucketResult";
  var _LC = "LocationConstraint";
  var _LCi = "LifecycleConfiguration";
  var _LDB = "ListDirectoryBuckets";
  var _LDBO = "ListDirectoryBucketsOutput";
  var _LDBR = "ListDirectoryBucketsRequest";
  var _LE = "LoggingEnabled";
  var _LEi = "LifecycleExpiration";
  var _LFA = "LambdaFunctionArn";
  var _LFC = "LambdaFunctionConfiguration";
  var _LFCL = "LambdaFunctionConfigurationList";
  var _LFCa = "LambdaFunctionConfigurations";
  var _LH = "LegalHold";
  var _LI = "LocationInfo";
  var _LICR = "ListInventoryConfigurationsResult";
  var _LM = "LastModified";
  var _LMCR = "ListMetricsConfigurationsResult";
  var _LMT = "LastModifiedTime";
  var _LMU = "ListMultipartUploads";
  var _LMUO = "ListMultipartUploadsOutput";
  var _LMUR = "ListMultipartUploadsResult";
  var _LMURi = "ListMultipartUploadsRequest";
  var _LM_ = "Last-Modified";
  var _LO = "ListObjects";
  var _LOO = "ListObjectsOutput";
  var _LOR = "ListObjectsRequest";
  var _LOV = "ListObjectsV2";
  var _LOVO = "ListObjectsV2Output";
  var _LOVOi = "ListObjectVersionsOutput";
  var _LOVR = "ListObjectsV2Request";
  var _LOVRi = "ListObjectVersionsRequest";
  var _LOVi = "ListObjectVersions";
  var _LP = "ListParts";
  var _LPO = "ListPartsOutput";
  var _LPR = "ListPartsResult";
  var _LPRi = "ListPartsRequest";
  var _LR = "LifecycleRule";
  var _LRAO = "LifecycleRuleAndOperator";
  var _LRF = "LifecycleRuleFilter";
  var _LRi = "LifecycleRules";
  var _LVR = "ListVersionsResult";
  var _M = "Metadata";
  var _MAO = "MetricsAndOperator";
  var _MAS = "MaxAgeSeconds";
  var _MB = "MaxBuckets";
  var _MC = "MetadataConfiguration";
  var _MCL = "MetricsConfigurationList";
  var _MCR = "MetadataConfigurationResult";
  var _MCe = "MetricsConfiguration";
  var _MD = "MetadataDirective";
  var _MDB = "MaxDirectoryBuckets";
  var _MDf = "MfaDelete";
  var _ME = "MetadataEntry";
  var _MF = "MetricsFilter";
  var _MFA = "MFA";
  var _MFAD = "MFADelete";
  var _MK = "MaxKeys";
  var _MM = "MissingMeta";
  var _MOS = "MpuObjectSize";
  var _MP = "MaxParts";
  var _MTC = "MetadataTableConfiguration";
  var _MTCR = "MetadataTableConfigurationResult";
  var _MTEC = "MetadataTableEncryptionConfiguration";
  var _MU = "MultipartUpload";
  var _MUL = "MultipartUploadList";
  var _MUa = "MaxUploads";
  var _Ma = "Marker";
  var _Me = "Metrics";
  var _Mes = "Message";
  var _Mi = "Minutes";
  var _Mo = "Mode";
  var _N = "Name";
  var _NC = "NotificationConfiguration";
  var _NCF = "NotificationConfigurationFilter";
  var _NCT = "NextContinuationToken";
  var _ND = "NoncurrentDays";
  var _NEKKAS = "NonEmptyKmsKeyArnString";
  var _NF = "NotFound";
  var _NKM = "NextKeyMarker";
  var _NM = "NextMarker";
  var _NNV = "NewerNoncurrentVersions";
  var _NPNM = "NextPartNumberMarker";
  var _NSB = "NoSuchBucket";
  var _NSK = "NoSuchKey";
  var _NSU = "NoSuchUpload";
  var _NUIM = "NextUploadIdMarker";
  var _NVE = "NoncurrentVersionExpiration";
  var _NVIM = "NextVersionIdMarker";
  var _NVT = "NoncurrentVersionTransitions";
  var _NVTL = "NoncurrentVersionTransitionList";
  var _NVTo = "NoncurrentVersionTransition";
  var _O = "Owner";
  var _OA = "ObjectAttributes";
  var _OAIATE = "ObjectAlreadyInActiveTierError";
  var _OC = "OwnershipControls";
  var _OCR = "OwnershipControlsRule";
  var _OCRw = "OwnershipControlsRules";
  var _OE = "ObjectEncryption";
  var _OF = "OptionalFields";
  var _OI = "ObjectIdentifier";
  var _OIL = "ObjectIdentifierList";
  var _OL = "OutputLocation";
  var _OLC = "ObjectLockConfiguration";
  var _OLE = "ObjectLockEnabled";
  var _OLEFB = "ObjectLockEnabledForBucket";
  var _OLLH = "ObjectLockLegalHold";
  var _OLLHS = "ObjectLockLegalHoldStatus";
  var _OLM = "ObjectLockMode";
  var _OLR = "ObjectLockRetention";
  var _OLRUD = "ObjectLockRetainUntilDate";
  var _OLRb = "ObjectLockRule";
  var _OLb = "ObjectList";
  var _ONIATE = "ObjectNotInActiveTierError";
  var _OO = "ObjectOwnership";
  var _OOA = "OptionalObjectAttributes";
  var _OP = "ObjectParts";
  var _OPb = "ObjectPart";
  var _OS = "ObjectSize";
  var _OSGT = "ObjectSizeGreaterThan";
  var _OSLT = "ObjectSizeLessThan";
  var _OSV = "OutputSchemaVersion";
  var _OSu = "OutputSerialization";
  var _OV = "ObjectVersion";
  var _OVL = "ObjectVersionList";
  var _Ob = "Objects";
  var _Obj = "Object";
  var _P = "Prefix";
  var _PABC = "PublicAccessBlockConfiguration";
  var _PBA = "PutBucketAbac";
  var _PBAC = "PutBucketAccelerateConfiguration";
  var _PBACR = "PutBucketAccelerateConfigurationRequest";
  var _PBACRu = "PutBucketAnalyticsConfigurationRequest";
  var _PBACu = "PutBucketAnalyticsConfiguration";
  var _PBAR = "PutBucketAbacRequest";
  var _PBARu = "PutBucketAclRequest";
  var _PBAu = "PutBucketAcl";
  var _PBC = "PutBucketCors";
  var _PBCR = "PutBucketCorsRequest";
  var _PBE = "PutBucketEncryption";
  var _PBER = "PutBucketEncryptionRequest";
  var _PBIC = "PutBucketInventoryConfiguration";
  var _PBICR = "PutBucketInventoryConfigurationRequest";
  var _PBITC = "PutBucketIntelligentTieringConfiguration";
  var _PBITCR = "PutBucketIntelligentTieringConfigurationRequest";
  var _PBL = "PutBucketLogging";
  var _PBLC = "PutBucketLifecycleConfiguration";
  var _PBLCO = "PutBucketLifecycleConfigurationOutput";
  var _PBLCR = "PutBucketLifecycleConfigurationRequest";
  var _PBLR = "PutBucketLoggingRequest";
  var _PBMC = "PutBucketMetricsConfiguration";
  var _PBMCR = "PutBucketMetricsConfigurationRequest";
  var _PBNC = "PutBucketNotificationConfiguration";
  var _PBNCR = "PutBucketNotificationConfigurationRequest";
  var _PBOC = "PutBucketOwnershipControls";
  var _PBOCR = "PutBucketOwnershipControlsRequest";
  var _PBP = "PutBucketPolicy";
  var _PBPR = "PutBucketPolicyRequest";
  var _PBR = "PutBucketReplication";
  var _PBRP = "PutBucketRequestPayment";
  var _PBRPR = "PutBucketRequestPaymentRequest";
  var _PBRR = "PutBucketReplicationRequest";
  var _PBT = "PutBucketTagging";
  var _PBTR = "PutBucketTaggingRequest";
  var _PBV = "PutBucketVersioning";
  var _PBVR = "PutBucketVersioningRequest";
  var _PBW = "PutBucketWebsite";
  var _PBWR = "PutBucketWebsiteRequest";
  var _PC = "PartsCount";
  var _PDS = "PartitionDateSource";
  var _PE = "ProgressEvent";
  var _PI = "ParquetInput";
  var _PL = "PartsList";
  var _PN = "PartNumber";
  var _PNM = "PartNumberMarker";
  var _PO = "PutObject";
  var _POA = "PutObjectAcl";
  var _POAO = "PutObjectAclOutput";
  var _POAR = "PutObjectAclRequest";
  var _POLC = "PutObjectLockConfiguration";
  var _POLCO = "PutObjectLockConfigurationOutput";
  var _POLCR = "PutObjectLockConfigurationRequest";
  var _POLH = "PutObjectLegalHold";
  var _POLHO = "PutObjectLegalHoldOutput";
  var _POLHR = "PutObjectLegalHoldRequest";
  var _POO = "PutObjectOutput";
  var _POR = "PutObjectRequest";
  var _PORO = "PutObjectRetentionOutput";
  var _PORR = "PutObjectRetentionRequest";
  var _PORu = "PutObjectRetention";
  var _POT = "PutObjectTagging";
  var _POTO = "PutObjectTaggingOutput";
  var _POTR = "PutObjectTaggingRequest";
  var _PP = "PartitionedPrefix";
  var _PPAB = "PutPublicAccessBlock";
  var _PPABR = "PutPublicAccessBlockRequest";
  var _PS = "PolicyStatus";
  var _Pa = "Parts";
  var _Par = "Part";
  var _Parq = "Parquet";
  var _Pay = "Payer";
  var _Payl = "Payload";
  var _Pe = "Permission";
  var _Po = "Policy";
  var _Pr = "Progress";
  var _Pri = "Priority";
  var _Pro = "Protocol";
  var _Q = "Quiet";
  var _QA = "QueueArn";
  var _QC = "QuoteCharacter";
  var _QCL = "QueueConfigurationList";
  var _QCu = "QueueConfigurations";
  var _QCue = "QueueConfiguration";
  var _QEC = "QuoteEscapeCharacter";
  var _QF = "QuoteFields";
  var _Qu = "Queue";
  var _R = "Rules";
  var _RART = "RedirectAllRequestsTo";
  var _RC = "RequestCharged";
  var _RCC = "ResponseCacheControl";
  var _RCD = "ResponseContentDisposition";
  var _RCE = "ResponseContentEncoding";
  var _RCL = "ResponseContentLanguage";
  var _RCT = "ResponseContentType";
  var _RCe = "ReplicationConfiguration";
  var _RD = "RecordDelimiter";
  var _RE = "ResponseExpires";
  var _RED = "RestoreExpiryDate";
  var _REe = "RecordExpiration";
  var _REec = "RecordsEvent";
  var _RKKID = "ReplicaKmsKeyID";
  var _RKPW = "ReplaceKeyPrefixWith";
  var _RKW = "ReplaceKeyWith";
  var _RM = "ReplicaModifications";
  var _RO = "RenameObject";
  var _ROO = "RenameObjectOutput";
  var _ROOe = "RestoreObjectOutput";
  var _ROP = "RestoreOutputPath";
  var _ROR = "RenameObjectRequest";
  var _RORe = "RestoreObjectRequest";
  var _ROe = "RestoreObject";
  var _RP = "RequestPayer";
  var _RPB = "RestrictPublicBuckets";
  var _RPC = "RequestPaymentConfiguration";
  var _RPe = "RequestProgress";
  var _RR = "RoutingRules";
  var _RRAO = "ReplicationRuleAndOperator";
  var _RRF = "ReplicationRuleFilter";
  var _RRe = "ReplicationRule";
  var _RRep = "ReplicationRules";
  var _RReq = "RequestRoute";
  var _RRes = "RestoreRequest";
  var _RRo = "RoutingRule";
  var _RS = "ReplicationStatus";
  var _RSe = "RestoreStatus";
  var _RSen = "RenameSource";
  var _RT = "ReplicationTime";
  var _RTV = "ReplicationTimeValue";
  var _RTe = "RequestToken";
  var _RUD = "RetainUntilDate";
  var _Ra = "Range";
  var _Re = "Restore";
  var _Rec = "Records";
  var _Red = "Redirect";
  var _Ret = "Retention";
  var _Ro = "Role";
  var _Ru = "Rule";
  var _S = "Status";
  var _SA = "StartAfter";
  var _SAK = "SecretAccessKey";
  var _SAs = "SseAlgorithm";
  var _SB = "StreamingBlob";
  var _SBD = "S3BucketDestination";
  var _SC = "StorageClass";
  var _SCA = "StorageClassAnalysis";
  var _SCADE = "StorageClassAnalysisDataExport";
  var _SCV = "SessionCredentialValue";
  var _SCe = "SessionCredentials";
  var _SCt = "StatusCode";
  var _SDV = "SkipDestinationValidation";
  var _SE = "StatsEvent";
  var _SIM = "SourceIfMatch";
  var _SIMS = "SourceIfModifiedSince";
  var _SINM = "SourceIfNoneMatch";
  var _SIUS = "SourceIfUnmodifiedSince";
  var _SK = "SSE-KMS";
  var _SKEO = "SseKmsEncryptedObjects";
  var _SKF = "S3KeyFilter";
  var _SKe = "S3Key";
  var _SL = "S3Location";
  var _SM = "SessionMode";
  var _SOC = "SelectObjectContent";
  var _SOCES = "SelectObjectContentEventStream";
  var _SOCO = "SelectObjectContentOutput";
  var _SOCR = "SelectObjectContentRequest";
  var _SP = "SelectParameters";
  var _SPi = "SimplePrefix";
  var _SR = "ScanRange";
  var _SS = "SSE-S3";
  var _SSC = "SourceSelectionCriteria";
  var _SSE = "ServerSideEncryption";
  var _SSEA = "SSEAlgorithm";
  var _SSEBD = "ServerSideEncryptionByDefault";
  var _SSEC = "ServerSideEncryptionConfiguration";
  var _SSECA = "SSECustomerAlgorithm";
  var _SSECK = "SSECustomerKey";
  var _SSECKMD = "SSECustomerKeyMD5";
  var _SSEKMS = "SSEKMS";
  var _SSEKMSE = "SSEKMSEncryption";
  var _SSEKMSEC = "SSEKMSEncryptionContext";
  var _SSEKMSKI = "SSEKMSKeyId";
  var _SSER = "ServerSideEncryptionRule";
  var _SSERe = "ServerSideEncryptionRules";
  var _SSES = "SSES3";
  var _ST = "SessionToken";
  var _STD = "S3TablesDestination";
  var _STDR = "S3TablesDestinationResult";
  var _S_ = "S3";
  var _Sc = "Schedule";
  var _Si = "Size";
  var _St = "Start";
  var _Sta = "Stats";
  var _Su = "Suffix";
  var _T = "Tags";
  var _TA = "TableArn";
  var _TAo = "TopicArn";
  var _TB = "TargetBucket";
  var _TBA = "TableBucketArn";
  var _TBT = "TableBucketType";
  var _TC = "TagCount";
  var _TCL = "TopicConfigurationList";
  var _TCo = "TopicConfigurations";
  var _TCop = "TopicConfiguration";
  var _TD = "TaggingDirective";
  var _TDMOS = "TransitionDefaultMinimumObjectSize";
  var _TG = "TargetGrants";
  var _TGa = "TargetGrant";
  var _TL = "TieringList";
  var _TLr = "TransitionList";
  var _TMP = "TooManyParts";
  var _TN = "TableNamespace";
  var _TNa = "TableName";
  var _TOKF = "TargetObjectKeyFormat";
  var _TP = "TargetPrefix";
  var _TPC = "TotalPartsCount";
  var _TS = "TagSet";
  var _TSa = "TableStatus";
  var _Ta = "Tag";
  var _Tag = "Tagging";
  var _Ti = "Tier";
  var _Tie = "Tierings";
  var _Tier = "Tiering";
  var _Tim = "Time";
  var _To = "Token";
  var _Top = "Topic";
  var _Tr = "Transitions";
  var _Tra = "Transition";
  var _Ty = "Type";
  var _U = "Uploads";
  var _UBMITC = "UpdateBucketMetadataInventoryTableConfiguration";
  var _UBMITCR = "UpdateBucketMetadataInventoryTableConfigurationRequest";
  var _UBMJTC = "UpdateBucketMetadataJournalTableConfiguration";
  var _UBMJTCR = "UpdateBucketMetadataJournalTableConfigurationRequest";
  var _UI = "UploadId";
  var _UIM = "UploadIdMarker";
  var _UM = "UserMetadata";
  var _UOE = "UpdateObjectEncryption";
  var _UOER = "UpdateObjectEncryptionRequest";
  var _UOERp = "UpdateObjectEncryptionResponse";
  var _UP = "UploadPart";
  var _UPC = "UploadPartCopy";
  var _UPCO = "UploadPartCopyOutput";
  var _UPCR = "UploadPartCopyRequest";
  var _UPO = "UploadPartOutput";
  var _UPR = "UploadPartRequest";
  var _URI = "URI";
  var _Up = "Upload";
  var _V = "Value";
  var _VC = "VersioningConfiguration";
  var _VI = "VersionId";
  var _VIM = "VersionIdMarker";
  var _Ve = "Versions";
  var _Ver = "Version";
  var _WC = "WebsiteConfiguration";
  var _WGOR = "WriteGetObjectResponse";
  var _WGORR = "WriteGetObjectResponseRequest";
  var _WOB = "WriteOffsetBytes";
  var _WRL = "WebsiteRedirectLocation";
  var _Y = "Years";
  var _ar = "accept-ranges";
  var _br = "bucket-region";
  var _c = "client";
  var _ct = "continuation-token";
  var _d = "delimiter";
  var _e = "error";
  var _eP = "eventPayload";
  var _en = "endpoint";
  var _et = "encoding-type";
  var _fo = "fetch-owner";
  var _h = "http";
  var _hC = "httpChecksum";
  var _hE = "httpError";
  var _hH = "httpHeader";
  var _hL = "hostLabel";
  var _hP = "httpPayload";
  var _hPH = "httpPrefixHeaders";
  var _hQ = "httpQuery";
  var _hi = "http://www.w3.org/2001/XMLSchema-instance";
  var _i = "id";
  var _iT = "idempotencyToken";
  var _km = "key-marker";
  var _m = "marker";
  var _mb = "max-buckets";
  var _mdb = "max-directory-buckets";
  var _mk = "max-keys";
  var _mp = "max-parts";
  var _mu = "max-uploads";
  var _p = "prefix";
  var _pN = "partNumber";
  var _pnm = "part-number-marker";
  var _rcc = "response-cache-control";
  var _rcd = "response-content-disposition";
  var _rce = "response-content-encoding";
  var _rcl = "response-content-language";
  var _rct = "response-content-type";
  var _re = "response-expires";
  var _s = "smithy.ts.sdk.synthetic.com.amazonaws.s3";
  var _sa = "start-after";
  var _st = "streaming";
  var _uI = "uploadId";
  var _uim = "upload-id-marker";
  var _vI = "versionId";
  var _vim = "version-id-marker";
  var _x = "xsi";
  var _xA = "xmlAttribute";
  var _xF = "xmlFlattened";
  var _xN = "xmlName";
  var _xNm = "xmlNamespace";
  var _xaa = "x-amz-acl";
  var _xaad = "x-amz-abort-date";
  var _xaapa = "x-amz-access-point-alias";
  var _xaari = "x-amz-abort-rule-id";
  var _xaas = "x-amz-archive-status";
  var _xaba = "x-amz-bucket-arn";
  var _xabgr = "x-amz-bypass-governance-retention";
  var _xabln = "x-amz-bucket-location-name";
  var _xablt = "x-amz-bucket-location-type";
  var _xabole = "x-amz-bucket-object-lock-enabled";
  var _xabolt = "x-amz-bucket-object-lock-token";
  var _xabr = "x-amz-bucket-region";
  var _xaca = "x-amz-checksum-algorithm";
  var _xacc = "x-amz-checksum-crc32";
  var _xacc_ = "x-amz-checksum-crc32c";
  var _xacc__ = "x-amz-checksum-crc64nvme";
  var _xacm = "x-amz-checksum-mode";
  var _xacrsba = "x-amz-confirm-remove-self-bucket-access";
  var _xacs = "x-amz-checksum-sha1";
  var _xacs_ = "x-amz-checksum-sha256";
  var _xacs__ = "x-amz-copy-source";
  var _xacsim = "x-amz-copy-source-if-match";
  var _xacsims = "x-amz-copy-source-if-modified-since";
  var _xacsinm = "x-amz-copy-source-if-none-match";
  var _xacsius = "x-amz-copy-source-if-unmodified-since";
  var _xacsm = "x-amz-create-session-mode";
  var _xacsr = "x-amz-copy-source-range";
  var _xacssseca = "x-amz-copy-source-server-side-encryption-customer-algorithm";
  var _xacssseck = "x-amz-copy-source-server-side-encryption-customer-key";
  var _xacssseckM = "x-amz-copy-source-server-side-encryption-customer-key-MD5";
  var _xacsvi = "x-amz-copy-source-version-id";
  var _xact = "x-amz-checksum-type";
  var _xact_ = "x-amz-client-token";
  var _xadm = "x-amz-delete-marker";
  var _xae = "x-amz-expiration";
  var _xaebo = "x-amz-expected-bucket-owner";
  var _xafec = "x-amz-fwd-error-code";
  var _xafem = "x-amz-fwd-error-message";
  var _xafhCC = "x-amz-fwd-header-Cache-Control";
  var _xafhCD = "x-amz-fwd-header-Content-Disposition";
  var _xafhCE = "x-amz-fwd-header-Content-Encoding";
  var _xafhCL = "x-amz-fwd-header-Content-Language";
  var _xafhCR = "x-amz-fwd-header-Content-Range";
  var _xafhCT = "x-amz-fwd-header-Content-Type";
  var _xafhE = "x-amz-fwd-header-ETag";
  var _xafhE_ = "x-amz-fwd-header-Expires";
  var _xafhLM = "x-amz-fwd-header-Last-Modified";
  var _xafhar = "x-amz-fwd-header-accept-ranges";
  var _xafhxacc = "x-amz-fwd-header-x-amz-checksum-crc32";
  var _xafhxacc_ = "x-amz-fwd-header-x-amz-checksum-crc32c";
  var _xafhxacc__ = "x-amz-fwd-header-x-amz-checksum-crc64nvme";
  var _xafhxacs = "x-amz-fwd-header-x-amz-checksum-sha1";
  var _xafhxacs_ = "x-amz-fwd-header-x-amz-checksum-sha256";
  var _xafhxadm = "x-amz-fwd-header-x-amz-delete-marker";
  var _xafhxae = "x-amz-fwd-header-x-amz-expiration";
  var _xafhxamm = "x-amz-fwd-header-x-amz-missing-meta";
  var _xafhxampc = "x-amz-fwd-header-x-amz-mp-parts-count";
  var _xafhxaollh = "x-amz-fwd-header-x-amz-object-lock-legal-hold";
  var _xafhxaolm = "x-amz-fwd-header-x-amz-object-lock-mode";
  var _xafhxaolrud = "x-amz-fwd-header-x-amz-object-lock-retain-until-date";
  var _xafhxar = "x-amz-fwd-header-x-amz-restore";
  var _xafhxarc = "x-amz-fwd-header-x-amz-request-charged";
  var _xafhxars = "x-amz-fwd-header-x-amz-replication-status";
  var _xafhxasc = "x-amz-fwd-header-x-amz-storage-class";
  var _xafhxasse = "x-amz-fwd-header-x-amz-server-side-encryption";
  var _xafhxasseakki = "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id";
  var _xafhxassebke = "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled";
  var _xafhxasseca = "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm";
  var _xafhxasseckM = "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-MD5";
  var _xafhxatc = "x-amz-fwd-header-x-amz-tagging-count";
  var _xafhxavi = "x-amz-fwd-header-x-amz-version-id";
  var _xafs = "x-amz-fwd-status";
  var _xagfc = "x-amz-grant-full-control";
  var _xagr = "x-amz-grant-read";
  var _xagra = "x-amz-grant-read-acp";
  var _xagw = "x-amz-grant-write";
  var _xagwa = "x-amz-grant-write-acp";
  var _xaimit = "x-amz-if-match-initiated-time";
  var _xaimlmt = "x-amz-if-match-last-modified-time";
  var _xaims = "x-amz-if-match-size";
  var _xam = "x-amz-meta-";
  var _xam_ = "x-amz-mfa";
  var _xamd = "x-amz-metadata-directive";
  var _xamm = "x-amz-missing-meta";
  var _xamos = "x-amz-mp-object-size";
  var _xamp = "x-amz-max-parts";
  var _xampc = "x-amz-mp-parts-count";
  var _xaoa = "x-amz-object-attributes";
  var _xaollh = "x-amz-object-lock-legal-hold";
  var _xaolm = "x-amz-object-lock-mode";
  var _xaolrud = "x-amz-object-lock-retain-until-date";
  var _xaoo = "x-amz-object-ownership";
  var _xaooa = "x-amz-optional-object-attributes";
  var _xaos = "x-amz-object-size";
  var _xapnm = "x-amz-part-number-marker";
  var _xar = "x-amz-restore";
  var _xarc = "x-amz-request-charged";
  var _xarop = "x-amz-restore-output-path";
  var _xarp = "x-amz-request-payer";
  var _xarr = "x-amz-request-route";
  var _xars = "x-amz-replication-status";
  var _xars_ = "x-amz-rename-source";
  var _xarsim = "x-amz-rename-source-if-match";
  var _xarsims = "x-amz-rename-source-if-modified-since";
  var _xarsinm = "x-amz-rename-source-if-none-match";
  var _xarsius = "x-amz-rename-source-if-unmodified-since";
  var _xart = "x-amz-request-token";
  var _xasc = "x-amz-storage-class";
  var _xasca = "x-amz-sdk-checksum-algorithm";
  var _xasdv = "x-amz-skip-destination-validation";
  var _xasebo = "x-amz-source-expected-bucket-owner";
  var _xasse = "x-amz-server-side-encryption";
  var _xasseakki = "x-amz-server-side-encryption-aws-kms-key-id";
  var _xassebke = "x-amz-server-side-encryption-bucket-key-enabled";
  var _xassec = "x-amz-server-side-encryption-context";
  var _xasseca = "x-amz-server-side-encryption-customer-algorithm";
  var _xasseck = "x-amz-server-side-encryption-customer-key";
  var _xasseckM = "x-amz-server-side-encryption-customer-key-MD5";
  var _xat = "x-amz-tagging";
  var _xatc = "x-amz-tagging-count";
  var _xatd = "x-amz-tagging-directive";
  var _xatdmos = "x-amz-transition-default-minimum-object-size";
  var _xavi = "x-amz-version-id";
  var _xawob = "x-amz-write-offset-bytes";
  var _xawrl = "x-amz-website-redirect-location";
  var _xs = "xsi:type";
  var n0 = "com.amazonaws.s3";
  var schema_1 = require_schema();
  var errors_1 = require_errors5();
  var S3ServiceException_1 = require_S3ServiceException();
  var _s_registry = schema_1.TypeRegistry.for(_s);
  exports.S3ServiceException$ = [-3, _s, "S3ServiceException", 0, [], []];
  _s_registry.registerError(exports.S3ServiceException$, S3ServiceException_1.S3ServiceException);
  var n0_registry = schema_1.TypeRegistry.for(n0);
  exports.AccessDenied$ = [
    -3,
    n0,
    _AD,
    { [_e]: _c, [_hE]: 403 },
    [],
    []
  ];
  n0_registry.registerError(exports.AccessDenied$, errors_1.AccessDenied);
  exports.BucketAlreadyExists$ = [
    -3,
    n0,
    _BAE,
    { [_e]: _c, [_hE]: 409 },
    [],
    []
  ];
  n0_registry.registerError(exports.BucketAlreadyExists$, errors_1.BucketAlreadyExists);
  exports.BucketAlreadyOwnedByYou$ = [
    -3,
    n0,
    _BAOBY,
    { [_e]: _c, [_hE]: 409 },
    [],
    []
  ];
  n0_registry.registerError(exports.BucketAlreadyOwnedByYou$, errors_1.BucketAlreadyOwnedByYou);
  exports.EncryptionTypeMismatch$ = [
    -3,
    n0,
    _ETM,
    { [_e]: _c, [_hE]: 400 },
    [],
    []
  ];
  n0_registry.registerError(exports.EncryptionTypeMismatch$, errors_1.EncryptionTypeMismatch);
  exports.IdempotencyParameterMismatch$ = [
    -3,
    n0,
    _IPM,
    { [_e]: _c, [_hE]: 400 },
    [],
    []
  ];
  n0_registry.registerError(exports.IdempotencyParameterMismatch$, errors_1.IdempotencyParameterMismatch);
  exports.InvalidObjectState$ = [
    -3,
    n0,
    _IOS,
    { [_e]: _c, [_hE]: 403 },
    [_SC, _AT],
    [0, 0]
  ];
  n0_registry.registerError(exports.InvalidObjectState$, errors_1.InvalidObjectState);
  exports.InvalidRequest$ = [
    -3,
    n0,
    _IR,
    { [_e]: _c, [_hE]: 400 },
    [],
    []
  ];
  n0_registry.registerError(exports.InvalidRequest$, errors_1.InvalidRequest);
  exports.InvalidWriteOffset$ = [
    -3,
    n0,
    _IWO,
    { [_e]: _c, [_hE]: 400 },
    [],
    []
  ];
  n0_registry.registerError(exports.InvalidWriteOffset$, errors_1.InvalidWriteOffset);
  exports.NoSuchBucket$ = [
    -3,
    n0,
    _NSB,
    { [_e]: _c, [_hE]: 404 },
    [],
    []
  ];
  n0_registry.registerError(exports.NoSuchBucket$, errors_1.NoSuchBucket);
  exports.NoSuchKey$ = [
    -3,
    n0,
    _NSK,
    { [_e]: _c, [_hE]: 404 },
    [],
    []
  ];
  n0_registry.registerError(exports.NoSuchKey$, errors_1.NoSuchKey);
  exports.NoSuchUpload$ = [
    -3,
    n0,
    _NSU,
    { [_e]: _c, [_hE]: 404 },
    [],
    []
  ];
  n0_registry.registerError(exports.NoSuchUpload$, errors_1.NoSuchUpload);
  exports.NotFound$ = [
    -3,
    n0,
    _NF,
    { [_e]: _c },
    [],
    []
  ];
  n0_registry.registerError(exports.NotFound$, errors_1.NotFound);
  exports.ObjectAlreadyInActiveTierError$ = [
    -3,
    n0,
    _OAIATE,
    { [_e]: _c, [_hE]: 403 },
    [],
    []
  ];
  n0_registry.registerError(exports.ObjectAlreadyInActiveTierError$, errors_1.ObjectAlreadyInActiveTierError);
  exports.ObjectNotInActiveTierError$ = [
    -3,
    n0,
    _ONIATE,
    { [_e]: _c, [_hE]: 403 },
    [],
    []
  ];
  n0_registry.registerError(exports.ObjectNotInActiveTierError$, errors_1.ObjectNotInActiveTierError);
  exports.TooManyParts$ = [
    -3,
    n0,
    _TMP,
    { [_e]: _c, [_hE]: 400 },
    [],
    []
  ];
  n0_registry.registerError(exports.TooManyParts$, errors_1.TooManyParts);
  exports.errorTypeRegistries = [
    _s_registry,
    n0_registry
  ];
  var CopySourceSSECustomerKey = [0, n0, _CSSSECK, 8, 0];
  var NonEmptyKmsKeyArnString = [0, n0, _NEKKAS, 8, 0];
  var SessionCredentialValue = [0, n0, _SCV, 8, 0];
  var SSECustomerKey = [0, n0, _SSECK, 8, 0];
  var SSEKMSEncryptionContext = [0, n0, _SSEKMSEC, 8, 0];
  var SSEKMSKeyId = [0, n0, _SSEKMSKI, 8, 0];
  var StreamingBlob = [0, n0, _SB, { [_st]: 1 }, 42];
  exports.AbacStatus$ = [
    3,
    n0,
    _AS,
    0,
    [_S],
    [0]
  ];
  exports.AbortIncompleteMultipartUpload$ = [
    3,
    n0,
    _AIMU,
    0,
    [_DAI],
    [1]
  ];
  exports.AbortMultipartUploadOutput$ = [
    3,
    n0,
    _AMUO,
    0,
    [_RC],
    [[0, { [_hH]: _xarc }]]
  ];
  exports.AbortMultipartUploadRequest$ = [
    3,
    n0,
    _AMUR,
    0,
    [_B, _K, _UI, _RP, _EBO, _IMIT],
    [[0, 1], [0, 1], [0, { [_hQ]: _uI }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }], [6, { [_hH]: _xaimit }]],
    3
  ];
  exports.AccelerateConfiguration$ = [
    3,
    n0,
    _AC,
    0,
    [_S],
    [0]
  ];
  exports.AccessControlPolicy$ = [
    3,
    n0,
    _ACP,
    0,
    [_G, _O],
    [[() => Grants, { [_xN]: _ACL }], () => exports.Owner$]
  ];
  exports.AccessControlTranslation$ = [
    3,
    n0,
    _ACT,
    0,
    [_O],
    [0],
    1
  ];
  exports.AnalyticsAndOperator$ = [
    3,
    n0,
    _AAO,
    0,
    [_P, _T],
    [0, [() => TagSet, { [_xF]: 1, [_xN]: _Ta }]]
  ];
  exports.AnalyticsConfiguration$ = [
    3,
    n0,
    _ACn,
    0,
    [_I, _SCA, _F],
    [0, () => exports.StorageClassAnalysis$, [() => exports.AnalyticsFilter$, 0]],
    2
  ];
  exports.AnalyticsExportDestination$ = [
    3,
    n0,
    _AED,
    0,
    [_SBD],
    [() => exports.AnalyticsS3BucketDestination$],
    1
  ];
  exports.AnalyticsS3BucketDestination$ = [
    3,
    n0,
    _ASBD,
    0,
    [_Fo, _B, _BAI, _P],
    [0, 0, 0, 0],
    2
  ];
  exports.BlockedEncryptionTypes$ = [
    3,
    n0,
    _BET,
    0,
    [_ET],
    [[() => EncryptionTypeList, { [_xF]: 1 }]]
  ];
  exports.Bucket$ = [
    3,
    n0,
    _B,
    0,
    [_N, _CD, _BR, _BA],
    [0, 4, 0, 0]
  ];
  exports.BucketInfo$ = [
    3,
    n0,
    _BI,
    0,
    [_DR, _Ty],
    [0, 0]
  ];
  exports.BucketLifecycleConfiguration$ = [
    3,
    n0,
    _BLC,
    0,
    [_R],
    [[() => LifecycleRules, { [_xF]: 1, [_xN]: _Ru }]],
    1
  ];
  exports.BucketLoggingStatus$ = [
    3,
    n0,
    _BLS,
    0,
    [_LE],
    [[() => exports.LoggingEnabled$, 0]]
  ];
  exports.Checksum$ = [
    3,
    n0,
    _C,
    0,
    [_CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _CT],
    [0, 0, 0, 0, 0, 0]
  ];
  exports.CommonPrefix$ = [
    3,
    n0,
    _CP,
    0,
    [_P],
    [0]
  ];
  exports.CompletedMultipartUpload$ = [
    3,
    n0,
    _CMU,
    0,
    [_Pa],
    [[() => CompletedPartList, { [_xF]: 1, [_xN]: _Par }]]
  ];
  exports.CompletedPart$ = [
    3,
    n0,
    _CPo,
    0,
    [_ETa, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _PN],
    [0, 0, 0, 0, 0, 0, 1]
  ];
  exports.CompleteMultipartUploadOutput$ = [
    3,
    n0,
    _CMUO,
    { [_xN]: _CMUR },
    [_L, _B, _K, _E, _ETa, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _CT, _SSE, _VI, _SSEKMSKI, _BKE, _RC],
    [0, 0, 0, [0, { [_hH]: _xae }], 0, 0, 0, 0, 0, 0, 0, [0, { [_hH]: _xasse }], [0, { [_hH]: _xavi }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xarc }]]
  ];
  exports.CompleteMultipartUploadRequest$ = [
    3,
    n0,
    _CMURo,
    0,
    [_B, _K, _UI, _MU, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _CT, _MOS, _RP, _EBO, _IM, _INM, _SSECA, _SSECK, _SSECKMD],
    [[0, 1], [0, 1], [0, { [_hQ]: _uI }], [() => exports.CompletedMultipartUpload$, { [_hP]: 1, [_xN]: _CMUo }], [0, { [_hH]: _xacc }], [0, { [_hH]: _xacc_ }], [0, { [_hH]: _xacc__ }], [0, { [_hH]: _xacs }], [0, { [_hH]: _xacs_ }], [0, { [_hH]: _xact }], [1, { [_hH]: _xamos }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _IM_ }], [0, { [_hH]: _INM_ }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }]],
    3
  ];
  exports.Condition$ = [
    3,
    n0,
    _Co,
    0,
    [_HECRE, _KPE],
    [0, 0]
  ];
  exports.ContinuationEvent$ = [
    3,
    n0,
    _CE,
    0,
    [],
    []
  ];
  exports.CopyObjectOutput$ = [
    3,
    n0,
    _COO,
    0,
    [_COR, _E, _CSVI, _VI, _SSE, _SSECA, _SSECKMD, _SSEKMSKI, _SSEKMSEC, _BKE, _RC],
    [[() => exports.CopyObjectResult$, 16], [0, { [_hH]: _xae }], [0, { [_hH]: _xacsvi }], [0, { [_hH]: _xavi }], [0, { [_hH]: _xasse }], [0, { [_hH]: _xasseca }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xarc }]]
  ];
  exports.CopyObjectRequest$ = [
    3,
    n0,
    _CORo,
    0,
    [_B, _CS, _K, _ACL_, _CC, _CA, _CDo, _CEo, _CL, _CTo, _CSIM, _CSIMS, _CSINM, _CSIUS, _Ex, _GFC, _GR, _GRACP, _GWACP, _IM, _INM, _M, _MD, _TD, _SSE, _SC, _WRL, _SSECA, _SSECK, _SSECKMD, _SSEKMSKI, _SSEKMSEC, _BKE, _CSSSECA, _CSSSECK, _CSSSECKMD, _RP, _Tag, _OLM, _OLRUD, _OLLHS, _EBO, _ESBO],
    [[0, 1], [0, { [_hH]: _xacs__ }], [0, 1], [0, { [_hH]: _xaa }], [0, { [_hH]: _CC_ }], [0, { [_hH]: _xaca }], [0, { [_hH]: _CD_ }], [0, { [_hH]: _CE_ }], [0, { [_hH]: _CL_ }], [0, { [_hH]: _CT_ }], [0, { [_hH]: _xacsim }], [4, { [_hH]: _xacsims }], [0, { [_hH]: _xacsinm }], [4, { [_hH]: _xacsius }], [4, { [_hH]: _Ex }], [0, { [_hH]: _xagfc }], [0, { [_hH]: _xagr }], [0, { [_hH]: _xagra }], [0, { [_hH]: _xagwa }], [0, { [_hH]: _IM_ }], [0, { [_hH]: _INM_ }], [128 | 0, { [_hPH]: _xam }], [0, { [_hH]: _xamd }], [0, { [_hH]: _xatd }], [0, { [_hH]: _xasse }], [0, { [_hH]: _xasc }], [0, { [_hH]: _xawrl }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xacssseca }], [() => CopySourceSSECustomerKey, { [_hH]: _xacssseck }], [0, { [_hH]: _xacssseckM }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xat }], [0, { [_hH]: _xaolm }], [5, { [_hH]: _xaolrud }], [0, { [_hH]: _xaollh }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xasebo }]],
    3
  ];
  exports.CopyObjectResult$ = [
    3,
    n0,
    _COR,
    0,
    [_ETa, _LM, _CT, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh],
    [0, 4, 0, 0, 0, 0, 0, 0]
  ];
  exports.CopyPartResult$ = [
    3,
    n0,
    _CPR,
    0,
    [_ETa, _LM, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh],
    [0, 4, 0, 0, 0, 0, 0]
  ];
  exports.CORSConfiguration$ = [
    3,
    n0,
    _CORSC,
    0,
    [_CORSR],
    [[() => CORSRules, { [_xF]: 1, [_xN]: _CORSRu }]],
    1
  ];
  exports.CORSRule$ = [
    3,
    n0,
    _CORSRu,
    0,
    [_AM, _AO, _ID, _AH, _EH, _MAS],
    [[64 | 0, { [_xF]: 1, [_xN]: _AMl }], [64 | 0, { [_xF]: 1, [_xN]: _AOl }], 0, [64 | 0, { [_xF]: 1, [_xN]: _AHl }], [64 | 0, { [_xF]: 1, [_xN]: _EHx }], 1],
    2
  ];
  exports.CreateBucketConfiguration$ = [
    3,
    n0,
    _CBC,
    0,
    [_LC, _L, _B, _T],
    [0, () => exports.LocationInfo$, () => exports.BucketInfo$, [() => TagSet, 0]]
  ];
  exports.CreateBucketMetadataConfigurationRequest$ = [
    3,
    n0,
    _CBMCR,
    0,
    [_B, _MC, _CMD, _CA, _EBO],
    [[0, 1], [() => exports.MetadataConfiguration$, { [_hP]: 1, [_xN]: _MC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.CreateBucketMetadataTableConfigurationRequest$ = [
    3,
    n0,
    _CBMTCR,
    0,
    [_B, _MTC, _CMD, _CA, _EBO],
    [[0, 1], [() => exports.MetadataTableConfiguration$, { [_hP]: 1, [_xN]: _MTC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.CreateBucketOutput$ = [
    3,
    n0,
    _CBO,
    0,
    [_L, _BA],
    [[0, { [_hH]: _L }], [0, { [_hH]: _xaba }]]
  ];
  exports.CreateBucketRequest$ = [
    3,
    n0,
    _CBR,
    0,
    [_B, _ACL_, _CBC, _GFC, _GR, _GRACP, _GW, _GWACP, _OLEFB, _OO],
    [[0, 1], [0, { [_hH]: _xaa }], [() => exports.CreateBucketConfiguration$, { [_hP]: 1, [_xN]: _CBC }], [0, { [_hH]: _xagfc }], [0, { [_hH]: _xagr }], [0, { [_hH]: _xagra }], [0, { [_hH]: _xagw }], [0, { [_hH]: _xagwa }], [2, { [_hH]: _xabole }], [0, { [_hH]: _xaoo }]],
    1
  ];
  exports.CreateMultipartUploadOutput$ = [
    3,
    n0,
    _CMUOr,
    { [_xN]: _IMUR },
    [_ADb, _ARI, _B, _K, _UI, _SSE, _SSECA, _SSECKMD, _SSEKMSKI, _SSEKMSEC, _BKE, _RC, _CA, _CT],
    [[4, { [_hH]: _xaad }], [0, { [_hH]: _xaari }], [0, { [_xN]: _B }], 0, 0, [0, { [_hH]: _xasse }], [0, { [_hH]: _xasseca }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xarc }], [0, { [_hH]: _xaca }], [0, { [_hH]: _xact }]]
  ];
  exports.CreateMultipartUploadRequest$ = [
    3,
    n0,
    _CMURr,
    0,
    [_B, _K, _ACL_, _CC, _CDo, _CEo, _CL, _CTo, _Ex, _GFC, _GR, _GRACP, _GWACP, _M, _SSE, _SC, _WRL, _SSECA, _SSECK, _SSECKMD, _SSEKMSKI, _SSEKMSEC, _BKE, _RP, _Tag, _OLM, _OLRUD, _OLLHS, _EBO, _CA, _CT],
    [[0, 1], [0, 1], [0, { [_hH]: _xaa }], [0, { [_hH]: _CC_ }], [0, { [_hH]: _CD_ }], [0, { [_hH]: _CE_ }], [0, { [_hH]: _CL_ }], [0, { [_hH]: _CT_ }], [4, { [_hH]: _Ex }], [0, { [_hH]: _xagfc }], [0, { [_hH]: _xagr }], [0, { [_hH]: _xagra }], [0, { [_hH]: _xagwa }], [128 | 0, { [_hPH]: _xam }], [0, { [_hH]: _xasse }], [0, { [_hH]: _xasc }], [0, { [_hH]: _xawrl }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xat }], [0, { [_hH]: _xaolm }], [5, { [_hH]: _xaolrud }], [0, { [_hH]: _xaollh }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xaca }], [0, { [_hH]: _xact }]],
    2
  ];
  exports.CreateSessionOutput$ = [
    3,
    n0,
    _CSO,
    { [_xN]: _CSR },
    [_Cr, _SSE, _SSEKMSKI, _SSEKMSEC, _BKE],
    [[() => exports.SessionCredentials$, { [_xN]: _Cr }], [0, { [_hH]: _xasse }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }]],
    1
  ];
  exports.CreateSessionRequest$ = [
    3,
    n0,
    _CSRr,
    0,
    [_B, _SM, _SSE, _SSEKMSKI, _SSEKMSEC, _BKE],
    [[0, 1], [0, { [_hH]: _xacsm }], [0, { [_hH]: _xasse }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }]],
    1
  ];
  exports.CSVInput$ = [
    3,
    n0,
    _CSVIn,
    0,
    [_FHI, _Com, _QEC, _RD, _FD, _QC, _AQRD],
    [0, 0, 0, 0, 0, 0, 2]
  ];
  exports.CSVOutput$ = [
    3,
    n0,
    _CSVO,
    0,
    [_QF, _QEC, _RD, _FD, _QC],
    [0, 0, 0, 0, 0]
  ];
  exports.DefaultRetention$ = [
    3,
    n0,
    _DRe,
    0,
    [_Mo, _D, _Y],
    [0, 1, 1]
  ];
  exports.Delete$ = [
    3,
    n0,
    _De,
    0,
    [_Ob, _Q],
    [[() => ObjectIdentifierList, { [_xF]: 1, [_xN]: _Obj }], 2],
    1
  ];
  exports.DeleteBucketAnalyticsConfigurationRequest$ = [
    3,
    n0,
    _DBACR,
    0,
    [_B, _I, _EBO],
    [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.DeleteBucketCorsRequest$ = [
    3,
    n0,
    _DBCR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.DeleteBucketEncryptionRequest$ = [
    3,
    n0,
    _DBER,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.DeleteBucketIntelligentTieringConfigurationRequest$ = [
    3,
    n0,
    _DBITCR,
    0,
    [_B, _I, _EBO],
    [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.DeleteBucketInventoryConfigurationRequest$ = [
    3,
    n0,
    _DBICR,
    0,
    [_B, _I, _EBO],
    [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.DeleteBucketLifecycleRequest$ = [
    3,
    n0,
    _DBLR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.DeleteBucketMetadataConfigurationRequest$ = [
    3,
    n0,
    _DBMCR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.DeleteBucketMetadataTableConfigurationRequest$ = [
    3,
    n0,
    _DBMTCR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.DeleteBucketMetricsConfigurationRequest$ = [
    3,
    n0,
    _DBMCRe,
    0,
    [_B, _I, _EBO],
    [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.DeleteBucketOwnershipControlsRequest$ = [
    3,
    n0,
    _DBOCR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.DeleteBucketPolicyRequest$ = [
    3,
    n0,
    _DBPR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.DeleteBucketReplicationRequest$ = [
    3,
    n0,
    _DBRR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.DeleteBucketRequest$ = [
    3,
    n0,
    _DBR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.DeleteBucketTaggingRequest$ = [
    3,
    n0,
    _DBTR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.DeleteBucketWebsiteRequest$ = [
    3,
    n0,
    _DBWR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.DeletedObject$ = [
    3,
    n0,
    _DO,
    0,
    [_K, _VI, _DM, _DMVI],
    [0, 0, 2, 0]
  ];
  exports.DeleteMarkerEntry$ = [
    3,
    n0,
    _DME,
    0,
    [_O, _K, _VI, _IL, _LM],
    [() => exports.Owner$, 0, 0, 2, 4]
  ];
  exports.DeleteMarkerReplication$ = [
    3,
    n0,
    _DMR,
    0,
    [_S],
    [0]
  ];
  exports.DeleteObjectOutput$ = [
    3,
    n0,
    _DOO,
    0,
    [_DM, _VI, _RC],
    [[2, { [_hH]: _xadm }], [0, { [_hH]: _xavi }], [0, { [_hH]: _xarc }]]
  ];
  exports.DeleteObjectRequest$ = [
    3,
    n0,
    _DOR,
    0,
    [_B, _K, _MFA, _VI, _RP, _BGR, _EBO, _IM, _IMLMT, _IMS],
    [[0, 1], [0, 1], [0, { [_hH]: _xam_ }], [0, { [_hQ]: _vI }], [0, { [_hH]: _xarp }], [2, { [_hH]: _xabgr }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _IM_ }], [6, { [_hH]: _xaimlmt }], [1, { [_hH]: _xaims }]],
    2
  ];
  exports.DeleteObjectsOutput$ = [
    3,
    n0,
    _DOOe,
    { [_xN]: _DRel },
    [_Del, _RC, _Er],
    [[() => DeletedObjects, { [_xF]: 1 }], [0, { [_hH]: _xarc }], [() => Errors, { [_xF]: 1, [_xN]: _Err }]]
  ];
  exports.DeleteObjectsRequest$ = [
    3,
    n0,
    _DORe,
    0,
    [_B, _De, _MFA, _RP, _BGR, _EBO, _CA],
    [[0, 1], [() => exports.Delete$, { [_hP]: 1, [_xN]: _De }], [0, { [_hH]: _xam_ }], [0, { [_hH]: _xarp }], [2, { [_hH]: _xabgr }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xasca }]],
    2
  ];
  exports.DeleteObjectTaggingOutput$ = [
    3,
    n0,
    _DOTO,
    0,
    [_VI],
    [[0, { [_hH]: _xavi }]]
  ];
  exports.DeleteObjectTaggingRequest$ = [
    3,
    n0,
    _DOTR,
    0,
    [_B, _K, _VI, _EBO],
    [[0, 1], [0, 1], [0, { [_hQ]: _vI }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.DeletePublicAccessBlockRequest$ = [
    3,
    n0,
    _DPABR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.Destination$ = [
    3,
    n0,
    _Des,
    0,
    [_B, _A, _SC, _ACT, _EC, _RT, _Me],
    [0, 0, 0, () => exports.AccessControlTranslation$, () => exports.EncryptionConfiguration$, () => exports.ReplicationTime$, () => exports.Metrics$],
    1
  ];
  exports.DestinationResult$ = [
    3,
    n0,
    _DRes,
    0,
    [_TBT, _TBA, _TN],
    [0, 0, 0]
  ];
  exports.Encryption$ = [
    3,
    n0,
    _En,
    0,
    [_ET, _KMSKI, _KMSC],
    [0, [() => SSEKMSKeyId, 0], 0],
    1
  ];
  exports.EncryptionConfiguration$ = [
    3,
    n0,
    _EC,
    0,
    [_RKKID],
    [0]
  ];
  exports.EndEvent$ = [
    3,
    n0,
    _EE,
    0,
    [],
    []
  ];
  exports._Error$ = [
    3,
    n0,
    _Err,
    0,
    [_K, _VI, _Cod, _Mes],
    [0, 0, 0, 0]
  ];
  exports.ErrorDetails$ = [
    3,
    n0,
    _ED,
    0,
    [_ECr, _EM],
    [0, 0]
  ];
  exports.ErrorDocument$ = [
    3,
    n0,
    _EDr,
    0,
    [_K],
    [0],
    1
  ];
  exports.EventBridgeConfiguration$ = [
    3,
    n0,
    _EBC,
    0,
    [],
    []
  ];
  exports.ExistingObjectReplication$ = [
    3,
    n0,
    _EOR,
    0,
    [_S],
    [0],
    1
  ];
  exports.FilterRule$ = [
    3,
    n0,
    _FR,
    0,
    [_N, _V],
    [0, 0]
  ];
  exports.GetBucketAbacOutput$ = [
    3,
    n0,
    _GBAO,
    0,
    [_AS],
    [[() => exports.AbacStatus$, 16]]
  ];
  exports.GetBucketAbacRequest$ = [
    3,
    n0,
    _GBAR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketAccelerateConfigurationOutput$ = [
    3,
    n0,
    _GBACO,
    { [_xN]: _AC },
    [_S, _RC],
    [0, [0, { [_hH]: _xarc }]]
  ];
  exports.GetBucketAccelerateConfigurationRequest$ = [
    3,
    n0,
    _GBACR,
    0,
    [_B, _EBO, _RP],
    [[0, 1], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xarp }]],
    1
  ];
  exports.GetBucketAclOutput$ = [
    3,
    n0,
    _GBAOe,
    { [_xN]: _ACP },
    [_O, _G],
    [() => exports.Owner$, [() => Grants, { [_xN]: _ACL }]]
  ];
  exports.GetBucketAclRequest$ = [
    3,
    n0,
    _GBARe,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketAnalyticsConfigurationOutput$ = [
    3,
    n0,
    _GBACOe,
    0,
    [_ACn],
    [[() => exports.AnalyticsConfiguration$, 16]]
  ];
  exports.GetBucketAnalyticsConfigurationRequest$ = [
    3,
    n0,
    _GBACRe,
    0,
    [_B, _I, _EBO],
    [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.GetBucketCorsOutput$ = [
    3,
    n0,
    _GBCO,
    { [_xN]: _CORSC },
    [_CORSR],
    [[() => CORSRules, { [_xF]: 1, [_xN]: _CORSRu }]]
  ];
  exports.GetBucketCorsRequest$ = [
    3,
    n0,
    _GBCR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketEncryptionOutput$ = [
    3,
    n0,
    _GBEO,
    0,
    [_SSEC],
    [[() => exports.ServerSideEncryptionConfiguration$, 16]]
  ];
  exports.GetBucketEncryptionRequest$ = [
    3,
    n0,
    _GBER,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketIntelligentTieringConfigurationOutput$ = [
    3,
    n0,
    _GBITCO,
    0,
    [_ITC],
    [[() => exports.IntelligentTieringConfiguration$, 16]]
  ];
  exports.GetBucketIntelligentTieringConfigurationRequest$ = [
    3,
    n0,
    _GBITCR,
    0,
    [_B, _I, _EBO],
    [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.GetBucketInventoryConfigurationOutput$ = [
    3,
    n0,
    _GBICO,
    0,
    [_IC],
    [[() => exports.InventoryConfiguration$, 16]]
  ];
  exports.GetBucketInventoryConfigurationRequest$ = [
    3,
    n0,
    _GBICR,
    0,
    [_B, _I, _EBO],
    [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.GetBucketLifecycleConfigurationOutput$ = [
    3,
    n0,
    _GBLCO,
    { [_xN]: _LCi },
    [_R, _TDMOS],
    [[() => LifecycleRules, { [_xF]: 1, [_xN]: _Ru }], [0, { [_hH]: _xatdmos }]]
  ];
  exports.GetBucketLifecycleConfigurationRequest$ = [
    3,
    n0,
    _GBLCR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketLocationOutput$ = [
    3,
    n0,
    _GBLO,
    { [_xN]: _LC },
    [_LC],
    [0]
  ];
  exports.GetBucketLocationRequest$ = [
    3,
    n0,
    _GBLR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketLoggingOutput$ = [
    3,
    n0,
    _GBLOe,
    { [_xN]: _BLS },
    [_LE],
    [[() => exports.LoggingEnabled$, 0]]
  ];
  exports.GetBucketLoggingRequest$ = [
    3,
    n0,
    _GBLRe,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketMetadataConfigurationOutput$ = [
    3,
    n0,
    _GBMCO,
    0,
    [_GBMCR],
    [[() => exports.GetBucketMetadataConfigurationResult$, 16]]
  ];
  exports.GetBucketMetadataConfigurationRequest$ = [
    3,
    n0,
    _GBMCRe,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketMetadataConfigurationResult$ = [
    3,
    n0,
    _GBMCR,
    0,
    [_MCR],
    [() => exports.MetadataConfigurationResult$],
    1
  ];
  exports.GetBucketMetadataTableConfigurationOutput$ = [
    3,
    n0,
    _GBMTCO,
    0,
    [_GBMTCR],
    [[() => exports.GetBucketMetadataTableConfigurationResult$, 16]]
  ];
  exports.GetBucketMetadataTableConfigurationRequest$ = [
    3,
    n0,
    _GBMTCRe,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketMetadataTableConfigurationResult$ = [
    3,
    n0,
    _GBMTCR,
    0,
    [_MTCR, _S, _Err],
    [() => exports.MetadataTableConfigurationResult$, 0, () => exports.ErrorDetails$],
    2
  ];
  exports.GetBucketMetricsConfigurationOutput$ = [
    3,
    n0,
    _GBMCOe,
    0,
    [_MCe],
    [[() => exports.MetricsConfiguration$, 16]]
  ];
  exports.GetBucketMetricsConfigurationRequest$ = [
    3,
    n0,
    _GBMCRet,
    0,
    [_B, _I, _EBO],
    [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.GetBucketNotificationConfigurationRequest$ = [
    3,
    n0,
    _GBNCR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketOwnershipControlsOutput$ = [
    3,
    n0,
    _GBOCO,
    0,
    [_OC],
    [[() => exports.OwnershipControls$, 16]]
  ];
  exports.GetBucketOwnershipControlsRequest$ = [
    3,
    n0,
    _GBOCR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketPolicyOutput$ = [
    3,
    n0,
    _GBPO,
    0,
    [_Po],
    [[0, 16]]
  ];
  exports.GetBucketPolicyRequest$ = [
    3,
    n0,
    _GBPR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketPolicyStatusOutput$ = [
    3,
    n0,
    _GBPSO,
    0,
    [_PS],
    [[() => exports.PolicyStatus$, 16]]
  ];
  exports.GetBucketPolicyStatusRequest$ = [
    3,
    n0,
    _GBPSR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketReplicationOutput$ = [
    3,
    n0,
    _GBRO,
    0,
    [_RCe],
    [[() => exports.ReplicationConfiguration$, 16]]
  ];
  exports.GetBucketReplicationRequest$ = [
    3,
    n0,
    _GBRR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketRequestPaymentOutput$ = [
    3,
    n0,
    _GBRPO,
    { [_xN]: _RPC },
    [_Pay],
    [0]
  ];
  exports.GetBucketRequestPaymentRequest$ = [
    3,
    n0,
    _GBRPR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketTaggingOutput$ = [
    3,
    n0,
    _GBTO,
    { [_xN]: _Tag },
    [_TS],
    [[() => TagSet, 0]],
    1
  ];
  exports.GetBucketTaggingRequest$ = [
    3,
    n0,
    _GBTR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketVersioningOutput$ = [
    3,
    n0,
    _GBVO,
    { [_xN]: _VC },
    [_S, _MFAD],
    [0, [0, { [_xN]: _MDf }]]
  ];
  exports.GetBucketVersioningRequest$ = [
    3,
    n0,
    _GBVR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetBucketWebsiteOutput$ = [
    3,
    n0,
    _GBWO,
    { [_xN]: _WC },
    [_RART, _IDn, _EDr, _RR],
    [() => exports.RedirectAllRequestsTo$, () => exports.IndexDocument$, () => exports.ErrorDocument$, [() => RoutingRules, 0]]
  ];
  exports.GetBucketWebsiteRequest$ = [
    3,
    n0,
    _GBWR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetObjectAclOutput$ = [
    3,
    n0,
    _GOAO,
    { [_xN]: _ACP },
    [_O, _G, _RC],
    [() => exports.Owner$, [() => Grants, { [_xN]: _ACL }], [0, { [_hH]: _xarc }]]
  ];
  exports.GetObjectAclRequest$ = [
    3,
    n0,
    _GOAR,
    0,
    [_B, _K, _VI, _RP, _EBO],
    [[0, 1], [0, 1], [0, { [_hQ]: _vI }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.GetObjectAttributesOutput$ = [
    3,
    n0,
    _GOAOe,
    { [_xN]: _GOARe },
    [_DM, _LM, _VI, _RC, _ETa, _C, _OP, _SC, _OS],
    [[2, { [_hH]: _xadm }], [4, { [_hH]: _LM_ }], [0, { [_hH]: _xavi }], [0, { [_hH]: _xarc }], 0, () => exports.Checksum$, [() => exports.GetObjectAttributesParts$, 0], 0, 1]
  ];
  exports.GetObjectAttributesParts$ = [
    3,
    n0,
    _GOAP,
    0,
    [_TPC, _PNM, _NPNM, _MP, _IT, _Pa],
    [[1, { [_xN]: _PC }], 0, 0, 1, 2, [() => PartsList, { [_xF]: 1, [_xN]: _Par }]]
  ];
  exports.GetObjectAttributesRequest$ = [
    3,
    n0,
    _GOARet,
    0,
    [_B, _K, _OA, _VI, _MP, _PNM, _SSECA, _SSECK, _SSECKMD, _RP, _EBO],
    [[0, 1], [0, 1], [64 | 0, { [_hH]: _xaoa }], [0, { [_hQ]: _vI }], [1, { [_hH]: _xamp }], [0, { [_hH]: _xapnm }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }]],
    3
  ];
  exports.GetObjectLegalHoldOutput$ = [
    3,
    n0,
    _GOLHO,
    0,
    [_LH],
    [[() => exports.ObjectLockLegalHold$, { [_hP]: 1, [_xN]: _LH }]]
  ];
  exports.GetObjectLegalHoldRequest$ = [
    3,
    n0,
    _GOLHR,
    0,
    [_B, _K, _VI, _RP, _EBO],
    [[0, 1], [0, 1], [0, { [_hQ]: _vI }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.GetObjectLockConfigurationOutput$ = [
    3,
    n0,
    _GOLCO,
    0,
    [_OLC],
    [[() => exports.ObjectLockConfiguration$, 16]]
  ];
  exports.GetObjectLockConfigurationRequest$ = [
    3,
    n0,
    _GOLCR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GetObjectOutput$ = [
    3,
    n0,
    _GOO,
    0,
    [_Bo, _DM, _AR, _E, _Re, _LM, _CLo, _ETa, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _CT, _MM, _VI, _CC, _CDo, _CEo, _CL, _CR, _CTo, _Ex, _ES, _WRL, _SSE, _M, _SSECA, _SSECKMD, _SSEKMSKI, _BKE, _SC, _RC, _RS, _PC, _TC, _OLM, _OLRUD, _OLLHS],
    [[() => StreamingBlob, 16], [2, { [_hH]: _xadm }], [0, { [_hH]: _ar }], [0, { [_hH]: _xae }], [0, { [_hH]: _xar }], [4, { [_hH]: _LM_ }], [1, { [_hH]: _CL__ }], [0, { [_hH]: _ETa }], [0, { [_hH]: _xacc }], [0, { [_hH]: _xacc_ }], [0, { [_hH]: _xacc__ }], [0, { [_hH]: _xacs }], [0, { [_hH]: _xacs_ }], [0, { [_hH]: _xact }], [1, { [_hH]: _xamm }], [0, { [_hH]: _xavi }], [0, { [_hH]: _CC_ }], [0, { [_hH]: _CD_ }], [0, { [_hH]: _CE_ }], [0, { [_hH]: _CL_ }], [0, { [_hH]: _CR_ }], [0, { [_hH]: _CT_ }], [4, { [_hH]: _Ex }], [0, { [_hH]: _ES }], [0, { [_hH]: _xawrl }], [0, { [_hH]: _xasse }], [128 | 0, { [_hPH]: _xam }], [0, { [_hH]: _xasseca }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xasc }], [0, { [_hH]: _xarc }], [0, { [_hH]: _xars }], [1, { [_hH]: _xampc }], [1, { [_hH]: _xatc }], [0, { [_hH]: _xaolm }], [5, { [_hH]: _xaolrud }], [0, { [_hH]: _xaollh }]]
  ];
  exports.GetObjectRequest$ = [
    3,
    n0,
    _GOR,
    0,
    [_B, _K, _IM, _IMSf, _INM, _IUS, _Ra, _RCC, _RCD, _RCE, _RCL, _RCT, _RE, _VI, _SSECA, _SSECK, _SSECKMD, _RP, _PN, _EBO, _CMh],
    [[0, 1], [0, 1], [0, { [_hH]: _IM_ }], [4, { [_hH]: _IMS_ }], [0, { [_hH]: _INM_ }], [4, { [_hH]: _IUS_ }], [0, { [_hH]: _Ra }], [0, { [_hQ]: _rcc }], [0, { [_hQ]: _rcd }], [0, { [_hQ]: _rce }], [0, { [_hQ]: _rcl }], [0, { [_hQ]: _rct }], [6, { [_hQ]: _re }], [0, { [_hQ]: _vI }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [0, { [_hH]: _xarp }], [1, { [_hQ]: _pN }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xacm }]],
    2
  ];
  exports.GetObjectRetentionOutput$ = [
    3,
    n0,
    _GORO,
    0,
    [_Ret],
    [[() => exports.ObjectLockRetention$, { [_hP]: 1, [_xN]: _Ret }]]
  ];
  exports.GetObjectRetentionRequest$ = [
    3,
    n0,
    _GORR,
    0,
    [_B, _K, _VI, _RP, _EBO],
    [[0, 1], [0, 1], [0, { [_hQ]: _vI }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.GetObjectTaggingOutput$ = [
    3,
    n0,
    _GOTO,
    { [_xN]: _Tag },
    [_TS, _VI],
    [[() => TagSet, 0], [0, { [_hH]: _xavi }]],
    1
  ];
  exports.GetObjectTaggingRequest$ = [
    3,
    n0,
    _GOTR,
    0,
    [_B, _K, _VI, _EBO, _RP],
    [[0, 1], [0, 1], [0, { [_hQ]: _vI }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xarp }]],
    2
  ];
  exports.GetObjectTorrentOutput$ = [
    3,
    n0,
    _GOTOe,
    0,
    [_Bo, _RC],
    [[() => StreamingBlob, 16], [0, { [_hH]: _xarc }]]
  ];
  exports.GetObjectTorrentRequest$ = [
    3,
    n0,
    _GOTRe,
    0,
    [_B, _K, _RP, _EBO],
    [[0, 1], [0, 1], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.GetPublicAccessBlockOutput$ = [
    3,
    n0,
    _GPABO,
    0,
    [_PABC],
    [[() => exports.PublicAccessBlockConfiguration$, 16]]
  ];
  exports.GetPublicAccessBlockRequest$ = [
    3,
    n0,
    _GPABR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.GlacierJobParameters$ = [
    3,
    n0,
    _GJP,
    0,
    [_Ti],
    [0],
    1
  ];
  exports.Grant$ = [
    3,
    n0,
    _Gr,
    0,
    [_Gra, _Pe],
    [[() => exports.Grantee$, { [_xNm]: [_x, _hi] }], 0]
  ];
  exports.Grantee$ = [
    3,
    n0,
    _Gra,
    0,
    [_Ty, _DN, _EA, _ID, _URI],
    [[0, { [_xA]: 1, [_xN]: _xs }], 0, 0, 0, 0],
    1
  ];
  exports.HeadBucketOutput$ = [
    3,
    n0,
    _HBO,
    0,
    [_BA, _BLT, _BLN, _BR, _APA],
    [[0, { [_hH]: _xaba }], [0, { [_hH]: _xablt }], [0, { [_hH]: _xabln }], [0, { [_hH]: _xabr }], [2, { [_hH]: _xaapa }]]
  ];
  exports.HeadBucketRequest$ = [
    3,
    n0,
    _HBR,
    0,
    [_B, _EBO],
    [[0, 1], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.HeadObjectOutput$ = [
    3,
    n0,
    _HOO,
    0,
    [_DM, _AR, _E, _Re, _ASr, _LM, _CLo, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _CT, _ETa, _MM, _VI, _CC, _CDo, _CEo, _CL, _CTo, _CR, _Ex, _ES, _WRL, _SSE, _M, _SSECA, _SSECKMD, _SSEKMSKI, _BKE, _SC, _RC, _RS, _PC, _TC, _OLM, _OLRUD, _OLLHS],
    [[2, { [_hH]: _xadm }], [0, { [_hH]: _ar }], [0, { [_hH]: _xae }], [0, { [_hH]: _xar }], [0, { [_hH]: _xaas }], [4, { [_hH]: _LM_ }], [1, { [_hH]: _CL__ }], [0, { [_hH]: _xacc }], [0, { [_hH]: _xacc_ }], [0, { [_hH]: _xacc__ }], [0, { [_hH]: _xacs }], [0, { [_hH]: _xacs_ }], [0, { [_hH]: _xact }], [0, { [_hH]: _ETa }], [1, { [_hH]: _xamm }], [0, { [_hH]: _xavi }], [0, { [_hH]: _CC_ }], [0, { [_hH]: _CD_ }], [0, { [_hH]: _CE_ }], [0, { [_hH]: _CL_ }], [0, { [_hH]: _CT_ }], [0, { [_hH]: _CR_ }], [4, { [_hH]: _Ex }], [0, { [_hH]: _ES }], [0, { [_hH]: _xawrl }], [0, { [_hH]: _xasse }], [128 | 0, { [_hPH]: _xam }], [0, { [_hH]: _xasseca }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xasc }], [0, { [_hH]: _xarc }], [0, { [_hH]: _xars }], [1, { [_hH]: _xampc }], [1, { [_hH]: _xatc }], [0, { [_hH]: _xaolm }], [5, { [_hH]: _xaolrud }], [0, { [_hH]: _xaollh }]]
  ];
  exports.HeadObjectRequest$ = [
    3,
    n0,
    _HOR,
    0,
    [_B, _K, _IM, _IMSf, _INM, _IUS, _Ra, _RCC, _RCD, _RCE, _RCL, _RCT, _RE, _VI, _SSECA, _SSECK, _SSECKMD, _RP, _PN, _EBO, _CMh],
    [[0, 1], [0, 1], [0, { [_hH]: _IM_ }], [4, { [_hH]: _IMS_ }], [0, { [_hH]: _INM_ }], [4, { [_hH]: _IUS_ }], [0, { [_hH]: _Ra }], [0, { [_hQ]: _rcc }], [0, { [_hQ]: _rcd }], [0, { [_hQ]: _rce }], [0, { [_hQ]: _rcl }], [0, { [_hQ]: _rct }], [6, { [_hQ]: _re }], [0, { [_hQ]: _vI }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [0, { [_hH]: _xarp }], [1, { [_hQ]: _pN }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xacm }]],
    2
  ];
  exports.IndexDocument$ = [
    3,
    n0,
    _IDn,
    0,
    [_Su],
    [0],
    1
  ];
  exports.Initiator$ = [
    3,
    n0,
    _In,
    0,
    [_ID, _DN],
    [0, 0]
  ];
  exports.InputSerialization$ = [
    3,
    n0,
    _IS,
    0,
    [_CSV, _CTom, _JSON, _Parq],
    [() => exports.CSVInput$, 0, () => exports.JSONInput$, () => exports.ParquetInput$]
  ];
  exports.IntelligentTieringAndOperator$ = [
    3,
    n0,
    _ITAO,
    0,
    [_P, _T],
    [0, [() => TagSet, { [_xF]: 1, [_xN]: _Ta }]]
  ];
  exports.IntelligentTieringConfiguration$ = [
    3,
    n0,
    _ITC,
    0,
    [_I, _S, _Tie, _F],
    [0, 0, [() => TieringList, { [_xF]: 1, [_xN]: _Tier }], [() => exports.IntelligentTieringFilter$, 0]],
    3
  ];
  exports.IntelligentTieringFilter$ = [
    3,
    n0,
    _ITF,
    0,
    [_P, _Ta, _An],
    [0, () => exports.Tag$, [() => exports.IntelligentTieringAndOperator$, 0]]
  ];
  exports.InventoryConfiguration$ = [
    3,
    n0,
    _IC,
    0,
    [_Des, _IE, _I, _IOV, _Sc, _F, _OF],
    [[() => exports.InventoryDestination$, 0], 2, 0, 0, () => exports.InventorySchedule$, () => exports.InventoryFilter$, [() => InventoryOptionalFields, 0]],
    5
  ];
  exports.InventoryDestination$ = [
    3,
    n0,
    _IDnv,
    0,
    [_SBD],
    [[() => exports.InventoryS3BucketDestination$, 0]],
    1
  ];
  exports.InventoryEncryption$ = [
    3,
    n0,
    _IEn,
    0,
    [_SSES, _SSEKMS],
    [[() => exports.SSES3$, { [_xN]: _SS }], [() => exports.SSEKMS$, { [_xN]: _SK }]]
  ];
  exports.InventoryFilter$ = [
    3,
    n0,
    _IF,
    0,
    [_P],
    [0],
    1
  ];
  exports.InventoryS3BucketDestination$ = [
    3,
    n0,
    _ISBD,
    0,
    [_B, _Fo, _AI, _P, _En],
    [0, 0, 0, 0, [() => exports.InventoryEncryption$, 0]],
    2
  ];
  exports.InventorySchedule$ = [
    3,
    n0,
    _ISn,
    0,
    [_Fr],
    [0],
    1
  ];
  exports.InventoryTableConfiguration$ = [
    3,
    n0,
    _ITCn,
    0,
    [_CSo, _EC],
    [0, () => exports.MetadataTableEncryptionConfiguration$],
    1
  ];
  exports.InventoryTableConfigurationResult$ = [
    3,
    n0,
    _ITCR,
    0,
    [_CSo, _TSa, _Err, _TNa, _TA],
    [0, 0, () => exports.ErrorDetails$, 0, 0],
    1
  ];
  exports.InventoryTableConfigurationUpdates$ = [
    3,
    n0,
    _ITCU,
    0,
    [_CSo, _EC],
    [0, () => exports.MetadataTableEncryptionConfiguration$],
    1
  ];
  exports.JournalTableConfiguration$ = [
    3,
    n0,
    _JTC,
    0,
    [_REe, _EC],
    [() => exports.RecordExpiration$, () => exports.MetadataTableEncryptionConfiguration$],
    1
  ];
  exports.JournalTableConfigurationResult$ = [
    3,
    n0,
    _JTCR,
    0,
    [_TSa, _TNa, _REe, _Err, _TA],
    [0, 0, () => exports.RecordExpiration$, () => exports.ErrorDetails$, 0],
    3
  ];
  exports.JournalTableConfigurationUpdates$ = [
    3,
    n0,
    _JTCU,
    0,
    [_REe],
    [() => exports.RecordExpiration$],
    1
  ];
  exports.JSONInput$ = [
    3,
    n0,
    _JSONI,
    0,
    [_Ty],
    [0]
  ];
  exports.JSONOutput$ = [
    3,
    n0,
    _JSONO,
    0,
    [_RD],
    [0]
  ];
  exports.LambdaFunctionConfiguration$ = [
    3,
    n0,
    _LFC,
    0,
    [_LFA, _Ev, _I, _F],
    [[0, { [_xN]: _CF }], [64 | 0, { [_xF]: 1, [_xN]: _Eve }], 0, [() => exports.NotificationConfigurationFilter$, 0]],
    2
  ];
  exports.LifecycleExpiration$ = [
    3,
    n0,
    _LEi,
    0,
    [_Da, _D, _EODM],
    [5, 1, 2]
  ];
  exports.LifecycleRule$ = [
    3,
    n0,
    _LR,
    0,
    [_S, _E, _ID, _P, _F, _Tr, _NVT, _NVE, _AIMU],
    [0, () => exports.LifecycleExpiration$, 0, 0, [() => exports.LifecycleRuleFilter$, 0], [() => TransitionList, { [_xF]: 1, [_xN]: _Tra }], [() => NoncurrentVersionTransitionList, { [_xF]: 1, [_xN]: _NVTo }], () => exports.NoncurrentVersionExpiration$, () => exports.AbortIncompleteMultipartUpload$],
    1
  ];
  exports.LifecycleRuleAndOperator$ = [
    3,
    n0,
    _LRAO,
    0,
    [_P, _T, _OSGT, _OSLT],
    [0, [() => TagSet, { [_xF]: 1, [_xN]: _Ta }], 1, 1]
  ];
  exports.LifecycleRuleFilter$ = [
    3,
    n0,
    _LRF,
    0,
    [_P, _Ta, _OSGT, _OSLT, _An],
    [0, () => exports.Tag$, 1, 1, [() => exports.LifecycleRuleAndOperator$, 0]]
  ];
  exports.ListBucketAnalyticsConfigurationsOutput$ = [
    3,
    n0,
    _LBACO,
    { [_xN]: _LBACR },
    [_IT, _CTon, _NCT, _ACLn],
    [2, 0, 0, [() => AnalyticsConfigurationList, { [_xF]: 1, [_xN]: _ACn }]]
  ];
  exports.ListBucketAnalyticsConfigurationsRequest$ = [
    3,
    n0,
    _LBACRi,
    0,
    [_B, _CTon, _EBO],
    [[0, 1], [0, { [_hQ]: _ct }], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.ListBucketIntelligentTieringConfigurationsOutput$ = [
    3,
    n0,
    _LBITCO,
    0,
    [_IT, _CTon, _NCT, _ITCL],
    [2, 0, 0, [() => IntelligentTieringConfigurationList, { [_xF]: 1, [_xN]: _ITC }]]
  ];
  exports.ListBucketIntelligentTieringConfigurationsRequest$ = [
    3,
    n0,
    _LBITCR,
    0,
    [_B, _CTon, _EBO],
    [[0, 1], [0, { [_hQ]: _ct }], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.ListBucketInventoryConfigurationsOutput$ = [
    3,
    n0,
    _LBICO,
    { [_xN]: _LICR },
    [_CTon, _ICL, _IT, _NCT],
    [0, [() => InventoryConfigurationList, { [_xF]: 1, [_xN]: _IC }], 2, 0]
  ];
  exports.ListBucketInventoryConfigurationsRequest$ = [
    3,
    n0,
    _LBICR,
    0,
    [_B, _CTon, _EBO],
    [[0, 1], [0, { [_hQ]: _ct }], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.ListBucketMetricsConfigurationsOutput$ = [
    3,
    n0,
    _LBMCO,
    { [_xN]: _LMCR },
    [_IT, _CTon, _NCT, _MCL],
    [2, 0, 0, [() => MetricsConfigurationList, { [_xF]: 1, [_xN]: _MCe }]]
  ];
  exports.ListBucketMetricsConfigurationsRequest$ = [
    3,
    n0,
    _LBMCR,
    0,
    [_B, _CTon, _EBO],
    [[0, 1], [0, { [_hQ]: _ct }], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.ListBucketsOutput$ = [
    3,
    n0,
    _LBO,
    { [_xN]: _LAMBR },
    [_Bu, _O, _CTon, _P],
    [[() => Buckets, 0], () => exports.Owner$, 0, 0]
  ];
  exports.ListBucketsRequest$ = [
    3,
    n0,
    _LBR,
    0,
    [_MB, _CTon, _P, _BR],
    [[1, { [_hQ]: _mb }], [0, { [_hQ]: _ct }], [0, { [_hQ]: _p }], [0, { [_hQ]: _br }]]
  ];
  exports.ListDirectoryBucketsOutput$ = [
    3,
    n0,
    _LDBO,
    { [_xN]: _LAMDBR },
    [_Bu, _CTon],
    [[() => Buckets, 0], 0]
  ];
  exports.ListDirectoryBucketsRequest$ = [
    3,
    n0,
    _LDBR,
    0,
    [_CTon, _MDB],
    [[0, { [_hQ]: _ct }], [1, { [_hQ]: _mdb }]]
  ];
  exports.ListMultipartUploadsOutput$ = [
    3,
    n0,
    _LMUO,
    { [_xN]: _LMUR },
    [_B, _KM, _UIM, _NKM, _P, _Deli, _NUIM, _MUa, _IT, _U, _CPom, _ETn, _RC],
    [0, 0, 0, 0, 0, 0, 0, 1, 2, [() => MultipartUploadList, { [_xF]: 1, [_xN]: _Up }], [() => CommonPrefixList, { [_xF]: 1 }], 0, [0, { [_hH]: _xarc }]]
  ];
  exports.ListMultipartUploadsRequest$ = [
    3,
    n0,
    _LMURi,
    0,
    [_B, _Deli, _ETn, _KM, _MUa, _P, _UIM, _EBO, _RP],
    [[0, 1], [0, { [_hQ]: _d }], [0, { [_hQ]: _et }], [0, { [_hQ]: _km }], [1, { [_hQ]: _mu }], [0, { [_hQ]: _p }], [0, { [_hQ]: _uim }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xarp }]],
    1
  ];
  exports.ListObjectsOutput$ = [
    3,
    n0,
    _LOO,
    { [_xN]: _LBRi },
    [_IT, _Ma, _NM, _Con, _N, _P, _Deli, _MK, _CPom, _ETn, _RC],
    [2, 0, 0, [() => ObjectList, { [_xF]: 1 }], 0, 0, 0, 1, [() => CommonPrefixList, { [_xF]: 1 }], 0, [0, { [_hH]: _xarc }]]
  ];
  exports.ListObjectsRequest$ = [
    3,
    n0,
    _LOR,
    0,
    [_B, _Deli, _ETn, _Ma, _MK, _P, _RP, _EBO, _OOA],
    [[0, 1], [0, { [_hQ]: _d }], [0, { [_hQ]: _et }], [0, { [_hQ]: _m }], [1, { [_hQ]: _mk }], [0, { [_hQ]: _p }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }], [64 | 0, { [_hH]: _xaooa }]],
    1
  ];
  exports.ListObjectsV2Output$ = [
    3,
    n0,
    _LOVO,
    { [_xN]: _LBRi },
    [_IT, _Con, _N, _P, _Deli, _MK, _CPom, _ETn, _KC, _CTon, _NCT, _SA, _RC],
    [2, [() => ObjectList, { [_xF]: 1 }], 0, 0, 0, 1, [() => CommonPrefixList, { [_xF]: 1 }], 0, 1, 0, 0, 0, [0, { [_hH]: _xarc }]]
  ];
  exports.ListObjectsV2Request$ = [
    3,
    n0,
    _LOVR,
    0,
    [_B, _Deli, _ETn, _MK, _P, _CTon, _FO, _SA, _RP, _EBO, _OOA],
    [[0, 1], [0, { [_hQ]: _d }], [0, { [_hQ]: _et }], [1, { [_hQ]: _mk }], [0, { [_hQ]: _p }], [0, { [_hQ]: _ct }], [2, { [_hQ]: _fo }], [0, { [_hQ]: _sa }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }], [64 | 0, { [_hH]: _xaooa }]],
    1
  ];
  exports.ListObjectVersionsOutput$ = [
    3,
    n0,
    _LOVOi,
    { [_xN]: _LVR },
    [_IT, _KM, _VIM, _NKM, _NVIM, _Ve, _DMe, _N, _P, _Deli, _MK, _CPom, _ETn, _RC],
    [2, 0, 0, 0, 0, [() => ObjectVersionList, { [_xF]: 1, [_xN]: _Ver }], [() => DeleteMarkers, { [_xF]: 1, [_xN]: _DM }], 0, 0, 0, 1, [() => CommonPrefixList, { [_xF]: 1 }], 0, [0, { [_hH]: _xarc }]]
  ];
  exports.ListObjectVersionsRequest$ = [
    3,
    n0,
    _LOVRi,
    0,
    [_B, _Deli, _ETn, _KM, _MK, _P, _VIM, _EBO, _RP, _OOA],
    [[0, 1], [0, { [_hQ]: _d }], [0, { [_hQ]: _et }], [0, { [_hQ]: _km }], [1, { [_hQ]: _mk }], [0, { [_hQ]: _p }], [0, { [_hQ]: _vim }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xarp }], [64 | 0, { [_hH]: _xaooa }]],
    1
  ];
  exports.ListPartsOutput$ = [
    3,
    n0,
    _LPO,
    { [_xN]: _LPR },
    [_ADb, _ARI, _B, _K, _UI, _PNM, _NPNM, _MP, _IT, _Pa, _In, _O, _SC, _RC, _CA, _CT],
    [[4, { [_hH]: _xaad }], [0, { [_hH]: _xaari }], 0, 0, 0, 0, 0, 1, 2, [() => Parts, { [_xF]: 1, [_xN]: _Par }], () => exports.Initiator$, () => exports.Owner$, 0, [0, { [_hH]: _xarc }], 0, 0]
  ];
  exports.ListPartsRequest$ = [
    3,
    n0,
    _LPRi,
    0,
    [_B, _K, _UI, _MP, _PNM, _RP, _EBO, _SSECA, _SSECK, _SSECKMD],
    [[0, 1], [0, 1], [0, { [_hQ]: _uI }], [1, { [_hQ]: _mp }], [0, { [_hQ]: _pnm }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }]],
    3
  ];
  exports.LocationInfo$ = [
    3,
    n0,
    _LI,
    0,
    [_Ty, _N],
    [0, 0]
  ];
  exports.LoggingEnabled$ = [
    3,
    n0,
    _LE,
    0,
    [_TB, _TP, _TG, _TOKF],
    [0, 0, [() => TargetGrants, 0], [() => exports.TargetObjectKeyFormat$, 0]],
    2
  ];
  exports.MetadataConfiguration$ = [
    3,
    n0,
    _MC,
    0,
    [_JTC, _ITCn],
    [() => exports.JournalTableConfiguration$, () => exports.InventoryTableConfiguration$],
    1
  ];
  exports.MetadataConfigurationResult$ = [
    3,
    n0,
    _MCR,
    0,
    [_DRes, _JTCR, _ITCR],
    [() => exports.DestinationResult$, () => exports.JournalTableConfigurationResult$, () => exports.InventoryTableConfigurationResult$],
    1
  ];
  exports.MetadataEntry$ = [
    3,
    n0,
    _ME,
    0,
    [_N, _V],
    [0, 0]
  ];
  exports.MetadataTableConfiguration$ = [
    3,
    n0,
    _MTC,
    0,
    [_STD],
    [() => exports.S3TablesDestination$],
    1
  ];
  exports.MetadataTableConfigurationResult$ = [
    3,
    n0,
    _MTCR,
    0,
    [_STDR],
    [() => exports.S3TablesDestinationResult$],
    1
  ];
  exports.MetadataTableEncryptionConfiguration$ = [
    3,
    n0,
    _MTEC,
    0,
    [_SAs, _KKA],
    [0, 0],
    1
  ];
  exports.Metrics$ = [
    3,
    n0,
    _Me,
    0,
    [_S, _ETv],
    [0, () => exports.ReplicationTimeValue$],
    1
  ];
  exports.MetricsAndOperator$ = [
    3,
    n0,
    _MAO,
    0,
    [_P, _T, _APAc],
    [0, [() => TagSet, { [_xF]: 1, [_xN]: _Ta }], 0]
  ];
  exports.MetricsConfiguration$ = [
    3,
    n0,
    _MCe,
    0,
    [_I, _F],
    [0, [() => exports.MetricsFilter$, 0]],
    1
  ];
  exports.MultipartUpload$ = [
    3,
    n0,
    _MU,
    0,
    [_UI, _K, _Ini, _SC, _O, _In, _CA, _CT],
    [0, 0, 4, 0, () => exports.Owner$, () => exports.Initiator$, 0, 0]
  ];
  exports.NoncurrentVersionExpiration$ = [
    3,
    n0,
    _NVE,
    0,
    [_ND, _NNV],
    [1, 1]
  ];
  exports.NoncurrentVersionTransition$ = [
    3,
    n0,
    _NVTo,
    0,
    [_ND, _SC, _NNV],
    [1, 0, 1]
  ];
  exports.NotificationConfiguration$ = [
    3,
    n0,
    _NC,
    0,
    [_TCo, _QCu, _LFCa, _EBC],
    [[() => TopicConfigurationList, { [_xF]: 1, [_xN]: _TCop }], [() => QueueConfigurationList, { [_xF]: 1, [_xN]: _QCue }], [() => LambdaFunctionConfigurationList, { [_xF]: 1, [_xN]: _CFC }], () => exports.EventBridgeConfiguration$]
  ];
  exports.NotificationConfigurationFilter$ = [
    3,
    n0,
    _NCF,
    0,
    [_K],
    [[() => exports.S3KeyFilter$, { [_xN]: _SKe }]]
  ];
  exports._Object$ = [
    3,
    n0,
    _Obj,
    0,
    [_K, _LM, _ETa, _CA, _CT, _Si, _SC, _O, _RSe],
    [0, 4, 0, [64 | 0, { [_xF]: 1 }], 0, 1, 0, () => exports.Owner$, () => exports.RestoreStatus$]
  ];
  exports.ObjectIdentifier$ = [
    3,
    n0,
    _OI,
    0,
    [_K, _VI, _ETa, _LMT, _Si],
    [0, 0, 0, 6, 1],
    1
  ];
  exports.ObjectLockConfiguration$ = [
    3,
    n0,
    _OLC,
    0,
    [_OLE, _Ru],
    [0, () => exports.ObjectLockRule$]
  ];
  exports.ObjectLockLegalHold$ = [
    3,
    n0,
    _OLLH,
    0,
    [_S],
    [0]
  ];
  exports.ObjectLockRetention$ = [
    3,
    n0,
    _OLR,
    0,
    [_Mo, _RUD],
    [0, 5]
  ];
  exports.ObjectLockRule$ = [
    3,
    n0,
    _OLRb,
    0,
    [_DRe],
    [() => exports.DefaultRetention$]
  ];
  exports.ObjectPart$ = [
    3,
    n0,
    _OPb,
    0,
    [_PN, _Si, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh],
    [1, 1, 0, 0, 0, 0, 0]
  ];
  exports.ObjectVersion$ = [
    3,
    n0,
    _OV,
    0,
    [_ETa, _CA, _CT, _Si, _SC, _K, _VI, _IL, _LM, _O, _RSe],
    [0, [64 | 0, { [_xF]: 1 }], 0, 1, 0, 0, 0, 2, 4, () => exports.Owner$, () => exports.RestoreStatus$]
  ];
  exports.OutputLocation$ = [
    3,
    n0,
    _OL,
    0,
    [_S_],
    [[() => exports.S3Location$, 0]]
  ];
  exports.OutputSerialization$ = [
    3,
    n0,
    _OSu,
    0,
    [_CSV, _JSON],
    [() => exports.CSVOutput$, () => exports.JSONOutput$]
  ];
  exports.Owner$ = [
    3,
    n0,
    _O,
    0,
    [_DN, _ID],
    [0, 0]
  ];
  exports.OwnershipControls$ = [
    3,
    n0,
    _OC,
    0,
    [_R],
    [[() => OwnershipControlsRules, { [_xF]: 1, [_xN]: _Ru }]],
    1
  ];
  exports.OwnershipControlsRule$ = [
    3,
    n0,
    _OCR,
    0,
    [_OO],
    [0],
    1
  ];
  exports.ParquetInput$ = [
    3,
    n0,
    _PI,
    0,
    [],
    []
  ];
  exports.Part$ = [
    3,
    n0,
    _Par,
    0,
    [_PN, _LM, _ETa, _Si, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh],
    [1, 4, 0, 1, 0, 0, 0, 0, 0]
  ];
  exports.PartitionedPrefix$ = [
    3,
    n0,
    _PP,
    { [_xN]: _PP },
    [_PDS],
    [0]
  ];
  exports.PolicyStatus$ = [
    3,
    n0,
    _PS,
    0,
    [_IP],
    [[2, { [_xN]: _IP }]]
  ];
  exports.Progress$ = [
    3,
    n0,
    _Pr,
    0,
    [_BS, _BP, _BRy],
    [1, 1, 1]
  ];
  exports.ProgressEvent$ = [
    3,
    n0,
    _PE,
    0,
    [_Det],
    [[() => exports.Progress$, { [_eP]: 1 }]]
  ];
  exports.PublicAccessBlockConfiguration$ = [
    3,
    n0,
    _PABC,
    0,
    [_BPA, _IPA, _BPP, _RPB],
    [[2, { [_xN]: _BPA }], [2, { [_xN]: _IPA }], [2, { [_xN]: _BPP }], [2, { [_xN]: _RPB }]]
  ];
  exports.PutBucketAbacRequest$ = [
    3,
    n0,
    _PBAR,
    0,
    [_B, _AS, _CMD, _CA, _EBO],
    [[0, 1], [() => exports.AbacStatus$, { [_hP]: 1, [_xN]: _AS }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.PutBucketAccelerateConfigurationRequest$ = [
    3,
    n0,
    _PBACR,
    0,
    [_B, _AC, _EBO, _CA],
    [[0, 1], [() => exports.AccelerateConfiguration$, { [_hP]: 1, [_xN]: _AC }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xasca }]],
    2
  ];
  exports.PutBucketAclRequest$ = [
    3,
    n0,
    _PBARu,
    0,
    [_B, _ACL_, _ACP, _CMD, _CA, _GFC, _GR, _GRACP, _GW, _GWACP, _EBO],
    [[0, 1], [0, { [_hH]: _xaa }], [() => exports.AccessControlPolicy$, { [_hP]: 1, [_xN]: _ACP }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xagfc }], [0, { [_hH]: _xagr }], [0, { [_hH]: _xagra }], [0, { [_hH]: _xagw }], [0, { [_hH]: _xagwa }], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.PutBucketAnalyticsConfigurationRequest$ = [
    3,
    n0,
    _PBACRu,
    0,
    [_B, _I, _ACn, _EBO],
    [[0, 1], [0, { [_hQ]: _i }], [() => exports.AnalyticsConfiguration$, { [_hP]: 1, [_xN]: _ACn }], [0, { [_hH]: _xaebo }]],
    3
  ];
  exports.PutBucketCorsRequest$ = [
    3,
    n0,
    _PBCR,
    0,
    [_B, _CORSC, _CMD, _CA, _EBO],
    [[0, 1], [() => exports.CORSConfiguration$, { [_hP]: 1, [_xN]: _CORSC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.PutBucketEncryptionRequest$ = [
    3,
    n0,
    _PBER,
    0,
    [_B, _SSEC, _CMD, _CA, _EBO],
    [[0, 1], [() => exports.ServerSideEncryptionConfiguration$, { [_hP]: 1, [_xN]: _SSEC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.PutBucketIntelligentTieringConfigurationRequest$ = [
    3,
    n0,
    _PBITCR,
    0,
    [_B, _I, _ITC, _EBO],
    [[0, 1], [0, { [_hQ]: _i }], [() => exports.IntelligentTieringConfiguration$, { [_hP]: 1, [_xN]: _ITC }], [0, { [_hH]: _xaebo }]],
    3
  ];
  exports.PutBucketInventoryConfigurationRequest$ = [
    3,
    n0,
    _PBICR,
    0,
    [_B, _I, _IC, _EBO],
    [[0, 1], [0, { [_hQ]: _i }], [() => exports.InventoryConfiguration$, { [_hP]: 1, [_xN]: _IC }], [0, { [_hH]: _xaebo }]],
    3
  ];
  exports.PutBucketLifecycleConfigurationOutput$ = [
    3,
    n0,
    _PBLCO,
    0,
    [_TDMOS],
    [[0, { [_hH]: _xatdmos }]]
  ];
  exports.PutBucketLifecycleConfigurationRequest$ = [
    3,
    n0,
    _PBLCR,
    0,
    [_B, _CA, _LCi, _EBO, _TDMOS],
    [[0, 1], [0, { [_hH]: _xasca }], [() => exports.BucketLifecycleConfiguration$, { [_hP]: 1, [_xN]: _LCi }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xatdmos }]],
    1
  ];
  exports.PutBucketLoggingRequest$ = [
    3,
    n0,
    _PBLR,
    0,
    [_B, _BLS, _CMD, _CA, _EBO],
    [[0, 1], [() => exports.BucketLoggingStatus$, { [_hP]: 1, [_xN]: _BLS }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.PutBucketMetricsConfigurationRequest$ = [
    3,
    n0,
    _PBMCR,
    0,
    [_B, _I, _MCe, _EBO],
    [[0, 1], [0, { [_hQ]: _i }], [() => exports.MetricsConfiguration$, { [_hP]: 1, [_xN]: _MCe }], [0, { [_hH]: _xaebo }]],
    3
  ];
  exports.PutBucketNotificationConfigurationRequest$ = [
    3,
    n0,
    _PBNCR,
    0,
    [_B, _NC, _EBO, _SDV],
    [[0, 1], [() => exports.NotificationConfiguration$, { [_hP]: 1, [_xN]: _NC }], [0, { [_hH]: _xaebo }], [2, { [_hH]: _xasdv }]],
    2
  ];
  exports.PutBucketOwnershipControlsRequest$ = [
    3,
    n0,
    _PBOCR,
    0,
    [_B, _OC, _CMD, _EBO, _CA],
    [[0, 1], [() => exports.OwnershipControls$, { [_hP]: 1, [_xN]: _OC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xasca }]],
    2
  ];
  exports.PutBucketPolicyRequest$ = [
    3,
    n0,
    _PBPR,
    0,
    [_B, _Po, _CMD, _CA, _CRSBA, _EBO],
    [[0, 1], [0, 16], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [2, { [_hH]: _xacrsba }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.PutBucketReplicationRequest$ = [
    3,
    n0,
    _PBRR,
    0,
    [_B, _RCe, _CMD, _CA, _To, _EBO],
    [[0, 1], [() => exports.ReplicationConfiguration$, { [_hP]: 1, [_xN]: _RCe }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xabolt }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.PutBucketRequestPaymentRequest$ = [
    3,
    n0,
    _PBRPR,
    0,
    [_B, _RPC, _CMD, _CA, _EBO],
    [[0, 1], [() => exports.RequestPaymentConfiguration$, { [_hP]: 1, [_xN]: _RPC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.PutBucketTaggingRequest$ = [
    3,
    n0,
    _PBTR,
    0,
    [_B, _Tag, _CMD, _CA, _EBO],
    [[0, 1], [() => exports.Tagging$, { [_hP]: 1, [_xN]: _Tag }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.PutBucketVersioningRequest$ = [
    3,
    n0,
    _PBVR,
    0,
    [_B, _VC, _CMD, _CA, _MFA, _EBO],
    [[0, 1], [() => exports.VersioningConfiguration$, { [_hP]: 1, [_xN]: _VC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xam_ }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.PutBucketWebsiteRequest$ = [
    3,
    n0,
    _PBWR,
    0,
    [_B, _WC, _CMD, _CA, _EBO],
    [[0, 1], [() => exports.WebsiteConfiguration$, { [_hP]: 1, [_xN]: _WC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.PutObjectAclOutput$ = [
    3,
    n0,
    _POAO,
    0,
    [_RC],
    [[0, { [_hH]: _xarc }]]
  ];
  exports.PutObjectAclRequest$ = [
    3,
    n0,
    _POAR,
    0,
    [_B, _K, _ACL_, _ACP, _CMD, _CA, _GFC, _GR, _GRACP, _GW, _GWACP, _RP, _VI, _EBO],
    [[0, 1], [0, 1], [0, { [_hH]: _xaa }], [() => exports.AccessControlPolicy$, { [_hP]: 1, [_xN]: _ACP }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xagfc }], [0, { [_hH]: _xagr }], [0, { [_hH]: _xagra }], [0, { [_hH]: _xagw }], [0, { [_hH]: _xagwa }], [0, { [_hH]: _xarp }], [0, { [_hQ]: _vI }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.PutObjectLegalHoldOutput$ = [
    3,
    n0,
    _POLHO,
    0,
    [_RC],
    [[0, { [_hH]: _xarc }]]
  ];
  exports.PutObjectLegalHoldRequest$ = [
    3,
    n0,
    _POLHR,
    0,
    [_B, _K, _LH, _RP, _VI, _CMD, _CA, _EBO],
    [[0, 1], [0, 1], [() => exports.ObjectLockLegalHold$, { [_hP]: 1, [_xN]: _LH }], [0, { [_hH]: _xarp }], [0, { [_hQ]: _vI }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.PutObjectLockConfigurationOutput$ = [
    3,
    n0,
    _POLCO,
    0,
    [_RC],
    [[0, { [_hH]: _xarc }]]
  ];
  exports.PutObjectLockConfigurationRequest$ = [
    3,
    n0,
    _POLCR,
    0,
    [_B, _OLC, _RP, _To, _CMD, _CA, _EBO],
    [[0, 1], [() => exports.ObjectLockConfiguration$, { [_hP]: 1, [_xN]: _OLC }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xabolt }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    1
  ];
  exports.PutObjectOutput$ = [
    3,
    n0,
    _POO,
    0,
    [_E, _ETa, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _CT, _SSE, _VI, _SSECA, _SSECKMD, _SSEKMSKI, _SSEKMSEC, _BKE, _Si, _RC],
    [[0, { [_hH]: _xae }], [0, { [_hH]: _ETa }], [0, { [_hH]: _xacc }], [0, { [_hH]: _xacc_ }], [0, { [_hH]: _xacc__ }], [0, { [_hH]: _xacs }], [0, { [_hH]: _xacs_ }], [0, { [_hH]: _xact }], [0, { [_hH]: _xasse }], [0, { [_hH]: _xavi }], [0, { [_hH]: _xasseca }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }], [1, { [_hH]: _xaos }], [0, { [_hH]: _xarc }]]
  ];
  exports.PutObjectRequest$ = [
    3,
    n0,
    _POR,
    0,
    [_B, _K, _ACL_, _Bo, _CC, _CDo, _CEo, _CL, _CLo, _CMD, _CTo, _CA, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _Ex, _IM, _INM, _GFC, _GR, _GRACP, _GWACP, _WOB, _M, _SSE, _SC, _WRL, _SSECA, _SSECK, _SSECKMD, _SSEKMSKI, _SSEKMSEC, _BKE, _RP, _Tag, _OLM, _OLRUD, _OLLHS, _EBO],
    [[0, 1], [0, 1], [0, { [_hH]: _xaa }], [() => StreamingBlob, 16], [0, { [_hH]: _CC_ }], [0, { [_hH]: _CD_ }], [0, { [_hH]: _CE_ }], [0, { [_hH]: _CL_ }], [1, { [_hH]: _CL__ }], [0, { [_hH]: _CM }], [0, { [_hH]: _CT_ }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xacc }], [0, { [_hH]: _xacc_ }], [0, { [_hH]: _xacc__ }], [0, { [_hH]: _xacs }], [0, { [_hH]: _xacs_ }], [4, { [_hH]: _Ex }], [0, { [_hH]: _IM_ }], [0, { [_hH]: _INM_ }], [0, { [_hH]: _xagfc }], [0, { [_hH]: _xagr }], [0, { [_hH]: _xagra }], [0, { [_hH]: _xagwa }], [1, { [_hH]: _xawob }], [128 | 0, { [_hPH]: _xam }], [0, { [_hH]: _xasse }], [0, { [_hH]: _xasc }], [0, { [_hH]: _xawrl }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xat }], [0, { [_hH]: _xaolm }], [5, { [_hH]: _xaolrud }], [0, { [_hH]: _xaollh }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.PutObjectRetentionOutput$ = [
    3,
    n0,
    _PORO,
    0,
    [_RC],
    [[0, { [_hH]: _xarc }]]
  ];
  exports.PutObjectRetentionRequest$ = [
    3,
    n0,
    _PORR,
    0,
    [_B, _K, _Ret, _RP, _VI, _BGR, _CMD, _CA, _EBO],
    [[0, 1], [0, 1], [() => exports.ObjectLockRetention$, { [_hP]: 1, [_xN]: _Ret }], [0, { [_hH]: _xarp }], [0, { [_hQ]: _vI }], [2, { [_hH]: _xabgr }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.PutObjectTaggingOutput$ = [
    3,
    n0,
    _POTO,
    0,
    [_VI],
    [[0, { [_hH]: _xavi }]]
  ];
  exports.PutObjectTaggingRequest$ = [
    3,
    n0,
    _POTR,
    0,
    [_B, _K, _Tag, _VI, _CMD, _CA, _EBO, _RP],
    [[0, 1], [0, 1], [() => exports.Tagging$, { [_hP]: 1, [_xN]: _Tag }], [0, { [_hQ]: _vI }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xarp }]],
    3
  ];
  exports.PutPublicAccessBlockRequest$ = [
    3,
    n0,
    _PPABR,
    0,
    [_B, _PABC, _CMD, _CA, _EBO],
    [[0, 1], [() => exports.PublicAccessBlockConfiguration$, { [_hP]: 1, [_xN]: _PABC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.QueueConfiguration$ = [
    3,
    n0,
    _QCue,
    0,
    [_QA, _Ev, _I, _F],
    [[0, { [_xN]: _Qu }], [64 | 0, { [_xF]: 1, [_xN]: _Eve }], 0, [() => exports.NotificationConfigurationFilter$, 0]],
    2
  ];
  exports.RecordExpiration$ = [
    3,
    n0,
    _REe,
    0,
    [_E, _D],
    [0, 1],
    1
  ];
  exports.RecordsEvent$ = [
    3,
    n0,
    _REec,
    0,
    [_Payl],
    [[21, { [_eP]: 1 }]]
  ];
  exports.Redirect$ = [
    3,
    n0,
    _Red,
    0,
    [_HN, _HRC, _Pro, _RKPW, _RKW],
    [0, 0, 0, 0, 0]
  ];
  exports.RedirectAllRequestsTo$ = [
    3,
    n0,
    _RART,
    0,
    [_HN, _Pro],
    [0, 0],
    1
  ];
  exports.RenameObjectOutput$ = [
    3,
    n0,
    _ROO,
    0,
    [],
    []
  ];
  exports.RenameObjectRequest$ = [
    3,
    n0,
    _ROR,
    0,
    [_B, _K, _RSen, _DIM, _DINM, _DIMS, _DIUS, _SIM, _SINM, _SIMS, _SIUS, _CTl],
    [[0, 1], [0, 1], [0, { [_hH]: _xars_ }], [0, { [_hH]: _IM_ }], [0, { [_hH]: _INM_ }], [4, { [_hH]: _IMS_ }], [4, { [_hH]: _IUS_ }], [0, { [_hH]: _xarsim }], [0, { [_hH]: _xarsinm }], [6, { [_hH]: _xarsims }], [6, { [_hH]: _xarsius }], [0, { [_hH]: _xact_, [_iT]: 1 }]],
    3
  ];
  exports.ReplicaModifications$ = [
    3,
    n0,
    _RM,
    0,
    [_S],
    [0],
    1
  ];
  exports.ReplicationConfiguration$ = [
    3,
    n0,
    _RCe,
    0,
    [_Ro, _R],
    [0, [() => ReplicationRules, { [_xF]: 1, [_xN]: _Ru }]],
    2
  ];
  exports.ReplicationRule$ = [
    3,
    n0,
    _RRe,
    0,
    [_S, _Des, _ID, _Pri, _P, _F, _SSC, _EOR, _DMR],
    [0, () => exports.Destination$, 0, 1, 0, [() => exports.ReplicationRuleFilter$, 0], () => exports.SourceSelectionCriteria$, () => exports.ExistingObjectReplication$, () => exports.DeleteMarkerReplication$],
    2
  ];
  exports.ReplicationRuleAndOperator$ = [
    3,
    n0,
    _RRAO,
    0,
    [_P, _T],
    [0, [() => TagSet, { [_xF]: 1, [_xN]: _Ta }]]
  ];
  exports.ReplicationRuleFilter$ = [
    3,
    n0,
    _RRF,
    0,
    [_P, _Ta, _An],
    [0, () => exports.Tag$, [() => exports.ReplicationRuleAndOperator$, 0]]
  ];
  exports.ReplicationTime$ = [
    3,
    n0,
    _RT,
    0,
    [_S, _Tim],
    [0, () => exports.ReplicationTimeValue$],
    2
  ];
  exports.ReplicationTimeValue$ = [
    3,
    n0,
    _RTV,
    0,
    [_Mi],
    [1]
  ];
  exports.RequestPaymentConfiguration$ = [
    3,
    n0,
    _RPC,
    0,
    [_Pay],
    [0],
    1
  ];
  exports.RequestProgress$ = [
    3,
    n0,
    _RPe,
    0,
    [_Ena],
    [2]
  ];
  exports.RestoreObjectOutput$ = [
    3,
    n0,
    _ROOe,
    0,
    [_RC, _ROP],
    [[0, { [_hH]: _xarc }], [0, { [_hH]: _xarop }]]
  ];
  exports.RestoreObjectRequest$ = [
    3,
    n0,
    _RORe,
    0,
    [_B, _K, _VI, _RRes, _RP, _CA, _EBO],
    [[0, 1], [0, 1], [0, { [_hQ]: _vI }], [() => exports.RestoreRequest$, { [_hP]: 1, [_xN]: _RRes }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.RestoreRequest$ = [
    3,
    n0,
    _RRes,
    0,
    [_D, _GJP, _Ty, _Ti, _Desc, _SP, _OL],
    [1, () => exports.GlacierJobParameters$, 0, 0, 0, () => exports.SelectParameters$, [() => exports.OutputLocation$, 0]]
  ];
  exports.RestoreStatus$ = [
    3,
    n0,
    _RSe,
    0,
    [_IRIP, _RED],
    [2, 4]
  ];
  exports.RoutingRule$ = [
    3,
    n0,
    _RRo,
    0,
    [_Red, _Co],
    [() => exports.Redirect$, () => exports.Condition$],
    1
  ];
  exports.S3KeyFilter$ = [
    3,
    n0,
    _SKF,
    0,
    [_FRi],
    [[() => FilterRuleList, { [_xF]: 1, [_xN]: _FR }]]
  ];
  exports.S3Location$ = [
    3,
    n0,
    _SL,
    0,
    [_BN, _P, _En, _CACL, _ACL, _Tag, _UM, _SC],
    [0, 0, [() => exports.Encryption$, 0], 0, [() => Grants, 0], [() => exports.Tagging$, 0], [() => UserMetadata, 0], 0],
    2
  ];
  exports.S3TablesDestination$ = [
    3,
    n0,
    _STD,
    0,
    [_TBA, _TNa],
    [0, 0],
    2
  ];
  exports.S3TablesDestinationResult$ = [
    3,
    n0,
    _STDR,
    0,
    [_TBA, _TNa, _TA, _TN],
    [0, 0, 0, 0],
    4
  ];
  exports.ScanRange$ = [
    3,
    n0,
    _SR,
    0,
    [_St, _End],
    [1, 1]
  ];
  exports.SelectObjectContentOutput$ = [
    3,
    n0,
    _SOCO,
    0,
    [_Payl],
    [[() => exports.SelectObjectContentEventStream$, 16]]
  ];
  exports.SelectObjectContentRequest$ = [
    3,
    n0,
    _SOCR,
    0,
    [_B, _K, _Exp, _ETx, _IS, _OSu, _SSECA, _SSECK, _SSECKMD, _RPe, _SR, _EBO],
    [[0, 1], [0, 1], 0, 0, () => exports.InputSerialization$, () => exports.OutputSerialization$, [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], () => exports.RequestProgress$, () => exports.ScanRange$, [0, { [_hH]: _xaebo }]],
    6
  ];
  exports.SelectParameters$ = [
    3,
    n0,
    _SP,
    0,
    [_IS, _ETx, _Exp, _OSu],
    [() => exports.InputSerialization$, 0, 0, () => exports.OutputSerialization$],
    4
  ];
  exports.ServerSideEncryptionByDefault$ = [
    3,
    n0,
    _SSEBD,
    0,
    [_SSEA, _KMSMKID],
    [0, [() => SSEKMSKeyId, 0]],
    1
  ];
  exports.ServerSideEncryptionConfiguration$ = [
    3,
    n0,
    _SSEC,
    0,
    [_R],
    [[() => ServerSideEncryptionRules, { [_xF]: 1, [_xN]: _Ru }]],
    1
  ];
  exports.ServerSideEncryptionRule$ = [
    3,
    n0,
    _SSER,
    0,
    [_ASSEBD, _BKE, _BET],
    [[() => exports.ServerSideEncryptionByDefault$, 0], 2, [() => exports.BlockedEncryptionTypes$, 0]]
  ];
  exports.SessionCredentials$ = [
    3,
    n0,
    _SCe,
    0,
    [_AKI, _SAK, _ST, _E],
    [[0, { [_xN]: _AKI }], [() => SessionCredentialValue, { [_xN]: _SAK }], [() => SessionCredentialValue, { [_xN]: _ST }], [4, { [_xN]: _E }]],
    4
  ];
  exports.SimplePrefix$ = [
    3,
    n0,
    _SPi,
    { [_xN]: _SPi },
    [],
    []
  ];
  exports.SourceSelectionCriteria$ = [
    3,
    n0,
    _SSC,
    0,
    [_SKEO, _RM],
    [() => exports.SseKmsEncryptedObjects$, () => exports.ReplicaModifications$]
  ];
  exports.SSEKMS$ = [
    3,
    n0,
    _SSEKMS,
    { [_xN]: _SK },
    [_KI],
    [[() => SSEKMSKeyId, 0]],
    1
  ];
  exports.SseKmsEncryptedObjects$ = [
    3,
    n0,
    _SKEO,
    0,
    [_S],
    [0],
    1
  ];
  exports.SSEKMSEncryption$ = [
    3,
    n0,
    _SSEKMSE,
    { [_xN]: _SK },
    [_KMSKA, _BKE],
    [[() => NonEmptyKmsKeyArnString, 0], 2],
    1
  ];
  exports.SSES3$ = [
    3,
    n0,
    _SSES,
    { [_xN]: _SS },
    [],
    []
  ];
  exports.Stats$ = [
    3,
    n0,
    _Sta,
    0,
    [_BS, _BP, _BRy],
    [1, 1, 1]
  ];
  exports.StatsEvent$ = [
    3,
    n0,
    _SE,
    0,
    [_Det],
    [[() => exports.Stats$, { [_eP]: 1 }]]
  ];
  exports.StorageClassAnalysis$ = [
    3,
    n0,
    _SCA,
    0,
    [_DE],
    [() => exports.StorageClassAnalysisDataExport$]
  ];
  exports.StorageClassAnalysisDataExport$ = [
    3,
    n0,
    _SCADE,
    0,
    [_OSV, _Des],
    [0, () => exports.AnalyticsExportDestination$],
    2
  ];
  exports.Tag$ = [
    3,
    n0,
    _Ta,
    0,
    [_K, _V],
    [0, 0],
    2
  ];
  exports.Tagging$ = [
    3,
    n0,
    _Tag,
    0,
    [_TS],
    [[() => TagSet, 0]],
    1
  ];
  exports.TargetGrant$ = [
    3,
    n0,
    _TGa,
    0,
    [_Gra, _Pe],
    [[() => exports.Grantee$, { [_xNm]: [_x, _hi] }], 0]
  ];
  exports.TargetObjectKeyFormat$ = [
    3,
    n0,
    _TOKF,
    0,
    [_SPi, _PP],
    [[() => exports.SimplePrefix$, { [_xN]: _SPi }], [() => exports.PartitionedPrefix$, { [_xN]: _PP }]]
  ];
  exports.Tiering$ = [
    3,
    n0,
    _Tier,
    0,
    [_D, _AT],
    [1, 0],
    2
  ];
  exports.TopicConfiguration$ = [
    3,
    n0,
    _TCop,
    0,
    [_TAo, _Ev, _I, _F],
    [[0, { [_xN]: _Top }], [64 | 0, { [_xF]: 1, [_xN]: _Eve }], 0, [() => exports.NotificationConfigurationFilter$, 0]],
    2
  ];
  exports.Transition$ = [
    3,
    n0,
    _Tra,
    0,
    [_Da, _D, _SC],
    [5, 1, 0]
  ];
  exports.UpdateBucketMetadataInventoryTableConfigurationRequest$ = [
    3,
    n0,
    _UBMITCR,
    0,
    [_B, _ITCn, _CMD, _CA, _EBO],
    [[0, 1], [() => exports.InventoryTableConfigurationUpdates$, { [_hP]: 1, [_xN]: _ITCn }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.UpdateBucketMetadataJournalTableConfigurationRequest$ = [
    3,
    n0,
    _UBMJTCR,
    0,
    [_B, _JTC, _CMD, _CA, _EBO],
    [[0, 1], [() => exports.JournalTableConfigurationUpdates$, { [_hP]: 1, [_xN]: _JTC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
    2
  ];
  exports.UpdateObjectEncryptionRequest$ = [
    3,
    n0,
    _UOER,
    0,
    [_B, _K, _OE, _VI, _RP, _EBO, _CMD, _CA],
    [[0, 1], [0, 1], [() => exports.ObjectEncryption$, 16], [0, { [_hQ]: _vI }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }]],
    3
  ];
  exports.UpdateObjectEncryptionResponse$ = [
    3,
    n0,
    _UOERp,
    0,
    [_RC],
    [[0, { [_hH]: _xarc }]]
  ];
  exports.UploadPartCopyOutput$ = [
    3,
    n0,
    _UPCO,
    0,
    [_CSVI, _CPR, _SSE, _SSECA, _SSECKMD, _SSEKMSKI, _BKE, _RC],
    [[0, { [_hH]: _xacsvi }], [() => exports.CopyPartResult$, 16], [0, { [_hH]: _xasse }], [0, { [_hH]: _xasseca }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xarc }]]
  ];
  exports.UploadPartCopyRequest$ = [
    3,
    n0,
    _UPCR,
    0,
    [_B, _CS, _K, _PN, _UI, _CSIM, _CSIMS, _CSINM, _CSIUS, _CSRo, _SSECA, _SSECK, _SSECKMD, _CSSSECA, _CSSSECK, _CSSSECKMD, _RP, _EBO, _ESBO],
    [[0, 1], [0, { [_hH]: _xacs__ }], [0, 1], [1, { [_hQ]: _pN }], [0, { [_hQ]: _uI }], [0, { [_hH]: _xacsim }], [4, { [_hH]: _xacsims }], [0, { [_hH]: _xacsinm }], [4, { [_hH]: _xacsius }], [0, { [_hH]: _xacsr }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [0, { [_hH]: _xacssseca }], [() => CopySourceSSECustomerKey, { [_hH]: _xacssseck }], [0, { [_hH]: _xacssseckM }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xasebo }]],
    5
  ];
  exports.UploadPartOutput$ = [
    3,
    n0,
    _UPO,
    0,
    [_SSE, _ETa, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _SSECA, _SSECKMD, _SSEKMSKI, _BKE, _RC],
    [[0, { [_hH]: _xasse }], [0, { [_hH]: _ETa }], [0, { [_hH]: _xacc }], [0, { [_hH]: _xacc_ }], [0, { [_hH]: _xacc__ }], [0, { [_hH]: _xacs }], [0, { [_hH]: _xacs_ }], [0, { [_hH]: _xasseca }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xarc }]]
  ];
  exports.UploadPartRequest$ = [
    3,
    n0,
    _UPR,
    0,
    [_B, _K, _PN, _UI, _Bo, _CLo, _CMD, _CA, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _SSECA, _SSECK, _SSECKMD, _RP, _EBO],
    [[0, 1], [0, 1], [1, { [_hQ]: _pN }], [0, { [_hQ]: _uI }], [() => StreamingBlob, 16], [1, { [_hH]: _CL__ }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xacc }], [0, { [_hH]: _xacc_ }], [0, { [_hH]: _xacc__ }], [0, { [_hH]: _xacs }], [0, { [_hH]: _xacs_ }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }]],
    4
  ];
  exports.VersioningConfiguration$ = [
    3,
    n0,
    _VC,
    0,
    [_MFAD, _S],
    [[0, { [_xN]: _MDf }], 0]
  ];
  exports.WebsiteConfiguration$ = [
    3,
    n0,
    _WC,
    0,
    [_EDr, _IDn, _RART, _RR],
    [() => exports.ErrorDocument$, () => exports.IndexDocument$, () => exports.RedirectAllRequestsTo$, [() => RoutingRules, 0]]
  ];
  exports.WriteGetObjectResponseRequest$ = [
    3,
    n0,
    _WGORR,
    0,
    [_RReq, _RTe, _Bo, _SCt, _ECr, _EM, _AR, _CC, _CDo, _CEo, _CL, _CLo, _CR, _CTo, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _DM, _ETa, _Ex, _E, _LM, _MM, _M, _OLM, _OLLHS, _OLRUD, _PC, _RS, _RC, _Re, _SSE, _SSECA, _SSEKMSKI, _SSECKMD, _SC, _TC, _VI, _BKE],
    [[0, { [_hL]: 1, [_hH]: _xarr }], [0, { [_hH]: _xart }], [() => StreamingBlob, 16], [1, { [_hH]: _xafs }], [0, { [_hH]: _xafec }], [0, { [_hH]: _xafem }], [0, { [_hH]: _xafhar }], [0, { [_hH]: _xafhCC }], [0, { [_hH]: _xafhCD }], [0, { [_hH]: _xafhCE }], [0, { [_hH]: _xafhCL }], [1, { [_hH]: _CL__ }], [0, { [_hH]: _xafhCR }], [0, { [_hH]: _xafhCT }], [0, { [_hH]: _xafhxacc }], [0, { [_hH]: _xafhxacc_ }], [0, { [_hH]: _xafhxacc__ }], [0, { [_hH]: _xafhxacs }], [0, { [_hH]: _xafhxacs_ }], [2, { [_hH]: _xafhxadm }], [0, { [_hH]: _xafhE }], [4, { [_hH]: _xafhE_ }], [0, { [_hH]: _xafhxae }], [4, { [_hH]: _xafhLM }], [1, { [_hH]: _xafhxamm }], [128 | 0, { [_hPH]: _xam }], [0, { [_hH]: _xafhxaolm }], [0, { [_hH]: _xafhxaollh }], [5, { [_hH]: _xafhxaolrud }], [1, { [_hH]: _xafhxampc }], [0, { [_hH]: _xafhxars }], [0, { [_hH]: _xafhxarc }], [0, { [_hH]: _xafhxar }], [0, { [_hH]: _xafhxasse }], [0, { [_hH]: _xafhxasseca }], [() => SSEKMSKeyId, { [_hH]: _xafhxasseakki }], [0, { [_hH]: _xafhxasseckM }], [0, { [_hH]: _xafhxasc }], [1, { [_hH]: _xafhxatc }], [0, { [_hH]: _xafhxavi }], [2, { [_hH]: _xafhxassebke }]],
    2
  ];
  var __Unit = "unit";
  var AllowedHeaders = 64 | 0;
  var AllowedMethods = 64 | 0;
  var AllowedOrigins = 64 | 0;
  var AnalyticsConfigurationList = [
    1,
    n0,
    _ACLn,
    0,
    [
      () => exports.AnalyticsConfiguration$,
      0
    ]
  ];
  var Buckets = [
    1,
    n0,
    _Bu,
    0,
    [
      () => exports.Bucket$,
      { [_xN]: _B }
    ]
  ];
  var ChecksumAlgorithmList = 64 | 0;
  var CommonPrefixList = [
    1,
    n0,
    _CPL,
    0,
    () => exports.CommonPrefix$
  ];
  var CompletedPartList = [
    1,
    n0,
    _CPLo,
    0,
    () => exports.CompletedPart$
  ];
  var CORSRules = [
    1,
    n0,
    _CORSR,
    0,
    [
      () => exports.CORSRule$,
      0
    ]
  ];
  var DeletedObjects = [
    1,
    n0,
    _DOe,
    0,
    () => exports.DeletedObject$
  ];
  var DeleteMarkers = [
    1,
    n0,
    _DMe,
    0,
    () => exports.DeleteMarkerEntry$
  ];
  var EncryptionTypeList = [
    1,
    n0,
    _ETL,
    0,
    [
      0,
      { [_xN]: _ET }
    ]
  ];
  var Errors = [
    1,
    n0,
    _Er,
    0,
    () => exports._Error$
  ];
  var EventList = 64 | 0;
  var ExposeHeaders = 64 | 0;
  var FilterRuleList = [
    1,
    n0,
    _FRL,
    0,
    () => exports.FilterRule$
  ];
  var Grants = [
    1,
    n0,
    _G,
    0,
    [
      () => exports.Grant$,
      { [_xN]: _Gr }
    ]
  ];
  var IntelligentTieringConfigurationList = [
    1,
    n0,
    _ITCL,
    0,
    [
      () => exports.IntelligentTieringConfiguration$,
      0
    ]
  ];
  var InventoryConfigurationList = [
    1,
    n0,
    _ICL,
    0,
    [
      () => exports.InventoryConfiguration$,
      0
    ]
  ];
  var InventoryOptionalFields = [
    1,
    n0,
    _IOF,
    0,
    [
      0,
      { [_xN]: _Fi }
    ]
  ];
  var LambdaFunctionConfigurationList = [
    1,
    n0,
    _LFCL,
    0,
    [
      () => exports.LambdaFunctionConfiguration$,
      0
    ]
  ];
  var LifecycleRules = [
    1,
    n0,
    _LRi,
    0,
    [
      () => exports.LifecycleRule$,
      0
    ]
  ];
  var MetricsConfigurationList = [
    1,
    n0,
    _MCL,
    0,
    [
      () => exports.MetricsConfiguration$,
      0
    ]
  ];
  var MultipartUploadList = [
    1,
    n0,
    _MUL,
    0,
    () => exports.MultipartUpload$
  ];
  var NoncurrentVersionTransitionList = [
    1,
    n0,
    _NVTL,
    0,
    () => exports.NoncurrentVersionTransition$
  ];
  var ObjectAttributesList = 64 | 0;
  var ObjectIdentifierList = [
    1,
    n0,
    _OIL,
    0,
    () => exports.ObjectIdentifier$
  ];
  var ObjectList = [
    1,
    n0,
    _OLb,
    0,
    [
      () => exports._Object$,
      0
    ]
  ];
  var ObjectVersionList = [
    1,
    n0,
    _OVL,
    0,
    [
      () => exports.ObjectVersion$,
      0
    ]
  ];
  var OptionalObjectAttributesList = 64 | 0;
  var OwnershipControlsRules = [
    1,
    n0,
    _OCRw,
    0,
    () => exports.OwnershipControlsRule$
  ];
  var Parts = [
    1,
    n0,
    _Pa,
    0,
    () => exports.Part$
  ];
  var PartsList = [
    1,
    n0,
    _PL,
    0,
    () => exports.ObjectPart$
  ];
  var QueueConfigurationList = [
    1,
    n0,
    _QCL,
    0,
    [
      () => exports.QueueConfiguration$,
      0
    ]
  ];
  var ReplicationRules = [
    1,
    n0,
    _RRep,
    0,
    [
      () => exports.ReplicationRule$,
      0
    ]
  ];
  var RoutingRules = [
    1,
    n0,
    _RR,
    0,
    [
      () => exports.RoutingRule$,
      { [_xN]: _RRo }
    ]
  ];
  var ServerSideEncryptionRules = [
    1,
    n0,
    _SSERe,
    0,
    [
      () => exports.ServerSideEncryptionRule$,
      0
    ]
  ];
  var TagSet = [
    1,
    n0,
    _TS,
    0,
    [
      () => exports.Tag$,
      { [_xN]: _Ta }
    ]
  ];
  var TargetGrants = [
    1,
    n0,
    _TG,
    0,
    [
      () => exports.TargetGrant$,
      { [_xN]: _Gr }
    ]
  ];
  var TieringList = [
    1,
    n0,
    _TL,
    0,
    () => exports.Tiering$
  ];
  var TopicConfigurationList = [
    1,
    n0,
    _TCL,
    0,
    [
      () => exports.TopicConfiguration$,
      0
    ]
  ];
  var TransitionList = [
    1,
    n0,
    _TLr,
    0,
    () => exports.Transition$
  ];
  var UserMetadata = [
    1,
    n0,
    _UM,
    0,
    [
      () => exports.MetadataEntry$,
      { [_xN]: _ME }
    ]
  ];
  var Metadata = 128 | 0;
  exports.AnalyticsFilter$ = [
    4,
    n0,
    _AF,
    0,
    [_P, _Ta, _An],
    [0, () => exports.Tag$, [() => exports.AnalyticsAndOperator$, 0]]
  ];
  exports.MetricsFilter$ = [
    4,
    n0,
    _MF,
    0,
    [_P, _Ta, _APAc, _An],
    [0, () => exports.Tag$, 0, [() => exports.MetricsAndOperator$, 0]]
  ];
  exports.ObjectEncryption$ = [
    4,
    n0,
    _OE,
    0,
    [_SSEKMS],
    [[() => exports.SSEKMSEncryption$, { [_xN]: _SK }]]
  ];
  exports.SelectObjectContentEventStream$ = [
    4,
    n0,
    _SOCES,
    { [_st]: 1 },
    [_Rec, _Sta, _Pr, _Cont, _End],
    [[() => exports.RecordsEvent$, 0], [() => exports.StatsEvent$, 0], [() => exports.ProgressEvent$, 0], () => exports.ContinuationEvent$, () => exports.EndEvent$]
  ];
  exports.AbortMultipartUpload$ = [
    9,
    n0,
    _AMU,
    { [_h]: ["DELETE", "/{Key+}?x-id=AbortMultipartUpload", 204] },
    () => exports.AbortMultipartUploadRequest$,
    () => exports.AbortMultipartUploadOutput$
  ];
  exports.CompleteMultipartUpload$ = [
    9,
    n0,
    _CMUo,
    { [_h]: ["POST", "/{Key+}", 200] },
    () => exports.CompleteMultipartUploadRequest$,
    () => exports.CompleteMultipartUploadOutput$
  ];
  exports.CopyObject$ = [
    9,
    n0,
    _CO,
    { [_h]: ["PUT", "/{Key+}?x-id=CopyObject", 200] },
    () => exports.CopyObjectRequest$,
    () => exports.CopyObjectOutput$
  ];
  exports.CreateBucket$ = [
    9,
    n0,
    _CB,
    { [_h]: ["PUT", "/", 200] },
    () => exports.CreateBucketRequest$,
    () => exports.CreateBucketOutput$
  ];
  exports.CreateBucketMetadataConfiguration$ = [
    9,
    n0,
    _CBMC,
    { [_hC]: "-", [_h]: ["POST", "/?metadataConfiguration", 200] },
    () => exports.CreateBucketMetadataConfigurationRequest$,
    () => __Unit
  ];
  exports.CreateBucketMetadataTableConfiguration$ = [
    9,
    n0,
    _CBMTC,
    { [_hC]: "-", [_h]: ["POST", "/?metadataTable", 200] },
    () => exports.CreateBucketMetadataTableConfigurationRequest$,
    () => __Unit
  ];
  exports.CreateMultipartUpload$ = [
    9,
    n0,
    _CMUr,
    { [_h]: ["POST", "/{Key+}?uploads", 200] },
    () => exports.CreateMultipartUploadRequest$,
    () => exports.CreateMultipartUploadOutput$
  ];
  exports.CreateSession$ = [
    9,
    n0,
    _CSr,
    { [_h]: ["GET", "/?session", 200] },
    () => exports.CreateSessionRequest$,
    () => exports.CreateSessionOutput$
  ];
  exports.DeleteBucket$ = [
    9,
    n0,
    _DB,
    { [_h]: ["DELETE", "/", 204] },
    () => exports.DeleteBucketRequest$,
    () => __Unit
  ];
  exports.DeleteBucketAnalyticsConfiguration$ = [
    9,
    n0,
    _DBAC,
    { [_h]: ["DELETE", "/?analytics", 204] },
    () => exports.DeleteBucketAnalyticsConfigurationRequest$,
    () => __Unit
  ];
  exports.DeleteBucketCors$ = [
    9,
    n0,
    _DBC,
    { [_h]: ["DELETE", "/?cors", 204] },
    () => exports.DeleteBucketCorsRequest$,
    () => __Unit
  ];
  exports.DeleteBucketEncryption$ = [
    9,
    n0,
    _DBE,
    { [_h]: ["DELETE", "/?encryption", 204] },
    () => exports.DeleteBucketEncryptionRequest$,
    () => __Unit
  ];
  exports.DeleteBucketIntelligentTieringConfiguration$ = [
    9,
    n0,
    _DBITC,
    { [_h]: ["DELETE", "/?intelligent-tiering", 204] },
    () => exports.DeleteBucketIntelligentTieringConfigurationRequest$,
    () => __Unit
  ];
  exports.DeleteBucketInventoryConfiguration$ = [
    9,
    n0,
    _DBIC,
    { [_h]: ["DELETE", "/?inventory", 204] },
    () => exports.DeleteBucketInventoryConfigurationRequest$,
    () => __Unit
  ];
  exports.DeleteBucketLifecycle$ = [
    9,
    n0,
    _DBL,
    { [_h]: ["DELETE", "/?lifecycle", 204] },
    () => exports.DeleteBucketLifecycleRequest$,
    () => __Unit
  ];
  exports.DeleteBucketMetadataConfiguration$ = [
    9,
    n0,
    _DBMC,
    { [_h]: ["DELETE", "/?metadataConfiguration", 204] },
    () => exports.DeleteBucketMetadataConfigurationRequest$,
    () => __Unit
  ];
  exports.DeleteBucketMetadataTableConfiguration$ = [
    9,
    n0,
    _DBMTC,
    { [_h]: ["DELETE", "/?metadataTable", 204] },
    () => exports.DeleteBucketMetadataTableConfigurationRequest$,
    () => __Unit
  ];
  exports.DeleteBucketMetricsConfiguration$ = [
    9,
    n0,
    _DBMCe,
    { [_h]: ["DELETE", "/?metrics", 204] },
    () => exports.DeleteBucketMetricsConfigurationRequest$,
    () => __Unit
  ];
  exports.DeleteBucketOwnershipControls$ = [
    9,
    n0,
    _DBOC,
    { [_h]: ["DELETE", "/?ownershipControls", 204] },
    () => exports.DeleteBucketOwnershipControlsRequest$,
    () => __Unit
  ];
  exports.DeleteBucketPolicy$ = [
    9,
    n0,
    _DBP,
    { [_h]: ["DELETE", "/?policy", 204] },
    () => exports.DeleteBucketPolicyRequest$,
    () => __Unit
  ];
  exports.DeleteBucketReplication$ = [
    9,
    n0,
    _DBRe,
    { [_h]: ["DELETE", "/?replication", 204] },
    () => exports.DeleteBucketReplicationRequest$,
    () => __Unit
  ];
  exports.DeleteBucketTagging$ = [
    9,
    n0,
    _DBT,
    { [_h]: ["DELETE", "/?tagging", 204] },
    () => exports.DeleteBucketTaggingRequest$,
    () => __Unit
  ];
  exports.DeleteBucketWebsite$ = [
    9,
    n0,
    _DBW,
    { [_h]: ["DELETE", "/?website", 204] },
    () => exports.DeleteBucketWebsiteRequest$,
    () => __Unit
  ];
  exports.DeleteObject$ = [
    9,
    n0,
    _DOel,
    { [_h]: ["DELETE", "/{Key+}?x-id=DeleteObject", 204] },
    () => exports.DeleteObjectRequest$,
    () => exports.DeleteObjectOutput$
  ];
  exports.DeleteObjects$ = [
    9,
    n0,
    _DOele,
    { [_hC]: "-", [_h]: ["POST", "/?delete", 200] },
    () => exports.DeleteObjectsRequest$,
    () => exports.DeleteObjectsOutput$
  ];
  exports.DeleteObjectTagging$ = [
    9,
    n0,
    _DOT,
    { [_h]: ["DELETE", "/{Key+}?tagging", 204] },
    () => exports.DeleteObjectTaggingRequest$,
    () => exports.DeleteObjectTaggingOutput$
  ];
  exports.DeletePublicAccessBlock$ = [
    9,
    n0,
    _DPAB,
    { [_h]: ["DELETE", "/?publicAccessBlock", 204] },
    () => exports.DeletePublicAccessBlockRequest$,
    () => __Unit
  ];
  exports.GetBucketAbac$ = [
    9,
    n0,
    _GBA,
    { [_h]: ["GET", "/?abac", 200] },
    () => exports.GetBucketAbacRequest$,
    () => exports.GetBucketAbacOutput$
  ];
  exports.GetBucketAccelerateConfiguration$ = [
    9,
    n0,
    _GBAC,
    { [_h]: ["GET", "/?accelerate", 200] },
    () => exports.GetBucketAccelerateConfigurationRequest$,
    () => exports.GetBucketAccelerateConfigurationOutput$
  ];
  exports.GetBucketAcl$ = [
    9,
    n0,
    _GBAe,
    { [_h]: ["GET", "/?acl", 200] },
    () => exports.GetBucketAclRequest$,
    () => exports.GetBucketAclOutput$
  ];
  exports.GetBucketAnalyticsConfiguration$ = [
    9,
    n0,
    _GBACe,
    { [_h]: ["GET", "/?analytics&x-id=GetBucketAnalyticsConfiguration", 200] },
    () => exports.GetBucketAnalyticsConfigurationRequest$,
    () => exports.GetBucketAnalyticsConfigurationOutput$
  ];
  exports.GetBucketCors$ = [
    9,
    n0,
    _GBC,
    { [_h]: ["GET", "/?cors", 200] },
    () => exports.GetBucketCorsRequest$,
    () => exports.GetBucketCorsOutput$
  ];
  exports.GetBucketEncryption$ = [
    9,
    n0,
    _GBE,
    { [_h]: ["GET", "/?encryption", 200] },
    () => exports.GetBucketEncryptionRequest$,
    () => exports.GetBucketEncryptionOutput$
  ];
  exports.GetBucketIntelligentTieringConfiguration$ = [
    9,
    n0,
    _GBITC,
    { [_h]: ["GET", "/?intelligent-tiering&x-id=GetBucketIntelligentTieringConfiguration", 200] },
    () => exports.GetBucketIntelligentTieringConfigurationRequest$,
    () => exports.GetBucketIntelligentTieringConfigurationOutput$
  ];
  exports.GetBucketInventoryConfiguration$ = [
    9,
    n0,
    _GBIC,
    { [_h]: ["GET", "/?inventory&x-id=GetBucketInventoryConfiguration", 200] },
    () => exports.GetBucketInventoryConfigurationRequest$,
    () => exports.GetBucketInventoryConfigurationOutput$
  ];
  exports.GetBucketLifecycleConfiguration$ = [
    9,
    n0,
    _GBLC,
    { [_h]: ["GET", "/?lifecycle", 200] },
    () => exports.GetBucketLifecycleConfigurationRequest$,
    () => exports.GetBucketLifecycleConfigurationOutput$
  ];
  exports.GetBucketLocation$ = [
    9,
    n0,
    _GBL,
    { [_h]: ["GET", "/?location", 200] },
    () => exports.GetBucketLocationRequest$,
    () => exports.GetBucketLocationOutput$
  ];
  exports.GetBucketLogging$ = [
    9,
    n0,
    _GBLe,
    { [_h]: ["GET", "/?logging", 200] },
    () => exports.GetBucketLoggingRequest$,
    () => exports.GetBucketLoggingOutput$
  ];
  exports.GetBucketMetadataConfiguration$ = [
    9,
    n0,
    _GBMC,
    { [_h]: ["GET", "/?metadataConfiguration", 200] },
    () => exports.GetBucketMetadataConfigurationRequest$,
    () => exports.GetBucketMetadataConfigurationOutput$
  ];
  exports.GetBucketMetadataTableConfiguration$ = [
    9,
    n0,
    _GBMTC,
    { [_h]: ["GET", "/?metadataTable", 200] },
    () => exports.GetBucketMetadataTableConfigurationRequest$,
    () => exports.GetBucketMetadataTableConfigurationOutput$
  ];
  exports.GetBucketMetricsConfiguration$ = [
    9,
    n0,
    _GBMCe,
    { [_h]: ["GET", "/?metrics&x-id=GetBucketMetricsConfiguration", 200] },
    () => exports.GetBucketMetricsConfigurationRequest$,
    () => exports.GetBucketMetricsConfigurationOutput$
  ];
  exports.GetBucketNotificationConfiguration$ = [
    9,
    n0,
    _GBNC,
    { [_h]: ["GET", "/?notification", 200] },
    () => exports.GetBucketNotificationConfigurationRequest$,
    () => exports.NotificationConfiguration$
  ];
  exports.GetBucketOwnershipControls$ = [
    9,
    n0,
    _GBOC,
    { [_h]: ["GET", "/?ownershipControls", 200] },
    () => exports.GetBucketOwnershipControlsRequest$,
    () => exports.GetBucketOwnershipControlsOutput$
  ];
  exports.GetBucketPolicy$ = [
    9,
    n0,
    _GBP,
    { [_h]: ["GET", "/?policy", 200] },
    () => exports.GetBucketPolicyRequest$,
    () => exports.GetBucketPolicyOutput$
  ];
  exports.GetBucketPolicyStatus$ = [
    9,
    n0,
    _GBPS,
    { [_h]: ["GET", "/?policyStatus", 200] },
    () => exports.GetBucketPolicyStatusRequest$,
    () => exports.GetBucketPolicyStatusOutput$
  ];
  exports.GetBucketReplication$ = [
    9,
    n0,
    _GBR,
    { [_h]: ["GET", "/?replication", 200] },
    () => exports.GetBucketReplicationRequest$,
    () => exports.GetBucketReplicationOutput$
  ];
  exports.GetBucketRequestPayment$ = [
    9,
    n0,
    _GBRP,
    { [_h]: ["GET", "/?requestPayment", 200] },
    () => exports.GetBucketRequestPaymentRequest$,
    () => exports.GetBucketRequestPaymentOutput$
  ];
  exports.GetBucketTagging$ = [
    9,
    n0,
    _GBT,
    { [_h]: ["GET", "/?tagging", 200] },
    () => exports.GetBucketTaggingRequest$,
    () => exports.GetBucketTaggingOutput$
  ];
  exports.GetBucketVersioning$ = [
    9,
    n0,
    _GBV,
    { [_h]: ["GET", "/?versioning", 200] },
    () => exports.GetBucketVersioningRequest$,
    () => exports.GetBucketVersioningOutput$
  ];
  exports.GetBucketWebsite$ = [
    9,
    n0,
    _GBW,
    { [_h]: ["GET", "/?website", 200] },
    () => exports.GetBucketWebsiteRequest$,
    () => exports.GetBucketWebsiteOutput$
  ];
  exports.GetObject$ = [
    9,
    n0,
    _GO,
    { [_hC]: "-", [_h]: ["GET", "/{Key+}?x-id=GetObject", 200] },
    () => exports.GetObjectRequest$,
    () => exports.GetObjectOutput$
  ];
  exports.GetObjectAcl$ = [
    9,
    n0,
    _GOA,
    { [_h]: ["GET", "/{Key+}?acl", 200] },
    () => exports.GetObjectAclRequest$,
    () => exports.GetObjectAclOutput$
  ];
  exports.GetObjectAttributes$ = [
    9,
    n0,
    _GOAe,
    { [_h]: ["GET", "/{Key+}?attributes", 200] },
    () => exports.GetObjectAttributesRequest$,
    () => exports.GetObjectAttributesOutput$
  ];
  exports.GetObjectLegalHold$ = [
    9,
    n0,
    _GOLH,
    { [_h]: ["GET", "/{Key+}?legal-hold", 200] },
    () => exports.GetObjectLegalHoldRequest$,
    () => exports.GetObjectLegalHoldOutput$
  ];
  exports.GetObjectLockConfiguration$ = [
    9,
    n0,
    _GOLC,
    { [_h]: ["GET", "/?object-lock", 200] },
    () => exports.GetObjectLockConfigurationRequest$,
    () => exports.GetObjectLockConfigurationOutput$
  ];
  exports.GetObjectRetention$ = [
    9,
    n0,
    _GORe,
    { [_h]: ["GET", "/{Key+}?retention", 200] },
    () => exports.GetObjectRetentionRequest$,
    () => exports.GetObjectRetentionOutput$
  ];
  exports.GetObjectTagging$ = [
    9,
    n0,
    _GOT,
    { [_h]: ["GET", "/{Key+}?tagging", 200] },
    () => exports.GetObjectTaggingRequest$,
    () => exports.GetObjectTaggingOutput$
  ];
  exports.GetObjectTorrent$ = [
    9,
    n0,
    _GOTe,
    { [_h]: ["GET", "/{Key+}?torrent", 200] },
    () => exports.GetObjectTorrentRequest$,
    () => exports.GetObjectTorrentOutput$
  ];
  exports.GetPublicAccessBlock$ = [
    9,
    n0,
    _GPAB,
    { [_h]: ["GET", "/?publicAccessBlock", 200] },
    () => exports.GetPublicAccessBlockRequest$,
    () => exports.GetPublicAccessBlockOutput$
  ];
  exports.HeadBucket$ = [
    9,
    n0,
    _HB,
    { [_h]: ["HEAD", "/", 200] },
    () => exports.HeadBucketRequest$,
    () => exports.HeadBucketOutput$
  ];
  exports.HeadObject$ = [
    9,
    n0,
    _HO,
    { [_h]: ["HEAD", "/{Key+}", 200] },
    () => exports.HeadObjectRequest$,
    () => exports.HeadObjectOutput$
  ];
  exports.ListBucketAnalyticsConfigurations$ = [
    9,
    n0,
    _LBAC,
    { [_h]: ["GET", "/?analytics&x-id=ListBucketAnalyticsConfigurations", 200] },
    () => exports.ListBucketAnalyticsConfigurationsRequest$,
    () => exports.ListBucketAnalyticsConfigurationsOutput$
  ];
  exports.ListBucketIntelligentTieringConfigurations$ = [
    9,
    n0,
    _LBITC,
    { [_h]: ["GET", "/?intelligent-tiering&x-id=ListBucketIntelligentTieringConfigurations", 200] },
    () => exports.ListBucketIntelligentTieringConfigurationsRequest$,
    () => exports.ListBucketIntelligentTieringConfigurationsOutput$
  ];
  exports.ListBucketInventoryConfigurations$ = [
    9,
    n0,
    _LBIC,
    { [_h]: ["GET", "/?inventory&x-id=ListBucketInventoryConfigurations", 200] },
    () => exports.ListBucketInventoryConfigurationsRequest$,
    () => exports.ListBucketInventoryConfigurationsOutput$
  ];
  exports.ListBucketMetricsConfigurations$ = [
    9,
    n0,
    _LBMC,
    { [_h]: ["GET", "/?metrics&x-id=ListBucketMetricsConfigurations", 200] },
    () => exports.ListBucketMetricsConfigurationsRequest$,
    () => exports.ListBucketMetricsConfigurationsOutput$
  ];
  exports.ListBuckets$ = [
    9,
    n0,
    _LB,
    { [_h]: ["GET", "/?x-id=ListBuckets", 200] },
    () => exports.ListBucketsRequest$,
    () => exports.ListBucketsOutput$
  ];
  exports.ListDirectoryBuckets$ = [
    9,
    n0,
    _LDB,
    { [_h]: ["GET", "/?x-id=ListDirectoryBuckets", 200] },
    () => exports.ListDirectoryBucketsRequest$,
    () => exports.ListDirectoryBucketsOutput$
  ];
  exports.ListMultipartUploads$ = [
    9,
    n0,
    _LMU,
    { [_h]: ["GET", "/?uploads", 200] },
    () => exports.ListMultipartUploadsRequest$,
    () => exports.ListMultipartUploadsOutput$
  ];
  exports.ListObjects$ = [
    9,
    n0,
    _LO,
    { [_h]: ["GET", "/", 200] },
    () => exports.ListObjectsRequest$,
    () => exports.ListObjectsOutput$
  ];
  exports.ListObjectsV2$ = [
    9,
    n0,
    _LOV,
    { [_h]: ["GET", "/?list-type=2", 200] },
    () => exports.ListObjectsV2Request$,
    () => exports.ListObjectsV2Output$
  ];
  exports.ListObjectVersions$ = [
    9,
    n0,
    _LOVi,
    { [_h]: ["GET", "/?versions", 200] },
    () => exports.ListObjectVersionsRequest$,
    () => exports.ListObjectVersionsOutput$
  ];
  exports.ListParts$ = [
    9,
    n0,
    _LP,
    { [_h]: ["GET", "/{Key+}?x-id=ListParts", 200] },
    () => exports.ListPartsRequest$,
    () => exports.ListPartsOutput$
  ];
  exports.PutBucketAbac$ = [
    9,
    n0,
    _PBA,
    { [_hC]: "-", [_h]: ["PUT", "/?abac", 200] },
    () => exports.PutBucketAbacRequest$,
    () => __Unit
  ];
  exports.PutBucketAccelerateConfiguration$ = [
    9,
    n0,
    _PBAC,
    { [_hC]: "-", [_h]: ["PUT", "/?accelerate", 200] },
    () => exports.PutBucketAccelerateConfigurationRequest$,
    () => __Unit
  ];
  exports.PutBucketAcl$ = [
    9,
    n0,
    _PBAu,
    { [_hC]: "-", [_h]: ["PUT", "/?acl", 200] },
    () => exports.PutBucketAclRequest$,
    () => __Unit
  ];
  exports.PutBucketAnalyticsConfiguration$ = [
    9,
    n0,
    _PBACu,
    { [_h]: ["PUT", "/?analytics", 200] },
    () => exports.PutBucketAnalyticsConfigurationRequest$,
    () => __Unit
  ];
  exports.PutBucketCors$ = [
    9,
    n0,
    _PBC,
    { [_hC]: "-", [_h]: ["PUT", "/?cors", 200] },
    () => exports.PutBucketCorsRequest$,
    () => __Unit
  ];
  exports.PutBucketEncryption$ = [
    9,
    n0,
    _PBE,
    { [_hC]: "-", [_h]: ["PUT", "/?encryption", 200] },
    () => exports.PutBucketEncryptionRequest$,
    () => __Unit
  ];
  exports.PutBucketIntelligentTieringConfiguration$ = [
    9,
    n0,
    _PBITC,
    { [_h]: ["PUT", "/?intelligent-tiering", 200] },
    () => exports.PutBucketIntelligentTieringConfigurationRequest$,
    () => __Unit
  ];
  exports.PutBucketInventoryConfiguration$ = [
    9,
    n0,
    _PBIC,
    { [_h]: ["PUT", "/?inventory", 200] },
    () => exports.PutBucketInventoryConfigurationRequest$,
    () => __Unit
  ];
  exports.PutBucketLifecycleConfiguration$ = [
    9,
    n0,
    _PBLC,
    { [_hC]: "-", [_h]: ["PUT", "/?lifecycle", 200] },
    () => exports.PutBucketLifecycleConfigurationRequest$,
    () => exports.PutBucketLifecycleConfigurationOutput$
  ];
  exports.PutBucketLogging$ = [
    9,
    n0,
    _PBL,
    { [_hC]: "-", [_h]: ["PUT", "/?logging", 200] },
    () => exports.PutBucketLoggingRequest$,
    () => __Unit
  ];
  exports.PutBucketMetricsConfiguration$ = [
    9,
    n0,
    _PBMC,
    { [_h]: ["PUT", "/?metrics", 200] },
    () => exports.PutBucketMetricsConfigurationRequest$,
    () => __Unit
  ];
  exports.PutBucketNotificationConfiguration$ = [
    9,
    n0,
    _PBNC,
    { [_h]: ["PUT", "/?notification", 200] },
    () => exports.PutBucketNotificationConfigurationRequest$,
    () => __Unit
  ];
  exports.PutBucketOwnershipControls$ = [
    9,
    n0,
    _PBOC,
    { [_hC]: "-", [_h]: ["PUT", "/?ownershipControls", 200] },
    () => exports.PutBucketOwnershipControlsRequest$,
    () => __Unit
  ];
  exports.PutBucketPolicy$ = [
    9,
    n0,
    _PBP,
    { [_hC]: "-", [_h]: ["PUT", "/?policy", 200] },
    () => exports.PutBucketPolicyRequest$,
    () => __Unit
  ];
  exports.PutBucketReplication$ = [
    9,
    n0,
    _PBR,
    { [_hC]: "-", [_h]: ["PUT", "/?replication", 200] },
    () => exports.PutBucketReplicationRequest$,
    () => __Unit
  ];
  exports.PutBucketRequestPayment$ = [
    9,
    n0,
    _PBRP,
    { [_hC]: "-", [_h]: ["PUT", "/?requestPayment", 200] },
    () => exports.PutBucketRequestPaymentRequest$,
    () => __Unit
  ];
  exports.PutBucketTagging$ = [
    9,
    n0,
    _PBT,
    { [_hC]: "-", [_h]: ["PUT", "/?tagging", 200] },
    () => exports.PutBucketTaggingRequest$,
    () => __Unit
  ];
  exports.PutBucketVersioning$ = [
    9,
    n0,
    _PBV,
    { [_hC]: "-", [_h]: ["PUT", "/?versioning", 200] },
    () => exports.PutBucketVersioningRequest$,
    () => __Unit
  ];
  exports.PutBucketWebsite$ = [
    9,
    n0,
    _PBW,
    { [_hC]: "-", [_h]: ["PUT", "/?website", 200] },
    () => exports.PutBucketWebsiteRequest$,
    () => __Unit
  ];
  exports.PutObject$ = [
    9,
    n0,
    _PO,
    { [_hC]: "-", [_h]: ["PUT", "/{Key+}?x-id=PutObject", 200] },
    () => exports.PutObjectRequest$,
    () => exports.PutObjectOutput$
  ];
  exports.PutObjectAcl$ = [
    9,
    n0,
    _POA,
    { [_hC]: "-", [_h]: ["PUT", "/{Key+}?acl", 200] },
    () => exports.PutObjectAclRequest$,
    () => exports.PutObjectAclOutput$
  ];
  exports.PutObjectLegalHold$ = [
    9,
    n0,
    _POLH,
    { [_hC]: "-", [_h]: ["PUT", "/{Key+}?legal-hold", 200] },
    () => exports.PutObjectLegalHoldRequest$,
    () => exports.PutObjectLegalHoldOutput$
  ];
  exports.PutObjectLockConfiguration$ = [
    9,
    n0,
    _POLC,
    { [_hC]: "-", [_h]: ["PUT", "/?object-lock", 200] },
    () => exports.PutObjectLockConfigurationRequest$,
    () => exports.PutObjectLockConfigurationOutput$
  ];
  exports.PutObjectRetention$ = [
    9,
    n0,
    _PORu,
    { [_hC]: "-", [_h]: ["PUT", "/{Key+}?retention", 200] },
    () => exports.PutObjectRetentionRequest$,
    () => exports.PutObjectRetentionOutput$
  ];
  exports.PutObjectTagging$ = [
    9,
    n0,
    _POT,
    { [_hC]: "-", [_h]: ["PUT", "/{Key+}?tagging", 200] },
    () => exports.PutObjectTaggingRequest$,
    () => exports.PutObjectTaggingOutput$
  ];
  exports.PutPublicAccessBlock$ = [
    9,
    n0,
    _PPAB,
    { [_hC]: "-", [_h]: ["PUT", "/?publicAccessBlock", 200] },
    () => exports.PutPublicAccessBlockRequest$,
    () => __Unit
  ];
  exports.RenameObject$ = [
    9,
    n0,
    _RO,
    { [_h]: ["PUT", "/{Key+}?renameObject", 200] },
    () => exports.RenameObjectRequest$,
    () => exports.RenameObjectOutput$
  ];
  exports.RestoreObject$ = [
    9,
    n0,
    _ROe,
    { [_hC]: "-", [_h]: ["POST", "/{Key+}?restore", 200] },
    () => exports.RestoreObjectRequest$,
    () => exports.RestoreObjectOutput$
  ];
  exports.SelectObjectContent$ = [
    9,
    n0,
    _SOC,
    { [_h]: ["POST", "/{Key+}?select&select-type=2", 200] },
    () => exports.SelectObjectContentRequest$,
    () => exports.SelectObjectContentOutput$
  ];
  exports.UpdateBucketMetadataInventoryTableConfiguration$ = [
    9,
    n0,
    _UBMITC,
    { [_hC]: "-", [_h]: ["PUT", "/?metadataInventoryTable", 200] },
    () => exports.UpdateBucketMetadataInventoryTableConfigurationRequest$,
    () => __Unit
  ];
  exports.UpdateBucketMetadataJournalTableConfiguration$ = [
    9,
    n0,
    _UBMJTC,
    { [_hC]: "-", [_h]: ["PUT", "/?metadataJournalTable", 200] },
    () => exports.UpdateBucketMetadataJournalTableConfigurationRequest$,
    () => __Unit
  ];
  exports.UpdateObjectEncryption$ = [
    9,
    n0,
    _UOE,
    { [_hC]: "-", [_h]: ["PUT", "/{Key+}?encryption", 200] },
    () => exports.UpdateObjectEncryptionRequest$,
    () => exports.UpdateObjectEncryptionResponse$
  ];
  exports.UploadPart$ = [
    9,
    n0,
    _UP,
    { [_hC]: "-", [_h]: ["PUT", "/{Key+}?x-id=UploadPart", 200] },
    () => exports.UploadPartRequest$,
    () => exports.UploadPartOutput$
  ];
  exports.UploadPartCopy$ = [
    9,
    n0,
    _UPC,
    { [_h]: ["PUT", "/{Key+}?x-id=UploadPartCopy", 200] },
    () => exports.UploadPartCopyRequest$,
    () => exports.UploadPartCopyOutput$
  ];
  exports.WriteGetObjectResponse$ = [
    9,
    n0,
    _WGOR,
    { [_en]: ["{RequestRoute}."], [_h]: ["POST", "/WriteGetObjectResponse", 200] },
    () => exports.WriteGetObjectResponseRequest$,
    () => __Unit
  ];
});

// node_modules/@aws-sdk/client-s3/package.json
var require_package4 = __commonJS((exports, module) => {
  module.exports = {
    name: "@aws-sdk/client-s3",
    description: "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native",
    version: "3.997.0",
    scripts: {
      build: "concurrently 'yarn:build:types' 'yarn:build:es' && yarn build:cjs",
      "build:cjs": "node ../../scripts/compilation/inline client-s3",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": 'yarn g:turbo run build -F="$npm_package_name"',
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "premove dist-cjs dist-es dist-types tsconfig.cjs.tsbuildinfo tsconfig.es.tsbuildinfo tsconfig.types.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
      test: "yarn g:vitest run",
      "test:browser": "node ./test/browser-build/esbuild && yarn g:vitest run -c vitest.config.browser.mts",
      "test:browser:watch": "node ./test/browser-build/esbuild && yarn g:vitest watch -c vitest.config.browser.mts",
      "test:e2e": "yarn g:vitest run -c vitest.config.e2e.mts && yarn test:browser",
      "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.mts",
      "test:index": "tsc --noEmit ./test/index-types.ts && node ./test/index-objects.spec.mjs",
      "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
      "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts",
      "test:watch": "yarn g:vitest watch"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: false,
    dependencies: {
      "@aws-crypto/sha1-browser": "5.2.0",
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "^3.973.13",
      "@aws-sdk/credential-provider-node": "^3.972.12",
      "@aws-sdk/middleware-bucket-endpoint": "^3.972.4",
      "@aws-sdk/middleware-expect-continue": "^3.972.4",
      "@aws-sdk/middleware-flexible-checksums": "^3.972.11",
      "@aws-sdk/middleware-host-header": "^3.972.4",
      "@aws-sdk/middleware-location-constraint": "^3.972.4",
      "@aws-sdk/middleware-logger": "^3.972.4",
      "@aws-sdk/middleware-recursion-detection": "^3.972.4",
      "@aws-sdk/middleware-sdk-s3": "^3.972.13",
      "@aws-sdk/middleware-ssec": "^3.972.4",
      "@aws-sdk/middleware-user-agent": "^3.972.13",
      "@aws-sdk/region-config-resolver": "^3.972.4",
      "@aws-sdk/signature-v4-multi-region": "^3.996.1",
      "@aws-sdk/types": "^3.973.2",
      "@aws-sdk/util-endpoints": "^3.996.1",
      "@aws-sdk/util-user-agent-browser": "^3.972.4",
      "@aws-sdk/util-user-agent-node": "^3.972.12",
      "@smithy/config-resolver": "^4.4.7",
      "@smithy/core": "^3.23.4",
      "@smithy/eventstream-serde-browser": "^4.2.9",
      "@smithy/eventstream-serde-config-resolver": "^4.3.9",
      "@smithy/eventstream-serde-node": "^4.2.9",
      "@smithy/fetch-http-handler": "^5.3.10",
      "@smithy/hash-blob-browser": "^4.2.10",
      "@smithy/hash-node": "^4.2.9",
      "@smithy/hash-stream-node": "^4.2.9",
      "@smithy/invalid-dependency": "^4.2.9",
      "@smithy/md5-js": "^4.2.9",
      "@smithy/middleware-content-length": "^4.2.9",
      "@smithy/middleware-endpoint": "^4.4.18",
      "@smithy/middleware-retry": "^4.4.35",
      "@smithy/middleware-serde": "^4.2.10",
      "@smithy/middleware-stack": "^4.2.9",
      "@smithy/node-config-provider": "^4.3.9",
      "@smithy/node-http-handler": "^4.4.11",
      "@smithy/protocol-http": "^5.3.9",
      "@smithy/smithy-client": "^4.11.7",
      "@smithy/types": "^4.12.1",
      "@smithy/url-parser": "^4.2.9",
      "@smithy/util-base64": "^4.3.1",
      "@smithy/util-body-length-browser": "^4.2.1",
      "@smithy/util-body-length-node": "^4.2.2",
      "@smithy/util-defaults-mode-browser": "^4.3.34",
      "@smithy/util-defaults-mode-node": "^4.2.37",
      "@smithy/util-endpoints": "^3.2.9",
      "@smithy/util-middleware": "^4.2.9",
      "@smithy/util-retry": "^4.2.9",
      "@smithy/util-stream": "^4.5.14",
      "@smithy/util-utf8": "^4.2.1",
      "@smithy/util-waiter": "^4.2.9",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@aws-sdk/signature-v4-crt": "3.997.0",
      "@tsconfig/node20": "20.1.8",
      "@types/node": "^20.14.8",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      premove: "4.0.0",
      typescript: "~5.8.3"
    },
    engines: {
      node: ">=20.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": [
          "dist-types/ts3.4/*"
        ]
      }
    },
    files: [
      "dist-*/**"
    ],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-s3"
    }
  };
});

// node_modules/@aws-sdk/credential-provider-env/dist-cjs/index.js
var require_dist_cjs51 = __commonJS((exports) => {
  var client3 = require_client2();
  var propertyProvider = require_dist_cjs18();
  var ENV_KEY = "AWS_ACCESS_KEY_ID";
  var ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
  var ENV_SESSION = "AWS_SESSION_TOKEN";
  var ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
  var ENV_CREDENTIAL_SCOPE = "AWS_CREDENTIAL_SCOPE";
  var ENV_ACCOUNT_ID = "AWS_ACCOUNT_ID";
  var fromEnv = (init) => async () => {
    init?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
    const accessKeyId = process.env[ENV_KEY];
    const secretAccessKey = process.env[ENV_SECRET];
    const sessionToken = process.env[ENV_SESSION];
    const expiry = process.env[ENV_EXPIRATION];
    const credentialScope = process.env[ENV_CREDENTIAL_SCOPE];
    const accountId = process.env[ENV_ACCOUNT_ID];
    if (accessKeyId && secretAccessKey) {
      const credentials = {
        accessKeyId,
        secretAccessKey,
        ...sessionToken && { sessionToken },
        ...expiry && { expiration: new Date(expiry) },
        ...credentialScope && { credentialScope },
        ...accountId && { accountId }
      };
      client3.setCredentialFeature(credentials, "CREDENTIALS_ENV_VARS", "g");
      return credentials;
    }
    throw new propertyProvider.CredentialsProviderError("Unable to find environment variable credentials.", { logger: init?.logger });
  };
  exports.ENV_ACCOUNT_ID = ENV_ACCOUNT_ID;
  exports.ENV_CREDENTIAL_SCOPE = ENV_CREDENTIAL_SCOPE;
  exports.ENV_EXPIRATION = ENV_EXPIRATION;
  exports.ENV_KEY = ENV_KEY;
  exports.ENV_SECRET = ENV_SECRET;
  exports.ENV_SESSION = ENV_SESSION;
  exports.fromEnv = fromEnv;
});

// node_modules/@smithy/credential-provider-imds/dist-cjs/index.js
var require_dist_cjs52 = __commonJS((exports) => {
  var propertyProvider = require_dist_cjs18();
  var url = __require("url");
  var buffer = __require("buffer");
  var http = __require("http");
  var nodeConfigProvider = require_dist_cjs45();
  var urlParser = require_dist_cjs38();
  function httpRequest(options) {
    return new Promise((resolve, reject) => {
      const req = http.request({
        method: "GET",
        ...options,
        hostname: options.hostname?.replace(/^\[(.+)\]$/, "$1")
      });
      req.on("error", (err) => {
        reject(Object.assign(new propertyProvider.ProviderError("Unable to connect to instance metadata service"), err));
        req.destroy();
      });
      req.on("timeout", () => {
        reject(new propertyProvider.ProviderError("TimeoutError from instance metadata service"));
        req.destroy();
      });
      req.on("response", (res) => {
        const { statusCode = 400 } = res;
        if (statusCode < 200 || 300 <= statusCode) {
          reject(Object.assign(new propertyProvider.ProviderError("Error response received from instance metadata service"), { statusCode }));
          req.destroy();
        }
        const chunks = [];
        res.on("data", (chunk) => {
          chunks.push(chunk);
        });
        res.on("end", () => {
          resolve(buffer.Buffer.concat(chunks));
          req.destroy();
        });
      });
      req.end();
    });
  }
  var isImdsCredentials = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.AccessKeyId === "string" && typeof arg.SecretAccessKey === "string" && typeof arg.Token === "string" && typeof arg.Expiration === "string";
  var fromImdsCredentials = (creds) => ({
    accessKeyId: creds.AccessKeyId,
    secretAccessKey: creds.SecretAccessKey,
    sessionToken: creds.Token,
    expiration: new Date(creds.Expiration),
    ...creds.AccountId && { accountId: creds.AccountId }
  });
  var DEFAULT_TIMEOUT = 1000;
  var DEFAULT_MAX_RETRIES2 = 0;
  var providerConfigFromInit = ({ maxRetries = DEFAULT_MAX_RETRIES2, timeout = DEFAULT_TIMEOUT }) => ({ maxRetries, timeout });
  var retry = (toRetry, maxRetries) => {
    let promise = toRetry();
    for (let i2 = 0;i2 < maxRetries; i2++) {
      promise = promise.catch(toRetry);
    }
    return promise;
  };
  var ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
  var ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
  var ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
  var fromContainerMetadata = (init = {}) => {
    const { timeout, maxRetries } = providerConfigFromInit(init);
    return () => retry(async () => {
      const requestOptions = await getCmdsUri({ logger: init.logger });
      const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
      if (!isImdsCredentials(credsResponse)) {
        throw new propertyProvider.CredentialsProviderError("Invalid response received from instance metadata service.", {
          logger: init.logger
        });
      }
      return fromImdsCredentials(credsResponse);
    }, maxRetries);
  };
  var requestFromEcsImds = async (timeout, options) => {
    if (process.env[ENV_CMDS_AUTH_TOKEN]) {
      options.headers = {
        ...options.headers,
        Authorization: process.env[ENV_CMDS_AUTH_TOKEN]
      };
    }
    const buffer2 = await httpRequest({
      ...options,
      timeout
    });
    return buffer2.toString();
  };
  var CMDS_IP = "169.254.170.2";
  var GREENGRASS_HOSTS = {
    localhost: true,
    "127.0.0.1": true
  };
  var GREENGRASS_PROTOCOLS = {
    "http:": true,
    "https:": true
  };
  var getCmdsUri = async ({ logger }) => {
    if (process.env[ENV_CMDS_RELATIVE_URI]) {
      return {
        hostname: CMDS_IP,
        path: process.env[ENV_CMDS_RELATIVE_URI]
      };
    }
    if (process.env[ENV_CMDS_FULL_URI]) {
      const parsed = url.parse(process.env[ENV_CMDS_FULL_URI]);
      if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
        throw new propertyProvider.CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, {
          tryNextLink: false,
          logger
        });
      }
      if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
        throw new propertyProvider.CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, {
          tryNextLink: false,
          logger
        });
      }
      return {
        ...parsed,
        port: parsed.port ? parseInt(parsed.port, 10) : undefined
      };
    }
    throw new propertyProvider.CredentialsProviderError("The container metadata credential provider cannot be used unless" + ` the ${ENV_CMDS_RELATIVE_URI} or ${ENV_CMDS_FULL_URI} environment` + " variable is set", {
      tryNextLink: false,
      logger
    });
  };

  class InstanceMetadataV1FallbackError extends propertyProvider.CredentialsProviderError {
    tryNextLink;
    name = "InstanceMetadataV1FallbackError";
    constructor(message3, tryNextLink = true) {
      super(message3, tryNextLink);
      this.tryNextLink = tryNextLink;
      Object.setPrototypeOf(this, InstanceMetadataV1FallbackError.prototype);
    }
  }
  exports.Endpoint = undefined;
  (function(Endpoint) {
    Endpoint["IPv4"] = "http://169.254.169.254";
    Endpoint["IPv6"] = "http://[fd00:ec2::254]";
  })(exports.Endpoint || (exports.Endpoint = {}));
  var ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
  var CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
  var ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[ENV_ENDPOINT_NAME],
    configFileSelector: (profile) => profile[CONFIG_ENDPOINT_NAME],
    default: undefined
  };
  var EndpointMode;
  (function(EndpointMode2) {
    EndpointMode2["IPv4"] = "IPv4";
    EndpointMode2["IPv6"] = "IPv6";
  })(EndpointMode || (EndpointMode = {}));
  var ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
  var CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
  var ENDPOINT_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[ENV_ENDPOINT_MODE_NAME],
    configFileSelector: (profile) => profile[CONFIG_ENDPOINT_MODE_NAME],
    default: EndpointMode.IPv4
  };
  var getInstanceMetadataEndpoint = async () => urlParser.parseUrl(await getFromEndpointConfig() || await getFromEndpointModeConfig());
  var getFromEndpointConfig = async () => nodeConfigProvider.loadConfig(ENDPOINT_CONFIG_OPTIONS)();
  var getFromEndpointModeConfig = async () => {
    const endpointMode = await nodeConfigProvider.loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS)();
    switch (endpointMode) {
      case EndpointMode.IPv4:
        return exports.Endpoint.IPv4;
      case EndpointMode.IPv6:
        return exports.Endpoint.IPv6;
      default:
        throw new Error(`Unsupported endpoint mode: ${endpointMode}.` + ` Select from ${Object.values(EndpointMode)}`);
    }
  };
  var STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
  var STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
  var STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
  var getExtendedInstanceMetadataCredentials = (credentials, logger) => {
    const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS + Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
    const newExpiration = new Date(Date.now() + refreshInterval * 1000);
    logger.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these " + `credentials will be attempted after ${new Date(newExpiration)}.
For more information, please visit: ` + STATIC_STABILITY_DOC_URL);
    const originalExpiration = credentials.originalExpiration ?? credentials.expiration;
    return {
      ...credentials,
      ...originalExpiration ? { originalExpiration } : {},
      expiration: newExpiration
    };
  };
  var staticStabilityProvider = (provider, options = {}) => {
    const logger = options?.logger || console;
    let pastCredentials;
    return async () => {
      let credentials;
      try {
        credentials = await provider();
        if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
          credentials = getExtendedInstanceMetadataCredentials(credentials, logger);
        }
      } catch (e) {
        if (pastCredentials) {
          logger.warn("Credential renew failed: ", e);
          credentials = getExtendedInstanceMetadataCredentials(pastCredentials, logger);
        } else {
          throw e;
        }
      }
      pastCredentials = credentials;
      return credentials;
    };
  };
  var IMDS_PATH = "/latest/meta-data/iam/security-credentials/";
  var IMDS_TOKEN_PATH = "/latest/api/token";
  var AWS_EC2_METADATA_V1_DISABLED = "AWS_EC2_METADATA_V1_DISABLED";
  var PROFILE_AWS_EC2_METADATA_V1_DISABLED = "ec2_metadata_v1_disabled";
  var X_AWS_EC2_METADATA_TOKEN = "x-aws-ec2-metadata-token";
  var fromInstanceMetadata = (init = {}) => staticStabilityProvider(getInstanceMetadataProvider(init), { logger: init.logger });
  var getInstanceMetadataProvider = (init = {}) => {
    let disableFetchToken = false;
    const { logger, profile } = init;
    const { timeout, maxRetries } = providerConfigFromInit(init);
    const getCredentials = async (maxRetries2, options) => {
      const isImdsV1Fallback = disableFetchToken || options.headers?.[X_AWS_EC2_METADATA_TOKEN] == null;
      if (isImdsV1Fallback) {
        let fallbackBlockedFromProfile = false;
        let fallbackBlockedFromProcessEnv = false;
        const configValue = await nodeConfigProvider.loadConfig({
          environmentVariableSelector: (env) => {
            const envValue = env[AWS_EC2_METADATA_V1_DISABLED];
            fallbackBlockedFromProcessEnv = !!envValue && envValue !== "false";
            if (envValue === undefined) {
              throw new propertyProvider.CredentialsProviderError(`${AWS_EC2_METADATA_V1_DISABLED} not set in env, checking config file next.`, { logger: init.logger });
            }
            return fallbackBlockedFromProcessEnv;
          },
          configFileSelector: (profile2) => {
            const profileValue = profile2[PROFILE_AWS_EC2_METADATA_V1_DISABLED];
            fallbackBlockedFromProfile = !!profileValue && profileValue !== "false";
            return fallbackBlockedFromProfile;
          },
          default: false
        }, {
          profile
        })();
        if (init.ec2MetadataV1Disabled || configValue) {
          const causes = [];
          if (init.ec2MetadataV1Disabled)
            causes.push("credential provider initialization (runtime option ec2MetadataV1Disabled)");
          if (fallbackBlockedFromProfile)
            causes.push(`config file profile (${PROFILE_AWS_EC2_METADATA_V1_DISABLED})`);
          if (fallbackBlockedFromProcessEnv)
            causes.push(`process environment variable (${AWS_EC2_METADATA_V1_DISABLED})`);
          throw new InstanceMetadataV1FallbackError(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${causes.join(", ")}].`);
        }
      }
      const imdsProfile = (await retry(async () => {
        let profile2;
        try {
          profile2 = await getProfile(options);
        } catch (err) {
          if (err.statusCode === 401) {
            disableFetchToken = false;
          }
          throw err;
        }
        return profile2;
      }, maxRetries2)).trim();
      return retry(async () => {
        let creds;
        try {
          creds = await getCredentialsFromProfile(imdsProfile, options, init);
        } catch (err) {
          if (err.statusCode === 401) {
            disableFetchToken = false;
          }
          throw err;
        }
        return creds;
      }, maxRetries2);
    };
    return async () => {
      const endpoint = await getInstanceMetadataEndpoint();
      if (disableFetchToken) {
        logger?.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)");
        return getCredentials(maxRetries, { ...endpoint, timeout });
      } else {
        let token2;
        try {
          token2 = (await getMetadataToken({ ...endpoint, timeout })).toString();
        } catch (error) {
          if (error?.statusCode === 400) {
            throw Object.assign(error, {
              message: "EC2 Metadata token request returned error"
            });
          } else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
            disableFetchToken = true;
          }
          logger?.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)");
          return getCredentials(maxRetries, { ...endpoint, timeout });
        }
        return getCredentials(maxRetries, {
          ...endpoint,
          headers: {
            [X_AWS_EC2_METADATA_TOKEN]: token2
          },
          timeout
        });
      }
    };
  };
  var getMetadataToken = async (options) => httpRequest({
    ...options,
    path: IMDS_TOKEN_PATH,
    method: "PUT",
    headers: {
      "x-aws-ec2-metadata-token-ttl-seconds": "21600"
    }
  });
  var getProfile = async (options) => (await httpRequest({ ...options, path: IMDS_PATH })).toString();
  var getCredentialsFromProfile = async (profile, options, init) => {
    const credentialsResponse = JSON.parse((await httpRequest({
      ...options,
      path: IMDS_PATH + profile
    })).toString());
    if (!isImdsCredentials(credentialsResponse)) {
      throw new propertyProvider.CredentialsProviderError("Invalid response received from instance metadata service.", {
        logger: init.logger
      });
    }
    return fromImdsCredentials(credentialsResponse);
  };
  exports.DEFAULT_MAX_RETRIES = DEFAULT_MAX_RETRIES2;
  exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
  exports.ENV_CMDS_AUTH_TOKEN = ENV_CMDS_AUTH_TOKEN;
  exports.ENV_CMDS_FULL_URI = ENV_CMDS_FULL_URI;
  exports.ENV_CMDS_RELATIVE_URI = ENV_CMDS_RELATIVE_URI;
  exports.fromContainerMetadata = fromContainerMetadata;
  exports.fromInstanceMetadata = fromInstanceMetadata;
  exports.getInstanceMetadataEndpoint = getInstanceMetadataEndpoint;
  exports.httpRequest = httpRequest;
  exports.providerConfigFromInit = providerConfigFromInit;
});

// node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/checkUrl.js
var require_checkUrl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkUrl = undefined;
  var property_provider_1 = require_dist_cjs18();
  var ECS_CONTAINER_HOST = "169.254.170.2";
  var EKS_CONTAINER_HOST_IPv4 = "169.254.170.23";
  var EKS_CONTAINER_HOST_IPv6 = "[fd00:ec2::23]";
  var checkUrl = (url, logger) => {
    if (url.protocol === "https:") {
      return;
    }
    if (url.hostname === ECS_CONTAINER_HOST || url.hostname === EKS_CONTAINER_HOST_IPv4 || url.hostname === EKS_CONTAINER_HOST_IPv6) {
      return;
    }
    if (url.hostname.includes("[")) {
      if (url.hostname === "[::1]" || url.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") {
        return;
      }
    } else {
      if (url.hostname === "localhost") {
        return;
      }
      const ipComponents = url.hostname.split(".");
      const inRange = (component) => {
        const num = parseInt(component, 10);
        return 0 <= num && num <= 255;
      };
      if (ipComponents[0] === "127" && inRange(ipComponents[1]) && inRange(ipComponents[2]) && inRange(ipComponents[3]) && ipComponents.length === 4) {
        return;
      }
    }
    throw new property_provider_1.CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, { logger });
  };
  exports.checkUrl = checkUrl;
});

// node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/requestHelpers.js
var require_requestHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createGetRequest = createGetRequest;
  exports.getCredentials = getCredentials;
  var property_provider_1 = require_dist_cjs18();
  var protocol_http_1 = require_dist_cjs2();
  var smithy_client_1 = require_dist_cjs22();
  var util_stream_1 = require_dist_cjs15();
  function createGetRequest(url) {
    return new protocol_http_1.HttpRequest({
      protocol: url.protocol,
      hostname: url.hostname,
      port: Number(url.port),
      path: url.pathname,
      query: Array.from(url.searchParams.entries()).reduce((acc, [k, v]) => {
        acc[k] = v;
        return acc;
      }, {}),
      fragment: url.hash
    });
  }
  async function getCredentials(response, logger) {
    const stream3 = (0, util_stream_1.sdkStreamMixin)(response.body);
    const str = await stream3.transformToString();
    if (response.statusCode === 200) {
      const parsed = JSON.parse(str);
      if (typeof parsed.AccessKeyId !== "string" || typeof parsed.SecretAccessKey !== "string" || typeof parsed.Token !== "string" || typeof parsed.Expiration !== "string") {
        throw new property_provider_1.CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: " + "{ AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", { logger });
      }
      return {
        accessKeyId: parsed.AccessKeyId,
        secretAccessKey: parsed.SecretAccessKey,
        sessionToken: parsed.Token,
        expiration: (0, smithy_client_1.parseRfc3339DateTime)(parsed.Expiration)
      };
    }
    if (response.statusCode >= 400 && response.statusCode < 500) {
      let parsedBody = {};
      try {
        parsedBody = JSON.parse(str);
      } catch (e) {}
      throw Object.assign(new property_provider_1.CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger }), {
        Code: parsedBody.Code,
        Message: parsedBody.Message
      });
    }
    throw new property_provider_1.CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger });
  }
});

// node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/retry-wrapper.js
var require_retry_wrapper = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryWrapper = undefined;
  var retryWrapper = (toRetry, maxRetries, delayMs) => {
    return async () => {
      for (let i2 = 0;i2 < maxRetries; ++i2) {
        try {
          return await toRetry();
        } catch (e) {
          await new Promise((resolve) => setTimeout(resolve, delayMs));
        }
      }
      return await toRetry();
    };
  };
  exports.retryWrapper = retryWrapper;
});

// node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/fromHttp.js
var require_fromHttp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromHttp = undefined;
  var tslib_1 = require_tslib();
  var client_1 = require_client2();
  var node_http_handler_1 = require_dist_cjs12();
  var property_provider_1 = require_dist_cjs18();
  var promises_1 = tslib_1.__importDefault(__require("fs/promises"));
  var checkUrl_1 = require_checkUrl();
  var requestHelpers_1 = require_requestHelpers();
  var retry_wrapper_1 = require_retry_wrapper();
  var AWS_CONTAINER_CREDENTIALS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
  var DEFAULT_LINK_LOCAL_HOST = "http://169.254.170.2";
  var AWS_CONTAINER_CREDENTIALS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
  var AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE";
  var AWS_CONTAINER_AUTHORIZATION_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
  var fromHttp = (options = {}) => {
    options.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
    let host;
    const relative = options.awsContainerCredentialsRelativeUri ?? process.env[AWS_CONTAINER_CREDENTIALS_RELATIVE_URI];
    const full = options.awsContainerCredentialsFullUri ?? process.env[AWS_CONTAINER_CREDENTIALS_FULL_URI];
    const token2 = options.awsContainerAuthorizationToken ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN];
    const tokenFile = options.awsContainerAuthorizationTokenFile ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE];
    const warn = options.logger?.constructor?.name === "NoOpLogger" || !options.logger?.warn ? console.warn : options.logger.warn.bind(options.logger);
    if (relative && full) {
      warn("@aws-sdk/credential-provider-http: " + "you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri.");
      warn("awsContainerCredentialsFullUri will take precedence.");
    }
    if (token2 && tokenFile) {
      warn("@aws-sdk/credential-provider-http: " + "you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile.");
      warn("awsContainerAuthorizationToken will take precedence.");
    }
    if (full) {
      host = full;
    } else if (relative) {
      host = `${DEFAULT_LINK_LOCAL_HOST}${relative}`;
    } else {
      throw new property_provider_1.CredentialsProviderError(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`, { logger: options.logger });
    }
    const url = new URL(host);
    (0, checkUrl_1.checkUrl)(url, options.logger);
    const requestHandler = node_http_handler_1.NodeHttpHandler.create({
      requestTimeout: options.timeout ?? 1000,
      connectionTimeout: options.timeout ?? 1000
    });
    return (0, retry_wrapper_1.retryWrapper)(async () => {
      const request = (0, requestHelpers_1.createGetRequest)(url);
      if (token2) {
        request.headers.Authorization = token2;
      } else if (tokenFile) {
        request.headers.Authorization = (await promises_1.default.readFile(tokenFile)).toString();
      }
      try {
        const result = await requestHandler.handle(request);
        return (0, requestHelpers_1.getCredentials)(result.response).then((creds) => (0, client_1.setCredentialFeature)(creds, "CREDENTIALS_HTTP", "z"));
      } catch (e) {
        throw new property_provider_1.CredentialsProviderError(String(e), { logger: options.logger });
      }
    }, options.maxRetries ?? 3, options.timeout ?? 1000);
  };
  exports.fromHttp = fromHttp;
});

// node_modules/@aws-sdk/credential-provider-http/dist-cjs/index.js
var require_dist_cjs53 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromHttp = undefined;
  var fromHttp_1 = require_fromHttp();
  Object.defineProperty(exports, "fromHttp", { enumerable: true, get: function() {
    return fromHttp_1.fromHttp;
  } });
});

// node_modules/@aws-sdk/core/dist-cjs/submodules/httpAuthSchemes/index.js
var require_httpAuthSchemes = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs2();
  var core = require_dist_cjs17();
  var propertyProvider = require_dist_cjs18();
  var client3 = require_client2();
  var signatureV4 = require_dist_cjs19();
  var getDateHeader = (response) => protocolHttp.HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : undefined;
  var getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
  var isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 300000;
  var getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
    const clockTimeInMs = Date.parse(clockTime);
    if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
      return clockTimeInMs - Date.now();
    }
    return currentSystemClockOffset;
  };
  var throwSigningPropertyError = (name, property) => {
    if (!property) {
      throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
    }
    return property;
  };
  var validateSigningProperties = async (signingProperties) => {
    const context = throwSigningPropertyError("context", signingProperties.context);
    const config = throwSigningPropertyError("config", signingProperties.config);
    const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
    const signerFunction = throwSigningPropertyError("signer", config.signer);
    const signer = await signerFunction(authScheme);
    const signingRegion = signingProperties?.signingRegion;
    const signingRegionSet = signingProperties?.signingRegionSet;
    const signingName = signingProperties?.signingName;
    return {
      config,
      signer,
      signingRegion,
      signingRegionSet,
      signingName
    };
  };

  class AwsSdkSigV4Signer {
    async sign(httpRequest, identity, signingProperties) {
      if (!protocolHttp.HttpRequest.isInstance(httpRequest)) {
        throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
      }
      const validatedProps = await validateSigningProperties(signingProperties);
      const { config, signer } = validatedProps;
      let { signingRegion, signingName } = validatedProps;
      const handlerExecutionContext = signingProperties.context;
      if (handlerExecutionContext?.authSchemes?.length ?? 0 > 1) {
        const [first, second] = handlerExecutionContext.authSchemes;
        if (first?.name === "sigv4a" && second?.name === "sigv4") {
          signingRegion = second?.signingRegion ?? signingRegion;
          signingName = second?.signingName ?? signingName;
        }
      }
      const signedRequest = await signer.sign(httpRequest, {
        signingDate: getSkewCorrectedDate(config.systemClockOffset),
        signingRegion,
        signingService: signingName
      });
      return signedRequest;
    }
    errorHandler(signingProperties) {
      return (error) => {
        const serverTime = error.ServerTime ?? getDateHeader(error.$response);
        if (serverTime) {
          const config = throwSigningPropertyError("config", signingProperties.config);
          const initialSystemClockOffset = config.systemClockOffset;
          config.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config.systemClockOffset);
          const clockSkewCorrected = config.systemClockOffset !== initialSystemClockOffset;
          if (clockSkewCorrected && error.$metadata) {
            error.$metadata.clockSkewCorrected = true;
          }
        }
        throw error;
      };
    }
    successHandler(httpResponse, signingProperties) {
      const dateHeader = getDateHeader(httpResponse);
      if (dateHeader) {
        const config = throwSigningPropertyError("config", signingProperties.config);
        config.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config.systemClockOffset);
      }
    }
  }
  var AWSSDKSigV4Signer = AwsSdkSigV4Signer;

  class AwsSdkSigV4ASigner extends AwsSdkSigV4Signer {
    async sign(httpRequest, identity, signingProperties) {
      if (!protocolHttp.HttpRequest.isInstance(httpRequest)) {
        throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
      }
      const { config, signer, signingRegion, signingRegionSet, signingName } = await validateSigningProperties(signingProperties);
      const configResolvedSigningRegionSet = await config.sigv4aSigningRegionSet?.();
      const multiRegionOverride = (configResolvedSigningRegionSet ?? signingRegionSet ?? [signingRegion]).join(",");
      const signedRequest = await signer.sign(httpRequest, {
        signingDate: getSkewCorrectedDate(config.systemClockOffset),
        signingRegion: multiRegionOverride,
        signingService: signingName
      });
      return signedRequest;
    }
  }
  var getArrayForCommaSeparatedString = (str) => typeof str === "string" && str.length > 0 ? str.split(",").map((item) => item.trim()) : [];
  var getBearerTokenEnvKey = (signingName) => `AWS_BEARER_TOKEN_${signingName.replace(/[\s-]/g, "_").toUpperCase()}`;
  var NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY = "AWS_AUTH_SCHEME_PREFERENCE";
  var NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY = "auth_scheme_preference";
  var NODE_AUTH_SCHEME_PREFERENCE_OPTIONS = {
    environmentVariableSelector: (env, options) => {
      if (options?.signingName) {
        const bearerTokenKey = getBearerTokenEnvKey(options.signingName);
        if (bearerTokenKey in env)
          return ["httpBearerAuth"];
      }
      if (!(NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY in env))
        return;
      return getArrayForCommaSeparatedString(env[NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY]);
    },
    configFileSelector: (profile) => {
      if (!(NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY in profile))
        return;
      return getArrayForCommaSeparatedString(profile[NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY]);
    },
    default: []
  };
  var resolveAwsSdkSigV4AConfig = (config) => {
    config.sigv4aSigningRegionSet = core.normalizeProvider(config.sigv4aSigningRegionSet);
    return config;
  };
  var NODE_SIGV4A_CONFIG_OPTIONS = {
    environmentVariableSelector(env) {
      if (env.AWS_SIGV4A_SIGNING_REGION_SET) {
        return env.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((_) => _.trim());
      }
      throw new propertyProvider.ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
        tryNextLink: true
      });
    },
    configFileSelector(profile) {
      if (profile.sigv4a_signing_region_set) {
        return (profile.sigv4a_signing_region_set ?? "").split(",").map((_) => _.trim());
      }
      throw new propertyProvider.ProviderError("sigv4a_signing_region_set not set in profile.", {
        tryNextLink: true
      });
    },
    default: undefined
  };
  var resolveAwsSdkSigV4Config = (config) => {
    let inputCredentials = config.credentials;
    let isUserSupplied = !!config.credentials;
    let resolvedCredentials = undefined;
    Object.defineProperty(config, "credentials", {
      set(credentials) {
        if (credentials && credentials !== inputCredentials && credentials !== resolvedCredentials) {
          isUserSupplied = true;
        }
        inputCredentials = credentials;
        const memoizedProvider = normalizeCredentialProvider(config, {
          credentials: inputCredentials,
          credentialDefaultProvider: config.credentialDefaultProvider
        });
        const boundProvider = bindCallerConfig(config, memoizedProvider);
        if (isUserSupplied && !boundProvider.attributed) {
          const isCredentialObject = typeof inputCredentials === "object" && inputCredentials !== null;
          resolvedCredentials = async (options) => {
            const creds = await boundProvider(options);
            const attributedCreds = creds;
            if (isCredentialObject && (!attributedCreds.$source || Object.keys(attributedCreds.$source).length === 0)) {
              return client3.setCredentialFeature(attributedCreds, "CREDENTIALS_CODE", "e");
            }
            return attributedCreds;
          };
          resolvedCredentials.memoized = boundProvider.memoized;
          resolvedCredentials.configBound = boundProvider.configBound;
          resolvedCredentials.attributed = true;
        } else {
          resolvedCredentials = boundProvider;
        }
      },
      get() {
        return resolvedCredentials;
      },
      enumerable: true,
      configurable: true
    });
    config.credentials = inputCredentials;
    const { signingEscapePath = true, systemClockOffset = config.systemClockOffset || 0, sha256 } = config;
    let signer;
    if (config.signer) {
      signer = core.normalizeProvider(config.signer);
    } else if (config.regionInfoProvider) {
      signer = () => core.normalizeProvider(config.region)().then(async (region) => [
        await config.regionInfoProvider(region, {
          useFipsEndpoint: await config.useFipsEndpoint(),
          useDualstackEndpoint: await config.useDualstackEndpoint()
        }) || {},
        region
      ]).then(([regionInfo, region]) => {
        const { signingRegion, signingService } = regionInfo;
        config.signingRegion = config.signingRegion || signingRegion || region;
        config.signingName = config.signingName || signingService || config.serviceId;
        const params = {
          ...config,
          credentials: config.credentials,
          region: config.signingRegion,
          service: config.signingName,
          sha256,
          uriEscapePath: signingEscapePath
        };
        const SignerCtor = config.signerConstructor || signatureV4.SignatureV4;
        return new SignerCtor(params);
      });
    } else {
      signer = async (authScheme) => {
        authScheme = Object.assign({}, {
          name: "sigv4",
          signingName: config.signingName || config.defaultSigningName,
          signingRegion: await core.normalizeProvider(config.region)(),
          properties: {}
        }, authScheme);
        const signingRegion = authScheme.signingRegion;
        const signingService = authScheme.signingName;
        config.signingRegion = config.signingRegion || signingRegion;
        config.signingName = config.signingName || signingService || config.serviceId;
        const params = {
          ...config,
          credentials: config.credentials,
          region: config.signingRegion,
          service: config.signingName,
          sha256,
          uriEscapePath: signingEscapePath
        };
        const SignerCtor = config.signerConstructor || signatureV4.SignatureV4;
        return new SignerCtor(params);
      };
    }
    const resolvedConfig = Object.assign(config, {
      systemClockOffset,
      signingEscapePath,
      signer
    });
    return resolvedConfig;
  };
  var resolveAWSSDKSigV4Config = resolveAwsSdkSigV4Config;
  function normalizeCredentialProvider(config, { credentials, credentialDefaultProvider }) {
    let credentialsProvider;
    if (credentials) {
      if (!credentials?.memoized) {
        credentialsProvider = core.memoizeIdentityProvider(credentials, core.isIdentityExpired, core.doesIdentityRequireRefresh);
      } else {
        credentialsProvider = credentials;
      }
    } else {
      if (credentialDefaultProvider) {
        credentialsProvider = core.normalizeProvider(credentialDefaultProvider(Object.assign({}, config, {
          parentClientConfig: config
        })));
      } else {
        credentialsProvider = async () => {
          throw new Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.");
        };
      }
    }
    credentialsProvider.memoized = true;
    return credentialsProvider;
  }
  function bindCallerConfig(config, credentialsProvider) {
    if (credentialsProvider.configBound) {
      return credentialsProvider;
    }
    const fn = async (options) => credentialsProvider({ ...options, callerClientConfig: config });
    fn.memoized = credentialsProvider.memoized;
    fn.configBound = true;
    return fn;
  }
  exports.AWSSDKSigV4Signer = AWSSDKSigV4Signer;
  exports.AwsSdkSigV4ASigner = AwsSdkSigV4ASigner;
  exports.AwsSdkSigV4Signer = AwsSdkSigV4Signer;
  exports.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS = NODE_AUTH_SCHEME_PREFERENCE_OPTIONS;
  exports.NODE_SIGV4A_CONFIG_OPTIONS = NODE_SIGV4A_CONFIG_OPTIONS;
  exports.getBearerTokenEnvKey = getBearerTokenEnvKey;
  exports.resolveAWSSDKSigV4Config = resolveAWSSDKSigV4Config;
  exports.resolveAwsSdkSigV4AConfig = resolveAwsSdkSigV4AConfig;
  exports.resolveAwsSdkSigV4Config = resolveAwsSdkSigV4Config;
  exports.validateSigningProperties = validateSigningProperties;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveHttpAuthSchemeConfig = exports.defaultSSOOIDCHttpAuthSchemeProvider = exports.defaultSSOOIDCHttpAuthSchemeParametersProvider = undefined;
  var core_1 = require_dist_cjs24();
  var util_middleware_1 = require_dist_cjs4();
  var defaultSSOOIDCHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
      operation: (0, util_middleware_1.getSmithyContext)(context).operation,
      region: await (0, util_middleware_1.normalizeProvider)(config.region)() || (() => {
        throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
      })()
    };
  };
  exports.defaultSSOOIDCHttpAuthSchemeParametersProvider = defaultSSOOIDCHttpAuthSchemeParametersProvider;
  function createAwsAuthSigv4HttpAuthOption(authParameters) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sso-oauth",
        region: authParameters.region
      },
      propertiesExtractor: (config, context) => ({
        signingProperties: {
          config,
          context
        }
      })
    };
  }
  function createSmithyApiNoAuthHttpAuthOption(authParameters) {
    return {
      schemeId: "smithy.api#noAuth"
    };
  }
  var defaultSSOOIDCHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
      case "CreateToken": {
        options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
        break;
      }
      default: {
        options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
      }
    }
    return options;
  };
  exports.defaultSSOOIDCHttpAuthSchemeProvider = defaultSSOOIDCHttpAuthSchemeProvider;
  var resolveHttpAuthSchemeConfig = (config) => {
    const config_0 = (0, core_1.resolveAwsSdkSigV4Config)(config);
    return Object.assign(config_0, {
      authSchemePreference: (0, util_middleware_1.normalizeProvider)(config.authSchemePreference ?? [])
    });
  };
  exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig;
});

// node_modules/@aws-sdk/nested-clients/package.json
var require_package5 = __commonJS((exports, module) => {
  module.exports = {
    name: "@aws-sdk/nested-clients",
    version: "3.996.1",
    description: "Nested clients for AWS SDK packages.",
    main: "./dist-cjs/index.js",
    module: "./dist-es/index.js",
    types: "./dist-types/index.d.ts",
    scripts: {
      build: "yarn lint && concurrently 'yarn:build:types' 'yarn:build:es' && yarn build:cjs",
      "build:cjs": "node ../../scripts/compilation/inline nested-clients",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": 'yarn g:turbo run build -F="$npm_package_name"',
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "premove dist-cjs dist-es dist-types tsconfig.cjs.tsbuildinfo tsconfig.es.tsbuildinfo tsconfig.types.tsbuildinfo",
      lint: "node ../../scripts/validation/submodules-linter.js --pkg nested-clients",
      test: "yarn g:vitest run",
      "test:watch": "yarn g:vitest watch"
    },
    engines: {
      node: ">=20.0.0"
    },
    sideEffects: false,
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "^3.973.13",
      "@aws-sdk/middleware-host-header": "^3.972.4",
      "@aws-sdk/middleware-logger": "^3.972.4",
      "@aws-sdk/middleware-recursion-detection": "^3.972.4",
      "@aws-sdk/middleware-user-agent": "^3.972.13",
      "@aws-sdk/region-config-resolver": "^3.972.4",
      "@aws-sdk/types": "^3.973.2",
      "@aws-sdk/util-endpoints": "^3.996.1",
      "@aws-sdk/util-user-agent-browser": "^3.972.4",
      "@aws-sdk/util-user-agent-node": "^3.972.12",
      "@smithy/config-resolver": "^4.4.7",
      "@smithy/core": "^3.23.4",
      "@smithy/fetch-http-handler": "^5.3.10",
      "@smithy/hash-node": "^4.2.9",
      "@smithy/invalid-dependency": "^4.2.9",
      "@smithy/middleware-content-length": "^4.2.9",
      "@smithy/middleware-endpoint": "^4.4.18",
      "@smithy/middleware-retry": "^4.4.35",
      "@smithy/middleware-serde": "^4.2.10",
      "@smithy/middleware-stack": "^4.2.9",
      "@smithy/node-config-provider": "^4.3.9",
      "@smithy/node-http-handler": "^4.4.11",
      "@smithy/protocol-http": "^5.3.9",
      "@smithy/smithy-client": "^4.11.7",
      "@smithy/types": "^4.12.1",
      "@smithy/url-parser": "^4.2.9",
      "@smithy/util-base64": "^4.3.1",
      "@smithy/util-body-length-browser": "^4.2.1",
      "@smithy/util-body-length-node": "^4.2.2",
      "@smithy/util-defaults-mode-browser": "^4.3.34",
      "@smithy/util-defaults-mode-node": "^4.2.37",
      "@smithy/util-endpoints": "^3.2.9",
      "@smithy/util-middleware": "^4.2.9",
      "@smithy/util-retry": "^4.2.9",
      "@smithy/util-utf8": "^4.2.1",
      tslib: "^2.6.2"
    },
    devDependencies: {
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      premove: "4.0.0",
      typescript: "~5.8.3"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": [
          "dist-types/ts3.4/*"
        ]
      }
    },
    files: [
      "./cognito-identity.d.ts",
      "./cognito-identity.js",
      "./signin.d.ts",
      "./signin.js",
      "./sso-oidc.d.ts",
      "./sso-oidc.js",
      "./sso.d.ts",
      "./sso.js",
      "./sts.d.ts",
      "./sts.js",
      "dist-*/**"
    ],
    browser: {
      "./dist-es/submodules/signin/runtimeConfig": "./dist-es/submodules/signin/runtimeConfig.browser",
      "./dist-es/submodules/sso-oidc/runtimeConfig": "./dist-es/submodules/sso-oidc/runtimeConfig.browser",
      "./dist-es/submodules/sts/runtimeConfig": "./dist-es/submodules/sts/runtimeConfig.browser"
    },
    "react-native": {},
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "packages/nested-clients"
    },
    exports: {
      "./package.json": "./package.json",
      "./sso-oidc": {
        types: "./dist-types/submodules/sso-oidc/index.d.ts",
        module: "./dist-es/submodules/sso-oidc/index.js",
        node: "./dist-cjs/submodules/sso-oidc/index.js",
        import: "./dist-es/submodules/sso-oidc/index.js",
        require: "./dist-cjs/submodules/sso-oidc/index.js"
      },
      "./sts": {
        types: "./dist-types/submodules/sts/index.d.ts",
        module: "./dist-es/submodules/sts/index.js",
        node: "./dist-cjs/submodules/sts/index.js",
        import: "./dist-es/submodules/sts/index.js",
        require: "./dist-cjs/submodules/sts/index.js"
      },
      "./signin": {
        types: "./dist-types/submodules/signin/index.d.ts",
        module: "./dist-es/submodules/signin/index.js",
        node: "./dist-cjs/submodules/signin/index.js",
        import: "./dist-es/submodules/signin/index.js",
        require: "./dist-cjs/submodules/signin/index.js"
      },
      "./cognito-identity": {
        types: "./dist-types/submodules/cognito-identity/index.d.ts",
        module: "./dist-es/submodules/cognito-identity/index.js",
        node: "./dist-cjs/submodules/cognito-identity/index.js",
        import: "./dist-es/submodules/cognito-identity/index.js",
        require: "./dist-cjs/submodules/cognito-identity/index.js"
      },
      "./sso": {
        types: "./dist-types/submodules/sso/index.d.ts",
        module: "./dist-es/submodules/sso/index.js",
        node: "./dist-cjs/submodules/sso/index.js",
        import: "./dist-es/submodules/sso/index.js",
        require: "./dist-cjs/submodules/sso/index.js"
      }
    }
  };
});

// node_modules/@aws-sdk/util-user-agent-node/dist-cjs/index.js
var require_dist_cjs54 = __commonJS((exports) => {
  var os = __require("os");
  var process2 = __require("process");
  var middlewareUserAgent = require_dist_cjs40();
  var getRuntimeUserAgentPair = () => {
    const runtimesToCheck = ["deno", "bun", "llrt"];
    for (const runtime of runtimesToCheck) {
      if (process2.versions[runtime]) {
        return [`md/${runtime}`, process2.versions[runtime]];
      }
    }
    return ["md/nodejs", process2.versions.node];
  };
  var crtAvailability = {
    isCrtAvailable: false
  };
  var isCrtAvailable = () => {
    if (crtAvailability.isCrtAvailable) {
      return ["md/crt-avail"];
    }
    return null;
  };
  var createDefaultUserAgentProvider = ({ serviceId, clientVersion }) => {
    const runtimeUserAgentPair = getRuntimeUserAgentPair();
    return async (config) => {
      const sections = [
        ["aws-sdk-js", clientVersion],
        ["ua", "2.1"],
        [`os/${os.platform()}`, os.release()],
        ["lang/js"],
        runtimeUserAgentPair
      ];
      const crtAvailable = isCrtAvailable();
      if (crtAvailable) {
        sections.push(crtAvailable);
      }
      if (serviceId) {
        sections.push([`api/${serviceId}`, clientVersion]);
      }
      if (process2.env.AWS_EXECUTION_ENV) {
        sections.push([`exec-env/${process2.env.AWS_EXECUTION_ENV}`]);
      }
      const appId = await config?.userAgentAppId?.();
      const resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
      return resolvedUserAgent;
    };
  };
  var defaultUserAgent2 = createDefaultUserAgentProvider;
  var UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
  var UA_APP_ID_INI_NAME = "sdk_ua_app_id";
  var UA_APP_ID_INI_NAME_DEPRECATED = "sdk-ua-app-id";
  var NODE_APP_ID_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[UA_APP_ID_ENV_NAME],
    configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME] ?? profile[UA_APP_ID_INI_NAME_DEPRECATED],
    default: middlewareUserAgent.DEFAULT_UA_APP_ID
  };
  exports.NODE_APP_ID_CONFIG_OPTIONS = NODE_APP_ID_CONFIG_OPTIONS;
  exports.UA_APP_ID_ENV_NAME = UA_APP_ID_ENV_NAME;
  exports.UA_APP_ID_INI_NAME = UA_APP_ID_INI_NAME;
  exports.createDefaultUserAgentProvider = createDefaultUserAgentProvider;
  exports.crtAvailability = crtAvailability;
  exports.defaultUserAgent = defaultUserAgent2;
});

// node_modules/@smithy/hash-node/dist-cjs/index.js
var require_dist_cjs55 = __commonJS((exports) => {
  var utilBufferFrom = require_dist_cjs7();
  var utilUtf8 = require_dist_cjs8();
  var buffer = __require("buffer");
  var crypto2 = __require("crypto");

  class Hash {
    algorithmIdentifier;
    secret;
    hash;
    constructor(algorithmIdentifier, secret) {
      this.algorithmIdentifier = algorithmIdentifier;
      this.secret = secret;
      this.reset();
    }
    update(toHash, encoding) {
      this.hash.update(utilUtf8.toUint8Array(castSourceData(toHash, encoding)));
    }
    digest() {
      return Promise.resolve(this.hash.digest());
    }
    reset() {
      this.hash = this.secret ? crypto2.createHmac(this.algorithmIdentifier, castSourceData(this.secret)) : crypto2.createHash(this.algorithmIdentifier);
    }
  }
  function castSourceData(toCast, encoding) {
    if (buffer.Buffer.isBuffer(toCast)) {
      return toCast;
    }
    if (typeof toCast === "string") {
      return utilBufferFrom.fromString(toCast, encoding);
    }
    if (ArrayBuffer.isView(toCast)) {
      return utilBufferFrom.fromArrayBuffer(toCast.buffer, toCast.byteOffset, toCast.byteLength);
    }
    return utilBufferFrom.fromArrayBuffer(toCast);
  }
  exports.Hash = Hash;
});

// node_modules/@smithy/util-body-length-node/dist-cjs/index.js
var require_dist_cjs56 = __commonJS((exports) => {
  var node_fs = __require("node:fs");
  var calculateBodyLength = (body) => {
    if (!body) {
      return 0;
    }
    if (typeof body === "string") {
      return Buffer.byteLength(body);
    } else if (typeof body.byteLength === "number") {
      return body.byteLength;
    } else if (typeof body.size === "number") {
      return body.size;
    } else if (typeof body.start === "number" && typeof body.end === "number") {
      return body.end + 1 - body.start;
    } else if (body instanceof node_fs.ReadStream) {
      if (body.path != null) {
        return node_fs.lstatSync(body.path).size;
      } else if (typeof body.fd === "number") {
        return node_fs.fstatSync(body.fd).size;
      }
    }
    throw new Error(`Body Length computation failed for ${body}`);
  };
  exports.calculateBodyLength = calculateBodyLength;
});

// node_modules/@smithy/util-defaults-mode-node/dist-cjs/index.js
var require_dist_cjs57 = __commonJS((exports) => {
  var configResolver = require_dist_cjs41();
  var nodeConfigProvider = require_dist_cjs45();
  var propertyProvider = require_dist_cjs18();
  var AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
  var AWS_REGION_ENV = "AWS_REGION";
  var AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
  var ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
  var DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
  var IMDS_REGION_PATH = "/latest/meta-data/placement/region";
  var AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
  var AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
  var NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
      return env[AWS_DEFAULTS_MODE_ENV];
    },
    configFileSelector: (profile) => {
      return profile[AWS_DEFAULTS_MODE_CONFIG];
    },
    default: "legacy"
  };
  var resolveDefaultsModeConfig = ({ region = nodeConfigProvider.loadConfig(configResolver.NODE_REGION_CONFIG_OPTIONS), defaultsMode = nodeConfigProvider.loadConfig(NODE_DEFAULTS_MODE_CONFIG_OPTIONS) } = {}) => propertyProvider.memoize(async () => {
    const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
    switch (mode?.toLowerCase()) {
      case "auto":
        return resolveNodeDefaultsModeAuto(region);
      case "in-region":
      case "cross-region":
      case "mobile":
      case "standard":
      case "legacy":
        return Promise.resolve(mode?.toLocaleLowerCase());
      case undefined:
        return Promise.resolve("legacy");
      default:
        throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
    }
  });
  var resolveNodeDefaultsModeAuto = async (clientRegion) => {
    if (clientRegion) {
      const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
      const inferredRegion = await inferPhysicalRegion();
      if (!inferredRegion) {
        return "standard";
      }
      if (resolvedRegion === inferredRegion) {
        return "in-region";
      } else {
        return "cross-region";
      }
    }
    return "standard";
  };
  var inferPhysicalRegion = async () => {
    if (process.env[AWS_EXECUTION_ENV] && (process.env[AWS_REGION_ENV] || process.env[AWS_DEFAULT_REGION_ENV])) {
      return process.env[AWS_REGION_ENV] ?? process.env[AWS_DEFAULT_REGION_ENV];
    }
    if (!process.env[ENV_IMDS_DISABLED]) {
      try {
        const { getInstanceMetadataEndpoint, httpRequest } = await Promise.resolve().then(() => __toESM(require_dist_cjs52()));
        const endpoint = await getInstanceMetadataEndpoint();
        return (await httpRequest({ ...endpoint, path: IMDS_REGION_PATH })).toString();
      } catch (e) {}
    }
  };
  exports.resolveDefaultsModeConfig = resolveDefaultsModeConfig;
});

// node_modules/@aws-sdk/core/dist-cjs/submodules/protocols/index.js
var require_protocols2 = __commonJS((exports) => {
  var cbor = require_cbor();
  var schema = require_schema();
  var smithyClient = require_dist_cjs22();
  var protocols = require_protocols();
  var serde = require_serde();
  var utilBase64 = require_dist_cjs9();
  var utilUtf8 = require_dist_cjs8();
  var xmlBuilder = require_dist_cjs23();

  class ProtocolLib {
    queryCompat;
    constructor(queryCompat = false) {
      this.queryCompat = queryCompat;
    }
    resolveRestContentType(defaultContentType, inputSchema) {
      const members = inputSchema.getMemberSchemas();
      const httpPayloadMember = Object.values(members).find((m) => {
        return !!m.getMergedTraits().httpPayload;
      });
      if (httpPayloadMember) {
        const mediaType = httpPayloadMember.getMergedTraits().mediaType;
        if (mediaType) {
          return mediaType;
        } else if (httpPayloadMember.isStringSchema()) {
          return "text/plain";
        } else if (httpPayloadMember.isBlobSchema()) {
          return "application/octet-stream";
        } else {
          return defaultContentType;
        }
      } else if (!inputSchema.isUnitSchema()) {
        const hasBody = Object.values(members).find((m) => {
          const { httpQuery, httpQueryParams, httpHeader, httpLabel, httpPrefixHeaders } = m.getMergedTraits();
          const noPrefixHeaders = httpPrefixHeaders === undefined;
          return !httpQuery && !httpQueryParams && !httpHeader && !httpLabel && noPrefixHeaders;
        });
        if (hasBody) {
          return defaultContentType;
        }
      }
    }
    async getErrorSchemaOrThrowBaseException(errorIdentifier, defaultNamespace, response, dataObject, metadata, getErrorSchema) {
      let namespace = defaultNamespace;
      let errorName = errorIdentifier;
      if (errorIdentifier.includes("#")) {
        [namespace, errorName] = errorIdentifier.split("#");
      }
      const errorMetadata = {
        $metadata: metadata,
        $fault: response.statusCode < 500 ? "client" : "server"
      };
      const registry = schema.TypeRegistry.for(namespace);
      try {
        const errorSchema = getErrorSchema?.(registry, errorName) ?? registry.getSchema(errorIdentifier);
        return { errorSchema, errorMetadata };
      } catch (e) {
        dataObject.message = dataObject.message ?? dataObject.Message ?? "UnknownError";
        const synthetic = schema.TypeRegistry.for("smithy.ts.sdk.synthetic." + namespace);
        const baseExceptionSchema = synthetic.getBaseException();
        if (baseExceptionSchema) {
          const ErrorCtor = synthetic.getErrorCtor(baseExceptionSchema) ?? Error;
          throw this.decorateServiceException(Object.assign(new ErrorCtor({ name: errorName }), errorMetadata), dataObject);
        }
        throw this.decorateServiceException(Object.assign(new Error(errorName), errorMetadata), dataObject);
      }
    }
    decorateServiceException(exception, additions = {}) {
      if (this.queryCompat) {
        const msg = exception.Message ?? additions.Message;
        const error = smithyClient.decorateServiceException(exception, additions);
        if (msg) {
          error.message = msg;
        }
        error.Error = {
          ...error.Error,
          Type: error.Error?.Type,
          Code: error.Error?.Code,
          Message: error.Error?.message ?? error.Error?.Message ?? msg
        };
        const reqId = error.$metadata.requestId;
        if (reqId) {
          error.RequestId = reqId;
        }
        return error;
      }
      return smithyClient.decorateServiceException(exception, additions);
    }
    setQueryCompatError(output, response) {
      const queryErrorHeader = response.headers?.["x-amzn-query-error"];
      if (output !== undefined && queryErrorHeader != null) {
        const [Code, Type] = queryErrorHeader.split(";");
        const entries = Object.entries(output);
        const Error2 = {
          Code,
          Type
        };
        Object.assign(output, Error2);
        for (const [k, v] of entries) {
          Error2[k === "message" ? "Message" : k] = v;
        }
        delete Error2.__type;
        output.Error = Error2;
      }
    }
    queryCompatOutput(queryCompatErrorData, errorData) {
      if (queryCompatErrorData.Error) {
        errorData.Error = queryCompatErrorData.Error;
      }
      if (queryCompatErrorData.Type) {
        errorData.Type = queryCompatErrorData.Type;
      }
      if (queryCompatErrorData.Code) {
        errorData.Code = queryCompatErrorData.Code;
      }
    }
    findQueryCompatibleError(registry, errorName) {
      try {
        return registry.getSchema(errorName);
      } catch (e) {
        return registry.find((schema$1) => schema.NormalizedSchema.of(schema$1).getMergedTraits().awsQueryError?.[0] === errorName);
      }
    }
  }

  class AwsSmithyRpcV2CborProtocol extends cbor.SmithyRpcV2CborProtocol {
    awsQueryCompatible;
    mixin;
    constructor({ defaultNamespace, awsQueryCompatible }) {
      super({ defaultNamespace });
      this.awsQueryCompatible = !!awsQueryCompatible;
      this.mixin = new ProtocolLib(this.awsQueryCompatible);
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      if (this.awsQueryCompatible) {
        request.headers["x-amzn-query-mode"] = "true";
      }
      return request;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      if (this.awsQueryCompatible) {
        this.mixin.setQueryCompatError(dataObject, response);
      }
      const errorName = (() => {
        const compatHeader = response.headers["x-amzn-query-error"];
        if (compatHeader && this.awsQueryCompatible) {
          return compatHeader.split(";")[0];
        }
        return cbor.loadSmithyRpcV2CborErrorCode(response, dataObject) ?? "Unknown";
      })();
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorName, this.options.defaultNamespace, response, dataObject, metadata, this.awsQueryCompatible ? this.mixin.findQueryCompatibleError : undefined);
      const ns = schema.NormalizedSchema.of(errorSchema);
      const message3 = dataObject.message ?? dataObject.Message ?? "Unknown";
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message3);
      const output = {};
      for (const [name, member] of ns.structIterator()) {
        if (dataObject[name] != null) {
          output[name] = this.deserializer.readValue(member, dataObject[name]);
        }
      }
      if (this.awsQueryCompatible) {
        this.mixin.queryCompatOutput(dataObject, output);
      }
      throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message: message3
      }, output), dataObject);
    }
  }
  var _toStr = (val) => {
    if (val == null) {
      return val;
    }
    if (typeof val === "number" || typeof val === "bigint") {
      const warning = new Error(`Received number ${val} where a string was expected.`);
      warning.name = "Warning";
      console.warn(warning);
      return String(val);
    }
    if (typeof val === "boolean") {
      const warning = new Error(`Received boolean ${val} where a string was expected.`);
      warning.name = "Warning";
      console.warn(warning);
      return String(val);
    }
    return val;
  };
  var _toBool = (val) => {
    if (val == null) {
      return val;
    }
    if (typeof val === "string") {
      const lowercase = val.toLowerCase();
      if (val !== "" && lowercase !== "false" && lowercase !== "true") {
        const warning = new Error(`Received string "${val}" where a boolean was expected.`);
        warning.name = "Warning";
        console.warn(warning);
      }
      return val !== "" && lowercase !== "false";
    }
    return val;
  };
  var _toNum = (val) => {
    if (val == null) {
      return val;
    }
    if (typeof val === "string") {
      const num = Number(val);
      if (num.toString() !== val) {
        const warning = new Error(`Received string "${val}" where a number was expected.`);
        warning.name = "Warning";
        console.warn(warning);
        return val;
      }
      return num;
    }
    return val;
  };

  class SerdeContextConfig {
    serdeContext;
    setSerdeContext(serdeContext) {
      this.serdeContext = serdeContext;
    }
  }

  class UnionSerde {
    from;
    to;
    keys;
    constructor(from, to) {
      this.from = from;
      this.to = to;
      this.keys = new Set(Object.keys(this.from).filter((k) => k !== "__type"));
    }
    mark(key) {
      this.keys.delete(key);
    }
    hasUnknown() {
      return this.keys.size === 1 && Object.keys(this.to).length === 0;
    }
    writeUnknown() {
      if (this.hasUnknown()) {
        const k = this.keys.values().next().value;
        const v = this.from[k];
        this.to.$unknown = [k, v];
      }
    }
  }
  function jsonReviver(key, value, context) {
    if (context?.source) {
      const numericString = context.source;
      if (typeof value === "number") {
        if (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER || numericString !== String(value)) {
          const isFractional = numericString.includes(".");
          if (isFractional) {
            return new serde.NumericValue(numericString, "bigDecimal");
          } else {
            return BigInt(numericString);
          }
        }
      }
    }
    return value;
  }
  var collectBodyString = (streamBody, context) => smithyClient.collectBody(streamBody, context).then((body) => (context?.utf8Encoder ?? utilUtf8.toUtf8)(body));
  var parseJsonBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      try {
        return JSON.parse(encoded);
      } catch (e) {
        if (e?.name === "SyntaxError") {
          Object.defineProperty(e, "$responseBodyText", {
            value: encoded
          });
        }
        throw e;
      }
    }
    return {};
  });
  var parseJsonErrorBody = async (errorBody, context) => {
    const value = await parseJsonBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
  };
  var loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
      let cleanValue = rawValue;
      if (typeof cleanValue === "number") {
        cleanValue = cleanValue.toString();
      }
      if (cleanValue.indexOf(",") >= 0) {
        cleanValue = cleanValue.split(",")[0];
      }
      if (cleanValue.indexOf(":") >= 0) {
        cleanValue = cleanValue.split(":")[0];
      }
      if (cleanValue.indexOf("#") >= 0) {
        cleanValue = cleanValue.split("#")[1];
      }
      return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
      return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data && typeof data === "object") {
      const codeKey = findKey(data, "code");
      if (codeKey && data[codeKey] !== undefined) {
        return sanitizeErrorCode(data[codeKey]);
      }
      if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
      }
    }
  };

  class JsonShapeDeserializer extends SerdeContextConfig {
    settings;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    async read(schema2, data) {
      return this._read(schema2, typeof data === "string" ? JSON.parse(data, jsonReviver) : await parseJsonBody(data, this.serdeContext));
    }
    readObject(schema2, data) {
      return this._read(schema2, data);
    }
    _read(schema$1, value) {
      const isObject2 = value !== null && typeof value === "object";
      const ns = schema.NormalizedSchema.of(schema$1);
      if (isObject2) {
        if (ns.isStructSchema()) {
          const record = value;
          const union = ns.isUnionSchema();
          const out = {};
          let nameMap = undefined;
          const { jsonName } = this.settings;
          if (jsonName) {
            nameMap = {};
          }
          let unionSerde;
          if (union) {
            unionSerde = new UnionSerde(record, out);
          }
          for (const [memberName, memberSchema] of ns.structIterator()) {
            let fromKey = memberName;
            if (jsonName) {
              fromKey = memberSchema.getMergedTraits().jsonName ?? fromKey;
              nameMap[fromKey] = memberName;
            }
            if (union) {
              unionSerde.mark(fromKey);
            }
            if (record[fromKey] != null) {
              out[memberName] = this._read(memberSchema, record[fromKey]);
            }
          }
          if (union) {
            unionSerde.writeUnknown();
          } else if (typeof record.__type === "string") {
            for (const [k, v] of Object.entries(record)) {
              const t = jsonName ? nameMap[k] ?? k : k;
              if (!(t in out)) {
                out[t] = v;
              }
            }
          }
          return out;
        }
        if (Array.isArray(value) && ns.isListSchema()) {
          const listMember = ns.getValueSchema();
          const out = [];
          const sparse = !!ns.getMergedTraits().sparse;
          for (const item of value) {
            if (sparse || item != null) {
              out.push(this._read(listMember, item));
            }
          }
          return out;
        }
        if (ns.isMapSchema()) {
          const mapMember = ns.getValueSchema();
          const out = {};
          const sparse = !!ns.getMergedTraits().sparse;
          for (const [_k, _v] of Object.entries(value)) {
            if (sparse || _v != null) {
              out[_k] = this._read(mapMember, _v);
            }
          }
          return out;
        }
      }
      if (ns.isBlobSchema() && typeof value === "string") {
        return utilBase64.fromBase64(value);
      }
      const mediaType = ns.getMergedTraits().mediaType;
      if (ns.isStringSchema() && typeof value === "string" && mediaType) {
        const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
        if (isJson) {
          return serde.LazyJsonString.from(value);
        }
        return value;
      }
      if (ns.isTimestampSchema() && value != null) {
        const format = protocols.determineTimestampFormat(ns, this.settings);
        switch (format) {
          case 5:
            return serde.parseRfc3339DateTimeWithOffset(value);
          case 6:
            return serde.parseRfc7231DateTime(value);
          case 7:
            return serde.parseEpochTimestamp(value);
          default:
            console.warn("Missing timestamp format, parsing value with Date constructor:", value);
            return new Date(value);
        }
      }
      if (ns.isBigIntegerSchema() && (typeof value === "number" || typeof value === "string")) {
        return BigInt(value);
      }
      if (ns.isBigDecimalSchema() && value != null) {
        if (value instanceof serde.NumericValue) {
          return value;
        }
        const untyped = value;
        if (untyped.type === "bigDecimal" && "string" in untyped) {
          return new serde.NumericValue(untyped.string, untyped.type);
        }
        return new serde.NumericValue(String(value), "bigDecimal");
      }
      if (ns.isNumericSchema() && typeof value === "string") {
        switch (value) {
          case "Infinity":
            return Infinity;
          case "-Infinity":
            return -Infinity;
          case "NaN":
            return NaN;
        }
        return value;
      }
      if (ns.isDocumentSchema()) {
        if (isObject2) {
          const out = Array.isArray(value) ? [] : {};
          for (const [k, v] of Object.entries(value)) {
            if (v instanceof serde.NumericValue) {
              out[k] = v;
            } else {
              out[k] = this._read(ns, v);
            }
          }
          return out;
        } else {
          return structuredClone(value);
        }
      }
      return value;
    }
  }
  var NUMERIC_CONTROL_CHAR = String.fromCharCode(925);

  class JsonReplacer {
    values = new Map;
    counter = 0;
    stage = 0;
    createReplacer() {
      if (this.stage === 1) {
        throw new Error("@aws-sdk/core/protocols - JsonReplacer already created.");
      }
      if (this.stage === 2) {
        throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
      }
      this.stage = 1;
      return (key, value) => {
        if (value instanceof serde.NumericValue) {
          const v = `${NUMERIC_CONTROL_CHAR + "nv" + this.counter++}_` + value.string;
          this.values.set(`"${v}"`, value.string);
          return v;
        }
        if (typeof value === "bigint") {
          const s = value.toString();
          const v = `${NUMERIC_CONTROL_CHAR + "b" + this.counter++}_` + s;
          this.values.set(`"${v}"`, s);
          return v;
        }
        return value;
      };
    }
    replaceInJson(json) {
      if (this.stage === 0) {
        throw new Error("@aws-sdk/core/protocols - JsonReplacer not created yet.");
      }
      if (this.stage === 2) {
        throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
      }
      this.stage = 2;
      if (this.counter === 0) {
        return json;
      }
      for (const [key, value] of this.values) {
        json = json.replace(key, value);
      }
      return json;
    }
  }

  class JsonShapeSerializer extends SerdeContextConfig {
    settings;
    buffer;
    useReplacer = false;
    rootSchema;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    write(schema$1, value) {
      this.rootSchema = schema.NormalizedSchema.of(schema$1);
      this.buffer = this._write(this.rootSchema, value);
    }
    writeDiscriminatedDocument(schema$1, value) {
      this.write(schema$1, value);
      if (typeof this.buffer === "object") {
        this.buffer.__type = schema.NormalizedSchema.of(schema$1).getName(true);
      }
    }
    flush() {
      const { rootSchema, useReplacer } = this;
      this.rootSchema = undefined;
      this.useReplacer = false;
      if (rootSchema?.isStructSchema() || rootSchema?.isDocumentSchema()) {
        if (!useReplacer) {
          return JSON.stringify(this.buffer);
        }
        const replacer = new JsonReplacer;
        return replacer.replaceInJson(JSON.stringify(this.buffer, replacer.createReplacer(), 0));
      }
      return this.buffer;
    }
    _write(schema$1, value, container) {
      const isObject2 = value !== null && typeof value === "object";
      const ns = schema.NormalizedSchema.of(schema$1);
      if (isObject2) {
        if (ns.isStructSchema()) {
          const record = value;
          const out = {};
          const { jsonName } = this.settings;
          let nameMap = undefined;
          if (jsonName) {
            nameMap = {};
          }
          for (const [memberName, memberSchema] of ns.structIterator()) {
            const serializableValue = this._write(memberSchema, record[memberName], ns);
            if (serializableValue !== undefined) {
              let targetKey = memberName;
              if (jsonName) {
                targetKey = memberSchema.getMergedTraits().jsonName ?? memberName;
                nameMap[memberName] = targetKey;
              }
              out[targetKey] = serializableValue;
            }
          }
          if (ns.isUnionSchema() && Object.keys(out).length === 0) {
            const { $unknown } = record;
            if (Array.isArray($unknown)) {
              const [k, v] = $unknown;
              out[k] = this._write(15, v);
            }
          } else if (typeof record.__type === "string") {
            for (const [k, v] of Object.entries(record)) {
              const targetKey = jsonName ? nameMap[k] ?? k : k;
              if (!(targetKey in out)) {
                out[targetKey] = this._write(15, v);
              }
            }
          }
          return out;
        }
        if (Array.isArray(value) && ns.isListSchema()) {
          const listMember = ns.getValueSchema();
          const out = [];
          const sparse = !!ns.getMergedTraits().sparse;
          for (const item of value) {
            if (sparse || item != null) {
              out.push(this._write(listMember, item));
            }
          }
          return out;
        }
        if (ns.isMapSchema()) {
          const mapMember = ns.getValueSchema();
          const out = {};
          const sparse = !!ns.getMergedTraits().sparse;
          for (const [_k, _v] of Object.entries(value)) {
            if (sparse || _v != null) {
              out[_k] = this._write(mapMember, _v);
            }
          }
          return out;
        }
        if (value instanceof Uint8Array && (ns.isBlobSchema() || ns.isDocumentSchema())) {
          if (ns === this.rootSchema) {
            return value;
          }
          return (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
        }
        if (value instanceof Date && (ns.isTimestampSchema() || ns.isDocumentSchema())) {
          const format = protocols.determineTimestampFormat(ns, this.settings);
          switch (format) {
            case 5:
              return value.toISOString().replace(".000Z", "Z");
            case 6:
              return serde.dateToUtcString(value);
            case 7:
              return value.getTime() / 1000;
            default:
              console.warn("Missing timestamp format, using epoch seconds", value);
              return value.getTime() / 1000;
          }
        }
        if (value instanceof serde.NumericValue) {
          this.useReplacer = true;
        }
      }
      if (value === null && container?.isStructSchema()) {
        return;
      }
      if (ns.isStringSchema()) {
        if (typeof value === "undefined" && ns.isIdempotencyToken()) {
          return serde.generateIdempotencyToken();
        }
        const mediaType = ns.getMergedTraits().mediaType;
        if (value != null && mediaType) {
          const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
          if (isJson) {
            return serde.LazyJsonString.from(value);
          }
        }
        return value;
      }
      if (typeof value === "number" && ns.isNumericSchema()) {
        if (Math.abs(value) === Infinity || isNaN(value)) {
          return String(value);
        }
        return value;
      }
      if (typeof value === "string" && ns.isBlobSchema()) {
        if (ns === this.rootSchema) {
          return value;
        }
        return (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
      }
      if (typeof value === "bigint") {
        this.useReplacer = true;
      }
      if (ns.isDocumentSchema()) {
        if (isObject2) {
          const out = Array.isArray(value) ? [] : {};
          for (const [k, v] of Object.entries(value)) {
            if (v instanceof serde.NumericValue) {
              this.useReplacer = true;
              out[k] = v;
            } else {
              out[k] = this._write(ns, v);
            }
          }
          return out;
        } else {
          return structuredClone(value);
        }
      }
      return value;
    }
  }

  class JsonCodec extends SerdeContextConfig {
    settings;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    createSerializer() {
      const serializer = new JsonShapeSerializer(this.settings);
      serializer.setSerdeContext(this.serdeContext);
      return serializer;
    }
    createDeserializer() {
      const deserializer = new JsonShapeDeserializer(this.settings);
      deserializer.setSerdeContext(this.serdeContext);
      return deserializer;
    }
  }

  class AwsJsonRpcProtocol extends protocols.RpcProtocol {
    serializer;
    deserializer;
    serviceTarget;
    codec;
    mixin;
    awsQueryCompatible;
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec }) {
      super({
        defaultNamespace
      });
      this.serviceTarget = serviceTarget;
      this.codec = jsonCodec ?? new JsonCodec({
        timestampFormat: {
          useTrait: true,
          default: 7
        },
        jsonName: false
      });
      this.serializer = this.codec.createSerializer();
      this.deserializer = this.codec.createDeserializer();
      this.awsQueryCompatible = !!awsQueryCompatible;
      this.mixin = new ProtocolLib(this.awsQueryCompatible);
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      if (!request.path.endsWith("/")) {
        request.path += "/";
      }
      Object.assign(request.headers, {
        "content-type": `application/x-amz-json-${this.getJsonRpcVersion()}`,
        "x-amz-target": `${this.serviceTarget}.${operationSchema.name}`
      });
      if (this.awsQueryCompatible) {
        request.headers["x-amzn-query-mode"] = "true";
      }
      if (schema.deref(operationSchema.input) === "unit" || !request.body) {
        request.body = "{}";
      }
      return request;
    }
    getPayloadCodec() {
      return this.codec;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      if (this.awsQueryCompatible) {
        this.mixin.setQueryCompatError(dataObject, response);
      }
      const errorIdentifier = loadRestJsonErrorCode(response, dataObject) ?? "Unknown";
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata, this.awsQueryCompatible ? this.mixin.findQueryCompatibleError : undefined);
      const ns = schema.NormalizedSchema.of(errorSchema);
      const message3 = dataObject.message ?? dataObject.Message ?? "Unknown";
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message3);
      const output = {};
      for (const [name, member] of ns.structIterator()) {
        if (dataObject[name] != null) {
          output[name] = this.codec.createDeserializer().readObject(member, dataObject[name]);
        }
      }
      if (this.awsQueryCompatible) {
        this.mixin.queryCompatOutput(dataObject, output);
      }
      throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message: message3
      }, output), dataObject);
    }
  }

  class AwsJson1_0Protocol extends AwsJsonRpcProtocol {
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec }) {
      super({
        defaultNamespace,
        serviceTarget,
        awsQueryCompatible,
        jsonCodec
      });
    }
    getShapeId() {
      return "aws.protocols#awsJson1_0";
    }
    getJsonRpcVersion() {
      return "1.0";
    }
    getDefaultContentType() {
      return "application/x-amz-json-1.0";
    }
  }

  class AwsJson1_1Protocol extends AwsJsonRpcProtocol {
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec }) {
      super({
        defaultNamespace,
        serviceTarget,
        awsQueryCompatible,
        jsonCodec
      });
    }
    getShapeId() {
      return "aws.protocols#awsJson1_1";
    }
    getJsonRpcVersion() {
      return "1.1";
    }
    getDefaultContentType() {
      return "application/x-amz-json-1.1";
    }
  }

  class AwsRestJsonProtocol extends protocols.HttpBindingProtocol {
    serializer;
    deserializer;
    codec;
    mixin = new ProtocolLib;
    constructor({ defaultNamespace }) {
      super({
        defaultNamespace
      });
      const settings = {
        timestampFormat: {
          useTrait: true,
          default: 7
        },
        httpBindings: true,
        jsonName: true
      };
      this.codec = new JsonCodec(settings);
      this.serializer = new protocols.HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);
      this.deserializer = new protocols.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);
    }
    getShapeId() {
      return "aws.protocols#restJson1";
    }
    getPayloadCodec() {
      return this.codec;
    }
    setSerdeContext(serdeContext) {
      this.codec.setSerdeContext(serdeContext);
      super.setSerdeContext(serdeContext);
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      const inputSchema = schema.NormalizedSchema.of(operationSchema.input);
      if (!request.headers["content-type"]) {
        const contentType = this.mixin.resolveRestContentType(this.getDefaultContentType(), inputSchema);
        if (contentType) {
          request.headers["content-type"] = contentType;
        }
      }
      if (request.body == null && request.headers["content-type"] === this.getDefaultContentType()) {
        request.body = "{}";
      }
      return request;
    }
    async deserializeResponse(operationSchema, context, response) {
      const output = await super.deserializeResponse(operationSchema, context, response);
      const outputSchema = schema.NormalizedSchema.of(operationSchema.output);
      for (const [name, member] of outputSchema.structIterator()) {
        if (member.getMemberTraits().httpPayload && !(name in output)) {
          output[name] = null;
        }
      }
      return output;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      const errorIdentifier = loadRestJsonErrorCode(response, dataObject) ?? "Unknown";
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata);
      const ns = schema.NormalizedSchema.of(errorSchema);
      const message3 = dataObject.message ?? dataObject.Message ?? "Unknown";
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message3);
      await this.deserializeHttpMessage(errorSchema, context, response, dataObject);
      const output = {};
      for (const [name, member] of ns.structIterator()) {
        const target = member.getMergedTraits().jsonName ?? name;
        output[name] = this.codec.createDeserializer().readObject(member, dataObject[target]);
      }
      throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message: message3
      }, output), dataObject);
    }
    getDefaultContentType() {
      return "application/json";
    }
  }
  var awsExpectUnion = (value) => {
    if (value == null) {
      return;
    }
    if (typeof value === "object" && "__type" in value) {
      delete value.__type;
    }
    return smithyClient.expectUnion(value);
  };

  class XmlShapeDeserializer extends SerdeContextConfig {
    settings;
    stringDeserializer;
    constructor(settings) {
      super();
      this.settings = settings;
      this.stringDeserializer = new protocols.FromStringShapeDeserializer(settings);
    }
    setSerdeContext(serdeContext) {
      this.serdeContext = serdeContext;
      this.stringDeserializer.setSerdeContext(serdeContext);
    }
    read(schema$1, bytes, key) {
      const ns = schema.NormalizedSchema.of(schema$1);
      const memberSchemas = ns.getMemberSchemas();
      const isEventPayload = ns.isStructSchema() && ns.isMemberSchema() && !!Object.values(memberSchemas).find((memberNs) => {
        return !!memberNs.getMemberTraits().eventPayload;
      });
      if (isEventPayload) {
        const output = {};
        const memberName = Object.keys(memberSchemas)[0];
        const eventMemberSchema = memberSchemas[memberName];
        if (eventMemberSchema.isBlobSchema()) {
          output[memberName] = bytes;
        } else {
          output[memberName] = this.read(memberSchemas[memberName], bytes);
        }
        return output;
      }
      const xmlString = (this.serdeContext?.utf8Encoder ?? utilUtf8.toUtf8)(bytes);
      const parsedObject = this.parseXml(xmlString);
      return this.readSchema(schema$1, key ? parsedObject[key] : parsedObject);
    }
    readSchema(_schema, value) {
      const ns = schema.NormalizedSchema.of(_schema);
      if (ns.isUnitSchema()) {
        return;
      }
      const traits = ns.getMergedTraits();
      if (ns.isListSchema() && !Array.isArray(value)) {
        return this.readSchema(ns, [value]);
      }
      if (value == null) {
        return value;
      }
      if (typeof value === "object") {
        const sparse = !!traits.sparse;
        const flat = !!traits.xmlFlattened;
        if (ns.isListSchema()) {
          const listValue = ns.getValueSchema();
          const buffer2 = [];
          const sourceKey = listValue.getMergedTraits().xmlName ?? "member";
          const source = flat ? value : (value[0] ?? value)[sourceKey];
          const sourceArray = Array.isArray(source) ? source : [source];
          for (const v of sourceArray) {
            if (v != null || sparse) {
              buffer2.push(this.readSchema(listValue, v));
            }
          }
          return buffer2;
        }
        const buffer = {};
        if (ns.isMapSchema()) {
          const keyNs = ns.getKeySchema();
          const memberNs = ns.getValueSchema();
          let entries;
          if (flat) {
            entries = Array.isArray(value) ? value : [value];
          } else {
            entries = Array.isArray(value.entry) ? value.entry : [value.entry];
          }
          const keyProperty = keyNs.getMergedTraits().xmlName ?? "key";
          const valueProperty = memberNs.getMergedTraits().xmlName ?? "value";
          for (const entry of entries) {
            const key = entry[keyProperty];
            const value2 = entry[valueProperty];
            if (value2 != null || sparse) {
              buffer[key] = this.readSchema(memberNs, value2);
            }
          }
          return buffer;
        }
        if (ns.isStructSchema()) {
          const union = ns.isUnionSchema();
          let unionSerde;
          if (union) {
            unionSerde = new UnionSerde(value, buffer);
          }
          for (const [memberName, memberSchema] of ns.structIterator()) {
            const memberTraits = memberSchema.getMergedTraits();
            const xmlObjectKey = !memberTraits.httpPayload ? memberSchema.getMemberTraits().xmlName ?? memberName : memberTraits.xmlName ?? memberSchema.getName();
            if (union) {
              unionSerde.mark(xmlObjectKey);
            }
            if (value[xmlObjectKey] != null) {
              buffer[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);
            }
          }
          if (union) {
            unionSerde.writeUnknown();
          }
          return buffer;
        }
        if (ns.isDocumentSchema()) {
          return value;
        }
        throw new Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${ns.getName(true)}`);
      }
      if (ns.isListSchema()) {
        return [];
      }
      if (ns.isMapSchema() || ns.isStructSchema()) {
        return {};
      }
      return this.stringDeserializer.read(ns, value);
    }
    parseXml(xml) {
      if (xml.length) {
        let parsedObj;
        try {
          parsedObj = xmlBuilder.parseXML(xml);
        } catch (e) {
          if (e && typeof e === "object") {
            Object.defineProperty(e, "$responseBodyText", {
              value: xml
            });
          }
          throw e;
        }
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
          parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
          delete parsedObjToReturn[textNodeName];
        }
        return smithyClient.getValueFromTextNode(parsedObjToReturn);
      }
      return {};
    }
  }

  class QueryShapeSerializer extends SerdeContextConfig {
    settings;
    buffer;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    write(schema$1, value, prefix = "") {
      if (this.buffer === undefined) {
        this.buffer = "";
      }
      const ns = schema.NormalizedSchema.of(schema$1);
      if (prefix && !prefix.endsWith(".")) {
        prefix += ".";
      }
      if (ns.isBlobSchema()) {
        if (typeof value === "string" || value instanceof Uint8Array) {
          this.writeKey(prefix);
          this.writeValue((this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value));
        }
      } else if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isStringSchema()) {
        if (value != null) {
          this.writeKey(prefix);
          this.writeValue(String(value));
        } else if (ns.isIdempotencyToken()) {
          this.writeKey(prefix);
          this.writeValue(serde.generateIdempotencyToken());
        }
      } else if (ns.isBigIntegerSchema()) {
        if (value != null) {
          this.writeKey(prefix);
          this.writeValue(String(value));
        }
      } else if (ns.isBigDecimalSchema()) {
        if (value != null) {
          this.writeKey(prefix);
          this.writeValue(value instanceof serde.NumericValue ? value.string : String(value));
        }
      } else if (ns.isTimestampSchema()) {
        if (value instanceof Date) {
          this.writeKey(prefix);
          const format = protocols.determineTimestampFormat(ns, this.settings);
          switch (format) {
            case 5:
              this.writeValue(value.toISOString().replace(".000Z", "Z"));
              break;
            case 6:
              this.writeValue(smithyClient.dateToUtcString(value));
              break;
            case 7:
              this.writeValue(String(value.getTime() / 1000));
              break;
          }
        }
      } else if (ns.isDocumentSchema()) {
        if (Array.isArray(value)) {
          this.write(64 | 15, value, prefix);
        } else if (value instanceof Date) {
          this.write(4, value, prefix);
        } else if (value instanceof Uint8Array) {
          this.write(21, value, prefix);
        } else if (value && typeof value === "object") {
          this.write(128 | 15, value, prefix);
        } else {
          this.writeKey(prefix);
          this.writeValue(String(value));
        }
      } else if (ns.isListSchema()) {
        if (Array.isArray(value)) {
          if (value.length === 0) {
            if (this.settings.serializeEmptyLists) {
              this.writeKey(prefix);
              this.writeValue("");
            }
          } else {
            const member = ns.getValueSchema();
            const flat = this.settings.flattenLists || ns.getMergedTraits().xmlFlattened;
            let i2 = 1;
            for (const item of value) {
              if (item == null) {
                continue;
              }
              const traits = member.getMergedTraits();
              const suffix = this.getKey("member", traits.xmlName, traits.ec2QueryName);
              const key = flat ? `${prefix}${i2}` : `${prefix}${suffix}.${i2}`;
              this.write(member, item, key);
              ++i2;
            }
          }
        }
      } else if (ns.isMapSchema()) {
        if (value && typeof value === "object") {
          const keySchema = ns.getKeySchema();
          const memberSchema = ns.getValueSchema();
          const flat = ns.getMergedTraits().xmlFlattened;
          let i2 = 1;
          for (const [k, v] of Object.entries(value)) {
            if (v == null) {
              continue;
            }
            const keyTraits = keySchema.getMergedTraits();
            const keySuffix = this.getKey("key", keyTraits.xmlName, keyTraits.ec2QueryName);
            const key = flat ? `${prefix}${i2}.${keySuffix}` : `${prefix}entry.${i2}.${keySuffix}`;
            const valTraits = memberSchema.getMergedTraits();
            const valueSuffix = this.getKey("value", valTraits.xmlName, valTraits.ec2QueryName);
            const valueKey = flat ? `${prefix}${i2}.${valueSuffix}` : `${prefix}entry.${i2}.${valueSuffix}`;
            this.write(keySchema, k, key);
            this.write(memberSchema, v, valueKey);
            ++i2;
          }
        }
      } else if (ns.isStructSchema()) {
        if (value && typeof value === "object") {
          let didWriteMember = false;
          for (const [memberName, member] of ns.structIterator()) {
            if (value[memberName] == null && !member.isIdempotencyToken()) {
              continue;
            }
            const traits = member.getMergedTraits();
            const suffix = this.getKey(memberName, traits.xmlName, traits.ec2QueryName, "struct");
            const key = `${prefix}${suffix}`;
            this.write(member, value[memberName], key);
            didWriteMember = true;
          }
          if (!didWriteMember && ns.isUnionSchema()) {
            const { $unknown } = value;
            if (Array.isArray($unknown)) {
              const [k, v] = $unknown;
              const key = `${prefix}${k}`;
              this.write(15, v, key);
            }
          }
        }
      } else if (ns.isUnitSchema())
        ;
      else {
        throw new Error(`@aws-sdk/core/protocols - QuerySerializer unrecognized schema type ${ns.getName(true)}`);
      }
    }
    flush() {
      if (this.buffer === undefined) {
        throw new Error("@aws-sdk/core/protocols - QuerySerializer cannot flush with nothing written to buffer.");
      }
      const str = this.buffer;
      delete this.buffer;
      return str;
    }
    getKey(memberName, xmlName, ec2QueryName, keySource) {
      const { ec2, capitalizeKeys } = this.settings;
      if (ec2 && ec2QueryName) {
        return ec2QueryName;
      }
      const key = xmlName ?? memberName;
      if (capitalizeKeys && keySource === "struct") {
        return key[0].toUpperCase() + key.slice(1);
      }
      return key;
    }
    writeKey(key) {
      if (key.endsWith(".")) {
        key = key.slice(0, key.length - 1);
      }
      this.buffer += `&${protocols.extendedEncodeURIComponent(key)}=`;
    }
    writeValue(value) {
      this.buffer += protocols.extendedEncodeURIComponent(value);
    }
  }

  class AwsQueryProtocol extends protocols.RpcProtocol {
    options;
    serializer;
    deserializer;
    mixin = new ProtocolLib;
    constructor(options) {
      super({
        defaultNamespace: options.defaultNamespace
      });
      this.options = options;
      const settings = {
        timestampFormat: {
          useTrait: true,
          default: 5
        },
        httpBindings: false,
        xmlNamespace: options.xmlNamespace,
        serviceNamespace: options.defaultNamespace,
        serializeEmptyLists: true
      };
      this.serializer = new QueryShapeSerializer(settings);
      this.deserializer = new XmlShapeDeserializer(settings);
    }
    getShapeId() {
      return "aws.protocols#awsQuery";
    }
    setSerdeContext(serdeContext) {
      this.serializer.setSerdeContext(serdeContext);
      this.deserializer.setSerdeContext(serdeContext);
    }
    getPayloadCodec() {
      throw new Error("AWSQuery protocol has no payload codec.");
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      if (!request.path.endsWith("/")) {
        request.path += "/";
      }
      Object.assign(request.headers, {
        "content-type": `application/x-www-form-urlencoded`
      });
      if (schema.deref(operationSchema.input) === "unit" || !request.body) {
        request.body = "";
      }
      const action = operationSchema.name.split("#")[1] ?? operationSchema.name;
      request.body = `Action=${action}&Version=${this.options.version}` + request.body;
      if (request.body.endsWith("&")) {
        request.body = request.body.slice(-1);
      }
      return request;
    }
    async deserializeResponse(operationSchema, context, response) {
      const deserializer = this.deserializer;
      const ns = schema.NormalizedSchema.of(operationSchema.output);
      const dataObject = {};
      if (response.statusCode >= 300) {
        const bytes2 = await protocols.collectBody(response.body, context);
        if (bytes2.byteLength > 0) {
          Object.assign(dataObject, await deserializer.read(15, bytes2));
        }
        await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));
      }
      for (const header in response.headers) {
        const value = response.headers[header];
        delete response.headers[header];
        response.headers[header.toLowerCase()] = value;
      }
      const shortName = operationSchema.name.split("#")[1] ?? operationSchema.name;
      const awsQueryResultKey = ns.isStructSchema() && this.useNestedResult() ? shortName + "Result" : undefined;
      const bytes = await protocols.collectBody(response.body, context);
      if (bytes.byteLength > 0) {
        Object.assign(dataObject, await deserializer.read(ns, bytes, awsQueryResultKey));
      }
      const output = {
        $metadata: this.deserializeMetadata(response),
        ...dataObject
      };
      return output;
    }
    useNestedResult() {
      return true;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      const errorIdentifier = this.loadQueryErrorCode(response, dataObject) ?? "Unknown";
      const errorData = this.loadQueryError(dataObject) ?? {};
      const message3 = this.loadQueryErrorMessage(dataObject);
      errorData.message = message3;
      errorData.Error = {
        Type: errorData.Type,
        Code: errorData.Code,
        Message: message3
      };
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, errorData, metadata, this.mixin.findQueryCompatibleError);
      const ns = schema.NormalizedSchema.of(errorSchema);
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message3);
      const output = {
        Type: errorData.Error.Type,
        Code: errorData.Error.Code,
        Error: errorData.Error
      };
      for (const [name, member] of ns.structIterator()) {
        const target = member.getMergedTraits().xmlName ?? name;
        const value = errorData[target] ?? dataObject[target];
        output[name] = this.deserializer.readSchema(member, value);
      }
      throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message: message3
      }, output), dataObject);
    }
    loadQueryErrorCode(output, data) {
      const code = (data.Errors?.[0]?.Error ?? data.Errors?.Error ?? data.Error)?.Code;
      if (code !== undefined) {
        return code;
      }
      if (output.statusCode == 404) {
        return "NotFound";
      }
    }
    loadQueryError(data) {
      return data.Errors?.[0]?.Error ?? data.Errors?.Error ?? data.Error;
    }
    loadQueryErrorMessage(data) {
      const errorData = this.loadQueryError(data);
      return errorData?.message ?? errorData?.Message ?? data.message ?? data.Message ?? "Unknown";
    }
    getDefaultContentType() {
      return "application/x-www-form-urlencoded";
    }
  }

  class AwsEc2QueryProtocol extends AwsQueryProtocol {
    options;
    constructor(options) {
      super(options);
      this.options = options;
      const ec2Settings = {
        capitalizeKeys: true,
        flattenLists: true,
        serializeEmptyLists: false,
        ec2: true
      };
      Object.assign(this.serializer.settings, ec2Settings);
    }
    useNestedResult() {
      return false;
    }
  }
  var parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      let parsedObj;
      try {
        parsedObj = xmlBuilder.parseXML(encoded);
      } catch (e) {
        if (e && typeof e === "object") {
          Object.defineProperty(e, "$responseBodyText", {
            value: encoded
          });
        }
        throw e;
      }
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return smithyClient.getValueFromTextNode(parsedObjToReturn);
    }
    return {};
  });
  var parseXmlErrorBody = async (errorBody, context) => {
    const value = await parseXmlBody(errorBody, context);
    if (value.Error) {
      value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
  };
  var loadRestXmlErrorCode = (output, data) => {
    if (data?.Error?.Code !== undefined) {
      return data.Error.Code;
    }
    if (data?.Code !== undefined) {
      return data.Code;
    }
    if (output.statusCode == 404) {
      return "NotFound";
    }
  };

  class XmlShapeSerializer extends SerdeContextConfig {
    settings;
    stringBuffer;
    byteBuffer;
    buffer;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    write(schema$1, value) {
      const ns = schema.NormalizedSchema.of(schema$1);
      if (ns.isStringSchema() && typeof value === "string") {
        this.stringBuffer = value;
      } else if (ns.isBlobSchema()) {
        this.byteBuffer = "byteLength" in value ? value : (this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(value);
      } else {
        this.buffer = this.writeStruct(ns, value, undefined);
        const traits = ns.getMergedTraits();
        if (traits.httpPayload && !traits.xmlName) {
          this.buffer.withName(ns.getName());
        }
      }
    }
    flush() {
      if (this.byteBuffer !== undefined) {
        const bytes = this.byteBuffer;
        delete this.byteBuffer;
        return bytes;
      }
      if (this.stringBuffer !== undefined) {
        const str = this.stringBuffer;
        delete this.stringBuffer;
        return str;
      }
      const buffer = this.buffer;
      if (this.settings.xmlNamespace) {
        if (!buffer?.attributes?.["xmlns"]) {
          buffer.addAttribute("xmlns", this.settings.xmlNamespace);
        }
      }
      delete this.buffer;
      return buffer.toString();
    }
    writeStruct(ns, value, parentXmlns) {
      const traits = ns.getMergedTraits();
      const name = ns.isMemberSchema() && !traits.httpPayload ? ns.getMemberTraits().xmlName ?? ns.getMemberName() : traits.xmlName ?? ns.getName();
      if (!name || !ns.isStructSchema()) {
        throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${ns.getName(true)}.`);
      }
      const structXmlNode = xmlBuilder.XmlNode.of(name);
      const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);
      for (const [memberName, memberSchema] of ns.structIterator()) {
        const val = value[memberName];
        if (val != null || memberSchema.isIdempotencyToken()) {
          if (memberSchema.getMergedTraits().xmlAttribute) {
            structXmlNode.addAttribute(memberSchema.getMergedTraits().xmlName ?? memberName, this.writeSimple(memberSchema, val));
            continue;
          }
          if (memberSchema.isListSchema()) {
            this.writeList(memberSchema, val, structXmlNode, xmlns);
          } else if (memberSchema.isMapSchema()) {
            this.writeMap(memberSchema, val, structXmlNode, xmlns);
          } else if (memberSchema.isStructSchema()) {
            structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));
          } else {
            const memberNode = xmlBuilder.XmlNode.of(memberSchema.getMergedTraits().xmlName ?? memberSchema.getMemberName());
            this.writeSimpleInto(memberSchema, val, memberNode, xmlns);
            structXmlNode.addChildNode(memberNode);
          }
        }
      }
      const { $unknown } = value;
      if ($unknown && ns.isUnionSchema() && Array.isArray($unknown) && Object.keys(value).length === 1) {
        const [k, v] = $unknown;
        const node = xmlBuilder.XmlNode.of(k);
        if (typeof v !== "string") {
          if (value instanceof xmlBuilder.XmlNode || value instanceof xmlBuilder.XmlText) {
            structXmlNode.addChildNode(value);
          } else {
            throw new Error(`@aws-sdk - $unknown union member in XML requires ` + `value of type string, @aws-sdk/xml-builder::XmlNode or XmlText.`);
          }
        }
        this.writeSimpleInto(0, v, node, xmlns);
        structXmlNode.addChildNode(node);
      }
      if (xmlns) {
        structXmlNode.addAttribute(xmlnsAttr, xmlns);
      }
      return structXmlNode;
    }
    writeList(listMember, array, container, parentXmlns) {
      if (!listMember.isMemberSchema()) {
        throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${listMember.getName(true)}`);
      }
      const listTraits = listMember.getMergedTraits();
      const listValueSchema = listMember.getValueSchema();
      const listValueTraits = listValueSchema.getMergedTraits();
      const sparse = !!listValueTraits.sparse;
      const flat = !!listTraits.xmlFlattened;
      const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);
      const writeItem = (container2, value) => {
        if (listValueSchema.isListSchema()) {
          this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container2, xmlns);
        } else if (listValueSchema.isMapSchema()) {
          this.writeMap(listValueSchema, value, container2, xmlns);
        } else if (listValueSchema.isStructSchema()) {
          const struct = this.writeStruct(listValueSchema, value, xmlns);
          container2.addChildNode(struct.withName(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? "member"));
        } else {
          const listItemNode = xmlBuilder.XmlNode.of(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? "member");
          this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);
          container2.addChildNode(listItemNode);
        }
      };
      if (flat) {
        for (const value of array) {
          if (sparse || value != null) {
            writeItem(container, value);
          }
        }
      } else {
        const listNode = xmlBuilder.XmlNode.of(listTraits.xmlName ?? listMember.getMemberName());
        if (xmlns) {
          listNode.addAttribute(xmlnsAttr, xmlns);
        }
        for (const value of array) {
          if (sparse || value != null) {
            writeItem(listNode, value);
          }
        }
        container.addChildNode(listNode);
      }
    }
    writeMap(mapMember, map, container, parentXmlns, containerIsMap = false) {
      if (!mapMember.isMemberSchema()) {
        throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${mapMember.getName(true)}`);
      }
      const mapTraits = mapMember.getMergedTraits();
      const mapKeySchema = mapMember.getKeySchema();
      const mapKeyTraits = mapKeySchema.getMergedTraits();
      const keyTag = mapKeyTraits.xmlName ?? "key";
      const mapValueSchema = mapMember.getValueSchema();
      const mapValueTraits = mapValueSchema.getMergedTraits();
      const valueTag = mapValueTraits.xmlName ?? "value";
      const sparse = !!mapValueTraits.sparse;
      const flat = !!mapTraits.xmlFlattened;
      const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);
      const addKeyValue = (entry, key, val) => {
        const keyNode = xmlBuilder.XmlNode.of(keyTag, key);
        const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);
        if (keyXmlns) {
          keyNode.addAttribute(keyXmlnsAttr, keyXmlns);
        }
        entry.addChildNode(keyNode);
        let valueNode = xmlBuilder.XmlNode.of(valueTag);
        if (mapValueSchema.isListSchema()) {
          this.writeList(mapValueSchema, val, valueNode, xmlns);
        } else if (mapValueSchema.isMapSchema()) {
          this.writeMap(mapValueSchema, val, valueNode, xmlns, true);
        } else if (mapValueSchema.isStructSchema()) {
          valueNode = this.writeStruct(mapValueSchema, val, xmlns);
        } else {
          this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);
        }
        entry.addChildNode(valueNode);
      };
      if (flat) {
        for (const [key, val] of Object.entries(map)) {
          if (sparse || val != null) {
            const entry = xmlBuilder.XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());
            addKeyValue(entry, key, val);
            container.addChildNode(entry);
          }
        }
      } else {
        let mapNode;
        if (!containerIsMap) {
          mapNode = xmlBuilder.XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());
          if (xmlns) {
            mapNode.addAttribute(xmlnsAttr, xmlns);
          }
          container.addChildNode(mapNode);
        }
        for (const [key, val] of Object.entries(map)) {
          if (sparse || val != null) {
            const entry = xmlBuilder.XmlNode.of("entry");
            addKeyValue(entry, key, val);
            (containerIsMap ? container : mapNode).addChildNode(entry);
          }
        }
      }
    }
    writeSimple(_schema, value) {
      if (value === null) {
        throw new Error("@aws-sdk/core/protocols - (XML serializer) cannot write null value.");
      }
      const ns = schema.NormalizedSchema.of(_schema);
      let nodeContents = null;
      if (value && typeof value === "object") {
        if (ns.isBlobSchema()) {
          nodeContents = (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
        } else if (ns.isTimestampSchema() && value instanceof Date) {
          const format = protocols.determineTimestampFormat(ns, this.settings);
          switch (format) {
            case 5:
              nodeContents = value.toISOString().replace(".000Z", "Z");
              break;
            case 6:
              nodeContents = smithyClient.dateToUtcString(value);
              break;
            case 7:
              nodeContents = String(value.getTime() / 1000);
              break;
            default:
              console.warn("Missing timestamp format, using http date", value);
              nodeContents = smithyClient.dateToUtcString(value);
              break;
          }
        } else if (ns.isBigDecimalSchema() && value) {
          if (value instanceof serde.NumericValue) {
            return value.string;
          }
          return String(value);
        } else if (ns.isMapSchema() || ns.isListSchema()) {
          throw new Error("@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.");
        } else {
          throw new Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${ns.getName(true)}`);
        }
      }
      if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isBigIntegerSchema() || ns.isBigDecimalSchema()) {
        nodeContents = String(value);
      }
      if (ns.isStringSchema()) {
        if (value === undefined && ns.isIdempotencyToken()) {
          nodeContents = serde.generateIdempotencyToken();
        } else {
          nodeContents = String(value);
        }
      }
      if (nodeContents === null) {
        throw new Error(`Unhandled schema-value pair ${ns.getName(true)}=${value}`);
      }
      return nodeContents;
    }
    writeSimpleInto(_schema, value, into, parentXmlns) {
      const nodeContents = this.writeSimple(_schema, value);
      const ns = schema.NormalizedSchema.of(_schema);
      const content = new xmlBuilder.XmlText(nodeContents);
      const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);
      if (xmlns) {
        into.addAttribute(xmlnsAttr, xmlns);
      }
      into.addChildNode(content);
    }
    getXmlnsAttribute(ns, parentXmlns) {
      const traits = ns.getMergedTraits();
      const [prefix, xmlns] = traits.xmlNamespace ?? [];
      if (xmlns && xmlns !== parentXmlns) {
        return [prefix ? `xmlns:${prefix}` : "xmlns", xmlns];
      }
      return [undefined, undefined];
    }
  }

  class XmlCodec extends SerdeContextConfig {
    settings;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    createSerializer() {
      const serializer = new XmlShapeSerializer(this.settings);
      serializer.setSerdeContext(this.serdeContext);
      return serializer;
    }
    createDeserializer() {
      const deserializer = new XmlShapeDeserializer(this.settings);
      deserializer.setSerdeContext(this.serdeContext);
      return deserializer;
    }
  }

  class AwsRestXmlProtocol extends protocols.HttpBindingProtocol {
    codec;
    serializer;
    deserializer;
    mixin = new ProtocolLib;
    constructor(options) {
      super(options);
      const settings = {
        timestampFormat: {
          useTrait: true,
          default: 5
        },
        httpBindings: true,
        xmlNamespace: options.xmlNamespace,
        serviceNamespace: options.defaultNamespace
      };
      this.codec = new XmlCodec(settings);
      this.serializer = new protocols.HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);
      this.deserializer = new protocols.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);
    }
    getPayloadCodec() {
      return this.codec;
    }
    getShapeId() {
      return "aws.protocols#restXml";
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      const inputSchema = schema.NormalizedSchema.of(operationSchema.input);
      if (!request.headers["content-type"]) {
        const contentType = this.mixin.resolveRestContentType(this.getDefaultContentType(), inputSchema);
        if (contentType) {
          request.headers["content-type"] = contentType;
        }
      }
      if (typeof request.body === "string" && request.headers["content-type"] === this.getDefaultContentType() && !request.body.startsWith("<?xml ") && !this.hasUnstructuredPayloadBinding(inputSchema)) {
        request.body = '<?xml version="1.0" encoding="UTF-8"?>' + request.body;
      }
      return request;
    }
    async deserializeResponse(operationSchema, context, response) {
      return super.deserializeResponse(operationSchema, context, response);
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      const errorIdentifier = loadRestXmlErrorCode(response, dataObject) ?? "Unknown";
      if (dataObject.Error && typeof dataObject.Error === "object") {
        for (const key of Object.keys(dataObject.Error)) {
          dataObject[key] = dataObject.Error[key];
          if (key.toLowerCase() === "message") {
            dataObject.message = dataObject.Error[key];
          }
        }
      }
      if (dataObject.RequestId && !metadata.requestId) {
        metadata.requestId = dataObject.RequestId;
      }
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata);
      const ns = schema.NormalizedSchema.of(errorSchema);
      const message3 = dataObject.Error?.message ?? dataObject.Error?.Message ?? dataObject.message ?? dataObject.Message ?? "Unknown";
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message3);
      await this.deserializeHttpMessage(errorSchema, context, response, dataObject);
      const output = {};
      for (const [name, member] of ns.structIterator()) {
        const target = member.getMergedTraits().xmlName ?? name;
        const value = dataObject.Error?.[target] ?? dataObject[target];
        output[name] = this.codec.createDeserializer().readSchema(member, value);
      }
      throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message: message3
      }, output), dataObject);
    }
    getDefaultContentType() {
      return "application/xml";
    }
    hasUnstructuredPayloadBinding(ns) {
      for (const [, member] of ns.structIterator()) {
        if (member.getMergedTraits().httpPayload) {
          return !(member.isStructSchema() || member.isMapSchema() || member.isListSchema());
        }
      }
      return false;
    }
  }
  exports.AwsEc2QueryProtocol = AwsEc2QueryProtocol;
  exports.AwsJson1_0Protocol = AwsJson1_0Protocol;
  exports.AwsJson1_1Protocol = AwsJson1_1Protocol;
  exports.AwsJsonRpcProtocol = AwsJsonRpcProtocol;
  exports.AwsQueryProtocol = AwsQueryProtocol;
  exports.AwsRestJsonProtocol = AwsRestJsonProtocol;
  exports.AwsRestXmlProtocol = AwsRestXmlProtocol;
  exports.AwsSmithyRpcV2CborProtocol = AwsSmithyRpcV2CborProtocol;
  exports.JsonCodec = JsonCodec;
  exports.JsonShapeDeserializer = JsonShapeDeserializer;
  exports.JsonShapeSerializer = JsonShapeSerializer;
  exports.XmlCodec = XmlCodec;
  exports.XmlShapeDeserializer = XmlShapeDeserializer;
  exports.XmlShapeSerializer = XmlShapeSerializer;
  exports._toBool = _toBool;
  exports._toNum = _toNum;
  exports._toStr = _toStr;
  exports.awsExpectUnion = awsExpectUnion;
  exports.loadRestJsonErrorCode = loadRestJsonErrorCode;
  exports.loadRestXmlErrorCode = loadRestXmlErrorCode;
  exports.parseJsonBody = parseJsonBody;
  exports.parseJsonErrorBody = parseJsonErrorBody;
  exports.parseXmlBody = parseXmlBody;
  exports.parseXmlErrorBody = parseXmlErrorBody;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/endpoint/ruleset.js
var require_ruleset2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ruleSet = undefined;
  var u = "required";
  var v = "fn";
  var w = "argv";
  var x = "ref";
  var a = true;
  var b = "isSet";
  var c = "booleanEquals";
  var d = "error";
  var e = "endpoint";
  var f = "tree";
  var g = "PartitionResult";
  var h = "getAttr";
  var i2 = { [u]: false, type: "string" };
  var j = { [u]: true, default: false, type: "boolean" };
  var k = { [x]: "Endpoint" };
  var l = { [v]: c, [w]: [{ [x]: "UseFIPS" }, true] };
  var m = { [v]: c, [w]: [{ [x]: "UseDualStack" }, true] };
  var n = {};
  var o = { [v]: h, [w]: [{ [x]: g }, "supportsFIPS"] };
  var p = { [x]: g };
  var q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] };
  var r = [l];
  var s = [m];
  var t = [{ [x]: "Region" }];
  var _data = {
    version: "1.0",
    parameters: { Region: i2, UseDualStack: j, UseFIPS: j, Endpoint: i2 },
    rules: [
      {
        conditions: [{ [v]: b, [w]: [k] }],
        rules: [
          { conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d },
          { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d },
          { endpoint: { url: k, properties: n, headers: n }, type: e }
        ],
        type: f
      },
      {
        conditions: [{ [v]: b, [w]: t }],
        rules: [
          {
            conditions: [{ [v]: "aws.partition", [w]: t, assign: g }],
            rules: [
              {
                conditions: [l, m],
                rules: [
                  {
                    conditions: [{ [v]: c, [w]: [a, o] }, q],
                    rules: [
                      {
                        endpoint: {
                          url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                          properties: n,
                          headers: n
                        },
                        type: e
                      }
                    ],
                    type: f
                  },
                  { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }
                ],
                type: f
              },
              {
                conditions: r,
                rules: [
                  {
                    conditions: [{ [v]: c, [w]: [o, a] }],
                    rules: [
                      {
                        conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }],
                        endpoint: { url: "https://oidc.{Region}.amazonaws.com", properties: n, headers: n },
                        type: e
                      },
                      {
                        endpoint: {
                          url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}",
                          properties: n,
                          headers: n
                        },
                        type: e
                      }
                    ],
                    type: f
                  },
                  { error: "FIPS is enabled but this partition does not support FIPS", type: d }
                ],
                type: f
              },
              {
                conditions: s,
                rules: [
                  {
                    conditions: [q],
                    rules: [
                      {
                        endpoint: {
                          url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}",
                          properties: n,
                          headers: n
                        },
                        type: e
                      }
                    ],
                    type: f
                  },
                  { error: "DualStack is enabled but this partition does not support DualStack", type: d }
                ],
                type: f
              },
              {
                endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n },
                type: e
              }
            ],
            type: f
          }
        ],
        type: f
      },
      { error: "Invalid Configuration: Missing Region", type: d }
    ]
  };
  exports.ruleSet = _data;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/endpoint/endpointResolver.js
var require_endpointResolver2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultEndpointResolver = undefined;
  var util_endpoints_1 = require_dist_cjs39();
  var util_endpoints_2 = require_dist_cjs36();
  var ruleset_1 = require_ruleset2();
  var cache2 = new util_endpoints_2.EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
  });
  var defaultEndpointResolver = (endpointParams, context = {}) => {
    return cache2.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
      endpointParams,
      logger: context.logger
    }));
  };
  exports.defaultEndpointResolver = defaultEndpointResolver;
  util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/models/SSOOIDCServiceException.js
var require_SSOOIDCServiceException = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SSOOIDCServiceException = exports.__ServiceException = undefined;
  var smithy_client_1 = require_dist_cjs22();
  Object.defineProperty(exports, "__ServiceException", { enumerable: true, get: function() {
    return smithy_client_1.ServiceException;
  } });

  class SSOOIDCServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, SSOOIDCServiceException.prototype);
    }
  }
  exports.SSOOIDCServiceException = SSOOIDCServiceException;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/models/errors.js
var require_errors6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnsupportedGrantTypeException = exports.UnauthorizedClientException = exports.SlowDownException = exports.InvalidScopeException = exports.InvalidRequestException = exports.InvalidGrantException = exports.InvalidClientException = exports.InternalServerException = exports.ExpiredTokenException = exports.AuthorizationPendingException = exports.AccessDeniedException = undefined;
  var SSOOIDCServiceException_1 = require_SSOOIDCServiceException();

  class AccessDeniedException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    name = "AccessDeniedException";
    $fault = "client";
    error;
    reason;
    error_description;
    constructor(opts) {
      super({
        name: "AccessDeniedException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, AccessDeniedException.prototype);
      this.error = opts.error;
      this.reason = opts.reason;
      this.error_description = opts.error_description;
    }
  }
  exports.AccessDeniedException = AccessDeniedException;

  class AuthorizationPendingException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    name = "AuthorizationPendingException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "AuthorizationPendingException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, AuthorizationPendingException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }
  exports.AuthorizationPendingException = AuthorizationPendingException;

  class ExpiredTokenException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    name = "ExpiredTokenException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "ExpiredTokenException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ExpiredTokenException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }
  exports.ExpiredTokenException = ExpiredTokenException;

  class InternalServerException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    name = "InternalServerException";
    $fault = "server";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "InternalServerException",
        $fault: "server",
        ...opts
      });
      Object.setPrototypeOf(this, InternalServerException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }
  exports.InternalServerException = InternalServerException;

  class InvalidClientException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    name = "InvalidClientException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "InvalidClientException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidClientException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }
  exports.InvalidClientException = InvalidClientException;

  class InvalidGrantException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    name = "InvalidGrantException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "InvalidGrantException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidGrantException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }
  exports.InvalidGrantException = InvalidGrantException;

  class InvalidRequestException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    name = "InvalidRequestException";
    $fault = "client";
    error;
    reason;
    error_description;
    constructor(opts) {
      super({
        name: "InvalidRequestException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidRequestException.prototype);
      this.error = opts.error;
      this.reason = opts.reason;
      this.error_description = opts.error_description;
    }
  }
  exports.InvalidRequestException = InvalidRequestException;

  class InvalidScopeException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    name = "InvalidScopeException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "InvalidScopeException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidScopeException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }
  exports.InvalidScopeException = InvalidScopeException;

  class SlowDownException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    name = "SlowDownException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "SlowDownException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, SlowDownException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }
  exports.SlowDownException = SlowDownException;

  class UnauthorizedClientException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    name = "UnauthorizedClientException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "UnauthorizedClientException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, UnauthorizedClientException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }
  exports.UnauthorizedClientException = UnauthorizedClientException;

  class UnsupportedGrantTypeException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    name = "UnsupportedGrantTypeException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "UnsupportedGrantTypeException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, UnsupportedGrantTypeException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }
  exports.UnsupportedGrantTypeException = UnsupportedGrantTypeException;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/schemas/schemas_0.js
var require_schemas_02 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateToken$ = exports.CreateTokenResponse$ = exports.CreateTokenRequest$ = exports.errorTypeRegistries = exports.UnsupportedGrantTypeException$ = exports.UnauthorizedClientException$ = exports.SlowDownException$ = exports.InvalidScopeException$ = exports.InvalidRequestException$ = exports.InvalidGrantException$ = exports.InvalidClientException$ = exports.InternalServerException$ = exports.ExpiredTokenException$ = exports.AuthorizationPendingException$ = exports.AccessDeniedException$ = exports.SSOOIDCServiceException$ = undefined;
  var _ADE = "AccessDeniedException";
  var _APE = "AuthorizationPendingException";
  var _AT = "AccessToken";
  var _CS = "ClientSecret";
  var _CT = "CreateToken";
  var _CTR = "CreateTokenRequest";
  var _CTRr = "CreateTokenResponse";
  var _CV = "CodeVerifier";
  var _ETE = "ExpiredTokenException";
  var _ICE = "InvalidClientException";
  var _IGE = "InvalidGrantException";
  var _IRE = "InvalidRequestException";
  var _ISE = "InternalServerException";
  var _ISEn = "InvalidScopeException";
  var _IT = "IdToken";
  var _RT = "RefreshToken";
  var _SDE = "SlowDownException";
  var _UCE = "UnauthorizedClientException";
  var _UGTE = "UnsupportedGrantTypeException";
  var _aT = "accessToken";
  var _c = "client";
  var _cI = "clientId";
  var _cS = "clientSecret";
  var _cV = "codeVerifier";
  var _co = "code";
  var _dC = "deviceCode";
  var _e = "error";
  var _eI = "expiresIn";
  var _ed = "error_description";
  var _gT = "grantType";
  var _h = "http";
  var _hE = "httpError";
  var _iT = "idToken";
  var _r = "reason";
  var _rT = "refreshToken";
  var _rU = "redirectUri";
  var _s = "smithy.ts.sdk.synthetic.com.amazonaws.ssooidc";
  var _sc = "scope";
  var _se = "server";
  var _tT = "tokenType";
  var n0 = "com.amazonaws.ssooidc";
  var schema_1 = require_schema();
  var errors_1 = require_errors6();
  var SSOOIDCServiceException_1 = require_SSOOIDCServiceException();
  var _s_registry = schema_1.TypeRegistry.for(_s);
  exports.SSOOIDCServiceException$ = [-3, _s, "SSOOIDCServiceException", 0, [], []];
  _s_registry.registerError(exports.SSOOIDCServiceException$, SSOOIDCServiceException_1.SSOOIDCServiceException);
  var n0_registry = schema_1.TypeRegistry.for(n0);
  exports.AccessDeniedException$ = [
    -3,
    n0,
    _ADE,
    { [_e]: _c, [_hE]: 400 },
    [_e, _r, _ed],
    [0, 0, 0]
  ];
  n0_registry.registerError(exports.AccessDeniedException$, errors_1.AccessDeniedException);
  exports.AuthorizationPendingException$ = [
    -3,
    n0,
    _APE,
    { [_e]: _c, [_hE]: 400 },
    [_e, _ed],
    [0, 0]
  ];
  n0_registry.registerError(exports.AuthorizationPendingException$, errors_1.AuthorizationPendingException);
  exports.ExpiredTokenException$ = [-3, n0, _ETE, { [_e]: _c, [_hE]: 400 }, [_e, _ed], [0, 0]];
  n0_registry.registerError(exports.ExpiredTokenException$, errors_1.ExpiredTokenException);
  exports.InternalServerException$ = [-3, n0, _ISE, { [_e]: _se, [_hE]: 500 }, [_e, _ed], [0, 0]];
  n0_registry.registerError(exports.InternalServerException$, errors_1.InternalServerException);
  exports.InvalidClientException$ = [-3, n0, _ICE, { [_e]: _c, [_hE]: 401 }, [_e, _ed], [0, 0]];
  n0_registry.registerError(exports.InvalidClientException$, errors_1.InvalidClientException);
  exports.InvalidGrantException$ = [-3, n0, _IGE, { [_e]: _c, [_hE]: 400 }, [_e, _ed], [0, 0]];
  n0_registry.registerError(exports.InvalidGrantException$, errors_1.InvalidGrantException);
  exports.InvalidRequestException$ = [
    -3,
    n0,
    _IRE,
    { [_e]: _c, [_hE]: 400 },
    [_e, _r, _ed],
    [0, 0, 0]
  ];
  n0_registry.registerError(exports.InvalidRequestException$, errors_1.InvalidRequestException);
  exports.InvalidScopeException$ = [-3, n0, _ISEn, { [_e]: _c, [_hE]: 400 }, [_e, _ed], [0, 0]];
  n0_registry.registerError(exports.InvalidScopeException$, errors_1.InvalidScopeException);
  exports.SlowDownException$ = [-3, n0, _SDE, { [_e]: _c, [_hE]: 400 }, [_e, _ed], [0, 0]];
  n0_registry.registerError(exports.SlowDownException$, errors_1.SlowDownException);
  exports.UnauthorizedClientException$ = [
    -3,
    n0,
    _UCE,
    { [_e]: _c, [_hE]: 400 },
    [_e, _ed],
    [0, 0]
  ];
  n0_registry.registerError(exports.UnauthorizedClientException$, errors_1.UnauthorizedClientException);
  exports.UnsupportedGrantTypeException$ = [
    -3,
    n0,
    _UGTE,
    { [_e]: _c, [_hE]: 400 },
    [_e, _ed],
    [0, 0]
  ];
  n0_registry.registerError(exports.UnsupportedGrantTypeException$, errors_1.UnsupportedGrantTypeException);
  exports.errorTypeRegistries = [_s_registry, n0_registry];
  var AccessToken = [0, n0, _AT, 8, 0];
  var ClientSecret = [0, n0, _CS, 8, 0];
  var CodeVerifier = [0, n0, _CV, 8, 0];
  var IdToken = [0, n0, _IT, 8, 0];
  var RefreshToken = [0, n0, _RT, 8, 0];
  exports.CreateTokenRequest$ = [
    3,
    n0,
    _CTR,
    0,
    [_cI, _cS, _gT, _dC, _co, _rT, _sc, _rU, _cV],
    [0, [() => ClientSecret, 0], 0, 0, 0, [() => RefreshToken, 0], 64 | 0, 0, [() => CodeVerifier, 0]],
    3
  ];
  exports.CreateTokenResponse$ = [
    3,
    n0,
    _CTRr,
    0,
    [_aT, _tT, _eI, _rT, _iT],
    [[() => AccessToken, 0], 0, 1, [() => RefreshToken, 0], [() => IdToken, 0]]
  ];
  var Scopes = 64 | 0;
  exports.CreateToken$ = [
    9,
    n0,
    _CT,
    { [_h]: ["POST", "/token", 200] },
    () => exports.CreateTokenRequest$,
    () => exports.CreateTokenResponse$
  ];
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/runtimeConfig.shared.js
var require_runtimeConfig_shared = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var core_1 = require_dist_cjs24();
  var protocols_1 = require_protocols2();
  var core_2 = require_dist_cjs17();
  var smithy_client_1 = require_dist_cjs22();
  var url_parser_1 = require_dist_cjs38();
  var util_base64_1 = require_dist_cjs9();
  var util_utf8_1 = require_dist_cjs8();
  var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider2();
  var endpointResolver_1 = require_endpointResolver2();
  var schemas_0_1 = require_schemas_02();
  var getRuntimeConfig = (config) => {
    return {
      apiVersion: "2019-06-10",
      base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
      base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
      disableHostPrefix: config?.disableHostPrefix ?? false,
      endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
      extensions: config?.extensions ?? [],
      httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultSSOOIDCHttpAuthSchemeProvider,
      httpAuthSchemes: config?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
          signer: new core_1.AwsSdkSigV4Signer
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new core_2.NoAuthSigner
        }
      ],
      logger: config?.logger ?? new smithy_client_1.NoOpLogger,
      protocol: config?.protocol ?? protocols_1.AwsRestJsonProtocol,
      protocolSettings: config?.protocolSettings ?? {
        defaultNamespace: "com.amazonaws.ssooidc",
        errorTypeRegistries: schemas_0_1.errorTypeRegistries,
        version: "2019-06-10",
        serviceTarget: "AWSSSOOIDCService"
      },
      serviceId: config?.serviceId ?? "SSO OIDC",
      urlParser: config?.urlParser ?? url_parser_1.parseUrl,
      utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
      utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/runtimeConfig.js
var require_runtimeConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var tslib_1 = require_tslib();
  var package_json_1 = tslib_1.__importDefault(require_package5());
  var core_1 = require_dist_cjs24();
  var util_user_agent_node_1 = require_dist_cjs54();
  var config_resolver_1 = require_dist_cjs41();
  var hash_node_1 = require_dist_cjs55();
  var middleware_retry_1 = require_dist_cjs49();
  var node_config_provider_1 = require_dist_cjs45();
  var node_http_handler_1 = require_dist_cjs12();
  var smithy_client_1 = require_dist_cjs22();
  var util_body_length_node_1 = require_dist_cjs56();
  var util_defaults_mode_node_1 = require_dist_cjs57();
  var util_retry_1 = require_dist_cjs48();
  var runtimeConfig_shared_1 = require_runtimeConfig_shared();
  var getRuntimeConfig = (config) => {
    (0, smithy_client_1.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    const loaderConfig = {
      profile: config?.profile,
      logger: clientSharedValues.logger
    };
    return {
      ...clientSharedValues,
      ...config,
      runtime: "node",
      defaultsMode,
      authSchemePreference: config?.authSchemePreference ?? (0, node_config_provider_1.loadConfig)(core_1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
      bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
      defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
      maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
      region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
      requestHandler: node_http_handler_1.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
      retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
        default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
      }, config),
      sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
      streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
      useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
      useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
      userAgentAppId: config?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/region-config-resolver/dist-cjs/regionConfig/stsRegionDefaultResolver.js
var require_stsRegionDefaultResolver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.warning = undefined;
  exports.stsRegionDefaultResolver = stsRegionDefaultResolver;
  var config_resolver_1 = require_dist_cjs41();
  var node_config_provider_1 = require_dist_cjs45();
  function stsRegionDefaultResolver(loaderConfig = {}) {
    return (0, node_config_provider_1.loadConfig)({
      ...config_resolver_1.NODE_REGION_CONFIG_OPTIONS,
      async default() {
        if (!exports.warning.silence) {
          console.warn("@aws-sdk - WARN - default STS region of us-east-1 used. See @aws-sdk/credential-providers README and set a region explicitly.");
        }
        return "us-east-1";
      }
    }, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig });
  }
  exports.warning = {
    silence: false
  };
});

// node_modules/@aws-sdk/region-config-resolver/dist-cjs/index.js
var require_dist_cjs58 = __commonJS((exports) => {
  var stsRegionDefaultResolver = require_stsRegionDefaultResolver();
  var configResolver = require_dist_cjs41();
  var getAwsRegionExtensionConfiguration = (runtimeConfig) => {
    return {
      setRegion(region) {
        runtimeConfig.region = region;
      },
      region() {
        return runtimeConfig.region;
      }
    };
  };
  var resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
    return {
      region: awsRegionExtensionConfiguration.region()
    };
  };
  exports.NODE_REGION_CONFIG_FILE_OPTIONS = configResolver.NODE_REGION_CONFIG_FILE_OPTIONS;
  exports.NODE_REGION_CONFIG_OPTIONS = configResolver.NODE_REGION_CONFIG_OPTIONS;
  exports.REGION_ENV_NAME = configResolver.REGION_ENV_NAME;
  exports.REGION_INI_NAME = configResolver.REGION_INI_NAME;
  exports.resolveRegionConfig = configResolver.resolveRegionConfig;
  exports.getAwsRegionExtensionConfiguration = getAwsRegionExtensionConfiguration;
  exports.resolveAwsRegionExtensionConfiguration = resolveAwsRegionExtensionConfiguration;
  Object.prototype.hasOwnProperty.call(stsRegionDefaultResolver, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: stsRegionDefaultResolver["__proto__"]
  });
  Object.keys(stsRegionDefaultResolver).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = stsRegionDefaultResolver[k];
  });
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/index.js
var require_sso_oidc = __commonJS((exports) => {
  var middlewareHostHeader = require_dist_cjs30();
  var middlewareLogger = require_dist_cjs31();
  var middlewareRecursionDetection = require_dist_cjs32();
  var middlewareUserAgent = require_dist_cjs40();
  var configResolver = require_dist_cjs41();
  var core = require_dist_cjs17();
  var schema = require_schema();
  var middlewareContentLength = require_dist_cjs43();
  var middlewareEndpoint = require_dist_cjs46();
  var middlewareRetry = require_dist_cjs49();
  var smithyClient = require_dist_cjs22();
  var httpAuthSchemeProvider = require_httpAuthSchemeProvider2();
  var runtimeConfig = require_runtimeConfig();
  var regionConfigResolver = require_dist_cjs58();
  var protocolHttp = require_dist_cjs2();
  var schemas_0 = require_schemas_02();
  var errors = require_errors6();
  var SSOOIDCServiceException = require_SSOOIDCServiceException();
  var resolveClientEndpointParameters = (options) => {
    return Object.assign(options, {
      useDualstackEndpoint: options.useDualstackEndpoint ?? false,
      useFipsEndpoint: options.useFipsEndpoint ?? false,
      defaultSigningName: "sso-oauth"
    });
  };
  var commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };
  var getHttpAuthExtensionConfiguration = (runtimeConfig2) => {
    const _httpAuthSchemes = runtimeConfig2.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig2.httpAuthSchemeProvider;
    let _credentials = runtimeConfig2.credentials;
    return {
      setHttpAuthScheme(httpAuthScheme) {
        const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
        if (index === -1) {
          _httpAuthSchemes.push(httpAuthScheme);
        } else {
          _httpAuthSchemes.splice(index, 1, httpAuthScheme);
        }
      },
      httpAuthSchemes() {
        return _httpAuthSchemes;
      },
      setHttpAuthSchemeProvider(httpAuthSchemeProvider2) {
        _httpAuthSchemeProvider = httpAuthSchemeProvider2;
      },
      httpAuthSchemeProvider() {
        return _httpAuthSchemeProvider;
      },
      setCredentials(credentials) {
        _credentials = credentials;
      },
      credentials() {
        return _credentials;
      }
    };
  };
  var resolveHttpAuthRuntimeConfig = (config) => {
    return {
      httpAuthSchemes: config.httpAuthSchemes(),
      httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
      credentials: config.credentials()
    };
  };
  var resolveRuntimeExtensions = (runtimeConfig2, extensions) => {
    const extensionConfiguration = Object.assign(regionConfigResolver.getAwsRegionExtensionConfiguration(runtimeConfig2), smithyClient.getDefaultExtensionConfiguration(runtimeConfig2), protocolHttp.getHttpHandlerExtensionConfiguration(runtimeConfig2), getHttpAuthExtensionConfiguration(runtimeConfig2));
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return Object.assign(runtimeConfig2, regionConfigResolver.resolveAwsRegionExtensionConfiguration(extensionConfiguration), smithyClient.resolveDefaultRuntimeConfig(extensionConfiguration), protocolHttp.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));
  };

  class SSOOIDCClient extends smithyClient.Client {
    config;
    constructor(...[configuration]) {
      const _config_0 = runtimeConfig.getRuntimeConfig(configuration || {});
      super(_config_0);
      this.initConfig = _config_0;
      const _config_1 = resolveClientEndpointParameters(_config_0);
      const _config_2 = middlewareUserAgent.resolveUserAgentConfig(_config_1);
      const _config_3 = middlewareRetry.resolveRetryConfig(_config_2);
      const _config_4 = configResolver.resolveRegionConfig(_config_3);
      const _config_5 = middlewareHostHeader.resolveHostHeaderConfig(_config_4);
      const _config_6 = middlewareEndpoint.resolveEndpointConfig(_config_5);
      const _config_7 = httpAuthSchemeProvider.resolveHttpAuthSchemeConfig(_config_6);
      const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
      this.config = _config_8;
      this.middlewareStack.use(schema.getSchemaSerdePlugin(this.config));
      this.middlewareStack.use(middlewareUserAgent.getUserAgentPlugin(this.config));
      this.middlewareStack.use(middlewareRetry.getRetryPlugin(this.config));
      this.middlewareStack.use(middlewareContentLength.getContentLengthPlugin(this.config));
      this.middlewareStack.use(middlewareHostHeader.getHostHeaderPlugin(this.config));
      this.middlewareStack.use(middlewareLogger.getLoggerPlugin(this.config));
      this.middlewareStack.use(middlewareRecursionDetection.getRecursionDetectionPlugin(this.config));
      this.middlewareStack.use(core.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
        httpAuthSchemeParametersProvider: httpAuthSchemeProvider.defaultSSOOIDCHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config) => new core.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config.credentials
        })
      }));
      this.middlewareStack.use(core.getHttpSigningPlugin(this.config));
    }
    destroy() {
      super.destroy();
    }
  }

  class CreateTokenCommand extends smithyClient.Command.classBuilder().ep(commonParams).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AWSSSOOIDCService", "CreateToken", {}).n("SSOOIDCClient", "CreateTokenCommand").sc(schemas_0.CreateToken$).build() {
  }
  var commands = {
    CreateTokenCommand
  };

  class SSOOIDC extends SSOOIDCClient {
  }
  smithyClient.createAggregatedClient(commands, SSOOIDC);
  var AccessDeniedExceptionReason = {
    KMS_ACCESS_DENIED: "KMS_AccessDeniedException"
  };
  var InvalidRequestExceptionReason = {
    KMS_DISABLED_KEY: "KMS_DisabledException",
    KMS_INVALID_KEY_USAGE: "KMS_InvalidKeyUsageException",
    KMS_INVALID_STATE: "KMS_InvalidStateException",
    KMS_KEY_NOT_FOUND: "KMS_NotFoundException"
  };
  exports.$Command = smithyClient.Command;
  exports.__Client = smithyClient.Client;
  exports.SSOOIDCServiceException = SSOOIDCServiceException.SSOOIDCServiceException;
  exports.AccessDeniedExceptionReason = AccessDeniedExceptionReason;
  exports.CreateTokenCommand = CreateTokenCommand;
  exports.InvalidRequestExceptionReason = InvalidRequestExceptionReason;
  exports.SSOOIDC = SSOOIDC;
  exports.SSOOIDCClient = SSOOIDCClient;
  Object.prototype.hasOwnProperty.call(schemas_0, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: schemas_0["__proto__"]
  });
  Object.keys(schemas_0).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = schemas_0[k];
  });
  Object.prototype.hasOwnProperty.call(errors, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: errors["__proto__"]
  });
  Object.keys(errors).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = errors[k];
  });
});

// node_modules/@aws-sdk/token-providers/dist-cjs/index.js
var require_dist_cjs59 = __commonJS((exports) => {
  var client3 = require_client2();
  var httpAuthSchemes = require_httpAuthSchemes();
  var propertyProvider = require_dist_cjs18();
  var sharedIniFileLoader = require_dist_cjs44();
  var fs = __require("fs");
  var fromEnvSigningName = ({ logger, signingName } = {}) => async () => {
    logger?.debug?.("@aws-sdk/token-providers - fromEnvSigningName");
    if (!signingName) {
      throw new propertyProvider.TokenProviderError("Please pass 'signingName' to compute environment variable key", { logger });
    }
    const bearerTokenKey = httpAuthSchemes.getBearerTokenEnvKey(signingName);
    if (!(bearerTokenKey in process.env)) {
      throw new propertyProvider.TokenProviderError(`Token not present in '${bearerTokenKey}' environment variable`, { logger });
    }
    const token2 = { token: process.env[bearerTokenKey] };
    client3.setTokenFeature(token2, "BEARER_SERVICE_ENV_VARS", "3");
    return token2;
  };
  var EXPIRE_WINDOW_MS = 5 * 60 * 1000;
  var REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;
  var getSsoOidcClient = async (ssoRegion, init = {}, callerClientConfig) => {
    const { SSOOIDCClient } = await Promise.resolve().then(() => __toESM(require_sso_oidc()));
    const coalesce = (prop) => init.clientConfig?.[prop] ?? init.parentClientConfig?.[prop] ?? callerClientConfig?.[prop];
    const ssoOidcClient = new SSOOIDCClient(Object.assign({}, init.clientConfig ?? {}, {
      region: ssoRegion ?? init.clientConfig?.region,
      logger: coalesce("logger"),
      userAgentAppId: coalesce("userAgentAppId")
    }));
    return ssoOidcClient;
  };
  var getNewSsoOidcToken = async (ssoToken, ssoRegion, init = {}, callerClientConfig) => {
    const { CreateTokenCommand } = await Promise.resolve().then(() => __toESM(require_sso_oidc()));
    const ssoOidcClient = await getSsoOidcClient(ssoRegion, init, callerClientConfig);
    return ssoOidcClient.send(new CreateTokenCommand({
      clientId: ssoToken.clientId,
      clientSecret: ssoToken.clientSecret,
      refreshToken: ssoToken.refreshToken,
      grantType: "refresh_token"
    }));
  };
  var validateTokenExpiry = (token2) => {
    if (token2.expiration && token2.expiration.getTime() < Date.now()) {
      throw new propertyProvider.TokenProviderError(`Token is expired. ${REFRESH_MESSAGE}`, false);
    }
  };
  var validateTokenKey = (key, value, forRefresh = false) => {
    if (typeof value === "undefined") {
      throw new propertyProvider.TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE}`, false);
    }
  };
  var { writeFile } = fs.promises;
  var writeSSOTokenToFile = (id, ssoToken) => {
    const tokenFilepath = sharedIniFileLoader.getSSOTokenFilepath(id);
    const tokenString = JSON.stringify(ssoToken, null, 2);
    return writeFile(tokenFilepath, tokenString);
  };
  var lastRefreshAttemptTime = new Date(0);
  var fromSso = (init = {}) => async ({ callerClientConfig } = {}) => {
    init.logger?.debug("@aws-sdk/token-providers - fromSso");
    const profiles = await sharedIniFileLoader.parseKnownFiles(init);
    const profileName = sharedIniFileLoader.getProfileName({
      profile: init.profile ?? callerClientConfig?.profile
    });
    const profile = profiles[profileName];
    if (!profile) {
      throw new propertyProvider.TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
    } else if (!profile["sso_session"]) {
      throw new propertyProvider.TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
    }
    const ssoSessionName = profile["sso_session"];
    const ssoSessions = await sharedIniFileLoader.loadSsoSessionData(init);
    const ssoSession = ssoSessions[ssoSessionName];
    if (!ssoSession) {
      throw new propertyProvider.TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
    }
    for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
      if (!ssoSession[ssoSessionRequiredKey]) {
        throw new propertyProvider.TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
      }
    }
    ssoSession["sso_start_url"];
    const ssoRegion = ssoSession["sso_region"];
    let ssoToken;
    try {
      ssoToken = await sharedIniFileLoader.getSSOTokenFromFile(ssoSessionName);
    } catch (e) {
      throw new propertyProvider.TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE}`, false);
    }
    validateTokenKey("accessToken", ssoToken.accessToken);
    validateTokenKey("expiresAt", ssoToken.expiresAt);
    const { accessToken, expiresAt } = ssoToken;
    const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
    if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS) {
      return existingToken;
    }
    if (Date.now() - lastRefreshAttemptTime.getTime() < 30000) {
      validateTokenExpiry(existingToken);
      return existingToken;
    }
    validateTokenKey("clientId", ssoToken.clientId, true);
    validateTokenKey("clientSecret", ssoToken.clientSecret, true);
    validateTokenKey("refreshToken", ssoToken.refreshToken, true);
    try {
      lastRefreshAttemptTime.setTime(Date.now());
      const newSsoOidcToken = await getNewSsoOidcToken(ssoToken, ssoRegion, init, callerClientConfig);
      validateTokenKey("accessToken", newSsoOidcToken.accessToken);
      validateTokenKey("expiresIn", newSsoOidcToken.expiresIn);
      const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1000);
      try {
        await writeSSOTokenToFile(ssoSessionName, {
          ...ssoToken,
          accessToken: newSsoOidcToken.accessToken,
          expiresAt: newTokenExpiration.toISOString(),
          refreshToken: newSsoOidcToken.refreshToken
        });
      } catch (error) {}
      return {
        token: newSsoOidcToken.accessToken,
        expiration: newTokenExpiration
      };
    } catch (error) {
      validateTokenExpiry(existingToken);
      return existingToken;
    }
  };
  var fromStatic = ({ token: token2, logger }) => async () => {
    logger?.debug("@aws-sdk/token-providers - fromStatic");
    if (!token2 || !token2.token) {
      throw new propertyProvider.TokenProviderError(`Please pass a valid token to fromStatic`, false);
    }
    return token2;
  };
  var nodeProvider = (init = {}) => propertyProvider.memoize(propertyProvider.chain(fromSso(init), async () => {
    throw new propertyProvider.TokenProviderError("Could not load token from any providers", false);
  }), (token2) => token2.expiration !== undefined && token2.expiration.getTime() - Date.now() < 300000, (token2) => token2.expiration !== undefined);
  exports.fromEnvSigningName = fromEnvSigningName;
  exports.fromSso = fromSso;
  exports.fromStatic = fromStatic;
  exports.nodeProvider = nodeProvider;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveHttpAuthSchemeConfig = exports.defaultSSOHttpAuthSchemeProvider = exports.defaultSSOHttpAuthSchemeParametersProvider = undefined;
  var core_1 = require_dist_cjs24();
  var util_middleware_1 = require_dist_cjs4();
  var defaultSSOHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
      operation: (0, util_middleware_1.getSmithyContext)(context).operation,
      region: await (0, util_middleware_1.normalizeProvider)(config.region)() || (() => {
        throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
      })()
    };
  };
  exports.defaultSSOHttpAuthSchemeParametersProvider = defaultSSOHttpAuthSchemeParametersProvider;
  function createAwsAuthSigv4HttpAuthOption(authParameters) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "awsssoportal",
        region: authParameters.region
      },
      propertiesExtractor: (config, context) => ({
        signingProperties: {
          config,
          context
        }
      })
    };
  }
  function createSmithyApiNoAuthHttpAuthOption(authParameters) {
    return {
      schemeId: "smithy.api#noAuth"
    };
  }
  var defaultSSOHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
      case "GetRoleCredentials": {
        options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
        break;
      }
      default: {
        options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
      }
    }
    return options;
  };
  exports.defaultSSOHttpAuthSchemeProvider = defaultSSOHttpAuthSchemeProvider;
  var resolveHttpAuthSchemeConfig = (config) => {
    const config_0 = (0, core_1.resolveAwsSdkSigV4Config)(config);
    return Object.assign(config_0, {
      authSchemePreference: (0, util_middleware_1.normalizeProvider)(config.authSchemePreference ?? [])
    });
  };
  exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso/endpoint/ruleset.js
var require_ruleset3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ruleSet = undefined;
  var u = "required";
  var v = "fn";
  var w = "argv";
  var x = "ref";
  var a = true;
  var b = "isSet";
  var c = "booleanEquals";
  var d = "error";
  var e = "endpoint";
  var f = "tree";
  var g = "PartitionResult";
  var h = "getAttr";
  var i2 = { [u]: false, type: "string" };
  var j = { [u]: true, default: false, type: "boolean" };
  var k = { [x]: "Endpoint" };
  var l = { [v]: c, [w]: [{ [x]: "UseFIPS" }, true] };
  var m = { [v]: c, [w]: [{ [x]: "UseDualStack" }, true] };
  var n = {};
  var o = { [v]: h, [w]: [{ [x]: g }, "supportsFIPS"] };
  var p = { [x]: g };
  var q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] };
  var r = [l];
  var s = [m];
  var t = [{ [x]: "Region" }];
  var _data = {
    version: "1.0",
    parameters: { Region: i2, UseDualStack: j, UseFIPS: j, Endpoint: i2 },
    rules: [
      {
        conditions: [{ [v]: b, [w]: [k] }],
        rules: [
          { conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d },
          { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d },
          { endpoint: { url: k, properties: n, headers: n }, type: e }
        ],
        type: f
      },
      {
        conditions: [{ [v]: b, [w]: t }],
        rules: [
          {
            conditions: [{ [v]: "aws.partition", [w]: t, assign: g }],
            rules: [
              {
                conditions: [l, m],
                rules: [
                  {
                    conditions: [{ [v]: c, [w]: [a, o] }, q],
                    rules: [
                      {
                        endpoint: {
                          url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                          properties: n,
                          headers: n
                        },
                        type: e
                      }
                    ],
                    type: f
                  },
                  { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }
                ],
                type: f
              },
              {
                conditions: r,
                rules: [
                  {
                    conditions: [{ [v]: c, [w]: [o, a] }],
                    rules: [
                      {
                        conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }],
                        endpoint: { url: "https://portal.sso.{Region}.amazonaws.com", properties: n, headers: n },
                        type: e
                      },
                      {
                        endpoint: {
                          url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}",
                          properties: n,
                          headers: n
                        },
                        type: e
                      }
                    ],
                    type: f
                  },
                  { error: "FIPS is enabled but this partition does not support FIPS", type: d }
                ],
                type: f
              },
              {
                conditions: s,
                rules: [
                  {
                    conditions: [q],
                    rules: [
                      {
                        endpoint: {
                          url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}",
                          properties: n,
                          headers: n
                        },
                        type: e
                      }
                    ],
                    type: f
                  },
                  { error: "DualStack is enabled but this partition does not support DualStack", type: d }
                ],
                type: f
              },
              {
                endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n },
                type: e
              }
            ],
            type: f
          }
        ],
        type: f
      },
      { error: "Invalid Configuration: Missing Region", type: d }
    ]
  };
  exports.ruleSet = _data;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso/endpoint/endpointResolver.js
var require_endpointResolver3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultEndpointResolver = undefined;
  var util_endpoints_1 = require_dist_cjs39();
  var util_endpoints_2 = require_dist_cjs36();
  var ruleset_1 = require_ruleset3();
  var cache2 = new util_endpoints_2.EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
  });
  var defaultEndpointResolver = (endpointParams, context = {}) => {
    return cache2.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
      endpointParams,
      logger: context.logger
    }));
  };
  exports.defaultEndpointResolver = defaultEndpointResolver;
  util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso/models/SSOServiceException.js
var require_SSOServiceException = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SSOServiceException = exports.__ServiceException = undefined;
  var smithy_client_1 = require_dist_cjs22();
  Object.defineProperty(exports, "__ServiceException", { enumerable: true, get: function() {
    return smithy_client_1.ServiceException;
  } });

  class SSOServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, SSOServiceException.prototype);
    }
  }
  exports.SSOServiceException = SSOServiceException;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso/models/errors.js
var require_errors7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnauthorizedException = exports.TooManyRequestsException = exports.ResourceNotFoundException = exports.InvalidRequestException = undefined;
  var SSOServiceException_1 = require_SSOServiceException();

  class InvalidRequestException extends SSOServiceException_1.SSOServiceException {
    name = "InvalidRequestException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "InvalidRequestException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidRequestException.prototype);
    }
  }
  exports.InvalidRequestException = InvalidRequestException;

  class ResourceNotFoundException extends SSOServiceException_1.SSOServiceException {
    name = "ResourceNotFoundException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ResourceNotFoundException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
  }
  exports.ResourceNotFoundException = ResourceNotFoundException;

  class TooManyRequestsException extends SSOServiceException_1.SSOServiceException {
    name = "TooManyRequestsException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "TooManyRequestsException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, TooManyRequestsException.prototype);
    }
  }
  exports.TooManyRequestsException = TooManyRequestsException;

  class UnauthorizedException extends SSOServiceException_1.SSOServiceException {
    name = "UnauthorizedException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "UnauthorizedException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, UnauthorizedException.prototype);
    }
  }
  exports.UnauthorizedException = UnauthorizedException;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso/schemas/schemas_0.js
var require_schemas_03 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetRoleCredentials$ = exports.RoleCredentials$ = exports.GetRoleCredentialsResponse$ = exports.GetRoleCredentialsRequest$ = exports.errorTypeRegistries = exports.UnauthorizedException$ = exports.TooManyRequestsException$ = exports.ResourceNotFoundException$ = exports.InvalidRequestException$ = exports.SSOServiceException$ = undefined;
  var _ATT = "AccessTokenType";
  var _GRC = "GetRoleCredentials";
  var _GRCR = "GetRoleCredentialsRequest";
  var _GRCRe = "GetRoleCredentialsResponse";
  var _IRE = "InvalidRequestException";
  var _RC = "RoleCredentials";
  var _RNFE = "ResourceNotFoundException";
  var _SAKT = "SecretAccessKeyType";
  var _STT = "SessionTokenType";
  var _TMRE = "TooManyRequestsException";
  var _UE = "UnauthorizedException";
  var _aI = "accountId";
  var _aKI = "accessKeyId";
  var _aT = "accessToken";
  var _ai = "account_id";
  var _c = "client";
  var _e = "error";
  var _ex = "expiration";
  var _h = "http";
  var _hE = "httpError";
  var _hH = "httpHeader";
  var _hQ = "httpQuery";
  var _m = "message";
  var _rC = "roleCredentials";
  var _rN = "roleName";
  var _rn = "role_name";
  var _s = "smithy.ts.sdk.synthetic.com.amazonaws.sso";
  var _sAK = "secretAccessKey";
  var _sT = "sessionToken";
  var _xasbt = "x-amz-sso_bearer_token";
  var n0 = "com.amazonaws.sso";
  var schema_1 = require_schema();
  var errors_1 = require_errors7();
  var SSOServiceException_1 = require_SSOServiceException();
  var _s_registry = schema_1.TypeRegistry.for(_s);
  exports.SSOServiceException$ = [-3, _s, "SSOServiceException", 0, [], []];
  _s_registry.registerError(exports.SSOServiceException$, SSOServiceException_1.SSOServiceException);
  var n0_registry = schema_1.TypeRegistry.for(n0);
  exports.InvalidRequestException$ = [-3, n0, _IRE, { [_e]: _c, [_hE]: 400 }, [_m], [0]];
  n0_registry.registerError(exports.InvalidRequestException$, errors_1.InvalidRequestException);
  exports.ResourceNotFoundException$ = [-3, n0, _RNFE, { [_e]: _c, [_hE]: 404 }, [_m], [0]];
  n0_registry.registerError(exports.ResourceNotFoundException$, errors_1.ResourceNotFoundException);
  exports.TooManyRequestsException$ = [-3, n0, _TMRE, { [_e]: _c, [_hE]: 429 }, [_m], [0]];
  n0_registry.registerError(exports.TooManyRequestsException$, errors_1.TooManyRequestsException);
  exports.UnauthorizedException$ = [-3, n0, _UE, { [_e]: _c, [_hE]: 401 }, [_m], [0]];
  n0_registry.registerError(exports.UnauthorizedException$, errors_1.UnauthorizedException);
  exports.errorTypeRegistries = [_s_registry, n0_registry];
  var AccessTokenType = [0, n0, _ATT, 8, 0];
  var SecretAccessKeyType = [0, n0, _SAKT, 8, 0];
  var SessionTokenType = [0, n0, _STT, 8, 0];
  exports.GetRoleCredentialsRequest$ = [
    3,
    n0,
    _GRCR,
    0,
    [_rN, _aI, _aT],
    [
      [0, { [_hQ]: _rn }],
      [0, { [_hQ]: _ai }],
      [() => AccessTokenType, { [_hH]: _xasbt }]
    ],
    3
  ];
  exports.GetRoleCredentialsResponse$ = [
    3,
    n0,
    _GRCRe,
    0,
    [_rC],
    [[() => exports.RoleCredentials$, 0]]
  ];
  exports.RoleCredentials$ = [
    3,
    n0,
    _RC,
    0,
    [_aKI, _sAK, _sT, _ex],
    [0, [() => SecretAccessKeyType, 0], [() => SessionTokenType, 0], 1]
  ];
  exports.GetRoleCredentials$ = [
    9,
    n0,
    _GRC,
    { [_h]: ["GET", "/federation/credentials", 200] },
    () => exports.GetRoleCredentialsRequest$,
    () => exports.GetRoleCredentialsResponse$
  ];
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso/runtimeConfig.shared.js
var require_runtimeConfig_shared2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var core_1 = require_dist_cjs24();
  var protocols_1 = require_protocols2();
  var core_2 = require_dist_cjs17();
  var smithy_client_1 = require_dist_cjs22();
  var url_parser_1 = require_dist_cjs38();
  var util_base64_1 = require_dist_cjs9();
  var util_utf8_1 = require_dist_cjs8();
  var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider3();
  var endpointResolver_1 = require_endpointResolver3();
  var schemas_0_1 = require_schemas_03();
  var getRuntimeConfig = (config) => {
    return {
      apiVersion: "2019-06-10",
      base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
      base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
      disableHostPrefix: config?.disableHostPrefix ?? false,
      endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
      extensions: config?.extensions ?? [],
      httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultSSOHttpAuthSchemeProvider,
      httpAuthSchemes: config?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
          signer: new core_1.AwsSdkSigV4Signer
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new core_2.NoAuthSigner
        }
      ],
      logger: config?.logger ?? new smithy_client_1.NoOpLogger,
      protocol: config?.protocol ?? protocols_1.AwsRestJsonProtocol,
      protocolSettings: config?.protocolSettings ?? {
        defaultNamespace: "com.amazonaws.sso",
        errorTypeRegistries: schemas_0_1.errorTypeRegistries,
        version: "2019-06-10",
        serviceTarget: "SWBPortalService"
      },
      serviceId: config?.serviceId ?? "SSO",
      urlParser: config?.urlParser ?? url_parser_1.parseUrl,
      utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
      utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso/runtimeConfig.js
var require_runtimeConfig2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var tslib_1 = require_tslib();
  var package_json_1 = tslib_1.__importDefault(require_package5());
  var core_1 = require_dist_cjs24();
  var util_user_agent_node_1 = require_dist_cjs54();
  var config_resolver_1 = require_dist_cjs41();
  var hash_node_1 = require_dist_cjs55();
  var middleware_retry_1 = require_dist_cjs49();
  var node_config_provider_1 = require_dist_cjs45();
  var node_http_handler_1 = require_dist_cjs12();
  var smithy_client_1 = require_dist_cjs22();
  var util_body_length_node_1 = require_dist_cjs56();
  var util_defaults_mode_node_1 = require_dist_cjs57();
  var util_retry_1 = require_dist_cjs48();
  var runtimeConfig_shared_1 = require_runtimeConfig_shared2();
  var getRuntimeConfig = (config) => {
    (0, smithy_client_1.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    const loaderConfig = {
      profile: config?.profile,
      logger: clientSharedValues.logger
    };
    return {
      ...clientSharedValues,
      ...config,
      runtime: "node",
      defaultsMode,
      authSchemePreference: config?.authSchemePreference ?? (0, node_config_provider_1.loadConfig)(core_1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
      bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
      defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
      maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
      region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
      requestHandler: node_http_handler_1.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
      retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
        default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
      }, config),
      sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
      streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
      useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
      useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
      userAgentAppId: config?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso/index.js
var require_sso = __commonJS((exports) => {
  var middlewareHostHeader = require_dist_cjs30();
  var middlewareLogger = require_dist_cjs31();
  var middlewareRecursionDetection = require_dist_cjs32();
  var middlewareUserAgent = require_dist_cjs40();
  var configResolver = require_dist_cjs41();
  var core = require_dist_cjs17();
  var schema = require_schema();
  var middlewareContentLength = require_dist_cjs43();
  var middlewareEndpoint = require_dist_cjs46();
  var middlewareRetry = require_dist_cjs49();
  var smithyClient = require_dist_cjs22();
  var httpAuthSchemeProvider = require_httpAuthSchemeProvider3();
  var runtimeConfig = require_runtimeConfig2();
  var regionConfigResolver = require_dist_cjs58();
  var protocolHttp = require_dist_cjs2();
  var schemas_0 = require_schemas_03();
  var errors = require_errors7();
  var SSOServiceException = require_SSOServiceException();
  var resolveClientEndpointParameters = (options) => {
    return Object.assign(options, {
      useDualstackEndpoint: options.useDualstackEndpoint ?? false,
      useFipsEndpoint: options.useFipsEndpoint ?? false,
      defaultSigningName: "awsssoportal"
    });
  };
  var commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };
  var getHttpAuthExtensionConfiguration = (runtimeConfig2) => {
    const _httpAuthSchemes = runtimeConfig2.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig2.httpAuthSchemeProvider;
    let _credentials = runtimeConfig2.credentials;
    return {
      setHttpAuthScheme(httpAuthScheme) {
        const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
        if (index === -1) {
          _httpAuthSchemes.push(httpAuthScheme);
        } else {
          _httpAuthSchemes.splice(index, 1, httpAuthScheme);
        }
      },
      httpAuthSchemes() {
        return _httpAuthSchemes;
      },
      setHttpAuthSchemeProvider(httpAuthSchemeProvider2) {
        _httpAuthSchemeProvider = httpAuthSchemeProvider2;
      },
      httpAuthSchemeProvider() {
        return _httpAuthSchemeProvider;
      },
      setCredentials(credentials) {
        _credentials = credentials;
      },
      credentials() {
        return _credentials;
      }
    };
  };
  var resolveHttpAuthRuntimeConfig = (config) => {
    return {
      httpAuthSchemes: config.httpAuthSchemes(),
      httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
      credentials: config.credentials()
    };
  };
  var resolveRuntimeExtensions = (runtimeConfig2, extensions) => {
    const extensionConfiguration = Object.assign(regionConfigResolver.getAwsRegionExtensionConfiguration(runtimeConfig2), smithyClient.getDefaultExtensionConfiguration(runtimeConfig2), protocolHttp.getHttpHandlerExtensionConfiguration(runtimeConfig2), getHttpAuthExtensionConfiguration(runtimeConfig2));
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return Object.assign(runtimeConfig2, regionConfigResolver.resolveAwsRegionExtensionConfiguration(extensionConfiguration), smithyClient.resolveDefaultRuntimeConfig(extensionConfiguration), protocolHttp.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));
  };

  class SSOClient extends smithyClient.Client {
    config;
    constructor(...[configuration]) {
      const _config_0 = runtimeConfig.getRuntimeConfig(configuration || {});
      super(_config_0);
      this.initConfig = _config_0;
      const _config_1 = resolveClientEndpointParameters(_config_0);
      const _config_2 = middlewareUserAgent.resolveUserAgentConfig(_config_1);
      const _config_3 = middlewareRetry.resolveRetryConfig(_config_2);
      const _config_4 = configResolver.resolveRegionConfig(_config_3);
      const _config_5 = middlewareHostHeader.resolveHostHeaderConfig(_config_4);
      const _config_6 = middlewareEndpoint.resolveEndpointConfig(_config_5);
      const _config_7 = httpAuthSchemeProvider.resolveHttpAuthSchemeConfig(_config_6);
      const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
      this.config = _config_8;
      this.middlewareStack.use(schema.getSchemaSerdePlugin(this.config));
      this.middlewareStack.use(middlewareUserAgent.getUserAgentPlugin(this.config));
      this.middlewareStack.use(middlewareRetry.getRetryPlugin(this.config));
      this.middlewareStack.use(middlewareContentLength.getContentLengthPlugin(this.config));
      this.middlewareStack.use(middlewareHostHeader.getHostHeaderPlugin(this.config));
      this.middlewareStack.use(middlewareLogger.getLoggerPlugin(this.config));
      this.middlewareStack.use(middlewareRecursionDetection.getRecursionDetectionPlugin(this.config));
      this.middlewareStack.use(core.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
        httpAuthSchemeParametersProvider: httpAuthSchemeProvider.defaultSSOHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config) => new core.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config.credentials
        })
      }));
      this.middlewareStack.use(core.getHttpSigningPlugin(this.config));
    }
    destroy() {
      super.destroy();
    }
  }

  class GetRoleCredentialsCommand extends smithyClient.Command.classBuilder().ep(commonParams).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").sc(schemas_0.GetRoleCredentials$).build() {
  }
  var commands = {
    GetRoleCredentialsCommand
  };

  class SSO extends SSOClient {
  }
  smithyClient.createAggregatedClient(commands, SSO);
  exports.$Command = smithyClient.Command;
  exports.__Client = smithyClient.Client;
  exports.SSOServiceException = SSOServiceException.SSOServiceException;
  exports.GetRoleCredentialsCommand = GetRoleCredentialsCommand;
  exports.SSO = SSO;
  exports.SSOClient = SSOClient;
  Object.prototype.hasOwnProperty.call(schemas_0, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: schemas_0["__proto__"]
  });
  Object.keys(schemas_0).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = schemas_0[k];
  });
  Object.prototype.hasOwnProperty.call(errors, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: errors["__proto__"]
  });
  Object.keys(errors).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = errors[k];
  });
});

// node_modules/@aws-sdk/credential-provider-sso/dist-cjs/loadSso-BKDNrsal.js
var require_loadSso_BKDNrsal = __commonJS((exports) => {
  var sso = require_sso();
  exports.GetRoleCredentialsCommand = sso.GetRoleCredentialsCommand;
  exports.SSOClient = sso.SSOClient;
});

// node_modules/@aws-sdk/credential-provider-sso/dist-cjs/index.js
var require_dist_cjs60 = __commonJS((exports) => {
  var propertyProvider = require_dist_cjs18();
  var sharedIniFileLoader = require_dist_cjs44();
  var client3 = require_client2();
  var tokenProviders = require_dist_cjs59();
  var isSsoProfile = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");
  var SHOULD_FAIL_CREDENTIAL_CHAIN = false;
  var resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, clientConfig, parentClientConfig, callerClientConfig, profile, filepath, configFilepath, ignoreCache, logger }) => {
    let token2;
    const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
    if (ssoSession) {
      try {
        const _token = await tokenProviders.fromSso({
          profile,
          filepath,
          configFilepath,
          ignoreCache
        })();
        token2 = {
          accessToken: _token.token,
          expiresAt: new Date(_token.expiration).toISOString()
        };
      } catch (e) {
        throw new propertyProvider.CredentialsProviderError(e.message, {
          tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
          logger
        });
      }
    } else {
      try {
        token2 = await sharedIniFileLoader.getSSOTokenFromFile(ssoStartUrl);
      } catch (e) {
        throw new propertyProvider.CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, {
          tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
          logger
        });
      }
    }
    if (new Date(token2.expiresAt).getTime() - Date.now() <= 0) {
      throw new propertyProvider.CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, {
        tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
        logger
      });
    }
    const { accessToken } = token2;
    const { SSOClient, GetRoleCredentialsCommand } = await Promise.resolve().then(function() {
      return require_loadSso_BKDNrsal();
    });
    const sso = ssoClient || new SSOClient(Object.assign({}, clientConfig ?? {}, {
      logger: clientConfig?.logger ?? callerClientConfig?.logger ?? parentClientConfig?.logger,
      region: clientConfig?.region ?? ssoRegion,
      userAgentAppId: clientConfig?.userAgentAppId ?? callerClientConfig?.userAgentAppId ?? parentClientConfig?.userAgentAppId
    }));
    let ssoResp;
    try {
      ssoResp = await sso.send(new GetRoleCredentialsCommand({
        accountId: ssoAccountId,
        roleName: ssoRoleName,
        accessToken
      }));
    } catch (e) {
      throw new propertyProvider.CredentialsProviderError(e, {
        tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
        logger
      });
    }
    const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration, credentialScope, accountId } = {} } = ssoResp;
    if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
      throw new propertyProvider.CredentialsProviderError("SSO returns an invalid temporary credential.", {
        tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
        logger
      });
    }
    const credentials = {
      accessKeyId,
      secretAccessKey,
      sessionToken,
      expiration: new Date(expiration),
      ...credentialScope && { credentialScope },
      ...accountId && { accountId }
    };
    if (ssoSession) {
      client3.setCredentialFeature(credentials, "CREDENTIALS_SSO", "s");
    } else {
      client3.setCredentialFeature(credentials, "CREDENTIALS_SSO_LEGACY", "u");
    }
    return credentials;
  };
  var validateSsoProfile = (profile, logger) => {
    const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
    if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
      throw new propertyProvider.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", ` + `"sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, { tryNextLink: false, logger });
    }
    return profile;
  };
  var fromSSO = (init = {}) => async ({ callerClientConfig } = {}) => {
    init.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
    const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;
    const { ssoClient } = init;
    const profileName = sharedIniFileLoader.getProfileName({
      profile: init.profile ?? callerClientConfig?.profile
    });
    if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
      const profiles = await sharedIniFileLoader.parseKnownFiles(init);
      const profile = profiles[profileName];
      if (!profile) {
        throw new propertyProvider.CredentialsProviderError(`Profile ${profileName} was not found.`, { logger: init.logger });
      }
      if (!isSsoProfile(profile)) {
        throw new propertyProvider.CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`, {
          logger: init.logger
        });
      }
      if (profile?.sso_session) {
        const ssoSessions = await sharedIniFileLoader.loadSsoSessionData(init);
        const session2 = ssoSessions[profile.sso_session];
        const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
        if (ssoRegion && ssoRegion !== session2.sso_region) {
          throw new propertyProvider.CredentialsProviderError(`Conflicting SSO region` + conflictMsg, {
            tryNextLink: false,
            logger: init.logger
          });
        }
        if (ssoStartUrl && ssoStartUrl !== session2.sso_start_url) {
          throw new propertyProvider.CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, {
            tryNextLink: false,
            logger: init.logger
          });
        }
        profile.sso_region = session2.sso_region;
        profile.sso_start_url = session2.sso_start_url;
      }
      const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile(profile, init.logger);
      return resolveSSOCredentials({
        ssoStartUrl: sso_start_url,
        ssoSession: sso_session,
        ssoAccountId: sso_account_id,
        ssoRegion: sso_region,
        ssoRoleName: sso_role_name,
        ssoClient,
        clientConfig: init.clientConfig,
        parentClientConfig: init.parentClientConfig,
        callerClientConfig: init.callerClientConfig,
        profile: profileName,
        filepath: init.filepath,
        configFilepath: init.configFilepath,
        ignoreCache: init.ignoreCache,
        logger: init.logger
      });
    } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
      throw new propertyProvider.CredentialsProviderError("Incomplete configuration. The fromSSO() argument hash must include " + '"ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"', { tryNextLink: false, logger: init.logger });
    } else {
      return resolveSSOCredentials({
        ssoStartUrl,
        ssoSession,
        ssoAccountId,
        ssoRegion,
        ssoRoleName,
        ssoClient,
        clientConfig: init.clientConfig,
        parentClientConfig: init.parentClientConfig,
        callerClientConfig: init.callerClientConfig,
        profile: profileName,
        filepath: init.filepath,
        configFilepath: init.configFilepath,
        ignoreCache: init.ignoreCache,
        logger: init.logger
      });
    }
  };
  exports.fromSSO = fromSSO;
  exports.isSsoProfile = isSsoProfile;
  exports.validateSsoProfile = validateSsoProfile;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/signin/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveHttpAuthSchemeConfig = exports.defaultSigninHttpAuthSchemeProvider = exports.defaultSigninHttpAuthSchemeParametersProvider = undefined;
  var core_1 = require_dist_cjs24();
  var util_middleware_1 = require_dist_cjs4();
  var defaultSigninHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
      operation: (0, util_middleware_1.getSmithyContext)(context).operation,
      region: await (0, util_middleware_1.normalizeProvider)(config.region)() || (() => {
        throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
      })()
    };
  };
  exports.defaultSigninHttpAuthSchemeParametersProvider = defaultSigninHttpAuthSchemeParametersProvider;
  function createAwsAuthSigv4HttpAuthOption(authParameters) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "signin",
        region: authParameters.region
      },
      propertiesExtractor: (config, context) => ({
        signingProperties: {
          config,
          context
        }
      })
    };
  }
  function createSmithyApiNoAuthHttpAuthOption(authParameters) {
    return {
      schemeId: "smithy.api#noAuth"
    };
  }
  var defaultSigninHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
      case "CreateOAuth2Token": {
        options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
        break;
      }
      default: {
        options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
      }
    }
    return options;
  };
  exports.defaultSigninHttpAuthSchemeProvider = defaultSigninHttpAuthSchemeProvider;
  var resolveHttpAuthSchemeConfig = (config) => {
    const config_0 = (0, core_1.resolveAwsSdkSigV4Config)(config);
    return Object.assign(config_0, {
      authSchemePreference: (0, util_middleware_1.normalizeProvider)(config.authSchemePreference ?? [])
    });
  };
  exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/signin/endpoint/ruleset.js
var require_ruleset4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ruleSet = undefined;
  var u = "required";
  var v = "fn";
  var w = "argv";
  var x = "ref";
  var a = true;
  var b = "isSet";
  var c = "booleanEquals";
  var d = "error";
  var e = "endpoint";
  var f = "tree";
  var g = "PartitionResult";
  var h = "stringEquals";
  var i2 = { [u]: true, default: false, type: "boolean" };
  var j = { [u]: false, type: "string" };
  var k = { [x]: "Endpoint" };
  var l = { [v]: c, [w]: [{ [x]: "UseFIPS" }, true] };
  var m = { [v]: c, [w]: [{ [x]: "UseDualStack" }, true] };
  var n = {};
  var o = { [v]: "getAttr", [w]: [{ [x]: g }, "name"] };
  var p = { [v]: c, [w]: [{ [x]: "UseFIPS" }, false] };
  var q = { [v]: c, [w]: [{ [x]: "UseDualStack" }, false] };
  var r = { [v]: "getAttr", [w]: [{ [x]: g }, "supportsFIPS"] };
  var s = { [v]: c, [w]: [true, { [v]: "getAttr", [w]: [{ [x]: g }, "supportsDualStack"] }] };
  var t = [{ [x]: "Region" }];
  var _data = {
    version: "1.0",
    parameters: { UseDualStack: i2, UseFIPS: i2, Endpoint: j, Region: j },
    rules: [
      {
        conditions: [{ [v]: b, [w]: [k] }],
        rules: [
          { conditions: [l], error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d },
          {
            rules: [
              {
                conditions: [m],
                error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
                type: d
              },
              { endpoint: { url: k, properties: n, headers: n }, type: e }
            ],
            type: f
          }
        ],
        type: f
      },
      {
        rules: [
          {
            conditions: [{ [v]: b, [w]: t }],
            rules: [
              {
                conditions: [{ [v]: "aws.partition", [w]: t, assign: g }],
                rules: [
                  {
                    conditions: [{ [v]: h, [w]: [o, "aws"] }, p, q],
                    endpoint: { url: "https://{Region}.signin.aws.amazon.com", properties: n, headers: n },
                    type: e
                  },
                  {
                    conditions: [{ [v]: h, [w]: [o, "aws-cn"] }, p, q],
                    endpoint: { url: "https://{Region}.signin.amazonaws.cn", properties: n, headers: n },
                    type: e
                  },
                  {
                    conditions: [{ [v]: h, [w]: [o, "aws-us-gov"] }, p, q],
                    endpoint: { url: "https://{Region}.signin.amazonaws-us-gov.com", properties: n, headers: n },
                    type: e
                  },
                  {
                    conditions: [l, m],
                    rules: [
                      {
                        conditions: [{ [v]: c, [w]: [a, r] }, s],
                        rules: [
                          {
                            endpoint: {
                              url: "https://signin-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: n,
                              headers: n
                            },
                            type: e
                          }
                        ],
                        type: f
                      },
                      {
                        error: "FIPS and DualStack are enabled, but this partition does not support one or both",
                        type: d
                      }
                    ],
                    type: f
                  },
                  {
                    conditions: [l, q],
                    rules: [
                      {
                        conditions: [{ [v]: c, [w]: [r, a] }],
                        rules: [
                          {
                            endpoint: {
                              url: "https://signin-fips.{Region}.{PartitionResult#dnsSuffix}",
                              properties: n,
                              headers: n
                            },
                            type: e
                          }
                        ],
                        type: f
                      },
                      { error: "FIPS is enabled but this partition does not support FIPS", type: d }
                    ],
                    type: f
                  },
                  {
                    conditions: [p, m],
                    rules: [
                      {
                        conditions: [s],
                        rules: [
                          {
                            endpoint: {
                              url: "https://signin.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: n,
                              headers: n
                            },
                            type: e
                          }
                        ],
                        type: f
                      },
                      { error: "DualStack is enabled but this partition does not support DualStack", type: d }
                    ],
                    type: f
                  },
                  {
                    endpoint: { url: "https://signin.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n },
                    type: e
                  }
                ],
                type: f
              }
            ],
            type: f
          },
          { error: "Invalid Configuration: Missing Region", type: d }
        ],
        type: f
      }
    ]
  };
  exports.ruleSet = _data;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/signin/endpoint/endpointResolver.js
var require_endpointResolver4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultEndpointResolver = undefined;
  var util_endpoints_1 = require_dist_cjs39();
  var util_endpoints_2 = require_dist_cjs36();
  var ruleset_1 = require_ruleset4();
  var cache2 = new util_endpoints_2.EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
  });
  var defaultEndpointResolver = (endpointParams, context = {}) => {
    return cache2.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
      endpointParams,
      logger: context.logger
    }));
  };
  exports.defaultEndpointResolver = defaultEndpointResolver;
  util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/signin/models/SigninServiceException.js
var require_SigninServiceException = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SigninServiceException = exports.__ServiceException = undefined;
  var smithy_client_1 = require_dist_cjs22();
  Object.defineProperty(exports, "__ServiceException", { enumerable: true, get: function() {
    return smithy_client_1.ServiceException;
  } });

  class SigninServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, SigninServiceException.prototype);
    }
  }
  exports.SigninServiceException = SigninServiceException;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/signin/models/errors.js
var require_errors8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValidationException = exports.TooManyRequestsError = exports.InternalServerException = exports.AccessDeniedException = undefined;
  var SigninServiceException_1 = require_SigninServiceException();

  class AccessDeniedException extends SigninServiceException_1.SigninServiceException {
    name = "AccessDeniedException";
    $fault = "client";
    error;
    constructor(opts) {
      super({
        name: "AccessDeniedException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, AccessDeniedException.prototype);
      this.error = opts.error;
    }
  }
  exports.AccessDeniedException = AccessDeniedException;

  class InternalServerException extends SigninServiceException_1.SigninServiceException {
    name = "InternalServerException";
    $fault = "server";
    error;
    constructor(opts) {
      super({
        name: "InternalServerException",
        $fault: "server",
        ...opts
      });
      Object.setPrototypeOf(this, InternalServerException.prototype);
      this.error = opts.error;
    }
  }
  exports.InternalServerException = InternalServerException;

  class TooManyRequestsError extends SigninServiceException_1.SigninServiceException {
    name = "TooManyRequestsError";
    $fault = "client";
    error;
    constructor(opts) {
      super({
        name: "TooManyRequestsError",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, TooManyRequestsError.prototype);
      this.error = opts.error;
    }
  }
  exports.TooManyRequestsError = TooManyRequestsError;

  class ValidationException extends SigninServiceException_1.SigninServiceException {
    name = "ValidationException";
    $fault = "client";
    error;
    constructor(opts) {
      super({
        name: "ValidationException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ValidationException.prototype);
      this.error = opts.error;
    }
  }
  exports.ValidationException = ValidationException;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/signin/schemas/schemas_0.js
var require_schemas_04 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateOAuth2Token$ = exports.CreateOAuth2TokenResponseBody$ = exports.CreateOAuth2TokenResponse$ = exports.CreateOAuth2TokenRequestBody$ = exports.CreateOAuth2TokenRequest$ = exports.AccessToken$ = exports.errorTypeRegistries = exports.ValidationException$ = exports.TooManyRequestsError$ = exports.InternalServerException$ = exports.AccessDeniedException$ = exports.SigninServiceException$ = undefined;
  var _ADE = "AccessDeniedException";
  var _AT = "AccessToken";
  var _COAT = "CreateOAuth2Token";
  var _COATR = "CreateOAuth2TokenRequest";
  var _COATRB = "CreateOAuth2TokenRequestBody";
  var _COATRBr = "CreateOAuth2TokenResponseBody";
  var _COATRr = "CreateOAuth2TokenResponse";
  var _ISE = "InternalServerException";
  var _RT = "RefreshToken";
  var _TMRE = "TooManyRequestsError";
  var _VE = "ValidationException";
  var _aKI = "accessKeyId";
  var _aT = "accessToken";
  var _c = "client";
  var _cI = "clientId";
  var _cV = "codeVerifier";
  var _co = "code";
  var _e = "error";
  var _eI = "expiresIn";
  var _gT = "grantType";
  var _h = "http";
  var _hE = "httpError";
  var _iT = "idToken";
  var _jN = "jsonName";
  var _m = "message";
  var _rT = "refreshToken";
  var _rU = "redirectUri";
  var _s = "smithy.ts.sdk.synthetic.com.amazonaws.signin";
  var _sAK = "secretAccessKey";
  var _sT = "sessionToken";
  var _se = "server";
  var _tI = "tokenInput";
  var _tO = "tokenOutput";
  var _tT = "tokenType";
  var n0 = "com.amazonaws.signin";
  var schema_1 = require_schema();
  var errors_1 = require_errors8();
  var SigninServiceException_1 = require_SigninServiceException();
  var _s_registry = schema_1.TypeRegistry.for(_s);
  exports.SigninServiceException$ = [-3, _s, "SigninServiceException", 0, [], []];
  _s_registry.registerError(exports.SigninServiceException$, SigninServiceException_1.SigninServiceException);
  var n0_registry = schema_1.TypeRegistry.for(n0);
  exports.AccessDeniedException$ = [-3, n0, _ADE, { [_e]: _c }, [_e, _m], [0, 0], 2];
  n0_registry.registerError(exports.AccessDeniedException$, errors_1.AccessDeniedException);
  exports.InternalServerException$ = [-3, n0, _ISE, { [_e]: _se, [_hE]: 500 }, [_e, _m], [0, 0], 2];
  n0_registry.registerError(exports.InternalServerException$, errors_1.InternalServerException);
  exports.TooManyRequestsError$ = [-3, n0, _TMRE, { [_e]: _c, [_hE]: 429 }, [_e, _m], [0, 0], 2];
  n0_registry.registerError(exports.TooManyRequestsError$, errors_1.TooManyRequestsError);
  exports.ValidationException$ = [-3, n0, _VE, { [_e]: _c, [_hE]: 400 }, [_e, _m], [0, 0], 2];
  n0_registry.registerError(exports.ValidationException$, errors_1.ValidationException);
  exports.errorTypeRegistries = [_s_registry, n0_registry];
  var RefreshToken = [0, n0, _RT, 8, 0];
  exports.AccessToken$ = [
    3,
    n0,
    _AT,
    8,
    [_aKI, _sAK, _sT],
    [
      [0, { [_jN]: _aKI }],
      [0, { [_jN]: _sAK }],
      [0, { [_jN]: _sT }]
    ],
    3
  ];
  exports.CreateOAuth2TokenRequest$ = [
    3,
    n0,
    _COATR,
    0,
    [_tI],
    [[() => exports.CreateOAuth2TokenRequestBody$, 16]],
    1
  ];
  exports.CreateOAuth2TokenRequestBody$ = [
    3,
    n0,
    _COATRB,
    0,
    [_cI, _gT, _co, _rU, _cV, _rT],
    [
      [0, { [_jN]: _cI }],
      [0, { [_jN]: _gT }],
      0,
      [0, { [_jN]: _rU }],
      [0, { [_jN]: _cV }],
      [() => RefreshToken, { [_jN]: _rT }]
    ],
    2
  ];
  exports.CreateOAuth2TokenResponse$ = [
    3,
    n0,
    _COATRr,
    0,
    [_tO],
    [[() => exports.CreateOAuth2TokenResponseBody$, 16]],
    1
  ];
  exports.CreateOAuth2TokenResponseBody$ = [
    3,
    n0,
    _COATRBr,
    0,
    [_aT, _tT, _eI, _rT, _iT],
    [
      [() => exports.AccessToken$, { [_jN]: _aT }],
      [0, { [_jN]: _tT }],
      [1, { [_jN]: _eI }],
      [() => RefreshToken, { [_jN]: _rT }],
      [0, { [_jN]: _iT }]
    ],
    4
  ];
  exports.CreateOAuth2Token$ = [
    9,
    n0,
    _COAT,
    { [_h]: ["POST", "/v1/token", 200] },
    () => exports.CreateOAuth2TokenRequest$,
    () => exports.CreateOAuth2TokenResponse$
  ];
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/signin/runtimeConfig.shared.js
var require_runtimeConfig_shared3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var core_1 = require_dist_cjs24();
  var protocols_1 = require_protocols2();
  var core_2 = require_dist_cjs17();
  var smithy_client_1 = require_dist_cjs22();
  var url_parser_1 = require_dist_cjs38();
  var util_base64_1 = require_dist_cjs9();
  var util_utf8_1 = require_dist_cjs8();
  var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider4();
  var endpointResolver_1 = require_endpointResolver4();
  var schemas_0_1 = require_schemas_04();
  var getRuntimeConfig = (config) => {
    return {
      apiVersion: "2023-01-01",
      base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
      base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
      disableHostPrefix: config?.disableHostPrefix ?? false,
      endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
      extensions: config?.extensions ?? [],
      httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultSigninHttpAuthSchemeProvider,
      httpAuthSchemes: config?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
          signer: new core_1.AwsSdkSigV4Signer
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new core_2.NoAuthSigner
        }
      ],
      logger: config?.logger ?? new smithy_client_1.NoOpLogger,
      protocol: config?.protocol ?? protocols_1.AwsRestJsonProtocol,
      protocolSettings: config?.protocolSettings ?? {
        defaultNamespace: "com.amazonaws.signin",
        errorTypeRegistries: schemas_0_1.errorTypeRegistries,
        version: "2023-01-01",
        serviceTarget: "Signin"
      },
      serviceId: config?.serviceId ?? "Signin",
      urlParser: config?.urlParser ?? url_parser_1.parseUrl,
      utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
      utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/signin/runtimeConfig.js
var require_runtimeConfig3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var tslib_1 = require_tslib();
  var package_json_1 = tslib_1.__importDefault(require_package5());
  var core_1 = require_dist_cjs24();
  var util_user_agent_node_1 = require_dist_cjs54();
  var config_resolver_1 = require_dist_cjs41();
  var hash_node_1 = require_dist_cjs55();
  var middleware_retry_1 = require_dist_cjs49();
  var node_config_provider_1 = require_dist_cjs45();
  var node_http_handler_1 = require_dist_cjs12();
  var smithy_client_1 = require_dist_cjs22();
  var util_body_length_node_1 = require_dist_cjs56();
  var util_defaults_mode_node_1 = require_dist_cjs57();
  var util_retry_1 = require_dist_cjs48();
  var runtimeConfig_shared_1 = require_runtimeConfig_shared3();
  var getRuntimeConfig = (config) => {
    (0, smithy_client_1.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    const loaderConfig = {
      profile: config?.profile,
      logger: clientSharedValues.logger
    };
    return {
      ...clientSharedValues,
      ...config,
      runtime: "node",
      defaultsMode,
      authSchemePreference: config?.authSchemePreference ?? (0, node_config_provider_1.loadConfig)(core_1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
      bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
      defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
      maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
      region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
      requestHandler: node_http_handler_1.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
      retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
        default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
      }, config),
      sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
      streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
      useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
      useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
      userAgentAppId: config?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/signin/index.js
var require_signin = __commonJS((exports) => {
  var middlewareHostHeader = require_dist_cjs30();
  var middlewareLogger = require_dist_cjs31();
  var middlewareRecursionDetection = require_dist_cjs32();
  var middlewareUserAgent = require_dist_cjs40();
  var configResolver = require_dist_cjs41();
  var core = require_dist_cjs17();
  var schema = require_schema();
  var middlewareContentLength = require_dist_cjs43();
  var middlewareEndpoint = require_dist_cjs46();
  var middlewareRetry = require_dist_cjs49();
  var smithyClient = require_dist_cjs22();
  var httpAuthSchemeProvider = require_httpAuthSchemeProvider4();
  var runtimeConfig = require_runtimeConfig3();
  var regionConfigResolver = require_dist_cjs58();
  var protocolHttp = require_dist_cjs2();
  var schemas_0 = require_schemas_04();
  var errors = require_errors8();
  var SigninServiceException = require_SigninServiceException();
  var resolveClientEndpointParameters = (options) => {
    return Object.assign(options, {
      useDualstackEndpoint: options.useDualstackEndpoint ?? false,
      useFipsEndpoint: options.useFipsEndpoint ?? false,
      defaultSigningName: "signin"
    });
  };
  var commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };
  var getHttpAuthExtensionConfiguration = (runtimeConfig2) => {
    const _httpAuthSchemes = runtimeConfig2.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig2.httpAuthSchemeProvider;
    let _credentials = runtimeConfig2.credentials;
    return {
      setHttpAuthScheme(httpAuthScheme) {
        const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
        if (index === -1) {
          _httpAuthSchemes.push(httpAuthScheme);
        } else {
          _httpAuthSchemes.splice(index, 1, httpAuthScheme);
        }
      },
      httpAuthSchemes() {
        return _httpAuthSchemes;
      },
      setHttpAuthSchemeProvider(httpAuthSchemeProvider2) {
        _httpAuthSchemeProvider = httpAuthSchemeProvider2;
      },
      httpAuthSchemeProvider() {
        return _httpAuthSchemeProvider;
      },
      setCredentials(credentials) {
        _credentials = credentials;
      },
      credentials() {
        return _credentials;
      }
    };
  };
  var resolveHttpAuthRuntimeConfig = (config) => {
    return {
      httpAuthSchemes: config.httpAuthSchemes(),
      httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
      credentials: config.credentials()
    };
  };
  var resolveRuntimeExtensions = (runtimeConfig2, extensions) => {
    const extensionConfiguration = Object.assign(regionConfigResolver.getAwsRegionExtensionConfiguration(runtimeConfig2), smithyClient.getDefaultExtensionConfiguration(runtimeConfig2), protocolHttp.getHttpHandlerExtensionConfiguration(runtimeConfig2), getHttpAuthExtensionConfiguration(runtimeConfig2));
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return Object.assign(runtimeConfig2, regionConfigResolver.resolveAwsRegionExtensionConfiguration(extensionConfiguration), smithyClient.resolveDefaultRuntimeConfig(extensionConfiguration), protocolHttp.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));
  };

  class SigninClient extends smithyClient.Client {
    config;
    constructor(...[configuration]) {
      const _config_0 = runtimeConfig.getRuntimeConfig(configuration || {});
      super(_config_0);
      this.initConfig = _config_0;
      const _config_1 = resolveClientEndpointParameters(_config_0);
      const _config_2 = middlewareUserAgent.resolveUserAgentConfig(_config_1);
      const _config_3 = middlewareRetry.resolveRetryConfig(_config_2);
      const _config_4 = configResolver.resolveRegionConfig(_config_3);
      const _config_5 = middlewareHostHeader.resolveHostHeaderConfig(_config_4);
      const _config_6 = middlewareEndpoint.resolveEndpointConfig(_config_5);
      const _config_7 = httpAuthSchemeProvider.resolveHttpAuthSchemeConfig(_config_6);
      const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
      this.config = _config_8;
      this.middlewareStack.use(schema.getSchemaSerdePlugin(this.config));
      this.middlewareStack.use(middlewareUserAgent.getUserAgentPlugin(this.config));
      this.middlewareStack.use(middlewareRetry.getRetryPlugin(this.config));
      this.middlewareStack.use(middlewareContentLength.getContentLengthPlugin(this.config));
      this.middlewareStack.use(middlewareHostHeader.getHostHeaderPlugin(this.config));
      this.middlewareStack.use(middlewareLogger.getLoggerPlugin(this.config));
      this.middlewareStack.use(middlewareRecursionDetection.getRecursionDetectionPlugin(this.config));
      this.middlewareStack.use(core.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
        httpAuthSchemeParametersProvider: httpAuthSchemeProvider.defaultSigninHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config) => new core.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config.credentials
        })
      }));
      this.middlewareStack.use(core.getHttpSigningPlugin(this.config));
    }
    destroy() {
      super.destroy();
    }
  }

  class CreateOAuth2TokenCommand extends smithyClient.Command.classBuilder().ep(commonParams).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("Signin", "CreateOAuth2Token", {}).n("SigninClient", "CreateOAuth2TokenCommand").sc(schemas_0.CreateOAuth2Token$).build() {
  }
  var commands = {
    CreateOAuth2TokenCommand
  };

  class Signin extends SigninClient {
  }
  smithyClient.createAggregatedClient(commands, Signin);
  var OAuth2ErrorCode = {
    AUTHCODE_EXPIRED: "AUTHCODE_EXPIRED",
    INSUFFICIENT_PERMISSIONS: "INSUFFICIENT_PERMISSIONS",
    INVALID_REQUEST: "INVALID_REQUEST",
    SERVER_ERROR: "server_error",
    TOKEN_EXPIRED: "TOKEN_EXPIRED",
    USER_CREDENTIALS_CHANGED: "USER_CREDENTIALS_CHANGED"
  };
  exports.$Command = smithyClient.Command;
  exports.__Client = smithyClient.Client;
  exports.SigninServiceException = SigninServiceException.SigninServiceException;
  exports.CreateOAuth2TokenCommand = CreateOAuth2TokenCommand;
  exports.OAuth2ErrorCode = OAuth2ErrorCode;
  exports.Signin = Signin;
  exports.SigninClient = SigninClient;
  Object.prototype.hasOwnProperty.call(schemas_0, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: schemas_0["__proto__"]
  });
  Object.keys(schemas_0).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = schemas_0[k];
  });
  Object.prototype.hasOwnProperty.call(errors, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: errors["__proto__"]
  });
  Object.keys(errors).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = errors[k];
  });
});

// node_modules/@aws-sdk/credential-provider-login/dist-cjs/index.js
var require_dist_cjs61 = __commonJS((exports) => {
  var client3 = require_client2();
  var propertyProvider = require_dist_cjs18();
  var sharedIniFileLoader = require_dist_cjs44();
  var protocolHttp = require_dist_cjs2();
  var node_crypto = __require("node:crypto");
  var node_fs = __require("node:fs");
  var node_os = __require("node:os");
  var node_path = __require("node:path");

  class LoginCredentialsFetcher {
    profileData;
    init;
    callerClientConfig;
    static REFRESH_THRESHOLD = 5 * 60 * 1000;
    constructor(profileData, init, callerClientConfig) {
      this.profileData = profileData;
      this.init = init;
      this.callerClientConfig = callerClientConfig;
    }
    async loadCredentials() {
      const token2 = await this.loadToken();
      if (!token2) {
        throw new propertyProvider.CredentialsProviderError(`Failed to load a token for session ${this.loginSession}, please re-authenticate using aws login`, { tryNextLink: false, logger: this.logger });
      }
      const accessToken = token2.accessToken;
      const now = Date.now();
      const expiryTime = new Date(accessToken.expiresAt).getTime();
      const timeUntilExpiry = expiryTime - now;
      if (timeUntilExpiry <= LoginCredentialsFetcher.REFRESH_THRESHOLD) {
        return this.refresh(token2);
      }
      return {
        accessKeyId: accessToken.accessKeyId,
        secretAccessKey: accessToken.secretAccessKey,
        sessionToken: accessToken.sessionToken,
        accountId: accessToken.accountId,
        expiration: new Date(accessToken.expiresAt)
      };
    }
    get logger() {
      return this.init?.logger;
    }
    get loginSession() {
      return this.profileData.login_session;
    }
    async refresh(token2) {
      const { SigninClient, CreateOAuth2TokenCommand } = await Promise.resolve().then(() => __toESM(require_signin()));
      const { logger, userAgentAppId } = this.callerClientConfig ?? {};
      const isH2 = (requestHandler2) => {
        return requestHandler2?.metadata?.handlerProtocol === "h2";
      };
      const requestHandler = isH2(this.callerClientConfig?.requestHandler) ? undefined : this.callerClientConfig?.requestHandler;
      const region = this.profileData.region ?? await this.callerClientConfig?.region?.() ?? process.env.AWS_REGION;
      const client4 = new SigninClient({
        credentials: {
          accessKeyId: "",
          secretAccessKey: ""
        },
        region,
        requestHandler,
        logger,
        userAgentAppId,
        ...this.init?.clientConfig
      });
      this.createDPoPInterceptor(client4.middlewareStack);
      const commandInput = {
        tokenInput: {
          clientId: token2.clientId,
          refreshToken: token2.refreshToken,
          grantType: "refresh_token"
        }
      };
      try {
        const response = await client4.send(new CreateOAuth2TokenCommand(commandInput));
        const { accessKeyId, secretAccessKey, sessionToken } = response.tokenOutput?.accessToken ?? {};
        const { refreshToken, expiresIn } = response.tokenOutput ?? {};
        if (!accessKeyId || !secretAccessKey || !sessionToken || !refreshToken) {
          throw new propertyProvider.CredentialsProviderError("Token refresh response missing required fields", {
            logger: this.logger,
            tryNextLink: false
          });
        }
        const expiresInMs = (expiresIn ?? 900) * 1000;
        const expiration = new Date(Date.now() + expiresInMs);
        const updatedToken = {
          ...token2,
          accessToken: {
            ...token2.accessToken,
            accessKeyId,
            secretAccessKey,
            sessionToken,
            expiresAt: expiration.toISOString()
          },
          refreshToken
        };
        await this.saveToken(updatedToken);
        const newAccessToken = updatedToken.accessToken;
        return {
          accessKeyId: newAccessToken.accessKeyId,
          secretAccessKey: newAccessToken.secretAccessKey,
          sessionToken: newAccessToken.sessionToken,
          accountId: newAccessToken.accountId,
          expiration
        };
      } catch (error) {
        if (error.name === "AccessDeniedException") {
          const errorType = error.error;
          let message3;
          switch (errorType) {
            case "TOKEN_EXPIRED":
              message3 = "Your session has expired. Please reauthenticate.";
              break;
            case "USER_CREDENTIALS_CHANGED":
              message3 = "Unable to refresh credentials because of a change in your password. Please reauthenticate with your new password.";
              break;
            case "INSUFFICIENT_PERMISSIONS":
              message3 = "Unable to refresh credentials due to insufficient permissions. You may be missing permission for the 'CreateOAuth2Token' action.";
              break;
            default:
              message3 = `Failed to refresh token: ${String(error)}. Please re-authenticate using \`aws login\``;
          }
          throw new propertyProvider.CredentialsProviderError(message3, { logger: this.logger, tryNextLink: false });
        }
        throw new propertyProvider.CredentialsProviderError(`Failed to refresh token: ${String(error)}. Please re-authenticate using aws login`, { logger: this.logger });
      }
    }
    async loadToken() {
      const tokenFilePath = this.getTokenFilePath();
      try {
        let tokenData;
        try {
          tokenData = await sharedIniFileLoader.readFile(tokenFilePath, { ignoreCache: this.init?.ignoreCache });
        } catch {
          tokenData = await node_fs.promises.readFile(tokenFilePath, "utf8");
        }
        const token2 = JSON.parse(tokenData);
        const missingFields = ["accessToken", "clientId", "refreshToken", "dpopKey"].filter((k) => !token2[k]);
        if (!token2.accessToken?.accountId) {
          missingFields.push("accountId");
        }
        if (missingFields.length > 0) {
          throw new propertyProvider.CredentialsProviderError(`Token validation failed, missing fields: ${missingFields.join(", ")}`, {
            logger: this.logger,
            tryNextLink: false
          });
        }
        return token2;
      } catch (error) {
        throw new propertyProvider.CredentialsProviderError(`Failed to load token from ${tokenFilePath}: ${String(error)}`, {
          logger: this.logger,
          tryNextLink: false
        });
      }
    }
    async saveToken(token2) {
      const tokenFilePath = this.getTokenFilePath();
      const directory = node_path.dirname(tokenFilePath);
      try {
        await node_fs.promises.mkdir(directory, { recursive: true });
      } catch (error) {}
      await node_fs.promises.writeFile(tokenFilePath, JSON.stringify(token2, null, 2), "utf8");
    }
    getTokenFilePath() {
      const directory = process.env.AWS_LOGIN_CACHE_DIRECTORY ?? node_path.join(node_os.homedir(), ".aws", "login", "cache");
      const loginSessionBytes = Buffer.from(this.loginSession, "utf8");
      const loginSessionSha256 = node_crypto.createHash("sha256").update(loginSessionBytes).digest("hex");
      return node_path.join(directory, `${loginSessionSha256}.json`);
    }
    derToRawSignature(derSignature) {
      let offset2 = 2;
      if (derSignature[offset2] !== 2) {
        throw new Error("Invalid DER signature");
      }
      offset2++;
      const rLength = derSignature[offset2++];
      let r = derSignature.subarray(offset2, offset2 + rLength);
      offset2 += rLength;
      if (derSignature[offset2] !== 2) {
        throw new Error("Invalid DER signature");
      }
      offset2++;
      const sLength = derSignature[offset2++];
      let s = derSignature.subarray(offset2, offset2 + sLength);
      r = r[0] === 0 ? r.subarray(1) : r;
      s = s[0] === 0 ? s.subarray(1) : s;
      const rPadded = Buffer.concat([Buffer.alloc(32 - r.length), r]);
      const sPadded = Buffer.concat([Buffer.alloc(32 - s.length), s]);
      return Buffer.concat([rPadded, sPadded]);
    }
    createDPoPInterceptor(middlewareStack) {
      middlewareStack.add((next) => async (args) => {
        if (protocolHttp.HttpRequest.isInstance(args.request)) {
          const request = args.request;
          const actualEndpoint = `${request.protocol}//${request.hostname}${request.port ? `:${request.port}` : ""}${request.path}`;
          const dpop = await this.generateDpop(request.method, actualEndpoint);
          request.headers = {
            ...request.headers,
            DPoP: dpop
          };
        }
        return next(args);
      }, {
        step: "finalizeRequest",
        name: "dpopInterceptor",
        override: true
      });
    }
    async generateDpop(method = "POST", endpoint) {
      const token2 = await this.loadToken();
      try {
        const privateKey = node_crypto.createPrivateKey({
          key: token2.dpopKey,
          format: "pem",
          type: "sec1"
        });
        const publicKey = node_crypto.createPublicKey(privateKey);
        const publicDer = publicKey.export({ format: "der", type: "spki" });
        let pointStart = -1;
        for (let i2 = 0;i2 < publicDer.length; i2++) {
          if (publicDer[i2] === 4) {
            pointStart = i2;
            break;
          }
        }
        const x = publicDer.slice(pointStart + 1, pointStart + 33);
        const y = publicDer.slice(pointStart + 33, pointStart + 65);
        const header = {
          alg: "ES256",
          typ: "dpop+jwt",
          jwk: {
            kty: "EC",
            crv: "P-256",
            x: x.toString("base64url"),
            y: y.toString("base64url")
          }
        };
        const payload = {
          jti: crypto.randomUUID(),
          htm: method,
          htu: endpoint,
          iat: Math.floor(Date.now() / 1000)
        };
        const headerB64 = Buffer.from(JSON.stringify(header)).toString("base64url");
        const payloadB64 = Buffer.from(JSON.stringify(payload)).toString("base64url");
        const message3 = `${headerB64}.${payloadB64}`;
        const asn1Signature = node_crypto.sign("sha256", Buffer.from(message3), privateKey);
        const rawSignature = this.derToRawSignature(asn1Signature);
        const signatureB64 = rawSignature.toString("base64url");
        return `${message3}.${signatureB64}`;
      } catch (error) {
        throw new propertyProvider.CredentialsProviderError(`Failed to generate Dpop proof: ${error instanceof Error ? error.message : String(error)}`, { logger: this.logger, tryNextLink: false });
      }
    }
  }
  var fromLoginCredentials = (init) => async ({ callerClientConfig } = {}) => {
    init?.logger?.debug?.("@aws-sdk/credential-providers - fromLoginCredentials");
    const profiles = await sharedIniFileLoader.parseKnownFiles(init || {});
    const profileName = sharedIniFileLoader.getProfileName({
      profile: init?.profile ?? callerClientConfig?.profile
    });
    const profile = profiles[profileName];
    if (!profile?.login_session) {
      throw new propertyProvider.CredentialsProviderError(`Profile ${profileName} does not contain login_session.`, {
        tryNextLink: true,
        logger: init?.logger
      });
    }
    const fetcher = new LoginCredentialsFetcher(profile, init, callerClientConfig);
    const credentials = await fetcher.loadCredentials();
    return client3.setCredentialFeature(credentials, "CREDENTIALS_LOGIN", "AD");
  };
  exports.fromLoginCredentials = fromLoginCredentials;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveHttpAuthSchemeConfig = exports.resolveStsAuthConfig = exports.defaultSTSHttpAuthSchemeProvider = exports.defaultSTSHttpAuthSchemeParametersProvider = undefined;
  var core_1 = require_dist_cjs24();
  var util_middleware_1 = require_dist_cjs4();
  var STSClient_1 = require_STSClient();
  var defaultSTSHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
      operation: (0, util_middleware_1.getSmithyContext)(context).operation,
      region: await (0, util_middleware_1.normalizeProvider)(config.region)() || (() => {
        throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
      })()
    };
  };
  exports.defaultSTSHttpAuthSchemeParametersProvider = defaultSTSHttpAuthSchemeParametersProvider;
  function createAwsAuthSigv4HttpAuthOption(authParameters) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sts",
        region: authParameters.region
      },
      propertiesExtractor: (config, context) => ({
        signingProperties: {
          config,
          context
        }
      })
    };
  }
  function createSmithyApiNoAuthHttpAuthOption(authParameters) {
    return {
      schemeId: "smithy.api#noAuth"
    };
  }
  var defaultSTSHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
      case "AssumeRoleWithWebIdentity": {
        options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
        break;
      }
      default: {
        options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
      }
    }
    return options;
  };
  exports.defaultSTSHttpAuthSchemeProvider = defaultSTSHttpAuthSchemeProvider;
  var resolveStsAuthConfig = (input) => Object.assign(input, {
    stsClientCtor: STSClient_1.STSClient
  });
  exports.resolveStsAuthConfig = resolveStsAuthConfig;
  var resolveHttpAuthSchemeConfig = (config) => {
    const config_0 = (0, exports.resolveStsAuthConfig)(config);
    const config_1 = (0, core_1.resolveAwsSdkSigV4Config)(config_0);
    return Object.assign(config_1, {
      authSchemePreference: (0, util_middleware_1.normalizeProvider)(config.authSchemePreference ?? [])
    });
  };
  exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/endpoint/EndpointParameters.js
var require_EndpointParameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.commonParams = exports.resolveClientEndpointParameters = undefined;
  var resolveClientEndpointParameters = (options) => {
    return Object.assign(options, {
      useDualstackEndpoint: options.useDualstackEndpoint ?? false,
      useFipsEndpoint: options.useFipsEndpoint ?? false,
      useGlobalEndpoint: options.useGlobalEndpoint ?? false,
      defaultSigningName: "sts"
    });
  };
  exports.resolveClientEndpointParameters = resolveClientEndpointParameters;
  exports.commonParams = {
    UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/endpoint/ruleset.js
var require_ruleset5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ruleSet = undefined;
  var F = "required";
  var G = "type";
  var H = "fn";
  var I = "argv";
  var J = "ref";
  var a = false;
  var b = true;
  var c = "booleanEquals";
  var d = "stringEquals";
  var e = "sigv4";
  var f = "sts";
  var g = "us-east-1";
  var h = "endpoint";
  var i2 = "https://sts.{Region}.{PartitionResult#dnsSuffix}";
  var j = "tree";
  var k = "error";
  var l = "getAttr";
  var m = { [F]: false, [G]: "string" };
  var n = { [F]: true, default: false, [G]: "boolean" };
  var o = { [J]: "Endpoint" };
  var p = { [H]: "isSet", [I]: [{ [J]: "Region" }] };
  var q = { [J]: "Region" };
  var r = { [H]: "aws.partition", [I]: [q], assign: "PartitionResult" };
  var s = { [J]: "UseFIPS" };
  var t = { [J]: "UseDualStack" };
  var u = {
    url: "https://sts.amazonaws.com",
    properties: { authSchemes: [{ name: e, signingName: f, signingRegion: g }] },
    headers: {}
  };
  var v = {};
  var w = { conditions: [{ [H]: d, [I]: [q, "aws-global"] }], [h]: u, [G]: h };
  var x = { [H]: c, [I]: [s, true] };
  var y = { [H]: c, [I]: [t, true] };
  var z = { [H]: l, [I]: [{ [J]: "PartitionResult" }, "supportsFIPS"] };
  var A = { [J]: "PartitionResult" };
  var B = { [H]: c, [I]: [true, { [H]: l, [I]: [A, "supportsDualStack"] }] };
  var C = [{ [H]: "isSet", [I]: [o] }];
  var D = [x];
  var E = [y];
  var _data = {
    version: "1.0",
    parameters: { Region: m, UseDualStack: n, UseFIPS: n, Endpoint: m, UseGlobalEndpoint: n },
    rules: [
      {
        conditions: [
          { [H]: c, [I]: [{ [J]: "UseGlobalEndpoint" }, b] },
          { [H]: "not", [I]: C },
          p,
          r,
          { [H]: c, [I]: [s, a] },
          { [H]: c, [I]: [t, a] }
        ],
        rules: [
          { conditions: [{ [H]: d, [I]: [q, "ap-northeast-1"] }], endpoint: u, [G]: h },
          { conditions: [{ [H]: d, [I]: [q, "ap-south-1"] }], endpoint: u, [G]: h },
          { conditions: [{ [H]: d, [I]: [q, "ap-southeast-1"] }], endpoint: u, [G]: h },
          { conditions: [{ [H]: d, [I]: [q, "ap-southeast-2"] }], endpoint: u, [G]: h },
          w,
          { conditions: [{ [H]: d, [I]: [q, "ca-central-1"] }], endpoint: u, [G]: h },
          { conditions: [{ [H]: d, [I]: [q, "eu-central-1"] }], endpoint: u, [G]: h },
          { conditions: [{ [H]: d, [I]: [q, "eu-north-1"] }], endpoint: u, [G]: h },
          { conditions: [{ [H]: d, [I]: [q, "eu-west-1"] }], endpoint: u, [G]: h },
          { conditions: [{ [H]: d, [I]: [q, "eu-west-2"] }], endpoint: u, [G]: h },
          { conditions: [{ [H]: d, [I]: [q, "eu-west-3"] }], endpoint: u, [G]: h },
          { conditions: [{ [H]: d, [I]: [q, "sa-east-1"] }], endpoint: u, [G]: h },
          { conditions: [{ [H]: d, [I]: [q, g] }], endpoint: u, [G]: h },
          { conditions: [{ [H]: d, [I]: [q, "us-east-2"] }], endpoint: u, [G]: h },
          { conditions: [{ [H]: d, [I]: [q, "us-west-1"] }], endpoint: u, [G]: h },
          { conditions: [{ [H]: d, [I]: [q, "us-west-2"] }], endpoint: u, [G]: h },
          {
            endpoint: {
              url: i2,
              properties: { authSchemes: [{ name: e, signingName: f, signingRegion: "{Region}" }] },
              headers: v
            },
            [G]: h
          }
        ],
        [G]: j
      },
      {
        conditions: C,
        rules: [
          { conditions: D, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [G]: k },
          { conditions: E, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [G]: k },
          { endpoint: { url: o, properties: v, headers: v }, [G]: h }
        ],
        [G]: j
      },
      {
        conditions: [p],
        rules: [
          {
            conditions: [r],
            rules: [
              {
                conditions: [x, y],
                rules: [
                  {
                    conditions: [{ [H]: c, [I]: [b, z] }, B],
                    rules: [
                      {
                        endpoint: {
                          url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                          properties: v,
                          headers: v
                        },
                        [G]: h
                      }
                    ],
                    [G]: j
                  },
                  { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [G]: k }
                ],
                [G]: j
              },
              {
                conditions: D,
                rules: [
                  {
                    conditions: [{ [H]: c, [I]: [z, b] }],
                    rules: [
                      {
                        conditions: [{ [H]: d, [I]: [{ [H]: l, [I]: [A, "name"] }, "aws-us-gov"] }],
                        endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: v, headers: v },
                        [G]: h
                      },
                      {
                        endpoint: {
                          url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}",
                          properties: v,
                          headers: v
                        },
                        [G]: h
                      }
                    ],
                    [G]: j
                  },
                  { error: "FIPS is enabled but this partition does not support FIPS", [G]: k }
                ],
                [G]: j
              },
              {
                conditions: E,
                rules: [
                  {
                    conditions: [B],
                    rules: [
                      {
                        endpoint: {
                          url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}",
                          properties: v,
                          headers: v
                        },
                        [G]: h
                      }
                    ],
                    [G]: j
                  },
                  { error: "DualStack is enabled but this partition does not support DualStack", [G]: k }
                ],
                [G]: j
              },
              w,
              { endpoint: { url: i2, properties: v, headers: v }, [G]: h }
            ],
            [G]: j
          }
        ],
        [G]: j
      },
      { error: "Invalid Configuration: Missing Region", [G]: k }
    ]
  };
  exports.ruleSet = _data;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/endpoint/endpointResolver.js
var require_endpointResolver5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultEndpointResolver = undefined;
  var util_endpoints_1 = require_dist_cjs39();
  var util_endpoints_2 = require_dist_cjs36();
  var ruleset_1 = require_ruleset5();
  var cache2 = new util_endpoints_2.EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS", "UseGlobalEndpoint"]
  });
  var defaultEndpointResolver = (endpointParams, context = {}) => {
    return cache2.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
      endpointParams,
      logger: context.logger
    }));
  };
  exports.defaultEndpointResolver = defaultEndpointResolver;
  util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/models/STSServiceException.js
var require_STSServiceException = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.STSServiceException = exports.__ServiceException = undefined;
  var smithy_client_1 = require_dist_cjs22();
  Object.defineProperty(exports, "__ServiceException", { enumerable: true, get: function() {
    return smithy_client_1.ServiceException;
  } });

  class STSServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, STSServiceException.prototype);
    }
  }
  exports.STSServiceException = STSServiceException;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/models/errors.js
var require_errors9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IDPCommunicationErrorException = exports.InvalidIdentityTokenException = exports.IDPRejectedClaimException = exports.RegionDisabledException = exports.PackedPolicyTooLargeException = exports.MalformedPolicyDocumentException = exports.ExpiredTokenException = undefined;
  var STSServiceException_1 = require_STSServiceException();

  class ExpiredTokenException extends STSServiceException_1.STSServiceException {
    name = "ExpiredTokenException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ExpiredTokenException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ExpiredTokenException.prototype);
    }
  }
  exports.ExpiredTokenException = ExpiredTokenException;

  class MalformedPolicyDocumentException extends STSServiceException_1.STSServiceException {
    name = "MalformedPolicyDocumentException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "MalformedPolicyDocumentException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
    }
  }
  exports.MalformedPolicyDocumentException = MalformedPolicyDocumentException;

  class PackedPolicyTooLargeException extends STSServiceException_1.STSServiceException {
    name = "PackedPolicyTooLargeException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "PackedPolicyTooLargeException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, PackedPolicyTooLargeException.prototype);
    }
  }
  exports.PackedPolicyTooLargeException = PackedPolicyTooLargeException;

  class RegionDisabledException extends STSServiceException_1.STSServiceException {
    name = "RegionDisabledException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "RegionDisabledException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, RegionDisabledException.prototype);
    }
  }
  exports.RegionDisabledException = RegionDisabledException;

  class IDPRejectedClaimException extends STSServiceException_1.STSServiceException {
    name = "IDPRejectedClaimException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "IDPRejectedClaimException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, IDPRejectedClaimException.prototype);
    }
  }
  exports.IDPRejectedClaimException = IDPRejectedClaimException;

  class InvalidIdentityTokenException extends STSServiceException_1.STSServiceException {
    name = "InvalidIdentityTokenException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "InvalidIdentityTokenException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidIdentityTokenException.prototype);
    }
  }
  exports.InvalidIdentityTokenException = InvalidIdentityTokenException;

  class IDPCommunicationErrorException extends STSServiceException_1.STSServiceException {
    name = "IDPCommunicationErrorException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "IDPCommunicationErrorException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, IDPCommunicationErrorException.prototype);
    }
  }
  exports.IDPCommunicationErrorException = IDPCommunicationErrorException;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/schemas/schemas_0.js
var require_schemas_05 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AssumeRoleWithWebIdentity$ = exports.AssumeRole$ = exports.Tag$ = exports.ProvidedContext$ = exports.PolicyDescriptorType$ = exports.Credentials$ = exports.AssumeRoleWithWebIdentityResponse$ = exports.AssumeRoleWithWebIdentityRequest$ = exports.AssumeRoleResponse$ = exports.AssumeRoleRequest$ = exports.AssumedRoleUser$ = exports.errorTypeRegistries = exports.RegionDisabledException$ = exports.PackedPolicyTooLargeException$ = exports.MalformedPolicyDocumentException$ = exports.InvalidIdentityTokenException$ = exports.IDPRejectedClaimException$ = exports.IDPCommunicationErrorException$ = exports.ExpiredTokenException$ = exports.STSServiceException$ = undefined;
  var _A = "Arn";
  var _AKI = "AccessKeyId";
  var _AR = "AssumeRole";
  var _ARI = "AssumedRoleId";
  var _ARR = "AssumeRoleRequest";
  var _ARRs = "AssumeRoleResponse";
  var _ARU = "AssumedRoleUser";
  var _ARWWI = "AssumeRoleWithWebIdentity";
  var _ARWWIR = "AssumeRoleWithWebIdentityRequest";
  var _ARWWIRs = "AssumeRoleWithWebIdentityResponse";
  var _Au = "Audience";
  var _C = "Credentials";
  var _CA = "ContextAssertion";
  var _DS = "DurationSeconds";
  var _E = "Expiration";
  var _EI = "ExternalId";
  var _ETE = "ExpiredTokenException";
  var _IDPCEE = "IDPCommunicationErrorException";
  var _IDPRCE = "IDPRejectedClaimException";
  var _IITE = "InvalidIdentityTokenException";
  var _K = "Key";
  var _MPDE = "MalformedPolicyDocumentException";
  var _P = "Policy";
  var _PA = "PolicyArns";
  var _PAr = "ProviderArn";
  var _PC = "ProvidedContexts";
  var _PCLT = "ProvidedContextsListType";
  var _PCr = "ProvidedContext";
  var _PDT = "PolicyDescriptorType";
  var _PI = "ProviderId";
  var _PPS = "PackedPolicySize";
  var _PPTLE = "PackedPolicyTooLargeException";
  var _Pr = "Provider";
  var _RA = "RoleArn";
  var _RDE = "RegionDisabledException";
  var _RSN = "RoleSessionName";
  var _SAK = "SecretAccessKey";
  var _SFWIT = "SubjectFromWebIdentityToken";
  var _SI = "SourceIdentity";
  var _SN = "SerialNumber";
  var _ST = "SessionToken";
  var _T = "Tags";
  var _TC = "TokenCode";
  var _TTK = "TransitiveTagKeys";
  var _Ta = "Tag";
  var _V = "Value";
  var _WIT = "WebIdentityToken";
  var _a = "arn";
  var _aKST = "accessKeySecretType";
  var _aQE = "awsQueryError";
  var _c = "client";
  var _cTT = "clientTokenType";
  var _e = "error";
  var _hE = "httpError";
  var _m = "message";
  var _pDLT = "policyDescriptorListType";
  var _s = "smithy.ts.sdk.synthetic.com.amazonaws.sts";
  var _tLT = "tagListType";
  var n0 = "com.amazonaws.sts";
  var schema_1 = require_schema();
  var errors_1 = require_errors9();
  var STSServiceException_1 = require_STSServiceException();
  var _s_registry = schema_1.TypeRegistry.for(_s);
  exports.STSServiceException$ = [-3, _s, "STSServiceException", 0, [], []];
  _s_registry.registerError(exports.STSServiceException$, STSServiceException_1.STSServiceException);
  var n0_registry = schema_1.TypeRegistry.for(n0);
  exports.ExpiredTokenException$ = [
    -3,
    n0,
    _ETE,
    { [_aQE]: [`ExpiredTokenException`, 400], [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
  ];
  n0_registry.registerError(exports.ExpiredTokenException$, errors_1.ExpiredTokenException);
  exports.IDPCommunicationErrorException$ = [
    -3,
    n0,
    _IDPCEE,
    { [_aQE]: [`IDPCommunicationError`, 400], [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
  ];
  n0_registry.registerError(exports.IDPCommunicationErrorException$, errors_1.IDPCommunicationErrorException);
  exports.IDPRejectedClaimException$ = [
    -3,
    n0,
    _IDPRCE,
    { [_aQE]: [`IDPRejectedClaim`, 403], [_e]: _c, [_hE]: 403 },
    [_m],
    [0]
  ];
  n0_registry.registerError(exports.IDPRejectedClaimException$, errors_1.IDPRejectedClaimException);
  exports.InvalidIdentityTokenException$ = [
    -3,
    n0,
    _IITE,
    { [_aQE]: [`InvalidIdentityToken`, 400], [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
  ];
  n0_registry.registerError(exports.InvalidIdentityTokenException$, errors_1.InvalidIdentityTokenException);
  exports.MalformedPolicyDocumentException$ = [
    -3,
    n0,
    _MPDE,
    { [_aQE]: [`MalformedPolicyDocument`, 400], [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
  ];
  n0_registry.registerError(exports.MalformedPolicyDocumentException$, errors_1.MalformedPolicyDocumentException);
  exports.PackedPolicyTooLargeException$ = [
    -3,
    n0,
    _PPTLE,
    { [_aQE]: [`PackedPolicyTooLarge`, 400], [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
  ];
  n0_registry.registerError(exports.PackedPolicyTooLargeException$, errors_1.PackedPolicyTooLargeException);
  exports.RegionDisabledException$ = [
    -3,
    n0,
    _RDE,
    { [_aQE]: [`RegionDisabledException`, 403], [_e]: _c, [_hE]: 403 },
    [_m],
    [0]
  ];
  n0_registry.registerError(exports.RegionDisabledException$, errors_1.RegionDisabledException);
  exports.errorTypeRegistries = [_s_registry, n0_registry];
  var accessKeySecretType = [0, n0, _aKST, 8, 0];
  var clientTokenType = [0, n0, _cTT, 8, 0];
  exports.AssumedRoleUser$ = [3, n0, _ARU, 0, [_ARI, _A], [0, 0], 2];
  exports.AssumeRoleRequest$ = [
    3,
    n0,
    _ARR,
    0,
    [_RA, _RSN, _PA, _P, _DS, _T, _TTK, _EI, _SN, _TC, _SI, _PC],
    [0, 0, () => policyDescriptorListType, 0, 1, () => tagListType, 64 | 0, 0, 0, 0, 0, () => ProvidedContextsListType],
    2
  ];
  exports.AssumeRoleResponse$ = [
    3,
    n0,
    _ARRs,
    0,
    [_C, _ARU, _PPS, _SI],
    [[() => exports.Credentials$, 0], () => exports.AssumedRoleUser$, 1, 0]
  ];
  exports.AssumeRoleWithWebIdentityRequest$ = [
    3,
    n0,
    _ARWWIR,
    0,
    [_RA, _RSN, _WIT, _PI, _PA, _P, _DS],
    [0, 0, [() => clientTokenType, 0], 0, () => policyDescriptorListType, 0, 1],
    3
  ];
  exports.AssumeRoleWithWebIdentityResponse$ = [
    3,
    n0,
    _ARWWIRs,
    0,
    [_C, _SFWIT, _ARU, _PPS, _Pr, _Au, _SI],
    [[() => exports.Credentials$, 0], 0, () => exports.AssumedRoleUser$, 1, 0, 0, 0]
  ];
  exports.Credentials$ = [
    3,
    n0,
    _C,
    0,
    [_AKI, _SAK, _ST, _E],
    [0, [() => accessKeySecretType, 0], 0, 4],
    4
  ];
  exports.PolicyDescriptorType$ = [3, n0, _PDT, 0, [_a], [0]];
  exports.ProvidedContext$ = [3, n0, _PCr, 0, [_PAr, _CA], [0, 0]];
  exports.Tag$ = [3, n0, _Ta, 0, [_K, _V], [0, 0], 2];
  var policyDescriptorListType = [1, n0, _pDLT, 0, () => exports.PolicyDescriptorType$];
  var ProvidedContextsListType = [1, n0, _PCLT, 0, () => exports.ProvidedContext$];
  var tagKeyListType = 64 | 0;
  var tagListType = [1, n0, _tLT, 0, () => exports.Tag$];
  exports.AssumeRole$ = [9, n0, _AR, 0, () => exports.AssumeRoleRequest$, () => exports.AssumeRoleResponse$];
  exports.AssumeRoleWithWebIdentity$ = [
    9,
    n0,
    _ARWWI,
    0,
    () => exports.AssumeRoleWithWebIdentityRequest$,
    () => exports.AssumeRoleWithWebIdentityResponse$
  ];
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/runtimeConfig.shared.js
var require_runtimeConfig_shared4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var core_1 = require_dist_cjs24();
  var protocols_1 = require_protocols2();
  var core_2 = require_dist_cjs17();
  var smithy_client_1 = require_dist_cjs22();
  var url_parser_1 = require_dist_cjs38();
  var util_base64_1 = require_dist_cjs9();
  var util_utf8_1 = require_dist_cjs8();
  var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider5();
  var endpointResolver_1 = require_endpointResolver5();
  var schemas_0_1 = require_schemas_05();
  var getRuntimeConfig = (config) => {
    return {
      apiVersion: "2011-06-15",
      base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
      base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
      disableHostPrefix: config?.disableHostPrefix ?? false,
      endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
      extensions: config?.extensions ?? [],
      httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultSTSHttpAuthSchemeProvider,
      httpAuthSchemes: config?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
          signer: new core_1.AwsSdkSigV4Signer
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new core_2.NoAuthSigner
        }
      ],
      logger: config?.logger ?? new smithy_client_1.NoOpLogger,
      protocol: config?.protocol ?? protocols_1.AwsQueryProtocol,
      protocolSettings: config?.protocolSettings ?? {
        defaultNamespace: "com.amazonaws.sts",
        errorTypeRegistries: schemas_0_1.errorTypeRegistries,
        xmlNamespace: "https://sts.amazonaws.com/doc/2011-06-15/",
        version: "2011-06-15",
        serviceTarget: "AWSSecurityTokenServiceV20110615"
      },
      serviceId: config?.serviceId ?? "STS",
      urlParser: config?.urlParser ?? url_parser_1.parseUrl,
      utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
      utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/runtimeConfig.js
var require_runtimeConfig4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var tslib_1 = require_tslib();
  var package_json_1 = tslib_1.__importDefault(require_package5());
  var core_1 = require_dist_cjs24();
  var util_user_agent_node_1 = require_dist_cjs54();
  var config_resolver_1 = require_dist_cjs41();
  var core_2 = require_dist_cjs17();
  var hash_node_1 = require_dist_cjs55();
  var middleware_retry_1 = require_dist_cjs49();
  var node_config_provider_1 = require_dist_cjs45();
  var node_http_handler_1 = require_dist_cjs12();
  var smithy_client_1 = require_dist_cjs22();
  var util_body_length_node_1 = require_dist_cjs56();
  var util_defaults_mode_node_1 = require_dist_cjs57();
  var util_retry_1 = require_dist_cjs48();
  var runtimeConfig_shared_1 = require_runtimeConfig_shared4();
  var getRuntimeConfig = (config) => {
    (0, smithy_client_1.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    const loaderConfig = {
      profile: config?.profile,
      logger: clientSharedValues.logger
    };
    return {
      ...clientSharedValues,
      ...config,
      runtime: "node",
      defaultsMode,
      authSchemePreference: config?.authSchemePreference ?? (0, node_config_provider_1.loadConfig)(core_1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
      bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
      defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
      httpAuthSchemes: config?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4") || (async (idProps) => await config.credentialDefaultProvider(idProps?.__config || {})()),
          signer: new core_1.AwsSdkSigV4Signer
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new core_2.NoAuthSigner
        }
      ],
      maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
      region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
      requestHandler: node_http_handler_1.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
      retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
        default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
      }, config),
      sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
      streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
      useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
      useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
      userAgentAppId: config?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/auth/httpAuthExtensionConfiguration.js
var require_httpAuthExtensionConfiguration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveHttpAuthRuntimeConfig = exports.getHttpAuthExtensionConfiguration = undefined;
  var getHttpAuthExtensionConfiguration = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
      setHttpAuthScheme(httpAuthScheme) {
        const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
        if (index === -1) {
          _httpAuthSchemes.push(httpAuthScheme);
        } else {
          _httpAuthSchemes.splice(index, 1, httpAuthScheme);
        }
      },
      httpAuthSchemes() {
        return _httpAuthSchemes;
      },
      setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
        _httpAuthSchemeProvider = httpAuthSchemeProvider;
      },
      httpAuthSchemeProvider() {
        return _httpAuthSchemeProvider;
      },
      setCredentials(credentials) {
        _credentials = credentials;
      },
      credentials() {
        return _credentials;
      }
    };
  };
  exports.getHttpAuthExtensionConfiguration = getHttpAuthExtensionConfiguration;
  var resolveHttpAuthRuntimeConfig = (config) => {
    return {
      httpAuthSchemes: config.httpAuthSchemes(),
      httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
      credentials: config.credentials()
    };
  };
  exports.resolveHttpAuthRuntimeConfig = resolveHttpAuthRuntimeConfig;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/runtimeExtensions.js
var require_runtimeExtensions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveRuntimeExtensions = undefined;
  var region_config_resolver_1 = require_dist_cjs58();
  var protocol_http_1 = require_dist_cjs2();
  var smithy_client_1 = require_dist_cjs22();
  var httpAuthExtensionConfiguration_1 = require_httpAuthExtensionConfiguration();
  var resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = Object.assign((0, region_config_resolver_1.getAwsRegionExtensionConfiguration)(runtimeConfig), (0, smithy_client_1.getDefaultExtensionConfiguration)(runtimeConfig), (0, protocol_http_1.getHttpHandlerExtensionConfiguration)(runtimeConfig), (0, httpAuthExtensionConfiguration_1.getHttpAuthExtensionConfiguration)(runtimeConfig));
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return Object.assign(runtimeConfig, (0, region_config_resolver_1.resolveAwsRegionExtensionConfiguration)(extensionConfiguration), (0, smithy_client_1.resolveDefaultRuntimeConfig)(extensionConfiguration), (0, protocol_http_1.resolveHttpHandlerRuntimeConfig)(extensionConfiguration), (0, httpAuthExtensionConfiguration_1.resolveHttpAuthRuntimeConfig)(extensionConfiguration));
  };
  exports.resolveRuntimeExtensions = resolveRuntimeExtensions;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/STSClient.js
var require_STSClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.STSClient = exports.__Client = undefined;
  var middleware_host_header_1 = require_dist_cjs30();
  var middleware_logger_1 = require_dist_cjs31();
  var middleware_recursion_detection_1 = require_dist_cjs32();
  var middleware_user_agent_1 = require_dist_cjs40();
  var config_resolver_1 = require_dist_cjs41();
  var core_1 = require_dist_cjs17();
  var schema_1 = require_schema();
  var middleware_content_length_1 = require_dist_cjs43();
  var middleware_endpoint_1 = require_dist_cjs46();
  var middleware_retry_1 = require_dist_cjs49();
  var smithy_client_1 = require_dist_cjs22();
  Object.defineProperty(exports, "__Client", { enumerable: true, get: function() {
    return smithy_client_1.Client;
  } });
  var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider5();
  var EndpointParameters_1 = require_EndpointParameters();
  var runtimeConfig_1 = require_runtimeConfig4();
  var runtimeExtensions_1 = require_runtimeExtensions();

  class STSClient extends smithy_client_1.Client {
    config;
    constructor(...[configuration]) {
      const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration || {});
      super(_config_0);
      this.initConfig = _config_0;
      const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
      const _config_2 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_1);
      const _config_3 = (0, middleware_retry_1.resolveRetryConfig)(_config_2);
      const _config_4 = (0, config_resolver_1.resolveRegionConfig)(_config_3);
      const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
      const _config_6 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_5);
      const _config_7 = (0, httpAuthSchemeProvider_1.resolveHttpAuthSchemeConfig)(_config_6);
      const _config_8 = (0, runtimeExtensions_1.resolveRuntimeExtensions)(_config_7, configuration?.extensions || []);
      this.config = _config_8;
      this.middlewareStack.use((0, schema_1.getSchemaSerdePlugin)(this.config));
      this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
      this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
      this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
      this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
      this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
      this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
      this.middlewareStack.use((0, core_1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
        httpAuthSchemeParametersProvider: httpAuthSchemeProvider_1.defaultSTSHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config) => new core_1.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config.credentials
        })
      }));
      this.middlewareStack.use((0, core_1.getHttpSigningPlugin)(this.config));
    }
    destroy() {
      super.destroy();
    }
  }
  exports.STSClient = STSClient;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/index.js
var require_sts = __commonJS((exports) => {
  var STSClient = require_STSClient();
  var smithyClient = require_dist_cjs22();
  var middlewareEndpoint = require_dist_cjs46();
  var EndpointParameters = require_EndpointParameters();
  var schemas_0 = require_schemas_05();
  var errors = require_errors9();
  var client3 = require_client2();
  var regionConfigResolver = require_dist_cjs58();
  var STSServiceException = require_STSServiceException();

  class AssumeRoleCommand extends smithyClient.Command.classBuilder().ep(EndpointParameters.commonParams).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AWSSecurityTokenServiceV20110615", "AssumeRole", {}).n("STSClient", "AssumeRoleCommand").sc(schemas_0.AssumeRole$).build() {
  }

  class AssumeRoleWithWebIdentityCommand extends smithyClient.Command.classBuilder().ep(EndpointParameters.commonParams).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {}).n("STSClient", "AssumeRoleWithWebIdentityCommand").sc(schemas_0.AssumeRoleWithWebIdentity$).build() {
  }
  var commands = {
    AssumeRoleCommand,
    AssumeRoleWithWebIdentityCommand
  };

  class STS extends STSClient.STSClient {
  }
  smithyClient.createAggregatedClient(commands, STS);
  var getAccountIdFromAssumedRoleUser = (assumedRoleUser) => {
    if (typeof assumedRoleUser?.Arn === "string") {
      const arnComponents = assumedRoleUser.Arn.split(":");
      if (arnComponents.length > 4 && arnComponents[4] !== "") {
        return arnComponents[4];
      }
    }
    return;
  };
  var resolveRegion = async (_region, _parentRegion, credentialProviderLogger, loaderConfig = {}) => {
    const region = typeof _region === "function" ? await _region() : _region;
    const parentRegion = typeof _parentRegion === "function" ? await _parentRegion() : _parentRegion;
    let stsDefaultRegion = "";
    const resolvedRegion = region ?? parentRegion ?? (stsDefaultRegion = await regionConfigResolver.stsRegionDefaultResolver(loaderConfig)());
    credentialProviderLogger?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${region} (credential provider clientConfig)`, `${parentRegion} (contextual client)`, `${stsDefaultRegion} (STS default: AWS_REGION, profile region, or us-east-1)`);
    return resolvedRegion;
  };
  var getDefaultRoleAssumer$1 = (stsOptions, STSClient2) => {
    let stsClient;
    let closureSourceCreds;
    return async (sourceCreds, params) => {
      closureSourceCreds = sourceCreds;
      if (!stsClient) {
        const { logger = stsOptions?.parentClientConfig?.logger, profile = stsOptions?.parentClientConfig?.profile, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger, userAgentAppId = stsOptions?.parentClientConfig?.userAgentAppId } = stsOptions;
        const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger, {
          logger,
          profile
        });
        const isCompatibleRequestHandler = !isH2(requestHandler);
        stsClient = new STSClient2({
          ...stsOptions,
          userAgentAppId,
          profile,
          credentialDefaultProvider: () => async () => closureSourceCreds,
          region: resolvedRegion,
          requestHandler: isCompatibleRequestHandler ? requestHandler : undefined,
          logger
        });
      }
      const { Credentials, AssumedRoleUser } = await stsClient.send(new AssumeRoleCommand(params));
      if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
        throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
      }
      const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser);
      const credentials = {
        accessKeyId: Credentials.AccessKeyId,
        secretAccessKey: Credentials.SecretAccessKey,
        sessionToken: Credentials.SessionToken,
        expiration: Credentials.Expiration,
        ...Credentials.CredentialScope && { credentialScope: Credentials.CredentialScope },
        ...accountId && { accountId }
      };
      client3.setCredentialFeature(credentials, "CREDENTIALS_STS_ASSUME_ROLE", "i");
      return credentials;
    };
  };
  var getDefaultRoleAssumerWithWebIdentity$1 = (stsOptions, STSClient2) => {
    let stsClient;
    return async (params) => {
      if (!stsClient) {
        const { logger = stsOptions?.parentClientConfig?.logger, profile = stsOptions?.parentClientConfig?.profile, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger, userAgentAppId = stsOptions?.parentClientConfig?.userAgentAppId } = stsOptions;
        const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger, {
          logger,
          profile
        });
        const isCompatibleRequestHandler = !isH2(requestHandler);
        stsClient = new STSClient2({
          ...stsOptions,
          userAgentAppId,
          profile,
          region: resolvedRegion,
          requestHandler: isCompatibleRequestHandler ? requestHandler : undefined,
          logger
        });
      }
      const { Credentials, AssumedRoleUser } = await stsClient.send(new AssumeRoleWithWebIdentityCommand(params));
      if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
        throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
      }
      const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser);
      const credentials = {
        accessKeyId: Credentials.AccessKeyId,
        secretAccessKey: Credentials.SecretAccessKey,
        sessionToken: Credentials.SessionToken,
        expiration: Credentials.Expiration,
        ...Credentials.CredentialScope && { credentialScope: Credentials.CredentialScope },
        ...accountId && { accountId }
      };
      if (accountId) {
        client3.setCredentialFeature(credentials, "RESOLVED_ACCOUNT_ID", "T");
      }
      client3.setCredentialFeature(credentials, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k");
      return credentials;
    };
  };
  var isH2 = (requestHandler) => {
    return requestHandler?.metadata?.handlerProtocol === "h2";
  };
  var getCustomizableStsClientCtor = (baseCtor, customizations) => {
    if (!customizations)
      return baseCtor;
    else
      return class CustomizableSTSClient extends baseCtor {
        constructor(config) {
          super(config);
          for (const customization of customizations) {
            this.middlewareStack.use(customization);
          }
        }
      };
  };
  var getDefaultRoleAssumer = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumer$1(stsOptions, getCustomizableStsClientCtor(STSClient.STSClient, stsPlugins));
  var getDefaultRoleAssumerWithWebIdentity = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity$1(stsOptions, getCustomizableStsClientCtor(STSClient.STSClient, stsPlugins));
  var decorateDefaultCredentialProvider = (provider) => (input) => provider({
    roleAssumer: getDefaultRoleAssumer(input),
    roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity(input),
    ...input
  });
  exports.$Command = smithyClient.Command;
  exports.STSServiceException = STSServiceException.STSServiceException;
  exports.AssumeRoleCommand = AssumeRoleCommand;
  exports.AssumeRoleWithWebIdentityCommand = AssumeRoleWithWebIdentityCommand;
  exports.STS = STS;
  exports.decorateDefaultCredentialProvider = decorateDefaultCredentialProvider;
  exports.getDefaultRoleAssumer = getDefaultRoleAssumer;
  exports.getDefaultRoleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity;
  Object.prototype.hasOwnProperty.call(STSClient, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: STSClient["__proto__"]
  });
  Object.keys(STSClient).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = STSClient[k];
  });
  Object.prototype.hasOwnProperty.call(schemas_0, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: schemas_0["__proto__"]
  });
  Object.keys(schemas_0).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = schemas_0[k];
  });
  Object.prototype.hasOwnProperty.call(errors, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: errors["__proto__"]
  });
  Object.keys(errors).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = errors[k];
  });
});

// node_modules/@aws-sdk/credential-provider-process/dist-cjs/index.js
var require_dist_cjs62 = __commonJS((exports) => {
  var sharedIniFileLoader = require_dist_cjs44();
  var propertyProvider = require_dist_cjs18();
  var child_process = __require("child_process");
  var util = __require("util");
  var client3 = require_client2();
  var getValidatedProcessCredentials = (profileName, data, profiles) => {
    if (data.Version !== 1) {
      throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
    }
    if (data.AccessKeyId === undefined || data.SecretAccessKey === undefined) {
      throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
    }
    if (data.Expiration) {
      const currentTime = new Date;
      const expireTime = new Date(data.Expiration);
      if (expireTime < currentTime) {
        throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
      }
    }
    let accountId = data.AccountId;
    if (!accountId && profiles?.[profileName]?.aws_account_id) {
      accountId = profiles[profileName].aws_account_id;
    }
    const credentials = {
      accessKeyId: data.AccessKeyId,
      secretAccessKey: data.SecretAccessKey,
      ...data.SessionToken && { sessionToken: data.SessionToken },
      ...data.Expiration && { expiration: new Date(data.Expiration) },
      ...data.CredentialScope && { credentialScope: data.CredentialScope },
      ...accountId && { accountId }
    };
    client3.setCredentialFeature(credentials, "CREDENTIALS_PROCESS", "w");
    return credentials;
  };
  var resolveProcessCredentials = async (profileName, profiles, logger) => {
    const profile = profiles[profileName];
    if (profiles[profileName]) {
      const credentialProcess = profile["credential_process"];
      if (credentialProcess !== undefined) {
        const execPromise = util.promisify(sharedIniFileLoader.externalDataInterceptor?.getTokenRecord?.().exec ?? child_process.exec);
        try {
          const { stdout } = await execPromise(credentialProcess);
          let data;
          try {
            data = JSON.parse(stdout.trim());
          } catch {
            throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
          }
          return getValidatedProcessCredentials(profileName, data, profiles);
        } catch (error) {
          throw new propertyProvider.CredentialsProviderError(error.message, { logger });
        }
      } else {
        throw new propertyProvider.CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`, { logger });
      }
    } else {
      throw new propertyProvider.CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`, {
        logger
      });
    }
  };
  var fromProcess = (init = {}) => async ({ callerClientConfig } = {}) => {
    init.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
    const profiles = await sharedIniFileLoader.parseKnownFiles(init);
    return resolveProcessCredentials(sharedIniFileLoader.getProfileName({
      profile: init.profile ?? callerClientConfig?.profile
    }), profiles, init.logger);
  };
  exports.fromProcess = fromProcess;
});

// node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/fromWebToken.js
var require_fromWebToken = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i2 = 0;i2 < k.length; i2++)
          if (k[i2] !== "default")
            __createBinding(result, mod, k[i2]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromWebToken = undefined;
  var fromWebToken = (init) => async (awsIdentityProperties) => {
    init.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
    const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds } = init;
    let { roleAssumerWithWebIdentity } = init;
    if (!roleAssumerWithWebIdentity) {
      const { getDefaultRoleAssumerWithWebIdentity } = await Promise.resolve().then(() => __importStar(require_sts()));
      roleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity({
        ...init.clientConfig,
        credentialProviderLogger: init.logger,
        parentClientConfig: {
          ...awsIdentityProperties?.callerClientConfig,
          ...init.parentClientConfig
        }
      }, init.clientPlugins);
    }
    return roleAssumerWithWebIdentity({
      RoleArn: roleArn,
      RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
      WebIdentityToken: webIdentityToken,
      ProviderId: providerId,
      PolicyArns: policyArns,
      Policy: policy,
      DurationSeconds: durationSeconds
    });
  };
  exports.fromWebToken = fromWebToken;
});

// node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/fromTokenFile.js
var require_fromTokenFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromTokenFile = undefined;
  var client_1 = require_client2();
  var property_provider_1 = require_dist_cjs18();
  var shared_ini_file_loader_1 = require_dist_cjs44();
  var fs_1 = __require("fs");
  var fromWebToken_1 = require_fromWebToken();
  var ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE";
  var ENV_ROLE_ARN = "AWS_ROLE_ARN";
  var ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME";
  var fromTokenFile = (init = {}) => async (awsIdentityProperties) => {
    init.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile");
    const webIdentityTokenFile = init?.webIdentityTokenFile ?? process.env[ENV_TOKEN_FILE];
    const roleArn = init?.roleArn ?? process.env[ENV_ROLE_ARN];
    const roleSessionName = init?.roleSessionName ?? process.env[ENV_ROLE_SESSION_NAME];
    if (!webIdentityTokenFile || !roleArn) {
      throw new property_provider_1.CredentialsProviderError("Web identity configuration not specified", {
        logger: init.logger
      });
    }
    const credentials = await (0, fromWebToken_1.fromWebToken)({
      ...init,
      webIdentityToken: shared_ini_file_loader_1.externalDataInterceptor?.getTokenRecord?.()[webIdentityTokenFile] ?? (0, fs_1.readFileSync)(webIdentityTokenFile, { encoding: "ascii" }),
      roleArn,
      roleSessionName
    })(awsIdentityProperties);
    if (webIdentityTokenFile === process.env[ENV_TOKEN_FILE]) {
      (0, client_1.setCredentialFeature)(credentials, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h");
    }
    return credentials;
  };
  exports.fromTokenFile = fromTokenFile;
});

// node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/index.js
var require_dist_cjs63 = __commonJS((exports) => {
  var fromTokenFile = require_fromTokenFile();
  var fromWebToken = require_fromWebToken();
  Object.prototype.hasOwnProperty.call(fromTokenFile, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: fromTokenFile["__proto__"]
  });
  Object.keys(fromTokenFile).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = fromTokenFile[k];
  });
  Object.prototype.hasOwnProperty.call(fromWebToken, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: fromWebToken["__proto__"]
  });
  Object.keys(fromWebToken).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = fromWebToken[k];
  });
});

// node_modules/@aws-sdk/credential-provider-ini/dist-cjs/index.js
var require_dist_cjs64 = __commonJS((exports) => {
  var sharedIniFileLoader = require_dist_cjs44();
  var propertyProvider = require_dist_cjs18();
  var client3 = require_client2();
  var credentialProviderLogin = require_dist_cjs61();
  var resolveCredentialSource = (credentialSource, profileName, logger) => {
    const sourceProvidersMap = {
      EcsContainer: async (options) => {
        const { fromHttp } = await Promise.resolve().then(() => __toESM(require_dist_cjs53()));
        const { fromContainerMetadata } = await Promise.resolve().then(() => __toESM(require_dist_cjs52()));
        logger?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer");
        return async () => propertyProvider.chain(fromHttp(options ?? {}), fromContainerMetadata(options))().then(setNamedProvider);
      },
      Ec2InstanceMetadata: async (options) => {
        logger?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata");
        const { fromInstanceMetadata } = await Promise.resolve().then(() => __toESM(require_dist_cjs52()));
        return async () => fromInstanceMetadata(options)().then(setNamedProvider);
      },
      Environment: async (options) => {
        logger?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment");
        const { fromEnv } = await Promise.resolve().then(() => __toESM(require_dist_cjs51()));
        return async () => fromEnv(options)().then(setNamedProvider);
      }
    };
    if (credentialSource in sourceProvidersMap) {
      return sourceProvidersMap[credentialSource];
    } else {
      throw new propertyProvider.CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, expected EcsContainer or Ec2InstanceMetadata or Environment.`, { logger });
    }
  };
  var setNamedProvider = (creds) => client3.setCredentialFeature(creds, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p");
  var isAssumeRoleProfile = (arg, { profile = "default", logger } = {}) => {
    return Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof arg.external_id) > -1 && ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile(arg, { profile, logger }) || isCredentialSourceProfile(arg, { profile, logger }));
  };
  var isAssumeRoleWithSourceProfile = (arg, { profile, logger }) => {
    const withSourceProfile = typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
    if (withSourceProfile) {
      logger?.debug?.(`    ${profile} isAssumeRoleWithSourceProfile source_profile=${arg.source_profile}`);
    }
    return withSourceProfile;
  };
  var isCredentialSourceProfile = (arg, { profile, logger }) => {
    const withProviderProfile = typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
    if (withProviderProfile) {
      logger?.debug?.(`    ${profile} isCredentialSourceProfile credential_source=${arg.credential_source}`);
    }
    return withProviderProfile;
  };
  var resolveAssumeRoleCredentials = async (profileName, profiles, options, callerClientConfig, visitedProfiles = {}, resolveProfileData2) => {
    options.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)");
    const profileData = profiles[profileName];
    const { source_profile, region } = profileData;
    if (!options.roleAssumer) {
      const { getDefaultRoleAssumer } = await Promise.resolve().then(() => __toESM(require_sts()));
      options.roleAssumer = getDefaultRoleAssumer({
        ...options.clientConfig,
        credentialProviderLogger: options.logger,
        parentClientConfig: {
          ...callerClientConfig,
          ...options?.parentClientConfig,
          region: region ?? options?.parentClientConfig?.region ?? callerClientConfig?.region
        }
      }, options.clientPlugins);
    }
    if (source_profile && source_profile in visitedProfiles) {
      throw new propertyProvider.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${sharedIniFileLoader.getProfileName(options)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "), { logger: options.logger });
    }
    options.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${source_profile ? `source_profile=[${source_profile}]` : `profile=[${profileName}]`}`);
    const sourceCredsProvider = source_profile ? resolveProfileData2(source_profile, profiles, options, callerClientConfig, {
      ...visitedProfiles,
      [source_profile]: true
    }, isCredentialSourceWithoutRoleArn(profiles[source_profile] ?? {})) : (await resolveCredentialSource(profileData.credential_source, profileName, options.logger)(options))();
    if (isCredentialSourceWithoutRoleArn(profileData)) {
      return sourceCredsProvider.then((creds) => client3.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
    } else {
      const params = {
        RoleArn: profileData.role_arn,
        RoleSessionName: profileData.role_session_name || `aws-sdk-js-${Date.now()}`,
        ExternalId: profileData.external_id,
        DurationSeconds: parseInt(profileData.duration_seconds || "3600", 10)
      };
      const { mfa_serial } = profileData;
      if (mfa_serial) {
        if (!options.mfaCodeProvider) {
          throw new propertyProvider.CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, { logger: options.logger, tryNextLink: false });
        }
        params.SerialNumber = mfa_serial;
        params.TokenCode = await options.mfaCodeProvider(mfa_serial);
      }
      const sourceCreds = await sourceCredsProvider;
      return options.roleAssumer(sourceCreds, params).then((creds) => client3.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
    }
  };
  var isCredentialSourceWithoutRoleArn = (section) => {
    return !section.role_arn && !!section.credential_source;
  };
  var isLoginProfile = (data) => {
    return Boolean(data && data.login_session);
  };
  var resolveLoginCredentials = async (profileName, options, callerClientConfig) => {
    const credentials = await credentialProviderLogin.fromLoginCredentials({
      ...options,
      profile: profileName
    })({ callerClientConfig });
    return client3.setCredentialFeature(credentials, "CREDENTIALS_PROFILE_LOGIN", "AC");
  };
  var isProcessProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string";
  var resolveProcessCredentials = async (options, profile) => Promise.resolve().then(() => __toESM(require_dist_cjs62())).then(({ fromProcess }) => fromProcess({
    ...options,
    profile
  })().then((creds) => client3.setCredentialFeature(creds, "CREDENTIALS_PROFILE_PROCESS", "v")));
  var resolveSsoCredentials = async (profile, profileData, options = {}, callerClientConfig) => {
    const { fromSSO } = await Promise.resolve().then(() => __toESM(require_dist_cjs60()));
    return fromSSO({
      profile,
      logger: options.logger,
      parentClientConfig: options.parentClientConfig,
      clientConfig: options.clientConfig
    })({
      callerClientConfig
    }).then((creds) => {
      if (profileData.sso_session) {
        return client3.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SSO", "r");
      } else {
        return client3.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SSO_LEGACY", "t");
      }
    });
  };
  var isSsoProfile = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");
  var isStaticCredsProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof arg.aws_account_id) > -1;
  var resolveStaticCredentials = async (profile, options) => {
    options?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials");
    const credentials = {
      accessKeyId: profile.aws_access_key_id,
      secretAccessKey: profile.aws_secret_access_key,
      sessionToken: profile.aws_session_token,
      ...profile.aws_credential_scope && { credentialScope: profile.aws_credential_scope },
      ...profile.aws_account_id && { accountId: profile.aws_account_id }
    };
    return client3.setCredentialFeature(credentials, "CREDENTIALS_PROFILE", "n");
  };
  var isWebIdentityProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1;
  var resolveWebIdentityCredentials = async (profile, options, callerClientConfig) => Promise.resolve().then(() => __toESM(require_dist_cjs63())).then(({ fromTokenFile }) => fromTokenFile({
    webIdentityTokenFile: profile.web_identity_token_file,
    roleArn: profile.role_arn,
    roleSessionName: profile.role_session_name,
    roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity,
    logger: options.logger,
    parentClientConfig: options.parentClientConfig
  })({
    callerClientConfig
  }).then((creds) => client3.setCredentialFeature(creds, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q")));
  var resolveProfileData = async (profileName, profiles, options, callerClientConfig, visitedProfiles = {}, isAssumeRoleRecursiveCall = false) => {
    const data = profiles[profileName];
    if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile(data)) {
      return resolveStaticCredentials(data, options);
    }
    if (isAssumeRoleRecursiveCall || isAssumeRoleProfile(data, { profile: profileName, logger: options.logger })) {
      return resolveAssumeRoleCredentials(profileName, profiles, options, callerClientConfig, visitedProfiles, resolveProfileData);
    }
    if (isStaticCredsProfile(data)) {
      return resolveStaticCredentials(data, options);
    }
    if (isWebIdentityProfile(data)) {
      return resolveWebIdentityCredentials(data, options, callerClientConfig);
    }
    if (isProcessProfile(data)) {
      return resolveProcessCredentials(options, profileName);
    }
    if (isSsoProfile(data)) {
      return await resolveSsoCredentials(profileName, data, options, callerClientConfig);
    }
    if (isLoginProfile(data)) {
      return resolveLoginCredentials(profileName, options, callerClientConfig);
    }
    throw new propertyProvider.CredentialsProviderError(`Could not resolve credentials using profile: [${profileName}] in configuration/credentials file(s).`, { logger: options.logger });
  };
  var fromIni = (init = {}) => async ({ callerClientConfig } = {}) => {
    init.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
    const profiles = await sharedIniFileLoader.parseKnownFiles(init);
    return resolveProfileData(sharedIniFileLoader.getProfileName({
      profile: init.profile ?? callerClientConfig?.profile
    }), profiles, init, callerClientConfig);
  };
  exports.fromIni = fromIni;
});

// node_modules/@aws-sdk/credential-provider-node/dist-cjs/index.js
var require_dist_cjs65 = __commonJS((exports) => {
  var credentialProviderEnv = require_dist_cjs51();
  var propertyProvider = require_dist_cjs18();
  var sharedIniFileLoader = require_dist_cjs44();
  var ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
  var remoteProvider = async (init) => {
    const { ENV_CMDS_FULL_URI, ENV_CMDS_RELATIVE_URI, fromContainerMetadata, fromInstanceMetadata } = await Promise.resolve().then(() => __toESM(require_dist_cjs52()));
    if (process.env[ENV_CMDS_RELATIVE_URI] || process.env[ENV_CMDS_FULL_URI]) {
      init.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
      const { fromHttp } = await Promise.resolve().then(() => __toESM(require_dist_cjs53()));
      return propertyProvider.chain(fromHttp(init), fromContainerMetadata(init));
    }
    if (process.env[ENV_IMDS_DISABLED] && process.env[ENV_IMDS_DISABLED] !== "false") {
      return async () => {
        throw new propertyProvider.CredentialsProviderError("EC2 Instance Metadata Service access disabled", { logger: init.logger });
      };
    }
    init.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata");
    return fromInstanceMetadata(init);
  };
  function memoizeChain(providers, treatAsExpired) {
    const chain = internalCreateChain(providers);
    let activeLock;
    let passiveLock;
    let credentials;
    const provider = async (options) => {
      if (options?.forceRefresh) {
        return await chain(options);
      }
      if (credentials?.expiration) {
        if (credentials?.expiration?.getTime() < Date.now()) {
          credentials = undefined;
        }
      }
      if (activeLock) {
        await activeLock;
      } else if (!credentials || treatAsExpired?.(credentials)) {
        if (credentials) {
          if (!passiveLock) {
            passiveLock = chain(options).then((c) => {
              credentials = c;
            }).finally(() => {
              passiveLock = undefined;
            });
          }
        } else {
          activeLock = chain(options).then((c) => {
            credentials = c;
          }).finally(() => {
            activeLock = undefined;
          });
          return provider(options);
        }
      }
      return credentials;
    };
    return provider;
  }
  var internalCreateChain = (providers) => async (awsIdentityProperties) => {
    let lastProviderError;
    for (const provider of providers) {
      try {
        return await provider(awsIdentityProperties);
      } catch (err) {
        lastProviderError = err;
        if (err?.tryNextLink) {
          continue;
        }
        throw err;
      }
    }
    throw lastProviderError;
  };
  var multipleCredentialSourceWarningEmitted = false;
  var defaultProvider = (init = {}) => memoizeChain([
    async () => {
      const profile = init.profile ?? process.env[sharedIniFileLoader.ENV_PROFILE];
      if (profile) {
        const envStaticCredentialsAreSet = process.env[credentialProviderEnv.ENV_KEY] && process.env[credentialProviderEnv.ENV_SECRET];
        if (envStaticCredentialsAreSet) {
          if (!multipleCredentialSourceWarningEmitted) {
            const warnFn = init.logger?.warn && init.logger?.constructor?.name !== "NoOpLogger" ? init.logger.warn.bind(init.logger) : console.warn;
            warnFn(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`);
            multipleCredentialSourceWarningEmitted = true;
          }
        }
        throw new propertyProvider.CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
          logger: init.logger,
          tryNextLink: true
        });
      }
      init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv");
      return credentialProviderEnv.fromEnv(init)();
    },
    async (awsIdentityProperties) => {
      init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
      const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;
      if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
        throw new propertyProvider.CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).", { logger: init.logger });
      }
      const { fromSSO } = await Promise.resolve().then(() => __toESM(require_dist_cjs60()));
      return fromSSO(init)(awsIdentityProperties);
    },
    async (awsIdentityProperties) => {
      init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
      const { fromIni } = await Promise.resolve().then(() => __toESM(require_dist_cjs64()));
      return fromIni(init)(awsIdentityProperties);
    },
    async (awsIdentityProperties) => {
      init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
      const { fromProcess } = await Promise.resolve().then(() => __toESM(require_dist_cjs62()));
      return fromProcess(init)(awsIdentityProperties);
    },
    async (awsIdentityProperties) => {
      init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
      const { fromTokenFile } = await Promise.resolve().then(() => __toESM(require_dist_cjs63()));
      return fromTokenFile(init)(awsIdentityProperties);
    },
    async () => {
      init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider");
      return (await remoteProvider(init))();
    },
    async () => {
      throw new propertyProvider.CredentialsProviderError("Could not load credentials from any providers", {
        tryNextLink: false,
        logger: init.logger
      });
    }
  ], credentialsTreatedAsExpired);
  var credentialsWillNeedRefresh = (credentials) => credentials?.expiration !== undefined;
  var credentialsTreatedAsExpired = (credentials) => credentials?.expiration !== undefined && credentials.expiration.getTime() - Date.now() < 300000;
  exports.credentialsTreatedAsExpired = credentialsTreatedAsExpired;
  exports.credentialsWillNeedRefresh = credentialsWillNeedRefresh;
  exports.defaultProvider = defaultProvider;
});

// node_modules/@aws-sdk/middleware-bucket-endpoint/dist-cjs/index.js
var require_dist_cjs66 = __commonJS((exports) => {
  var utilConfigProvider = require_dist_cjs34();
  var utilArnParser = require_dist_cjs33();
  var protocolHttp = require_dist_cjs2();
  var NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME = "AWS_S3_DISABLE_MULTIREGION_ACCESS_POINTS";
  var NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME = "s3_disable_multiregion_access_points";
  var NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => utilConfigProvider.booleanSelector(env, NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME, utilConfigProvider.SelectorType.ENV),
    configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME, utilConfigProvider.SelectorType.CONFIG),
    default: false
  };
  var NODE_USE_ARN_REGION_ENV_NAME = "AWS_S3_USE_ARN_REGION";
  var NODE_USE_ARN_REGION_INI_NAME = "s3_use_arn_region";
  var NODE_USE_ARN_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => utilConfigProvider.booleanSelector(env, NODE_USE_ARN_REGION_ENV_NAME, utilConfigProvider.SelectorType.ENV),
    configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, NODE_USE_ARN_REGION_INI_NAME, utilConfigProvider.SelectorType.CONFIG),
    default: undefined
  };
  var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
  var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
  var DOTS_PATTERN = /\.\./;
  var DOT_PATTERN = /\./;
  var S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
  var S3_US_EAST_1_ALTNAME_PATTERN = /^s3(-external-1)?\.amazonaws\.com$/;
  var AWS_PARTITION_SUFFIX = "amazonaws.com";
  var isBucketNameOptions = (options) => typeof options.bucketName === "string";
  var isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
  var getRegionalSuffix = (hostname) => {
    const parts = hostname.match(S3_HOSTNAME_PATTERN);
    return [parts[4], hostname.replace(new RegExp(`^${parts[0]}`), "")];
  };
  var getSuffix = (hostname) => S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? ["us-east-1", AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);
  var getSuffixForArnEndpoint = (hostname) => S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? [hostname.replace(`.${AWS_PARTITION_SUFFIX}`, ""), AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);
  var validateArnEndpointOptions = (options) => {
    if (options.pathStyleEndpoint) {
      throw new Error("Path-style S3 endpoint is not supported when bucket is an ARN");
    }
    if (options.accelerateEndpoint) {
      throw new Error("Accelerate endpoint is not supported when bucket is an ARN");
    }
    if (!options.tlsCompatible) {
      throw new Error("HTTPS is required when bucket is an ARN");
    }
  };
  var validateService = (service) => {
    if (service !== "s3" && service !== "s3-outposts" && service !== "s3-object-lambda") {
      throw new Error("Expect 's3' or 's3-outposts' or 's3-object-lambda' in ARN service component");
    }
  };
  var validateS3Service = (service) => {
    if (service !== "s3") {
      throw new Error("Expect 's3' in Accesspoint ARN service component");
    }
  };
  var validateOutpostService = (service) => {
    if (service !== "s3-outposts") {
      throw new Error("Expect 's3-posts' in Outpost ARN service component");
    }
  };
  var validatePartition = (partition2, options) => {
    if (partition2 !== options.clientPartition) {
      throw new Error(`Partition in ARN is incompatible, got "${partition2}" but expected "${options.clientPartition}"`);
    }
  };
  var validateRegion = (region, options) => {};
  var validateRegionalClient = (region) => {
    if (["s3-external-1", "aws-global"].includes(region)) {
      throw new Error(`Client region ${region} is not regional`);
    }
  };
  var validateAccountId = (accountId) => {
    if (!/[0-9]{12}/.exec(accountId)) {
      throw new Error("Access point ARN accountID does not match regex '[0-9]{12}'");
    }
  };
  var validateDNSHostLabel = (label, options = { tlsCompatible: true }) => {
    if (label.length >= 64 || !/^[a-z0-9][a-z0-9.-]*[a-z0-9]$/.test(label) || /(\d+\.){3}\d+/.test(label) || /[.-]{2}/.test(label) || options?.tlsCompatible && DOT_PATTERN.test(label)) {
      throw new Error(`Invalid DNS label ${label}`);
    }
  };
  var validateCustomEndpoint = (options) => {
    if (options.isCustomEndpoint) {
      if (options.dualstackEndpoint)
        throw new Error("Dualstack endpoint is not supported with custom endpoint");
      if (options.accelerateEndpoint)
        throw new Error("Accelerate endpoint is not supported with custom endpoint");
    }
  };
  var getArnResources = (resource) => {
    const delimiter = resource.includes(":") ? ":" : "/";
    const [resourceType, ...rest] = resource.split(delimiter);
    if (resourceType === "accesspoint") {
      if (rest.length !== 1 || rest[0] === "") {
        throw new Error(`Access Point ARN should have one resource accesspoint${delimiter}{accesspointname}`);
      }
      return { accesspointName: rest[0] };
    } else if (resourceType === "outpost") {
      if (!rest[0] || rest[1] !== "accesspoint" || !rest[2] || rest.length !== 3) {
        throw new Error(`Outpost ARN should have resource outpost${delimiter}{outpostId}${delimiter}accesspoint${delimiter}{accesspointName}`);
      }
      const [outpostId, _, accesspointName] = rest;
      return { outpostId, accesspointName };
    } else {
      throw new Error(`ARN resource should begin with 'accesspoint${delimiter}' or 'outpost${delimiter}'`);
    }
  };
  var validateNoDualstack = (dualstackEndpoint) => {};
  var validateNoFIPS = (useFipsEndpoint) => {
    if (useFipsEndpoint)
      throw new Error(`FIPS region is not supported with Outpost.`);
  };
  var validateMrapAlias = (name) => {
    try {
      name.split(".").forEach((label) => {
        validateDNSHostLabel(label);
      });
    } catch (e) {
      throw new Error(`"${name}" is not a DNS compatible name.`);
    }
  };
  var bucketHostname = (options) => {
    validateCustomEndpoint(options);
    return isBucketNameOptions(options) ? getEndpointFromBucketName(options) : getEndpointFromArn(options);
  };
  var getEndpointFromBucketName = ({ accelerateEndpoint = false, clientRegion: region, baseHostname, bucketName, dualstackEndpoint = false, fipsEndpoint = false, pathStyleEndpoint = false, tlsCompatible = true, isCustomEndpoint = false }) => {
    const [clientRegion, hostnameSuffix] = isCustomEndpoint ? [region, baseHostname] : getSuffix(baseHostname);
    if (pathStyleEndpoint || !isDnsCompatibleBucketName(bucketName) || tlsCompatible && DOT_PATTERN.test(bucketName)) {
      return {
        bucketEndpoint: false,
        hostname: dualstackEndpoint ? `s3.dualstack.${clientRegion}.${hostnameSuffix}` : baseHostname
      };
    }
    if (accelerateEndpoint) {
      baseHostname = `s3-accelerate${dualstackEndpoint ? ".dualstack" : ""}.${hostnameSuffix}`;
    } else if (dualstackEndpoint) {
      baseHostname = `s3.dualstack.${clientRegion}.${hostnameSuffix}`;
    }
    return {
      bucketEndpoint: true,
      hostname: `${bucketName}.${baseHostname}`
    };
  };
  var getEndpointFromArn = (options) => {
    const { isCustomEndpoint, baseHostname, clientRegion } = options;
    const hostnameSuffix = isCustomEndpoint ? baseHostname : getSuffixForArnEndpoint(baseHostname)[1];
    const { pathStyleEndpoint, accelerateEndpoint = false, fipsEndpoint = false, tlsCompatible = true, bucketName, clientPartition = "aws" } = options;
    validateArnEndpointOptions({ pathStyleEndpoint, accelerateEndpoint, tlsCompatible });
    const { service, partition: partition2, accountId, region, resource } = bucketName;
    validateService(service);
    validatePartition(partition2, { clientPartition });
    validateAccountId(accountId);
    const { accesspointName, outpostId } = getArnResources(resource);
    if (service === "s3-object-lambda") {
      return getEndpointFromObjectLambdaArn({ ...options, tlsCompatible, bucketName, accesspointName, hostnameSuffix });
    }
    if (region === "") {
      return getEndpointFromMRAPArn({ ...options, mrapAlias: accesspointName, hostnameSuffix });
    }
    if (outpostId) {
      return getEndpointFromOutpostArn({ ...options, clientRegion, outpostId, accesspointName, hostnameSuffix });
    }
    return getEndpointFromAccessPointArn({ ...options, clientRegion, accesspointName, hostnameSuffix });
  };
  var getEndpointFromObjectLambdaArn = ({ dualstackEndpoint = false, fipsEndpoint = false, tlsCompatible = true, useArnRegion, clientRegion, clientSigningRegion = clientRegion, accesspointName, bucketName, hostnameSuffix }) => {
    const { accountId, region, service } = bucketName;
    validateRegionalClient(clientRegion);
    const DNSHostLabel = `${accesspointName}-${accountId}`;
    validateDNSHostLabel(DNSHostLabel, { tlsCompatible });
    const endpointRegion = useArnRegion ? region : clientRegion;
    const signingRegion = useArnRegion ? region : clientSigningRegion;
    return {
      bucketEndpoint: true,
      hostname: `${DNSHostLabel}.${service}${fipsEndpoint ? "-fips" : ""}.${endpointRegion}.${hostnameSuffix}`,
      signingRegion,
      signingService: service
    };
  };
  var getEndpointFromMRAPArn = ({ disableMultiregionAccessPoints, dualstackEndpoint = false, isCustomEndpoint, mrapAlias, hostnameSuffix }) => {
    if (disableMultiregionAccessPoints === true) {
      throw new Error("SDK is attempting to use a MRAP ARN. Please enable to feature.");
    }
    validateMrapAlias(mrapAlias);
    return {
      bucketEndpoint: true,
      hostname: `${mrapAlias}${isCustomEndpoint ? "" : `.accesspoint.s3-global`}.${hostnameSuffix}`,
      signingRegion: "*"
    };
  };
  var getEndpointFromOutpostArn = ({ useArnRegion, clientRegion, clientSigningRegion = clientRegion, bucketName, outpostId, dualstackEndpoint = false, fipsEndpoint = false, tlsCompatible = true, accesspointName, isCustomEndpoint, hostnameSuffix }) => {
    validateRegionalClient(clientRegion);
    const DNSHostLabel = `${accesspointName}-${bucketName.accountId}`;
    validateDNSHostLabel(DNSHostLabel, { tlsCompatible });
    const endpointRegion = useArnRegion ? bucketName.region : clientRegion;
    const signingRegion = useArnRegion ? bucketName.region : clientSigningRegion;
    validateOutpostService(bucketName.service);
    validateDNSHostLabel(outpostId, { tlsCompatible });
    validateNoFIPS(fipsEndpoint);
    const hostnamePrefix = `${DNSHostLabel}.${outpostId}`;
    return {
      bucketEndpoint: true,
      hostname: `${hostnamePrefix}${isCustomEndpoint ? "" : `.s3-outposts.${endpointRegion}`}.${hostnameSuffix}`,
      signingRegion,
      signingService: "s3-outposts"
    };
  };
  var getEndpointFromAccessPointArn = ({ useArnRegion, clientRegion, clientSigningRegion = clientRegion, bucketName, dualstackEndpoint = false, fipsEndpoint = false, tlsCompatible = true, accesspointName, isCustomEndpoint, hostnameSuffix }) => {
    validateRegionalClient(clientRegion);
    const hostnamePrefix = `${accesspointName}-${bucketName.accountId}`;
    validateDNSHostLabel(hostnamePrefix, { tlsCompatible });
    const endpointRegion = useArnRegion ? bucketName.region : clientRegion;
    const signingRegion = useArnRegion ? bucketName.region : clientSigningRegion;
    validateS3Service(bucketName.service);
    return {
      bucketEndpoint: true,
      hostname: `${hostnamePrefix}${isCustomEndpoint ? "" : `.s3-accesspoint${fipsEndpoint ? "-fips" : ""}${dualstackEndpoint ? ".dualstack" : ""}.${endpointRegion}`}.${hostnameSuffix}`,
      signingRegion
    };
  };
  var bucketEndpointMiddleware = (options) => (next, context) => async (args) => {
    const { Bucket: bucketName } = args.input;
    let replaceBucketInPath = options.bucketEndpoint;
    const request = args.request;
    if (protocolHttp.HttpRequest.isInstance(request)) {
      if (options.bucketEndpoint) {
        request.hostname = bucketName;
      } else if (utilArnParser.validate(bucketName)) {
        const bucketArn = utilArnParser.parse(bucketName);
        const clientRegion = await options.region();
        const useDualstackEndpoint = await options.useDualstackEndpoint();
        const useFipsEndpoint = await options.useFipsEndpoint();
        const { partition: partition2, signingRegion = clientRegion } = await options.regionInfoProvider(clientRegion, { useDualstackEndpoint, useFipsEndpoint }) || {};
        const useArnRegion = await options.useArnRegion();
        const { hostname, bucketEndpoint, signingRegion: modifiedSigningRegion, signingService } = bucketHostname({
          bucketName: bucketArn,
          baseHostname: request.hostname,
          accelerateEndpoint: options.useAccelerateEndpoint,
          dualstackEndpoint: useDualstackEndpoint,
          fipsEndpoint: useFipsEndpoint,
          pathStyleEndpoint: options.forcePathStyle,
          tlsCompatible: request.protocol === "https:",
          useArnRegion,
          clientPartition: partition2,
          clientSigningRegion: signingRegion,
          clientRegion,
          isCustomEndpoint: options.isCustomEndpoint,
          disableMultiregionAccessPoints: await options.disableMultiregionAccessPoints()
        });
        if (modifiedSigningRegion && modifiedSigningRegion !== signingRegion) {
          context["signing_region"] = modifiedSigningRegion;
        }
        if (signingService && signingService !== "s3") {
          context["signing_service"] = signingService;
        }
        request.hostname = hostname;
        replaceBucketInPath = bucketEndpoint;
      } else {
        const clientRegion = await options.region();
        const dualstackEndpoint = await options.useDualstackEndpoint();
        const fipsEndpoint = await options.useFipsEndpoint();
        const { hostname, bucketEndpoint } = bucketHostname({
          bucketName,
          clientRegion,
          baseHostname: request.hostname,
          accelerateEndpoint: options.useAccelerateEndpoint,
          dualstackEndpoint,
          fipsEndpoint,
          pathStyleEndpoint: options.forcePathStyle,
          tlsCompatible: request.protocol === "https:",
          isCustomEndpoint: options.isCustomEndpoint
        });
        request.hostname = hostname;
        replaceBucketInPath = bucketEndpoint;
      }
      if (replaceBucketInPath) {
        request.path = request.path.replace(/^(\/)?[^\/]+/, "");
        if (request.path === "") {
          request.path = "/";
        }
      }
    }
    return next({ ...args, request });
  };
  var bucketEndpointMiddlewareOptions = {
    tags: ["BUCKET_ENDPOINT"],
    name: "bucketEndpointMiddleware",
    relation: "before",
    toMiddleware: "hostHeaderMiddleware",
    override: true
  };
  var getBucketEndpointPlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);
    }
  });
  function resolveBucketEndpointConfig(input) {
    const { bucketEndpoint = false, forcePathStyle = false, useAccelerateEndpoint = false, useArnRegion, disableMultiregionAccessPoints = false } = input;
    return Object.assign(input, {
      bucketEndpoint,
      forcePathStyle,
      useAccelerateEndpoint,
      useArnRegion: typeof useArnRegion === "function" ? useArnRegion : () => Promise.resolve(useArnRegion),
      disableMultiregionAccessPoints: typeof disableMultiregionAccessPoints === "function" ? disableMultiregionAccessPoints : () => Promise.resolve(disableMultiregionAccessPoints)
    });
  }
  exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS = NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS;
  exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME = NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME;
  exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME = NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME;
  exports.NODE_USE_ARN_REGION_CONFIG_OPTIONS = NODE_USE_ARN_REGION_CONFIG_OPTIONS;
  exports.NODE_USE_ARN_REGION_ENV_NAME = NODE_USE_ARN_REGION_ENV_NAME;
  exports.NODE_USE_ARN_REGION_INI_NAME = NODE_USE_ARN_REGION_INI_NAME;
  exports.bucketEndpointMiddleware = bucketEndpointMiddleware;
  exports.bucketEndpointMiddlewareOptions = bucketEndpointMiddlewareOptions;
  exports.bucketHostname = bucketHostname;
  exports.getArnResources = getArnResources;
  exports.getBucketEndpointPlugin = getBucketEndpointPlugin;
  exports.getSuffixForArnEndpoint = getSuffixForArnEndpoint;
  exports.resolveBucketEndpointConfig = resolveBucketEndpointConfig;
  exports.validateAccountId = validateAccountId;
  exports.validateDNSHostLabel = validateDNSHostLabel;
  exports.validateNoDualstack = validateNoDualstack;
  exports.validateNoFIPS = validateNoFIPS;
  exports.validateOutpostService = validateOutpostService;
  exports.validatePartition = validatePartition;
  exports.validateRegion = validateRegion;
});

// node_modules/@smithy/eventstream-codec/dist-cjs/index.js
var require_dist_cjs67 = __commonJS((exports) => {
  var crc32 = require_main3();
  var utilHexEncoding = require_dist_cjs14();

  class Int642 {
    bytes;
    constructor(bytes) {
      this.bytes = bytes;
      if (bytes.byteLength !== 8) {
        throw new Error("Int64 buffers must be exactly 8 bytes");
      }
    }
    static fromNumber(number) {
      if (number > 9223372036854776000 || number < -9223372036854776000) {
        throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
      }
      const bytes = new Uint8Array(8);
      for (let i2 = 7, remaining = Math.abs(Math.round(number));i2 > -1 && remaining > 0; i2--, remaining /= 256) {
        bytes[i2] = remaining;
      }
      if (number < 0) {
        negate(bytes);
      }
      return new Int642(bytes);
    }
    valueOf() {
      const bytes = this.bytes.slice(0);
      const negative = bytes[0] & 128;
      if (negative) {
        negate(bytes);
      }
      return parseInt(utilHexEncoding.toHex(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
      return String(this.valueOf());
    }
  }
  function negate(bytes) {
    for (let i2 = 0;i2 < 8; i2++) {
      bytes[i2] ^= 255;
    }
    for (let i2 = 7;i2 > -1; i2--) {
      bytes[i2]++;
      if (bytes[i2] !== 0)
        break;
    }
  }

  class HeaderMarshaller {
    toUtf8;
    fromUtf8;
    constructor(toUtf8, fromUtf8) {
      this.toUtf8 = toUtf8;
      this.fromUtf8 = fromUtf8;
    }
    format(headers) {
      const chunks = [];
      for (const headerName of Object.keys(headers)) {
        const bytes = this.fromUtf8(headerName);
        chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
      }
      const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
      let position = 0;
      for (const chunk of chunks) {
        out.set(chunk, position);
        position += chunk.byteLength;
      }
      return out;
    }
    formatHeaderValue(header) {
      switch (header.type) {
        case "boolean":
          return Uint8Array.from([header.value ? 0 : 1]);
        case "byte":
          return Uint8Array.from([2, header.value]);
        case "short":
          const shortView = new DataView(new ArrayBuffer(3));
          shortView.setUint8(0, 3);
          shortView.setInt16(1, header.value, false);
          return new Uint8Array(shortView.buffer);
        case "integer":
          const intView = new DataView(new ArrayBuffer(5));
          intView.setUint8(0, 4);
          intView.setInt32(1, header.value, false);
          return new Uint8Array(intView.buffer);
        case "long":
          const longBytes = new Uint8Array(9);
          longBytes[0] = 5;
          longBytes.set(header.value.bytes, 1);
          return longBytes;
        case "binary":
          const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
          binView.setUint8(0, 6);
          binView.setUint16(1, header.value.byteLength, false);
          const binBytes = new Uint8Array(binView.buffer);
          binBytes.set(header.value, 3);
          return binBytes;
        case "string":
          const utf8Bytes = this.fromUtf8(header.value);
          const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
          strView.setUint8(0, 7);
          strView.setUint16(1, utf8Bytes.byteLength, false);
          const strBytes = new Uint8Array(strView.buffer);
          strBytes.set(utf8Bytes, 3);
          return strBytes;
        case "timestamp":
          const tsBytes = new Uint8Array(9);
          tsBytes[0] = 8;
          tsBytes.set(Int642.fromNumber(header.value.valueOf()).bytes, 1);
          return tsBytes;
        case "uuid":
          if (!UUID_PATTERN.test(header.value)) {
            throw new Error(`Invalid UUID received: ${header.value}`);
          }
          const uuidBytes = new Uint8Array(17);
          uuidBytes[0] = 9;
          uuidBytes.set(utilHexEncoding.fromHex(header.value.replace(/\-/g, "")), 1);
          return uuidBytes;
      }
    }
    parse(headers) {
      const out = {};
      let position = 0;
      while (position < headers.byteLength) {
        const nameLength = headers.getUint8(position++);
        const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
        position += nameLength;
        switch (headers.getUint8(position++)) {
          case 0:
            out[name] = {
              type: BOOLEAN_TAG,
              value: true
            };
            break;
          case 1:
            out[name] = {
              type: BOOLEAN_TAG,
              value: false
            };
            break;
          case 2:
            out[name] = {
              type: BYTE_TAG,
              value: headers.getInt8(position++)
            };
            break;
          case 3:
            out[name] = {
              type: SHORT_TAG,
              value: headers.getInt16(position, false)
            };
            position += 2;
            break;
          case 4:
            out[name] = {
              type: INT_TAG,
              value: headers.getInt32(position, false)
            };
            position += 4;
            break;
          case 5:
            out[name] = {
              type: LONG_TAG,
              value: new Int642(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
            };
            position += 8;
            break;
          case 6:
            const binaryLength = headers.getUint16(position, false);
            position += 2;
            out[name] = {
              type: BINARY_TAG,
              value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
            };
            position += binaryLength;
            break;
          case 7:
            const stringLength = headers.getUint16(position, false);
            position += 2;
            out[name] = {
              type: STRING_TAG,
              value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
            };
            position += stringLength;
            break;
          case 8:
            out[name] = {
              type: TIMESTAMP_TAG,
              value: new Date(new Int642(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
            };
            position += 8;
            break;
          case 9:
            const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
            position += 16;
            out[name] = {
              type: UUID_TAG,
              value: `${utilHexEncoding.toHex(uuidBytes.subarray(0, 4))}-${utilHexEncoding.toHex(uuidBytes.subarray(4, 6))}-${utilHexEncoding.toHex(uuidBytes.subarray(6, 8))}-${utilHexEncoding.toHex(uuidBytes.subarray(8, 10))}-${utilHexEncoding.toHex(uuidBytes.subarray(10))}`
            };
            break;
          default:
            throw new Error(`Unrecognized header type tag`);
        }
      }
      return out;
    }
  }
  var BOOLEAN_TAG = "boolean";
  var BYTE_TAG = "byte";
  var SHORT_TAG = "short";
  var INT_TAG = "integer";
  var LONG_TAG = "long";
  var BINARY_TAG = "binary";
  var STRING_TAG = "string";
  var TIMESTAMP_TAG = "timestamp";
  var UUID_TAG = "uuid";
  var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
  var PRELUDE_MEMBER_LENGTH = 4;
  var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
  var CHECKSUM_LENGTH = 4;
  var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
  function splitMessage({ byteLength, byteOffset, buffer }) {
    if (byteLength < MINIMUM_MESSAGE_LENGTH) {
      throw new Error("Provided message too short to accommodate event stream message overhead");
    }
    const view = new DataView(buffer, byteOffset, byteLength);
    const messageLength = view.getUint32(0, false);
    if (byteLength !== messageLength) {
      throw new Error("Reported message length does not match received message length");
    }
    const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
    const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
    const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
    const checksummer = new crc32.Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
    if (expectedPreludeChecksum !== checksummer.digest()) {
      throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
    }
    checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
    if (expectedMessageChecksum !== checksummer.digest()) {
      throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
    }
    return {
      headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
      body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
    };
  }

  class EventStreamCodec {
    headerMarshaller;
    messageBuffer;
    isEndOfStream;
    constructor(toUtf8, fromUtf8) {
      this.headerMarshaller = new HeaderMarshaller(toUtf8, fromUtf8);
      this.messageBuffer = [];
      this.isEndOfStream = false;
    }
    feed(message3) {
      this.messageBuffer.push(this.decode(message3));
    }
    endOfStream() {
      this.isEndOfStream = true;
    }
    getMessage() {
      const message3 = this.messageBuffer.pop();
      const isEndOfStream = this.isEndOfStream;
      return {
        getMessage() {
          return message3;
        },
        isEndOfStream() {
          return isEndOfStream;
        }
      };
    }
    getAvailableMessages() {
      const messages = this.messageBuffer;
      this.messageBuffer = [];
      const isEndOfStream = this.isEndOfStream;
      return {
        getMessages() {
          return messages;
        },
        isEndOfStream() {
          return isEndOfStream;
        }
      };
    }
    encode({ headers: rawHeaders, body }) {
      const headers = this.headerMarshaller.format(rawHeaders);
      const length = headers.byteLength + body.byteLength + 16;
      const out = new Uint8Array(length);
      const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      const checksum = new crc32.Crc32;
      view.setUint32(0, length, false);
      view.setUint32(4, headers.byteLength, false);
      view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
      out.set(headers, 12);
      out.set(body, headers.byteLength + 12);
      view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
      return out;
    }
    decode(message3) {
      const { headers, body } = splitMessage(message3);
      return { headers: this.headerMarshaller.parse(headers), body };
    }
    formatHeaders(rawHeaders) {
      return this.headerMarshaller.format(rawHeaders);
    }
  }

  class MessageDecoderStream {
    options;
    constructor(options) {
      this.options = options;
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator();
    }
    async* asyncIterator() {
      for await (const bytes of this.options.inputStream) {
        const decoded = this.options.decoder.decode(bytes);
        yield decoded;
      }
    }
  }

  class MessageEncoderStream {
    options;
    constructor(options) {
      this.options = options;
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator();
    }
    async* asyncIterator() {
      for await (const msg of this.options.messageStream) {
        const encoded = this.options.encoder.encode(msg);
        yield encoded;
      }
      if (this.options.includeEndFrame) {
        yield new Uint8Array(0);
      }
    }
  }

  class SmithyMessageDecoderStream {
    options;
    constructor(options) {
      this.options = options;
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator();
    }
    async* asyncIterator() {
      for await (const message3 of this.options.messageStream) {
        const deserialized = await this.options.deserializer(message3);
        if (deserialized === undefined)
          continue;
        yield deserialized;
      }
    }
  }

  class SmithyMessageEncoderStream {
    options;
    constructor(options) {
      this.options = options;
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator();
    }
    async* asyncIterator() {
      for await (const chunk of this.options.inputStream) {
        const payloadBuf = this.options.serializer(chunk);
        yield payloadBuf;
      }
    }
  }
  exports.EventStreamCodec = EventStreamCodec;
  exports.HeaderMarshaller = HeaderMarshaller;
  exports.Int64 = Int642;
  exports.MessageDecoderStream = MessageDecoderStream;
  exports.MessageEncoderStream = MessageEncoderStream;
  exports.SmithyMessageDecoderStream = SmithyMessageDecoderStream;
  exports.SmithyMessageEncoderStream = SmithyMessageEncoderStream;
});

// node_modules/@smithy/eventstream-serde-universal/dist-cjs/index.js
var require_dist_cjs68 = __commonJS((exports) => {
  var eventstreamCodec = require_dist_cjs67();
  function getChunkedStream(source) {
    let currentMessageTotalLength = 0;
    let currentMessagePendingLength = 0;
    let currentMessage = null;
    let messageLengthBuffer = null;
    const allocateMessage = (size) => {
      if (typeof size !== "number") {
        throw new Error("Attempted to allocate an event message where size was not a number: " + size);
      }
      currentMessageTotalLength = size;
      currentMessagePendingLength = 4;
      currentMessage = new Uint8Array(size);
      const currentMessageView = new DataView(currentMessage.buffer);
      currentMessageView.setUint32(0, size, false);
    };
    const iterator = async function* () {
      const sourceIterator = source[Symbol.asyncIterator]();
      while (true) {
        const { value, done } = await sourceIterator.next();
        if (done) {
          if (!currentMessageTotalLength) {
            return;
          } else if (currentMessageTotalLength === currentMessagePendingLength) {
            yield currentMessage;
          } else {
            throw new Error("Truncated event message received.");
          }
          return;
        }
        const chunkLength = value.length;
        let currentOffset = 0;
        while (currentOffset < chunkLength) {
          if (!currentMessage) {
            const bytesRemaining = chunkLength - currentOffset;
            if (!messageLengthBuffer) {
              messageLengthBuffer = new Uint8Array(4);
            }
            const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
            messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
            currentMessagePendingLength += numBytesForTotal;
            currentOffset += numBytesForTotal;
            if (currentMessagePendingLength < 4) {
              break;
            }
            allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
            messageLengthBuffer = null;
          }
          const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
          currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
          currentMessagePendingLength += numBytesToWrite;
          currentOffset += numBytesToWrite;
          if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
            yield currentMessage;
            currentMessage = null;
            currentMessageTotalLength = 0;
            currentMessagePendingLength = 0;
          }
        }
      }
    };
    return {
      [Symbol.asyncIterator]: iterator
    };
  }
  function getMessageUnmarshaller(deserializer, toUtf8) {
    return async function(message3) {
      const { value: messageType } = message3.headers[":message-type"];
      if (messageType === "error") {
        const unmodeledError = new Error(message3.headers[":error-message"].value || "UnknownError");
        unmodeledError.name = message3.headers[":error-code"].value;
        throw unmodeledError;
      } else if (messageType === "exception") {
        const code = message3.headers[":exception-type"].value;
        const exception = { [code]: message3 };
        const deserializedException = await deserializer(exception);
        if (deserializedException.$unknown) {
          const error = new Error(toUtf8(message3.body));
          error.name = code;
          throw error;
        }
        throw deserializedException[code];
      } else if (messageType === "event") {
        const event = {
          [message3.headers[":event-type"].value]: message3
        };
        const deserialized = await deserializer(event);
        if (deserialized.$unknown)
          return;
        return deserialized;
      } else {
        throw Error(`Unrecognizable event type: ${message3.headers[":event-type"].value}`);
      }
    };
  }

  class EventStreamMarshaller {
    eventStreamCodec;
    utfEncoder;
    constructor({ utf8Encoder, utf8Decoder }) {
      this.eventStreamCodec = new eventstreamCodec.EventStreamCodec(utf8Encoder, utf8Decoder);
      this.utfEncoder = utf8Encoder;
    }
    deserialize(body, deserializer) {
      const inputStream = getChunkedStream(body);
      return new eventstreamCodec.SmithyMessageDecoderStream({
        messageStream: new eventstreamCodec.MessageDecoderStream({ inputStream, decoder: this.eventStreamCodec }),
        deserializer: getMessageUnmarshaller(deserializer, this.utfEncoder)
      });
    }
    serialize(inputStream, serializer) {
      return new eventstreamCodec.MessageEncoderStream({
        messageStream: new eventstreamCodec.SmithyMessageEncoderStream({ inputStream, serializer }),
        encoder: this.eventStreamCodec,
        includeEndFrame: true
      });
    }
  }
  var eventStreamSerdeProvider = (options) => new EventStreamMarshaller(options);
  exports.EventStreamMarshaller = EventStreamMarshaller;
  exports.eventStreamSerdeProvider = eventStreamSerdeProvider;
});

// node_modules/@smithy/eventstream-serde-node/dist-cjs/index.js
var require_dist_cjs69 = __commonJS((exports) => {
  var eventstreamSerdeUniversal = require_dist_cjs68();
  var stream3 = __require("stream");
  async function* readabletoIterable(readStream) {
    let streamEnded = false;
    let generationEnded = false;
    const records = new Array;
    readStream.on("error", (err) => {
      if (!streamEnded) {
        streamEnded = true;
      }
      if (err) {
        throw err;
      }
    });
    readStream.on("data", (data) => {
      records.push(data);
    });
    readStream.on("end", () => {
      streamEnded = true;
    });
    while (!generationEnded) {
      const value = await new Promise((resolve) => setTimeout(() => resolve(records.shift()), 0));
      if (value) {
        yield value;
      }
      generationEnded = streamEnded && records.length === 0;
    }
  }

  class EventStreamMarshaller {
    universalMarshaller;
    constructor({ utf8Encoder, utf8Decoder }) {
      this.universalMarshaller = new eventstreamSerdeUniversal.EventStreamMarshaller({
        utf8Decoder,
        utf8Encoder
      });
    }
    deserialize(body, deserializer) {
      const bodyIterable = typeof body[Symbol.asyncIterator] === "function" ? body : readabletoIterable(body);
      return this.universalMarshaller.deserialize(bodyIterable, deserializer);
    }
    serialize(input, serializer) {
      return stream3.Readable.from(this.universalMarshaller.serialize(input, serializer));
    }
  }
  var eventStreamSerdeProvider = (options) => new EventStreamMarshaller(options);
  exports.EventStreamMarshaller = EventStreamMarshaller;
  exports.eventStreamSerdeProvider = eventStreamSerdeProvider;
});

// node_modules/@smithy/hash-stream-node/dist-cjs/index.js
var require_dist_cjs70 = __commonJS((exports) => {
  var fs = __require("fs");
  var utilUtf8 = require_dist_cjs8();
  var stream3 = __require("stream");

  class HashCalculator extends stream3.Writable {
    hash;
    constructor(hash, options) {
      super(options);
      this.hash = hash;
    }
    _write(chunk, encoding, callback) {
      try {
        this.hash.update(utilUtf8.toUint8Array(chunk));
      } catch (err) {
        return callback(err);
      }
      callback();
    }
  }
  var fileStreamHasher = (hashCtor, fileStream) => new Promise((resolve, reject) => {
    if (!isReadStream(fileStream)) {
      reject(new Error("Unable to calculate hash for non-file streams."));
      return;
    }
    const fileStreamTee = fs.createReadStream(fileStream.path, {
      start: fileStream.start,
      end: fileStream.end
    });
    const hash = new hashCtor;
    const hashCalculator = new HashCalculator(hash);
    fileStreamTee.pipe(hashCalculator);
    fileStreamTee.on("error", (err) => {
      hashCalculator.end();
      reject(err);
    });
    hashCalculator.on("error", reject);
    hashCalculator.on("finish", function() {
      hash.digest().then(resolve).catch(reject);
    });
  });
  var isReadStream = (stream4) => typeof stream4.path === "string";
  var readableStreamHasher = (hashCtor, readableStream) => {
    if (readableStream.readableFlowing !== null) {
      throw new Error("Unable to calculate hash for flowing readable stream");
    }
    const hash = new hashCtor;
    const hashCalculator = new HashCalculator(hash);
    readableStream.pipe(hashCalculator);
    return new Promise((resolve, reject) => {
      readableStream.on("error", (err) => {
        hashCalculator.end();
        reject(err);
      });
      hashCalculator.on("error", reject);
      hashCalculator.on("finish", () => {
        hash.digest().then(resolve).catch(reject);
      });
    });
  };
  exports.fileStreamHasher = fileStreamHasher;
  exports.readableStreamHasher = readableStreamHasher;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/runtimeConfig.shared.js
var require_runtimeConfig_shared5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var core_1 = require_dist_cjs24();
  var protocols_1 = require_protocols2();
  var signature_v4_multi_region_1 = require_dist_cjs50();
  var smithy_client_1 = require_dist_cjs22();
  var url_parser_1 = require_dist_cjs38();
  var util_base64_1 = require_dist_cjs9();
  var util_stream_1 = require_dist_cjs15();
  var util_utf8_1 = require_dist_cjs8();
  var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider();
  var endpointResolver_1 = require_endpointResolver();
  var schemas_0_1 = require_schemas_0();
  var getRuntimeConfig = (config) => {
    return {
      apiVersion: "2006-03-01",
      base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
      base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
      disableHostPrefix: config?.disableHostPrefix ?? false,
      endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
      extensions: config?.extensions ?? [],
      getAwsChunkedEncodingStream: config?.getAwsChunkedEncodingStream ?? util_stream_1.getAwsChunkedEncodingStream,
      httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultS3HttpAuthSchemeProvider,
      httpAuthSchemes: config?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
          signer: new core_1.AwsSdkSigV4Signer
        },
        {
          schemeId: "aws.auth#sigv4a",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4a"),
          signer: new core_1.AwsSdkSigV4ASigner
        }
      ],
      logger: config?.logger ?? new smithy_client_1.NoOpLogger,
      protocol: config?.protocol ?? protocols_1.AwsRestXmlProtocol,
      protocolSettings: config?.protocolSettings ?? {
        defaultNamespace: "com.amazonaws.s3",
        errorTypeRegistries: schemas_0_1.errorTypeRegistries,
        xmlNamespace: "http://s3.amazonaws.com/doc/2006-03-01/",
        version: "2006-03-01",
        serviceTarget: "AmazonS3"
      },
      sdkStreamMixin: config?.sdkStreamMixin ?? util_stream_1.sdkStreamMixin,
      serviceId: config?.serviceId ?? "S3",
      signerConstructor: config?.signerConstructor ?? signature_v4_multi_region_1.SignatureV4MultiRegion,
      signingEscapePath: config?.signingEscapePath ?? false,
      urlParser: config?.urlParser ?? url_parser_1.parseUrl,
      useArnRegion: config?.useArnRegion ?? undefined,
      utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
      utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/runtimeConfig.js
var require_runtimeConfig5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var tslib_1 = require_tslib();
  var package_json_1 = tslib_1.__importDefault(require_package4());
  var core_1 = require_dist_cjs24();
  var credential_provider_node_1 = require_dist_cjs65();
  var middleware_bucket_endpoint_1 = require_dist_cjs66();
  var middleware_flexible_checksums_1 = require_dist_cjs29();
  var middleware_sdk_s3_1 = require_dist_cjs35();
  var util_user_agent_node_1 = require_dist_cjs54();
  var config_resolver_1 = require_dist_cjs41();
  var eventstream_serde_node_1 = require_dist_cjs69();
  var hash_node_1 = require_dist_cjs55();
  var hash_stream_node_1 = require_dist_cjs70();
  var middleware_retry_1 = require_dist_cjs49();
  var node_config_provider_1 = require_dist_cjs45();
  var node_http_handler_1 = require_dist_cjs12();
  var smithy_client_1 = require_dist_cjs22();
  var util_body_length_node_1 = require_dist_cjs56();
  var util_defaults_mode_node_1 = require_dist_cjs57();
  var util_retry_1 = require_dist_cjs48();
  var runtimeConfig_shared_1 = require_runtimeConfig_shared5();
  var getRuntimeConfig = (config) => {
    (0, smithy_client_1.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    const loaderConfig = {
      profile: config?.profile,
      logger: clientSharedValues.logger
    };
    return {
      ...clientSharedValues,
      ...config,
      runtime: "node",
      defaultsMode,
      authSchemePreference: config?.authSchemePreference ?? (0, node_config_provider_1.loadConfig)(core_1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
      bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
      credentialDefaultProvider: config?.credentialDefaultProvider ?? credential_provider_node_1.defaultProvider,
      defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
      disableS3ExpressSessionAuth: config?.disableS3ExpressSessionAuth ?? (0, node_config_provider_1.loadConfig)(middleware_sdk_s3_1.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS, loaderConfig),
      eventStreamSerdeProvider: config?.eventStreamSerdeProvider ?? eventstream_serde_node_1.eventStreamSerdeProvider,
      maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
      md5: config?.md5 ?? hash_node_1.Hash.bind(null, "md5"),
      region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
      requestChecksumCalculation: config?.requestChecksumCalculation ?? (0, node_config_provider_1.loadConfig)(middleware_flexible_checksums_1.NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS, loaderConfig),
      requestHandler: node_http_handler_1.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
      responseChecksumValidation: config?.responseChecksumValidation ?? (0, node_config_provider_1.loadConfig)(middleware_flexible_checksums_1.NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS, loaderConfig),
      retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
        default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
      }, config),
      sha1: config?.sha1 ?? hash_node_1.Hash.bind(null, "sha1"),
      sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
      sigv4aSigningRegionSet: config?.sigv4aSigningRegionSet ?? (0, node_config_provider_1.loadConfig)(core_1.NODE_SIGV4A_CONFIG_OPTIONS, loaderConfig),
      streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
      streamHasher: config?.streamHasher ?? hash_stream_node_1.readableStreamHasher,
      useArnRegion: config?.useArnRegion ?? (0, node_config_provider_1.loadConfig)(middleware_bucket_endpoint_1.NODE_USE_ARN_REGION_CONFIG_OPTIONS, loaderConfig),
      useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
      useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
      userAgentAppId: config?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/middleware-ssec/dist-cjs/index.js
var require_dist_cjs71 = __commonJS((exports) => {
  function ssecMiddleware(options) {
    return (next) => async (args) => {
      const input = { ...args.input };
      const properties = [
        {
          target: "SSECustomerKey",
          hash: "SSECustomerKeyMD5"
        },
        {
          target: "CopySourceSSECustomerKey",
          hash: "CopySourceSSECustomerKeyMD5"
        }
      ];
      for (const prop of properties) {
        const value = input[prop.target];
        if (value) {
          let valueForHash;
          if (typeof value === "string") {
            if (isValidBase64EncodedSSECustomerKey(value, options)) {
              valueForHash = options.base64Decoder(value);
            } else {
              valueForHash = options.utf8Decoder(value);
              input[prop.target] = options.base64Encoder(valueForHash);
            }
          } else {
            valueForHash = ArrayBuffer.isView(value) ? new Uint8Array(value.buffer, value.byteOffset, value.byteLength) : new Uint8Array(value);
            input[prop.target] = options.base64Encoder(valueForHash);
          }
          const hash = new options.md5;
          hash.update(valueForHash);
          input[prop.hash] = options.base64Encoder(await hash.digest());
        }
      }
      return next({
        ...args,
        input
      });
    };
  }
  var ssecMiddlewareOptions = {
    name: "ssecMiddleware",
    step: "initialize",
    tags: ["SSE"],
    override: true
  };
  var getSsecPlugin = (config) => ({
    applyToStack: (clientStack) => {
      clientStack.add(ssecMiddleware(config), ssecMiddlewareOptions);
    }
  });
  function isValidBase64EncodedSSECustomerKey(str, options) {
    const base64Regex = /^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
    if (!base64Regex.test(str))
      return false;
    try {
      const decodedBytes = options.base64Decoder(str);
      return decodedBytes.length === 32;
    } catch {
      return false;
    }
  }
  exports.getSsecPlugin = getSsecPlugin;
  exports.isValidBase64EncodedSSECustomerKey = isValidBase64EncodedSSECustomerKey;
  exports.ssecMiddleware = ssecMiddleware;
  exports.ssecMiddlewareOptions = ssecMiddlewareOptions;
});

// node_modules/@aws-sdk/middleware-location-constraint/dist-cjs/index.js
var require_dist_cjs72 = __commonJS((exports) => {
  function locationConstraintMiddleware(options) {
    return (next) => async (args) => {
      const { CreateBucketConfiguration } = args.input;
      const region = await options.region();
      if (!CreateBucketConfiguration?.LocationConstraint && !CreateBucketConfiguration?.Location) {
        if (region !== "us-east-1") {
          args.input.CreateBucketConfiguration = args.input.CreateBucketConfiguration ?? {};
          args.input.CreateBucketConfiguration.LocationConstraint = region;
        }
      }
      return next(args);
    };
  }
  var locationConstraintMiddlewareOptions = {
    step: "initialize",
    tags: ["LOCATION_CONSTRAINT", "CREATE_BUCKET_CONFIGURATION"],
    name: "locationConstraintMiddleware",
    override: true
  };
  var getLocationConstraintPlugin = (config) => ({
    applyToStack: (clientStack) => {
      clientStack.add(locationConstraintMiddleware(config), locationConstraintMiddlewareOptions);
    }
  });
  exports.getLocationConstraintPlugin = getLocationConstraintPlugin;
  exports.locationConstraintMiddleware = locationConstraintMiddleware;
  exports.locationConstraintMiddlewareOptions = locationConstraintMiddlewareOptions;
});

// node_modules/@smithy/util-waiter/dist-cjs/index.js
var require_dist_cjs73 = __commonJS((exports) => {
  var getCircularReplacer = () => {
    const seen = new WeakSet;
    return (key, value) => {
      if (typeof value === "object" && value !== null) {
        if (seen.has(value)) {
          return "[Circular]";
        }
        seen.add(value);
      }
      return value;
    };
  };
  var sleep = (seconds) => {
    return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
  };
  var waiterServiceDefaults = {
    minDelay: 2,
    maxDelay: 120
  };
  exports.WaiterState = undefined;
  (function(WaiterState) {
    WaiterState["ABORTED"] = "ABORTED";
    WaiterState["FAILURE"] = "FAILURE";
    WaiterState["SUCCESS"] = "SUCCESS";
    WaiterState["RETRY"] = "RETRY";
    WaiterState["TIMEOUT"] = "TIMEOUT";
  })(exports.WaiterState || (exports.WaiterState = {}));
  var checkExceptions = (result) => {
    if (result.state === exports.WaiterState.ABORTED) {
      const abortError = new Error(`${JSON.stringify({
        ...result,
        reason: "Request was aborted"
      }, getCircularReplacer())}`);
      abortError.name = "AbortError";
      throw abortError;
    } else if (result.state === exports.WaiterState.TIMEOUT) {
      const timeoutError = new Error(`${JSON.stringify({
        ...result,
        reason: "Waiter has timed out"
      }, getCircularReplacer())}`);
      timeoutError.name = "TimeoutError";
      throw timeoutError;
    } else if (result.state !== exports.WaiterState.SUCCESS) {
      throw new Error(`${JSON.stringify(result, getCircularReplacer())}`);
    }
    return result;
  };
  var exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {
    if (attempt > attemptCeiling)
      return maxDelay;
    const delay = minDelay * 2 ** (attempt - 1);
    return randomInRange(minDelay, delay);
  };
  var randomInRange = (min, max) => min + Math.random() * (max - min);
  var runPolling = async ({ minDelay, maxDelay, maxWaitTime, abortController, client: client3, abortSignal }, input, acceptorChecks) => {
    const observedResponses = {};
    const { state, reason } = await acceptorChecks(client3, input);
    if (reason) {
      const message3 = createMessageFromResponse(reason);
      observedResponses[message3] |= 0;
      observedResponses[message3] += 1;
    }
    if (state !== exports.WaiterState.RETRY) {
      return { state, reason, observedResponses };
    }
    let currentAttempt = 1;
    const waitUntil = Date.now() + maxWaitTime * 1000;
    const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;
    while (true) {
      if (abortController?.signal?.aborted || abortSignal?.aborted) {
        const message3 = "AbortController signal aborted.";
        observedResponses[message3] |= 0;
        observedResponses[message3] += 1;
        return { state: exports.WaiterState.ABORTED, observedResponses };
      }
      const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);
      if (Date.now() + delay * 1000 > waitUntil) {
        return { state: exports.WaiterState.TIMEOUT, observedResponses };
      }
      await sleep(delay);
      const { state: state2, reason: reason2 } = await acceptorChecks(client3, input);
      if (reason2) {
        const message3 = createMessageFromResponse(reason2);
        observedResponses[message3] |= 0;
        observedResponses[message3] += 1;
      }
      if (state2 !== exports.WaiterState.RETRY) {
        return { state: state2, reason: reason2, observedResponses };
      }
      currentAttempt += 1;
    }
  };
  var createMessageFromResponse = (reason) => {
    if (reason?.$responseBodyText) {
      return `Deserialization error for body: ${reason.$responseBodyText}`;
    }
    if (reason?.$metadata?.httpStatusCode) {
      if (reason.$response || reason.message) {
        return `${reason.$response.statusCode ?? reason.$metadata.httpStatusCode ?? "Unknown"}: ${reason.message}`;
      }
      return `${reason.$metadata.httpStatusCode}: OK`;
    }
    return String(reason?.message ?? JSON.stringify(reason, getCircularReplacer()) ?? "Unknown");
  };
  var validateWaiterOptions = (options) => {
    if (options.maxWaitTime <= 0) {
      throw new Error(`WaiterConfiguration.maxWaitTime must be greater than 0`);
    } else if (options.minDelay <= 0) {
      throw new Error(`WaiterConfiguration.minDelay must be greater than 0`);
    } else if (options.maxDelay <= 0) {
      throw new Error(`WaiterConfiguration.maxDelay must be greater than 0`);
    } else if (options.maxWaitTime <= options.minDelay) {
      throw new Error(`WaiterConfiguration.maxWaitTime [${options.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
    } else if (options.maxDelay < options.minDelay) {
      throw new Error(`WaiterConfiguration.maxDelay [${options.maxDelay}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
    }
  };
  var abortTimeout = (abortSignal) => {
    let onAbort;
    const promise = new Promise((resolve) => {
      onAbort = () => resolve({ state: exports.WaiterState.ABORTED });
      if (typeof abortSignal.addEventListener === "function") {
        abortSignal.addEventListener("abort", onAbort);
      } else {
        abortSignal.onabort = onAbort;
      }
    });
    return {
      clearListener() {
        if (typeof abortSignal.removeEventListener === "function") {
          abortSignal.removeEventListener("abort", onAbort);
        }
      },
      aborted: promise
    };
  };
  var createWaiter = async (options, input, acceptorChecks) => {
    const params = {
      ...waiterServiceDefaults,
      ...options
    };
    validateWaiterOptions(params);
    const exitConditions = [runPolling(params, input, acceptorChecks)];
    const finalize = [];
    if (options.abortSignal) {
      const { aborted, clearListener } = abortTimeout(options.abortSignal);
      finalize.push(clearListener);
      exitConditions.push(aborted);
    }
    if (options.abortController?.signal) {
      const { aborted, clearListener } = abortTimeout(options.abortController.signal);
      finalize.push(clearListener);
      exitConditions.push(aborted);
    }
    return Promise.race(exitConditions).then((result) => {
      for (const fn of finalize) {
        fn();
      }
      return result;
    });
  };
  exports.checkExceptions = checkExceptions;
  exports.createWaiter = createWaiter;
  exports.waiterServiceDefaults = waiterServiceDefaults;
});

// node_modules/@aws-sdk/client-s3/dist-cjs/index.js
var require_dist_cjs74 = __commonJS((exports) => {
  var middlewareExpectContinue = require_dist_cjs3();
  var middlewareFlexibleChecksums = require_dist_cjs29();
  var middlewareHostHeader = require_dist_cjs30();
  var middlewareLogger = require_dist_cjs31();
  var middlewareRecursionDetection = require_dist_cjs32();
  var middlewareSdkS3 = require_dist_cjs35();
  var middlewareUserAgent = require_dist_cjs40();
  var configResolver = require_dist_cjs41();
  var core = require_dist_cjs17();
  var schema = require_schema();
  var eventstreamSerdeConfigResolver = require_dist_cjs42();
  var middlewareContentLength = require_dist_cjs43();
  var middlewareEndpoint = require_dist_cjs46();
  var middlewareRetry = require_dist_cjs49();
  var smithyClient = require_dist_cjs22();
  var httpAuthSchemeProvider = require_httpAuthSchemeProvider();
  var schemas_0 = require_schemas_0();
  var runtimeConfig = require_runtimeConfig5();
  var regionConfigResolver = require_dist_cjs58();
  var protocolHttp = require_dist_cjs2();
  var middlewareSsec = require_dist_cjs71();
  var middlewareLocationConstraint = require_dist_cjs72();
  var utilWaiter = require_dist_cjs73();
  var errors = require_errors5();
  var S3ServiceException = require_S3ServiceException();
  var resolveClientEndpointParameters = (options) => {
    return Object.assign(options, {
      useFipsEndpoint: options.useFipsEndpoint ?? false,
      useDualstackEndpoint: options.useDualstackEndpoint ?? false,
      forcePathStyle: options.forcePathStyle ?? false,
      useAccelerateEndpoint: options.useAccelerateEndpoint ?? false,
      useGlobalEndpoint: options.useGlobalEndpoint ?? false,
      disableMultiregionAccessPoints: options.disableMultiregionAccessPoints ?? false,
      defaultSigningName: "s3",
      clientContextParams: options.clientContextParams ?? {}
    });
  };
  var commonParams = {
    ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
    UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
    DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
    Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
    DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
    UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };

  class CreateSessionCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "CreateSession", {}).n("S3Client", "CreateSessionCommand").sc(schemas_0.CreateSession$).build() {
  }
  var getHttpAuthExtensionConfiguration = (runtimeConfig2) => {
    const _httpAuthSchemes = runtimeConfig2.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig2.httpAuthSchemeProvider;
    let _credentials = runtimeConfig2.credentials;
    return {
      setHttpAuthScheme(httpAuthScheme) {
        const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
        if (index === -1) {
          _httpAuthSchemes.push(httpAuthScheme);
        } else {
          _httpAuthSchemes.splice(index, 1, httpAuthScheme);
        }
      },
      httpAuthSchemes() {
        return _httpAuthSchemes;
      },
      setHttpAuthSchemeProvider(httpAuthSchemeProvider2) {
        _httpAuthSchemeProvider = httpAuthSchemeProvider2;
      },
      httpAuthSchemeProvider() {
        return _httpAuthSchemeProvider;
      },
      setCredentials(credentials) {
        _credentials = credentials;
      },
      credentials() {
        return _credentials;
      }
    };
  };
  var resolveHttpAuthRuntimeConfig = (config) => {
    return {
      httpAuthSchemes: config.httpAuthSchemes(),
      httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
      credentials: config.credentials()
    };
  };
  var resolveRuntimeExtensions = (runtimeConfig2, extensions) => {
    const extensionConfiguration = Object.assign(regionConfigResolver.getAwsRegionExtensionConfiguration(runtimeConfig2), smithyClient.getDefaultExtensionConfiguration(runtimeConfig2), protocolHttp.getHttpHandlerExtensionConfiguration(runtimeConfig2), getHttpAuthExtensionConfiguration(runtimeConfig2));
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return Object.assign(runtimeConfig2, regionConfigResolver.resolveAwsRegionExtensionConfiguration(extensionConfiguration), smithyClient.resolveDefaultRuntimeConfig(extensionConfiguration), protocolHttp.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));
  };

  class S3Client extends smithyClient.Client {
    config;
    constructor(...[configuration]) {
      const _config_0 = runtimeConfig.getRuntimeConfig(configuration || {});
      super(_config_0);
      this.initConfig = _config_0;
      const _config_1 = resolveClientEndpointParameters(_config_0);
      const _config_2 = middlewareUserAgent.resolveUserAgentConfig(_config_1);
      const _config_3 = middlewareFlexibleChecksums.resolveFlexibleChecksumsConfig(_config_2);
      const _config_4 = middlewareRetry.resolveRetryConfig(_config_3);
      const _config_5 = configResolver.resolveRegionConfig(_config_4);
      const _config_6 = middlewareHostHeader.resolveHostHeaderConfig(_config_5);
      const _config_7 = middlewareEndpoint.resolveEndpointConfig(_config_6);
      const _config_8 = eventstreamSerdeConfigResolver.resolveEventStreamSerdeConfig(_config_7);
      const _config_9 = httpAuthSchemeProvider.resolveHttpAuthSchemeConfig(_config_8);
      const _config_10 = middlewareSdkS3.resolveS3Config(_config_9, { session: [() => this, CreateSessionCommand] });
      const _config_11 = resolveRuntimeExtensions(_config_10, configuration?.extensions || []);
      this.config = _config_11;
      this.middlewareStack.use(schema.getSchemaSerdePlugin(this.config));
      this.middlewareStack.use(middlewareUserAgent.getUserAgentPlugin(this.config));
      this.middlewareStack.use(middlewareRetry.getRetryPlugin(this.config));
      this.middlewareStack.use(middlewareContentLength.getContentLengthPlugin(this.config));
      this.middlewareStack.use(middlewareHostHeader.getHostHeaderPlugin(this.config));
      this.middlewareStack.use(middlewareLogger.getLoggerPlugin(this.config));
      this.middlewareStack.use(middlewareRecursionDetection.getRecursionDetectionPlugin(this.config));
      this.middlewareStack.use(core.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
        httpAuthSchemeParametersProvider: httpAuthSchemeProvider.defaultS3HttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config) => new core.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config.credentials,
          "aws.auth#sigv4a": config.credentials
        })
      }));
      this.middlewareStack.use(core.getHttpSigningPlugin(this.config));
      this.middlewareStack.use(middlewareSdkS3.getValidateBucketNamePlugin(this.config));
      this.middlewareStack.use(middlewareExpectContinue.getAddExpectContinuePlugin(this.config));
      this.middlewareStack.use(middlewareSdkS3.getRegionRedirectMiddlewarePlugin(this.config));
      this.middlewareStack.use(middlewareSdkS3.getS3ExpressPlugin(this.config));
      this.middlewareStack.use(middlewareSdkS3.getS3ExpressHttpSigningPlugin(this.config));
    }
    destroy() {
      super.destroy();
    }
  }

  class AbortMultipartUploadCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "AbortMultipartUpload", {}).n("S3Client", "AbortMultipartUploadCommand").sc(schemas_0.AbortMultipartUpload$).build() {
  }

  class CompleteMultipartUploadCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config),
      middlewareSsec.getSsecPlugin(config)
    ];
  }).s("AmazonS3", "CompleteMultipartUpload", {}).n("S3Client", "CompleteMultipartUploadCommand").sc(schemas_0.CompleteMultipartUpload$).build() {
  }

  class CopyObjectCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" },
    CopySource: { type: "contextParams", name: "CopySource" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config),
      middlewareSsec.getSsecPlugin(config)
    ];
  }).s("AmazonS3", "CopyObject", {}).n("S3Client", "CopyObjectCommand").sc(schemas_0.CopyObject$).build() {
  }

  class CreateBucketCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    DisableAccessPoints: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config),
      middlewareLocationConstraint.getLocationConstraintPlugin(config)
    ];
  }).s("AmazonS3", "CreateBucket", {}).n("S3Client", "CreateBucketCommand").sc(schemas_0.CreateBucket$).build() {
  }

  class CreateBucketMetadataConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "CreateBucketMetadataConfiguration", {}).n("S3Client", "CreateBucketMetadataConfigurationCommand").sc(schemas_0.CreateBucketMetadataConfiguration$).build() {
  }

  class CreateBucketMetadataTableConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "CreateBucketMetadataTableConfiguration", {}).n("S3Client", "CreateBucketMetadataTableConfigurationCommand").sc(schemas_0.CreateBucketMetadataTableConfiguration$).build() {
  }

  class CreateMultipartUploadCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config),
      middlewareSsec.getSsecPlugin(config)
    ];
  }).s("AmazonS3", "CreateMultipartUpload", {}).n("S3Client", "CreateMultipartUploadCommand").sc(schemas_0.CreateMultipartUpload$).build() {
  }

  class DeleteBucketAnalyticsConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucketAnalyticsConfiguration", {}).n("S3Client", "DeleteBucketAnalyticsConfigurationCommand").sc(schemas_0.DeleteBucketAnalyticsConfiguration$).build() {
  }

  class DeleteBucketCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucket", {}).n("S3Client", "DeleteBucketCommand").sc(schemas_0.DeleteBucket$).build() {
  }

  class DeleteBucketCorsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucketCors", {}).n("S3Client", "DeleteBucketCorsCommand").sc(schemas_0.DeleteBucketCors$).build() {
  }

  class DeleteBucketEncryptionCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucketEncryption", {}).n("S3Client", "DeleteBucketEncryptionCommand").sc(schemas_0.DeleteBucketEncryption$).build() {
  }

  class DeleteBucketIntelligentTieringConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucketIntelligentTieringConfiguration", {}).n("S3Client", "DeleteBucketIntelligentTieringConfigurationCommand").sc(schemas_0.DeleteBucketIntelligentTieringConfiguration$).build() {
  }

  class DeleteBucketInventoryConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucketInventoryConfiguration", {}).n("S3Client", "DeleteBucketInventoryConfigurationCommand").sc(schemas_0.DeleteBucketInventoryConfiguration$).build() {
  }

  class DeleteBucketLifecycleCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucketLifecycle", {}).n("S3Client", "DeleteBucketLifecycleCommand").sc(schemas_0.DeleteBucketLifecycle$).build() {
  }

  class DeleteBucketMetadataConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucketMetadataConfiguration", {}).n("S3Client", "DeleteBucketMetadataConfigurationCommand").sc(schemas_0.DeleteBucketMetadataConfiguration$).build() {
  }

  class DeleteBucketMetadataTableConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucketMetadataTableConfiguration", {}).n("S3Client", "DeleteBucketMetadataTableConfigurationCommand").sc(schemas_0.DeleteBucketMetadataTableConfiguration$).build() {
  }

  class DeleteBucketMetricsConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucketMetricsConfiguration", {}).n("S3Client", "DeleteBucketMetricsConfigurationCommand").sc(schemas_0.DeleteBucketMetricsConfiguration$).build() {
  }

  class DeleteBucketOwnershipControlsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucketOwnershipControls", {}).n("S3Client", "DeleteBucketOwnershipControlsCommand").sc(schemas_0.DeleteBucketOwnershipControls$).build() {
  }

  class DeleteBucketPolicyCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucketPolicy", {}).n("S3Client", "DeleteBucketPolicyCommand").sc(schemas_0.DeleteBucketPolicy$).build() {
  }

  class DeleteBucketReplicationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucketReplication", {}).n("S3Client", "DeleteBucketReplicationCommand").sc(schemas_0.DeleteBucketReplication$).build() {
  }

  class DeleteBucketTaggingCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucketTagging", {}).n("S3Client", "DeleteBucketTaggingCommand").sc(schemas_0.DeleteBucketTagging$).build() {
  }

  class DeleteBucketWebsiteCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeleteBucketWebsite", {}).n("S3Client", "DeleteBucketWebsiteCommand").sc(schemas_0.DeleteBucketWebsite$).build() {
  }

  class DeleteObjectCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "DeleteObject", {}).n("S3Client", "DeleteObjectCommand").sc(schemas_0.DeleteObject$).build() {
  }

  class DeleteObjectsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      }),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "DeleteObjects", {}).n("S3Client", "DeleteObjectsCommand").sc(schemas_0.DeleteObjects$).build() {
  }

  class DeleteObjectTaggingCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "DeleteObjectTagging", {}).n("S3Client", "DeleteObjectTaggingCommand").sc(schemas_0.DeleteObjectTagging$).build() {
  }

  class DeletePublicAccessBlockCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "DeletePublicAccessBlock", {}).n("S3Client", "DeletePublicAccessBlockCommand").sc(schemas_0.DeletePublicAccessBlock$).build() {
  }

  class GetBucketAbacCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketAbac", {}).n("S3Client", "GetBucketAbacCommand").sc(schemas_0.GetBucketAbac$).build() {
  }

  class GetBucketAccelerateConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketAccelerateConfiguration", {}).n("S3Client", "GetBucketAccelerateConfigurationCommand").sc(schemas_0.GetBucketAccelerateConfiguration$).build() {
  }

  class GetBucketAclCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketAcl", {}).n("S3Client", "GetBucketAclCommand").sc(schemas_0.GetBucketAcl$).build() {
  }

  class GetBucketAnalyticsConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketAnalyticsConfiguration", {}).n("S3Client", "GetBucketAnalyticsConfigurationCommand").sc(schemas_0.GetBucketAnalyticsConfiguration$).build() {
  }

  class GetBucketCorsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketCors", {}).n("S3Client", "GetBucketCorsCommand").sc(schemas_0.GetBucketCors$).build() {
  }

  class GetBucketEncryptionCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketEncryption", {}).n("S3Client", "GetBucketEncryptionCommand").sc(schemas_0.GetBucketEncryption$).build() {
  }

  class GetBucketIntelligentTieringConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketIntelligentTieringConfiguration", {}).n("S3Client", "GetBucketIntelligentTieringConfigurationCommand").sc(schemas_0.GetBucketIntelligentTieringConfiguration$).build() {
  }

  class GetBucketInventoryConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketInventoryConfiguration", {}).n("S3Client", "GetBucketInventoryConfigurationCommand").sc(schemas_0.GetBucketInventoryConfiguration$).build() {
  }

  class GetBucketLifecycleConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketLifecycleConfiguration", {}).n("S3Client", "GetBucketLifecycleConfigurationCommand").sc(schemas_0.GetBucketLifecycleConfiguration$).build() {
  }

  class GetBucketLocationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketLocation", {}).n("S3Client", "GetBucketLocationCommand").sc(schemas_0.GetBucketLocation$).build() {
  }

  class GetBucketLoggingCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketLogging", {}).n("S3Client", "GetBucketLoggingCommand").sc(schemas_0.GetBucketLogging$).build() {
  }

  class GetBucketMetadataConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketMetadataConfiguration", {}).n("S3Client", "GetBucketMetadataConfigurationCommand").sc(schemas_0.GetBucketMetadataConfiguration$).build() {
  }

  class GetBucketMetadataTableConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketMetadataTableConfiguration", {}).n("S3Client", "GetBucketMetadataTableConfigurationCommand").sc(schemas_0.GetBucketMetadataTableConfiguration$).build() {
  }

  class GetBucketMetricsConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketMetricsConfiguration", {}).n("S3Client", "GetBucketMetricsConfigurationCommand").sc(schemas_0.GetBucketMetricsConfiguration$).build() {
  }

  class GetBucketNotificationConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketNotificationConfiguration", {}).n("S3Client", "GetBucketNotificationConfigurationCommand").sc(schemas_0.GetBucketNotificationConfiguration$).build() {
  }

  class GetBucketOwnershipControlsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketOwnershipControls", {}).n("S3Client", "GetBucketOwnershipControlsCommand").sc(schemas_0.GetBucketOwnershipControls$).build() {
  }

  class GetBucketPolicyCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketPolicy", {}).n("S3Client", "GetBucketPolicyCommand").sc(schemas_0.GetBucketPolicy$).build() {
  }

  class GetBucketPolicyStatusCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketPolicyStatus", {}).n("S3Client", "GetBucketPolicyStatusCommand").sc(schemas_0.GetBucketPolicyStatus$).build() {
  }

  class GetBucketReplicationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketReplication", {}).n("S3Client", "GetBucketReplicationCommand").sc(schemas_0.GetBucketReplication$).build() {
  }

  class GetBucketRequestPaymentCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketRequestPayment", {}).n("S3Client", "GetBucketRequestPaymentCommand").sc(schemas_0.GetBucketRequestPayment$).build() {
  }

  class GetBucketTaggingCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketTagging", {}).n("S3Client", "GetBucketTaggingCommand").sc(schemas_0.GetBucketTagging$).build() {
  }

  class GetBucketVersioningCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketVersioning", {}).n("S3Client", "GetBucketVersioningCommand").sc(schemas_0.GetBucketVersioning$).build() {
  }

  class GetBucketWebsiteCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetBucketWebsite", {}).n("S3Client", "GetBucketWebsiteCommand").sc(schemas_0.GetBucketWebsite$).build() {
  }

  class GetObjectAclCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetObjectAcl", {}).n("S3Client", "GetObjectAclCommand").sc(schemas_0.GetObjectAcl$).build() {
  }

  class GetObjectAttributesCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config),
      middlewareSsec.getSsecPlugin(config)
    ];
  }).s("AmazonS3", "GetObjectAttributes", {}).n("S3Client", "GetObjectAttributesCommand").sc(schemas_0.GetObjectAttributes$).build() {
  }

  class GetObjectCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestChecksumRequired: false,
        requestValidationModeMember: "ChecksumMode",
        responseAlgorithms: ["CRC64NVME", "CRC32", "CRC32C", "SHA256", "SHA1"]
      }),
      middlewareSsec.getSsecPlugin(config),
      middlewareSdkS3.getS3ExpiresMiddlewarePlugin(config)
    ];
  }).s("AmazonS3", "GetObject", {}).n("S3Client", "GetObjectCommand").sc(schemas_0.GetObject$).build() {
  }

  class GetObjectLegalHoldCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetObjectLegalHold", {}).n("S3Client", "GetObjectLegalHoldCommand").sc(schemas_0.GetObjectLegalHold$).build() {
  }

  class GetObjectLockConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetObjectLockConfiguration", {}).n("S3Client", "GetObjectLockConfigurationCommand").sc(schemas_0.GetObjectLockConfiguration$).build() {
  }

  class GetObjectRetentionCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetObjectRetention", {}).n("S3Client", "GetObjectRetentionCommand").sc(schemas_0.GetObjectRetention$).build() {
  }

  class GetObjectTaggingCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetObjectTagging", {}).n("S3Client", "GetObjectTaggingCommand").sc(schemas_0.GetObjectTagging$).build() {
  }

  class GetObjectTorrentCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "GetObjectTorrent", {}).n("S3Client", "GetObjectTorrentCommand").sc(schemas_0.GetObjectTorrent$).build() {
  }

  class GetPublicAccessBlockCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "GetPublicAccessBlock", {}).n("S3Client", "GetPublicAccessBlockCommand").sc(schemas_0.GetPublicAccessBlock$).build() {
  }

  class HeadBucketCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "HeadBucket", {}).n("S3Client", "HeadBucketCommand").sc(schemas_0.HeadBucket$).build() {
  }

  class HeadObjectCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config),
      middlewareSsec.getSsecPlugin(config),
      middlewareSdkS3.getS3ExpiresMiddlewarePlugin(config)
    ];
  }).s("AmazonS3", "HeadObject", {}).n("S3Client", "HeadObjectCommand").sc(schemas_0.HeadObject$).build() {
  }

  class ListBucketAnalyticsConfigurationsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "ListBucketAnalyticsConfigurations", {}).n("S3Client", "ListBucketAnalyticsConfigurationsCommand").sc(schemas_0.ListBucketAnalyticsConfigurations$).build() {
  }

  class ListBucketIntelligentTieringConfigurationsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "ListBucketIntelligentTieringConfigurations", {}).n("S3Client", "ListBucketIntelligentTieringConfigurationsCommand").sc(schemas_0.ListBucketIntelligentTieringConfigurations$).build() {
  }

  class ListBucketInventoryConfigurationsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "ListBucketInventoryConfigurations", {}).n("S3Client", "ListBucketInventoryConfigurationsCommand").sc(schemas_0.ListBucketInventoryConfigurations$).build() {
  }

  class ListBucketMetricsConfigurationsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "ListBucketMetricsConfigurations", {}).n("S3Client", "ListBucketMetricsConfigurationsCommand").sc(schemas_0.ListBucketMetricsConfigurations$).build() {
  }

  class ListBucketsCommand extends smithyClient.Command.classBuilder().ep(commonParams).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "ListBuckets", {}).n("S3Client", "ListBucketsCommand").sc(schemas_0.ListBuckets$).build() {
  }

  class ListDirectoryBucketsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "ListDirectoryBuckets", {}).n("S3Client", "ListDirectoryBucketsCommand").sc(schemas_0.ListDirectoryBuckets$).build() {
  }

  class ListMultipartUploadsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Prefix: { type: "contextParams", name: "Prefix" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "ListMultipartUploads", {}).n("S3Client", "ListMultipartUploadsCommand").sc(schemas_0.ListMultipartUploads$).build() {
  }

  class ListObjectsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Prefix: { type: "contextParams", name: "Prefix" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "ListObjects", {}).n("S3Client", "ListObjectsCommand").sc(schemas_0.ListObjects$).build() {
  }

  class ListObjectsV2Command extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Prefix: { type: "contextParams", name: "Prefix" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "ListObjectsV2", {}).n("S3Client", "ListObjectsV2Command").sc(schemas_0.ListObjectsV2$).build() {
  }

  class ListObjectVersionsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Prefix: { type: "contextParams", name: "Prefix" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "ListObjectVersions", {}).n("S3Client", "ListObjectVersionsCommand").sc(schemas_0.ListObjectVersions$).build() {
  }

  class ListPartsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config),
      middlewareSsec.getSsecPlugin(config)
    ];
  }).s("AmazonS3", "ListParts", {}).n("S3Client", "ListPartsCommand").sc(schemas_0.ListParts$).build() {
  }

  class PutBucketAbacCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: false
      })
    ];
  }).s("AmazonS3", "PutBucketAbac", {}).n("S3Client", "PutBucketAbacCommand").sc(schemas_0.PutBucketAbac$).build() {
  }

  class PutBucketAccelerateConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: false
      })
    ];
  }).s("AmazonS3", "PutBucketAccelerateConfiguration", {}).n("S3Client", "PutBucketAccelerateConfigurationCommand").sc(schemas_0.PutBucketAccelerateConfiguration$).build() {
  }

  class PutBucketAclCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "PutBucketAcl", {}).n("S3Client", "PutBucketAclCommand").sc(schemas_0.PutBucketAcl$).build() {
  }

  class PutBucketAnalyticsConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "PutBucketAnalyticsConfiguration", {}).n("S3Client", "PutBucketAnalyticsConfigurationCommand").sc(schemas_0.PutBucketAnalyticsConfiguration$).build() {
  }

  class PutBucketCorsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "PutBucketCors", {}).n("S3Client", "PutBucketCorsCommand").sc(schemas_0.PutBucketCors$).build() {
  }

  class PutBucketEncryptionCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "PutBucketEncryption", {}).n("S3Client", "PutBucketEncryptionCommand").sc(schemas_0.PutBucketEncryption$).build() {
  }

  class PutBucketIntelligentTieringConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "PutBucketIntelligentTieringConfiguration", {}).n("S3Client", "PutBucketIntelligentTieringConfigurationCommand").sc(schemas_0.PutBucketIntelligentTieringConfiguration$).build() {
  }

  class PutBucketInventoryConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "PutBucketInventoryConfiguration", {}).n("S3Client", "PutBucketInventoryConfigurationCommand").sc(schemas_0.PutBucketInventoryConfiguration$).build() {
  }

  class PutBucketLifecycleConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      }),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "PutBucketLifecycleConfiguration", {}).n("S3Client", "PutBucketLifecycleConfigurationCommand").sc(schemas_0.PutBucketLifecycleConfiguration$).build() {
  }

  class PutBucketLoggingCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "PutBucketLogging", {}).n("S3Client", "PutBucketLoggingCommand").sc(schemas_0.PutBucketLogging$).build() {
  }

  class PutBucketMetricsConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "PutBucketMetricsConfiguration", {}).n("S3Client", "PutBucketMetricsConfigurationCommand").sc(schemas_0.PutBucketMetricsConfiguration$).build() {
  }

  class PutBucketNotificationConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "PutBucketNotificationConfiguration", {}).n("S3Client", "PutBucketNotificationConfigurationCommand").sc(schemas_0.PutBucketNotificationConfiguration$).build() {
  }

  class PutBucketOwnershipControlsCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "PutBucketOwnershipControls", {}).n("S3Client", "PutBucketOwnershipControlsCommand").sc(schemas_0.PutBucketOwnershipControls$).build() {
  }

  class PutBucketPolicyCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "PutBucketPolicy", {}).n("S3Client", "PutBucketPolicyCommand").sc(schemas_0.PutBucketPolicy$).build() {
  }

  class PutBucketReplicationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "PutBucketReplication", {}).n("S3Client", "PutBucketReplicationCommand").sc(schemas_0.PutBucketReplication$).build() {
  }

  class PutBucketRequestPaymentCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "PutBucketRequestPayment", {}).n("S3Client", "PutBucketRequestPaymentCommand").sc(schemas_0.PutBucketRequestPayment$).build() {
  }

  class PutBucketTaggingCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "PutBucketTagging", {}).n("S3Client", "PutBucketTaggingCommand").sc(schemas_0.PutBucketTagging$).build() {
  }

  class PutBucketVersioningCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "PutBucketVersioning", {}).n("S3Client", "PutBucketVersioningCommand").sc(schemas_0.PutBucketVersioning$).build() {
  }

  class PutBucketWebsiteCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "PutBucketWebsite", {}).n("S3Client", "PutBucketWebsiteCommand").sc(schemas_0.PutBucketWebsite$).build() {
  }

  class PutObjectAclCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      }),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "PutObjectAcl", {}).n("S3Client", "PutObjectAclCommand").sc(schemas_0.PutObjectAcl$).build() {
  }

  class PutObjectCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: false
      }),
      middlewareSdkS3.getCheckContentLengthHeaderPlugin(config),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config),
      middlewareSsec.getSsecPlugin(config)
    ];
  }).s("AmazonS3", "PutObject", {}).n("S3Client", "PutObjectCommand").sc(schemas_0.PutObject$).build() {
  }

  class PutObjectLegalHoldCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      }),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "PutObjectLegalHold", {}).n("S3Client", "PutObjectLegalHoldCommand").sc(schemas_0.PutObjectLegalHold$).build() {
  }

  class PutObjectLockConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      }),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "PutObjectLockConfiguration", {}).n("S3Client", "PutObjectLockConfigurationCommand").sc(schemas_0.PutObjectLockConfiguration$).build() {
  }

  class PutObjectRetentionCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      }),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "PutObjectRetention", {}).n("S3Client", "PutObjectRetentionCommand").sc(schemas_0.PutObjectRetention$).build() {
  }

  class PutObjectTaggingCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      }),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "PutObjectTagging", {}).n("S3Client", "PutObjectTaggingCommand").sc(schemas_0.PutObjectTagging$).build() {
  }

  class PutPublicAccessBlockCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "PutPublicAccessBlock", {}).n("S3Client", "PutPublicAccessBlockCommand").sc(schemas_0.PutPublicAccessBlock$).build() {
  }

  class RenameObjectCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "RenameObject", {}).n("S3Client", "RenameObjectCommand").sc(schemas_0.RenameObject$).build() {
  }

  class RestoreObjectCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: false
      }),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "RestoreObject", {}).n("S3Client", "RestoreObjectCommand").sc(schemas_0.RestoreObject$).build() {
  }

  class SelectObjectContentCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config),
      middlewareSsec.getSsecPlugin(config)
    ];
  }).s("AmazonS3", "SelectObjectContent", {
    eventStream: {
      output: true
    }
  }).n("S3Client", "SelectObjectContentCommand").sc(schemas_0.SelectObjectContent$).build() {
  }

  class UpdateBucketMetadataInventoryTableConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "UpdateBucketMetadataInventoryTableConfiguration", {}).n("S3Client", "UpdateBucketMetadataInventoryTableConfigurationCommand").sc(schemas_0.UpdateBucketMetadataInventoryTableConfiguration$).build() {
  }

  class UpdateBucketMetadataJournalTableConfigurationCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      })
    ];
  }).s("AmazonS3", "UpdateBucketMetadataJournalTableConfiguration", {}).n("S3Client", "UpdateBucketMetadataJournalTableConfigurationCommand").sc(schemas_0.UpdateBucketMetadataJournalTableConfiguration$).build() {
  }

  class UpdateObjectEncryptionCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: true
      }),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config)
    ];
  }).s("AmazonS3", "UpdateObjectEncryption", {}).n("S3Client", "UpdateObjectEncryptionCommand").sc(schemas_0.UpdateObjectEncryption$).build() {
  }

  class UploadPartCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: false
      }),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config),
      middlewareSsec.getSsecPlugin(config)
    ];
  }).s("AmazonS3", "UploadPart", {}).n("S3Client", "UploadPartCommand").sc(schemas_0.UploadPart$).build() {
  }

  class UploadPartCopyCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command, cs, config, o) {
    return [
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
      middlewareSdkS3.getThrow200ExceptionsPlugin(config),
      middlewareSsec.getSsecPlugin(config)
    ];
  }).s("AmazonS3", "UploadPartCopy", {}).n("S3Client", "UploadPartCopyCommand").sc(schemas_0.UploadPartCopy$).build() {
  }

  class WriteGetObjectResponseCommand extends smithyClient.Command.classBuilder().ep({
    ...commonParams,
    UseObjectLambdaEndpoint: { type: "staticContextParams", value: true }
  }).m(function(Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
  }).s("AmazonS3", "WriteGetObjectResponse", {}).n("S3Client", "WriteGetObjectResponseCommand").sc(schemas_0.WriteGetObjectResponse$).build() {
  }
  var paginateListBuckets = core.createPaginator(S3Client, ListBucketsCommand, "ContinuationToken", "ContinuationToken", "MaxBuckets");
  var paginateListDirectoryBuckets = core.createPaginator(S3Client, ListDirectoryBucketsCommand, "ContinuationToken", "ContinuationToken", "MaxDirectoryBuckets");
  var paginateListObjectsV2 = core.createPaginator(S3Client, ListObjectsV2Command, "ContinuationToken", "NextContinuationToken", "MaxKeys");
  var paginateListParts = core.createPaginator(S3Client, ListPartsCommand, "PartNumberMarker", "NextPartNumberMarker", "MaxParts");
  var checkState$3 = async (client3, input) => {
    let reason;
    try {
      let result = await client3.send(new HeadBucketCommand(input));
      reason = result;
      return { state: utilWaiter.WaiterState.SUCCESS, reason };
    } catch (exception) {
      reason = exception;
      if (exception.name && exception.name == "NotFound") {
        return { state: utilWaiter.WaiterState.RETRY, reason };
      }
    }
    return { state: utilWaiter.WaiterState.RETRY, reason };
  };
  var waitForBucketExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    return utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState$3);
  };
  var waitUntilBucketExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    const result = await utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState$3);
    return utilWaiter.checkExceptions(result);
  };
  var checkState$2 = async (client3, input) => {
    let reason;
    try {
      let result = await client3.send(new HeadBucketCommand(input));
      reason = result;
    } catch (exception) {
      reason = exception;
      if (exception.name && exception.name == "NotFound") {
        return { state: utilWaiter.WaiterState.SUCCESS, reason };
      }
    }
    return { state: utilWaiter.WaiterState.RETRY, reason };
  };
  var waitForBucketNotExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    return utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState$2);
  };
  var waitUntilBucketNotExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    const result = await utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState$2);
    return utilWaiter.checkExceptions(result);
  };
  var checkState$1 = async (client3, input) => {
    let reason;
    try {
      let result = await client3.send(new HeadObjectCommand(input));
      reason = result;
      return { state: utilWaiter.WaiterState.SUCCESS, reason };
    } catch (exception) {
      reason = exception;
      if (exception.name && exception.name == "NotFound") {
        return { state: utilWaiter.WaiterState.RETRY, reason };
      }
    }
    return { state: utilWaiter.WaiterState.RETRY, reason };
  };
  var waitForObjectExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    return utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState$1);
  };
  var waitUntilObjectExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    const result = await utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState$1);
    return utilWaiter.checkExceptions(result);
  };
  var checkState = async (client3, input) => {
    let reason;
    try {
      let result = await client3.send(new HeadObjectCommand(input));
      reason = result;
    } catch (exception) {
      reason = exception;
      if (exception.name && exception.name == "NotFound") {
        return { state: utilWaiter.WaiterState.SUCCESS, reason };
      }
    }
    return { state: utilWaiter.WaiterState.RETRY, reason };
  };
  var waitForObjectNotExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    return utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState);
  };
  var waitUntilObjectNotExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    const result = await utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState);
    return utilWaiter.checkExceptions(result);
  };
  var commands = {
    AbortMultipartUploadCommand,
    CompleteMultipartUploadCommand,
    CopyObjectCommand,
    CreateBucketCommand,
    CreateBucketMetadataConfigurationCommand,
    CreateBucketMetadataTableConfigurationCommand,
    CreateMultipartUploadCommand,
    CreateSessionCommand,
    DeleteBucketCommand,
    DeleteBucketAnalyticsConfigurationCommand,
    DeleteBucketCorsCommand,
    DeleteBucketEncryptionCommand,
    DeleteBucketIntelligentTieringConfigurationCommand,
    DeleteBucketInventoryConfigurationCommand,
    DeleteBucketLifecycleCommand,
    DeleteBucketMetadataConfigurationCommand,
    DeleteBucketMetadataTableConfigurationCommand,
    DeleteBucketMetricsConfigurationCommand,
    DeleteBucketOwnershipControlsCommand,
    DeleteBucketPolicyCommand,
    DeleteBucketReplicationCommand,
    DeleteBucketTaggingCommand,
    DeleteBucketWebsiteCommand,
    DeleteObjectCommand,
    DeleteObjectsCommand,
    DeleteObjectTaggingCommand,
    DeletePublicAccessBlockCommand,
    GetBucketAbacCommand,
    GetBucketAccelerateConfigurationCommand,
    GetBucketAclCommand,
    GetBucketAnalyticsConfigurationCommand,
    GetBucketCorsCommand,
    GetBucketEncryptionCommand,
    GetBucketIntelligentTieringConfigurationCommand,
    GetBucketInventoryConfigurationCommand,
    GetBucketLifecycleConfigurationCommand,
    GetBucketLocationCommand,
    GetBucketLoggingCommand,
    GetBucketMetadataConfigurationCommand,
    GetBucketMetadataTableConfigurationCommand,
    GetBucketMetricsConfigurationCommand,
    GetBucketNotificationConfigurationCommand,
    GetBucketOwnershipControlsCommand,
    GetBucketPolicyCommand,
    GetBucketPolicyStatusCommand,
    GetBucketReplicationCommand,
    GetBucketRequestPaymentCommand,
    GetBucketTaggingCommand,
    GetBucketVersioningCommand,
    GetBucketWebsiteCommand,
    GetObjectCommand,
    GetObjectAclCommand,
    GetObjectAttributesCommand,
    GetObjectLegalHoldCommand,
    GetObjectLockConfigurationCommand,
    GetObjectRetentionCommand,
    GetObjectTaggingCommand,
    GetObjectTorrentCommand,
    GetPublicAccessBlockCommand,
    HeadBucketCommand,
    HeadObjectCommand,
    ListBucketAnalyticsConfigurationsCommand,
    ListBucketIntelligentTieringConfigurationsCommand,
    ListBucketInventoryConfigurationsCommand,
    ListBucketMetricsConfigurationsCommand,
    ListBucketsCommand,
    ListDirectoryBucketsCommand,
    ListMultipartUploadsCommand,
    ListObjectsCommand,
    ListObjectsV2Command,
    ListObjectVersionsCommand,
    ListPartsCommand,
    PutBucketAbacCommand,
    PutBucketAccelerateConfigurationCommand,
    PutBucketAclCommand,
    PutBucketAnalyticsConfigurationCommand,
    PutBucketCorsCommand,
    PutBucketEncryptionCommand,
    PutBucketIntelligentTieringConfigurationCommand,
    PutBucketInventoryConfigurationCommand,
    PutBucketLifecycleConfigurationCommand,
    PutBucketLoggingCommand,
    PutBucketMetricsConfigurationCommand,
    PutBucketNotificationConfigurationCommand,
    PutBucketOwnershipControlsCommand,
    PutBucketPolicyCommand,
    PutBucketReplicationCommand,
    PutBucketRequestPaymentCommand,
    PutBucketTaggingCommand,
    PutBucketVersioningCommand,
    PutBucketWebsiteCommand,
    PutObjectCommand,
    PutObjectAclCommand,
    PutObjectLegalHoldCommand,
    PutObjectLockConfigurationCommand,
    PutObjectRetentionCommand,
    PutObjectTaggingCommand,
    PutPublicAccessBlockCommand,
    RenameObjectCommand,
    RestoreObjectCommand,
    SelectObjectContentCommand,
    UpdateBucketMetadataInventoryTableConfigurationCommand,
    UpdateBucketMetadataJournalTableConfigurationCommand,
    UpdateObjectEncryptionCommand,
    UploadPartCommand,
    UploadPartCopyCommand,
    WriteGetObjectResponseCommand
  };
  var paginators = {
    paginateListBuckets,
    paginateListDirectoryBuckets,
    paginateListObjectsV2,
    paginateListParts
  };
  var waiters = {
    waitUntilBucketExists,
    waitUntilBucketNotExists,
    waitUntilObjectExists,
    waitUntilObjectNotExists
  };

  class S3 extends S3Client {
  }
  smithyClient.createAggregatedClient(commands, S3, { paginators, waiters });
  var BucketAbacStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  var RequestCharged = {
    requester: "requester"
  };
  var RequestPayer = {
    requester: "requester"
  };
  var BucketAccelerateStatus = {
    Enabled: "Enabled",
    Suspended: "Suspended"
  };
  var Type = {
    AmazonCustomerByEmail: "AmazonCustomerByEmail",
    CanonicalUser: "CanonicalUser",
    Group: "Group"
  };
  var Permission = {
    FULL_CONTROL: "FULL_CONTROL",
    READ: "READ",
    READ_ACP: "READ_ACP",
    WRITE: "WRITE",
    WRITE_ACP: "WRITE_ACP"
  };
  var OwnerOverride = {
    Destination: "Destination"
  };
  var ChecksumType = {
    COMPOSITE: "COMPOSITE",
    FULL_OBJECT: "FULL_OBJECT"
  };
  var ServerSideEncryption = {
    AES256: "AES256",
    aws_fsx: "aws:fsx",
    aws_kms: "aws:kms",
    aws_kms_dsse: "aws:kms:dsse"
  };
  var ObjectCannedACL = {
    authenticated_read: "authenticated-read",
    aws_exec_read: "aws-exec-read",
    bucket_owner_full_control: "bucket-owner-full-control",
    bucket_owner_read: "bucket-owner-read",
    private: "private",
    public_read: "public-read",
    public_read_write: "public-read-write"
  };
  var ChecksumAlgorithm = {
    CRC32: "CRC32",
    CRC32C: "CRC32C",
    CRC64NVME: "CRC64NVME",
    SHA1: "SHA1",
    SHA256: "SHA256"
  };
  var MetadataDirective = {
    COPY: "COPY",
    REPLACE: "REPLACE"
  };
  var ObjectLockLegalHoldStatus = {
    OFF: "OFF",
    ON: "ON"
  };
  var ObjectLockMode = {
    COMPLIANCE: "COMPLIANCE",
    GOVERNANCE: "GOVERNANCE"
  };
  var StorageClass = {
    DEEP_ARCHIVE: "DEEP_ARCHIVE",
    EXPRESS_ONEZONE: "EXPRESS_ONEZONE",
    FSX_ONTAP: "FSX_ONTAP",
    FSX_OPENZFS: "FSX_OPENZFS",
    GLACIER: "GLACIER",
    GLACIER_IR: "GLACIER_IR",
    INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
    ONEZONE_IA: "ONEZONE_IA",
    OUTPOSTS: "OUTPOSTS",
    REDUCED_REDUNDANCY: "REDUCED_REDUNDANCY",
    SNOW: "SNOW",
    STANDARD: "STANDARD",
    STANDARD_IA: "STANDARD_IA"
  };
  var TaggingDirective = {
    COPY: "COPY",
    REPLACE: "REPLACE"
  };
  var BucketCannedACL = {
    authenticated_read: "authenticated-read",
    private: "private",
    public_read: "public-read",
    public_read_write: "public-read-write"
  };
  var DataRedundancy = {
    SingleAvailabilityZone: "SingleAvailabilityZone",
    SingleLocalZone: "SingleLocalZone"
  };
  var BucketType = {
    Directory: "Directory"
  };
  var LocationType = {
    AvailabilityZone: "AvailabilityZone",
    LocalZone: "LocalZone"
  };
  var BucketLocationConstraint = {
    EU: "EU",
    af_south_1: "af-south-1",
    ap_east_1: "ap-east-1",
    ap_northeast_1: "ap-northeast-1",
    ap_northeast_2: "ap-northeast-2",
    ap_northeast_3: "ap-northeast-3",
    ap_south_1: "ap-south-1",
    ap_south_2: "ap-south-2",
    ap_southeast_1: "ap-southeast-1",
    ap_southeast_2: "ap-southeast-2",
    ap_southeast_3: "ap-southeast-3",
    ap_southeast_4: "ap-southeast-4",
    ap_southeast_5: "ap-southeast-5",
    ca_central_1: "ca-central-1",
    cn_north_1: "cn-north-1",
    cn_northwest_1: "cn-northwest-1",
    eu_central_1: "eu-central-1",
    eu_central_2: "eu-central-2",
    eu_north_1: "eu-north-1",
    eu_south_1: "eu-south-1",
    eu_south_2: "eu-south-2",
    eu_west_1: "eu-west-1",
    eu_west_2: "eu-west-2",
    eu_west_3: "eu-west-3",
    il_central_1: "il-central-1",
    me_central_1: "me-central-1",
    me_south_1: "me-south-1",
    sa_east_1: "sa-east-1",
    us_east_2: "us-east-2",
    us_gov_east_1: "us-gov-east-1",
    us_gov_west_1: "us-gov-west-1",
    us_west_1: "us-west-1",
    us_west_2: "us-west-2"
  };
  var ObjectOwnership = {
    BucketOwnerEnforced: "BucketOwnerEnforced",
    BucketOwnerPreferred: "BucketOwnerPreferred",
    ObjectWriter: "ObjectWriter"
  };
  var InventoryConfigurationState = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED"
  };
  var TableSseAlgorithm = {
    AES256: "AES256",
    aws_kms: "aws:kms"
  };
  var ExpirationState = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED"
  };
  var SessionMode = {
    ReadOnly: "ReadOnly",
    ReadWrite: "ReadWrite"
  };
  var AnalyticsS3ExportFileFormat = {
    CSV: "CSV"
  };
  var StorageClassAnalysisSchemaVersion = {
    V_1: "V_1"
  };
  var EncryptionType = {
    NONE: "NONE",
    SSE_C: "SSE-C"
  };
  var IntelligentTieringStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  var IntelligentTieringAccessTier = {
    ARCHIVE_ACCESS: "ARCHIVE_ACCESS",
    DEEP_ARCHIVE_ACCESS: "DEEP_ARCHIVE_ACCESS"
  };
  var InventoryFormat = {
    CSV: "CSV",
    ORC: "ORC",
    Parquet: "Parquet"
  };
  var InventoryIncludedObjectVersions = {
    All: "All",
    Current: "Current"
  };
  var InventoryOptionalField = {
    BucketKeyStatus: "BucketKeyStatus",
    ChecksumAlgorithm: "ChecksumAlgorithm",
    ETag: "ETag",
    EncryptionStatus: "EncryptionStatus",
    IntelligentTieringAccessTier: "IntelligentTieringAccessTier",
    IsMultipartUploaded: "IsMultipartUploaded",
    LastModifiedDate: "LastModifiedDate",
    LifecycleExpirationDate: "LifecycleExpirationDate",
    ObjectAccessControlList: "ObjectAccessControlList",
    ObjectLockLegalHoldStatus: "ObjectLockLegalHoldStatus",
    ObjectLockMode: "ObjectLockMode",
    ObjectLockRetainUntilDate: "ObjectLockRetainUntilDate",
    ObjectOwner: "ObjectOwner",
    ReplicationStatus: "ReplicationStatus",
    Size: "Size",
    StorageClass: "StorageClass"
  };
  var InventoryFrequency = {
    Daily: "Daily",
    Weekly: "Weekly"
  };
  var TransitionStorageClass = {
    DEEP_ARCHIVE: "DEEP_ARCHIVE",
    GLACIER: "GLACIER",
    GLACIER_IR: "GLACIER_IR",
    INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
    ONEZONE_IA: "ONEZONE_IA",
    STANDARD_IA: "STANDARD_IA"
  };
  var ExpirationStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  var TransitionDefaultMinimumObjectSize = {
    all_storage_classes_128K: "all_storage_classes_128K",
    varies_by_storage_class: "varies_by_storage_class"
  };
  var BucketLogsPermission = {
    FULL_CONTROL: "FULL_CONTROL",
    READ: "READ",
    WRITE: "WRITE"
  };
  var PartitionDateSource = {
    DeliveryTime: "DeliveryTime",
    EventTime: "EventTime"
  };
  var S3TablesBucketType = {
    aws: "aws",
    customer: "customer"
  };
  var Event = {
    s3_IntelligentTiering: "s3:IntelligentTiering",
    s3_LifecycleExpiration_: "s3:LifecycleExpiration:*",
    s3_LifecycleExpiration_Delete: "s3:LifecycleExpiration:Delete",
    s3_LifecycleExpiration_DeleteMarkerCreated: "s3:LifecycleExpiration:DeleteMarkerCreated",
    s3_LifecycleTransition: "s3:LifecycleTransition",
    s3_ObjectAcl_Put: "s3:ObjectAcl:Put",
    s3_ObjectCreated_: "s3:ObjectCreated:*",
    s3_ObjectCreated_CompleteMultipartUpload: "s3:ObjectCreated:CompleteMultipartUpload",
    s3_ObjectCreated_Copy: "s3:ObjectCreated:Copy",
    s3_ObjectCreated_Post: "s3:ObjectCreated:Post",
    s3_ObjectCreated_Put: "s3:ObjectCreated:Put",
    s3_ObjectRemoved_: "s3:ObjectRemoved:*",
    s3_ObjectRemoved_Delete: "s3:ObjectRemoved:Delete",
    s3_ObjectRemoved_DeleteMarkerCreated: "s3:ObjectRemoved:DeleteMarkerCreated",
    s3_ObjectRestore_: "s3:ObjectRestore:*",
    s3_ObjectRestore_Completed: "s3:ObjectRestore:Completed",
    s3_ObjectRestore_Delete: "s3:ObjectRestore:Delete",
    s3_ObjectRestore_Post: "s3:ObjectRestore:Post",
    s3_ObjectTagging_: "s3:ObjectTagging:*",
    s3_ObjectTagging_Delete: "s3:ObjectTagging:Delete",
    s3_ObjectTagging_Put: "s3:ObjectTagging:Put",
    s3_ReducedRedundancyLostObject: "s3:ReducedRedundancyLostObject",
    s3_Replication_: "s3:Replication:*",
    s3_Replication_OperationFailedReplication: "s3:Replication:OperationFailedReplication",
    s3_Replication_OperationMissedThreshold: "s3:Replication:OperationMissedThreshold",
    s3_Replication_OperationNotTracked: "s3:Replication:OperationNotTracked",
    s3_Replication_OperationReplicatedAfterThreshold: "s3:Replication:OperationReplicatedAfterThreshold"
  };
  var FilterRuleName = {
    prefix: "prefix",
    suffix: "suffix"
  };
  var DeleteMarkerReplicationStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  var MetricsStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  var ReplicationTimeStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  var ExistingObjectReplicationStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  var ReplicaModificationsStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  var SseKmsEncryptedObjectsStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  var ReplicationRuleStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  var Payer = {
    BucketOwner: "BucketOwner",
    Requester: "Requester"
  };
  var MFADeleteStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  var BucketVersioningStatus = {
    Enabled: "Enabled",
    Suspended: "Suspended"
  };
  var Protocol = {
    http: "http",
    https: "https"
  };
  var ReplicationStatus = {
    COMPLETE: "COMPLETE",
    COMPLETED: "COMPLETED",
    FAILED: "FAILED",
    PENDING: "PENDING",
    REPLICA: "REPLICA"
  };
  var ChecksumMode = {
    ENABLED: "ENABLED"
  };
  var ObjectAttributes = {
    CHECKSUM: "Checksum",
    ETAG: "ETag",
    OBJECT_PARTS: "ObjectParts",
    OBJECT_SIZE: "ObjectSize",
    STORAGE_CLASS: "StorageClass"
  };
  var ObjectLockEnabled = {
    Enabled: "Enabled"
  };
  var ObjectLockRetentionMode = {
    COMPLIANCE: "COMPLIANCE",
    GOVERNANCE: "GOVERNANCE"
  };
  var ArchiveStatus = {
    ARCHIVE_ACCESS: "ARCHIVE_ACCESS",
    DEEP_ARCHIVE_ACCESS: "DEEP_ARCHIVE_ACCESS"
  };
  var EncodingType = {
    url: "url"
  };
  var ObjectStorageClass = {
    DEEP_ARCHIVE: "DEEP_ARCHIVE",
    EXPRESS_ONEZONE: "EXPRESS_ONEZONE",
    FSX_ONTAP: "FSX_ONTAP",
    FSX_OPENZFS: "FSX_OPENZFS",
    GLACIER: "GLACIER",
    GLACIER_IR: "GLACIER_IR",
    INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
    ONEZONE_IA: "ONEZONE_IA",
    OUTPOSTS: "OUTPOSTS",
    REDUCED_REDUNDANCY: "REDUCED_REDUNDANCY",
    SNOW: "SNOW",
    STANDARD: "STANDARD",
    STANDARD_IA: "STANDARD_IA"
  };
  var OptionalObjectAttributes = {
    RESTORE_STATUS: "RestoreStatus"
  };
  var ObjectVersionStorageClass = {
    STANDARD: "STANDARD"
  };
  var MFADelete = {
    Disabled: "Disabled",
    Enabled: "Enabled"
  };
  var Tier = {
    Bulk: "Bulk",
    Expedited: "Expedited",
    Standard: "Standard"
  };
  var ExpressionType = {
    SQL: "SQL"
  };
  var CompressionType = {
    BZIP2: "BZIP2",
    GZIP: "GZIP",
    NONE: "NONE"
  };
  var FileHeaderInfo = {
    IGNORE: "IGNORE",
    NONE: "NONE",
    USE: "USE"
  };
  var JSONType = {
    DOCUMENT: "DOCUMENT",
    LINES: "LINES"
  };
  var QuoteFields = {
    ALWAYS: "ALWAYS",
    ASNEEDED: "ASNEEDED"
  };
  var RestoreRequestType = {
    SELECT: "SELECT"
  };
  exports.$Command = smithyClient.Command;
  exports.__Client = smithyClient.Client;
  exports.S3ServiceException = S3ServiceException.S3ServiceException;
  exports.AbortMultipartUploadCommand = AbortMultipartUploadCommand;
  exports.AnalyticsS3ExportFileFormat = AnalyticsS3ExportFileFormat;
  exports.ArchiveStatus = ArchiveStatus;
  exports.BucketAbacStatus = BucketAbacStatus;
  exports.BucketAccelerateStatus = BucketAccelerateStatus;
  exports.BucketCannedACL = BucketCannedACL;
  exports.BucketLocationConstraint = BucketLocationConstraint;
  exports.BucketLogsPermission = BucketLogsPermission;
  exports.BucketType = BucketType;
  exports.BucketVersioningStatus = BucketVersioningStatus;
  exports.ChecksumAlgorithm = ChecksumAlgorithm;
  exports.ChecksumMode = ChecksumMode;
  exports.ChecksumType = ChecksumType;
  exports.CompleteMultipartUploadCommand = CompleteMultipartUploadCommand;
  exports.CompressionType = CompressionType;
  exports.CopyObjectCommand = CopyObjectCommand;
  exports.CreateBucketCommand = CreateBucketCommand;
  exports.CreateBucketMetadataConfigurationCommand = CreateBucketMetadataConfigurationCommand;
  exports.CreateBucketMetadataTableConfigurationCommand = CreateBucketMetadataTableConfigurationCommand;
  exports.CreateMultipartUploadCommand = CreateMultipartUploadCommand;
  exports.CreateSessionCommand = CreateSessionCommand;
  exports.DataRedundancy = DataRedundancy;
  exports.DeleteBucketAnalyticsConfigurationCommand = DeleteBucketAnalyticsConfigurationCommand;
  exports.DeleteBucketCommand = DeleteBucketCommand;
  exports.DeleteBucketCorsCommand = DeleteBucketCorsCommand;
  exports.DeleteBucketEncryptionCommand = DeleteBucketEncryptionCommand;
  exports.DeleteBucketIntelligentTieringConfigurationCommand = DeleteBucketIntelligentTieringConfigurationCommand;
  exports.DeleteBucketInventoryConfigurationCommand = DeleteBucketInventoryConfigurationCommand;
  exports.DeleteBucketLifecycleCommand = DeleteBucketLifecycleCommand;
  exports.DeleteBucketMetadataConfigurationCommand = DeleteBucketMetadataConfigurationCommand;
  exports.DeleteBucketMetadataTableConfigurationCommand = DeleteBucketMetadataTableConfigurationCommand;
  exports.DeleteBucketMetricsConfigurationCommand = DeleteBucketMetricsConfigurationCommand;
  exports.DeleteBucketOwnershipControlsCommand = DeleteBucketOwnershipControlsCommand;
  exports.DeleteBucketPolicyCommand = DeleteBucketPolicyCommand;
  exports.DeleteBucketReplicationCommand = DeleteBucketReplicationCommand;
  exports.DeleteBucketTaggingCommand = DeleteBucketTaggingCommand;
  exports.DeleteBucketWebsiteCommand = DeleteBucketWebsiteCommand;
  exports.DeleteMarkerReplicationStatus = DeleteMarkerReplicationStatus;
  exports.DeleteObjectCommand = DeleteObjectCommand;
  exports.DeleteObjectTaggingCommand = DeleteObjectTaggingCommand;
  exports.DeleteObjectsCommand = DeleteObjectsCommand;
  exports.DeletePublicAccessBlockCommand = DeletePublicAccessBlockCommand;
  exports.EncodingType = EncodingType;
  exports.EncryptionType = EncryptionType;
  exports.Event = Event;
  exports.ExistingObjectReplicationStatus = ExistingObjectReplicationStatus;
  exports.ExpirationState = ExpirationState;
  exports.ExpirationStatus = ExpirationStatus;
  exports.ExpressionType = ExpressionType;
  exports.FileHeaderInfo = FileHeaderInfo;
  exports.FilterRuleName = FilterRuleName;
  exports.GetBucketAbacCommand = GetBucketAbacCommand;
  exports.GetBucketAccelerateConfigurationCommand = GetBucketAccelerateConfigurationCommand;
  exports.GetBucketAclCommand = GetBucketAclCommand;
  exports.GetBucketAnalyticsConfigurationCommand = GetBucketAnalyticsConfigurationCommand;
  exports.GetBucketCorsCommand = GetBucketCorsCommand;
  exports.GetBucketEncryptionCommand = GetBucketEncryptionCommand;
  exports.GetBucketIntelligentTieringConfigurationCommand = GetBucketIntelligentTieringConfigurationCommand;
  exports.GetBucketInventoryConfigurationCommand = GetBucketInventoryConfigurationCommand;
  exports.GetBucketLifecycleConfigurationCommand = GetBucketLifecycleConfigurationCommand;
  exports.GetBucketLocationCommand = GetBucketLocationCommand;
  exports.GetBucketLoggingCommand = GetBucketLoggingCommand;
  exports.GetBucketMetadataConfigurationCommand = GetBucketMetadataConfigurationCommand;
  exports.GetBucketMetadataTableConfigurationCommand = GetBucketMetadataTableConfigurationCommand;
  exports.GetBucketMetricsConfigurationCommand = GetBucketMetricsConfigurationCommand;
  exports.GetBucketNotificationConfigurationCommand = GetBucketNotificationConfigurationCommand;
  exports.GetBucketOwnershipControlsCommand = GetBucketOwnershipControlsCommand;
  exports.GetBucketPolicyCommand = GetBucketPolicyCommand;
  exports.GetBucketPolicyStatusCommand = GetBucketPolicyStatusCommand;
  exports.GetBucketReplicationCommand = GetBucketReplicationCommand;
  exports.GetBucketRequestPaymentCommand = GetBucketRequestPaymentCommand;
  exports.GetBucketTaggingCommand = GetBucketTaggingCommand;
  exports.GetBucketVersioningCommand = GetBucketVersioningCommand;
  exports.GetBucketWebsiteCommand = GetBucketWebsiteCommand;
  exports.GetObjectAclCommand = GetObjectAclCommand;
  exports.GetObjectAttributesCommand = GetObjectAttributesCommand;
  exports.GetObjectCommand = GetObjectCommand;
  exports.GetObjectLegalHoldCommand = GetObjectLegalHoldCommand;
  exports.GetObjectLockConfigurationCommand = GetObjectLockConfigurationCommand;
  exports.GetObjectRetentionCommand = GetObjectRetentionCommand;
  exports.GetObjectTaggingCommand = GetObjectTaggingCommand;
  exports.GetObjectTorrentCommand = GetObjectTorrentCommand;
  exports.GetPublicAccessBlockCommand = GetPublicAccessBlockCommand;
  exports.HeadBucketCommand = HeadBucketCommand;
  exports.HeadObjectCommand = HeadObjectCommand;
  exports.IntelligentTieringAccessTier = IntelligentTieringAccessTier;
  exports.IntelligentTieringStatus = IntelligentTieringStatus;
  exports.InventoryConfigurationState = InventoryConfigurationState;
  exports.InventoryFormat = InventoryFormat;
  exports.InventoryFrequency = InventoryFrequency;
  exports.InventoryIncludedObjectVersions = InventoryIncludedObjectVersions;
  exports.InventoryOptionalField = InventoryOptionalField;
  exports.JSONType = JSONType;
  exports.ListBucketAnalyticsConfigurationsCommand = ListBucketAnalyticsConfigurationsCommand;
  exports.ListBucketIntelligentTieringConfigurationsCommand = ListBucketIntelligentTieringConfigurationsCommand;
  exports.ListBucketInventoryConfigurationsCommand = ListBucketInventoryConfigurationsCommand;
  exports.ListBucketMetricsConfigurationsCommand = ListBucketMetricsConfigurationsCommand;
  exports.ListBucketsCommand = ListBucketsCommand;
  exports.ListDirectoryBucketsCommand = ListDirectoryBucketsCommand;
  exports.ListMultipartUploadsCommand = ListMultipartUploadsCommand;
  exports.ListObjectVersionsCommand = ListObjectVersionsCommand;
  exports.ListObjectsCommand = ListObjectsCommand;
  exports.ListObjectsV2Command = ListObjectsV2Command;
  exports.ListPartsCommand = ListPartsCommand;
  exports.LocationType = LocationType;
  exports.MFADelete = MFADelete;
  exports.MFADeleteStatus = MFADeleteStatus;
  exports.MetadataDirective = MetadataDirective;
  exports.MetricsStatus = MetricsStatus;
  exports.ObjectAttributes = ObjectAttributes;
  exports.ObjectCannedACL = ObjectCannedACL;
  exports.ObjectLockEnabled = ObjectLockEnabled;
  exports.ObjectLockLegalHoldStatus = ObjectLockLegalHoldStatus;
  exports.ObjectLockMode = ObjectLockMode;
  exports.ObjectLockRetentionMode = ObjectLockRetentionMode;
  exports.ObjectOwnership = ObjectOwnership;
  exports.ObjectStorageClass = ObjectStorageClass;
  exports.ObjectVersionStorageClass = ObjectVersionStorageClass;
  exports.OptionalObjectAttributes = OptionalObjectAttributes;
  exports.OwnerOverride = OwnerOverride;
  exports.PartitionDateSource = PartitionDateSource;
  exports.Payer = Payer;
  exports.Permission = Permission;
  exports.Protocol = Protocol;
  exports.PutBucketAbacCommand = PutBucketAbacCommand;
  exports.PutBucketAccelerateConfigurationCommand = PutBucketAccelerateConfigurationCommand;
  exports.PutBucketAclCommand = PutBucketAclCommand;
  exports.PutBucketAnalyticsConfigurationCommand = PutBucketAnalyticsConfigurationCommand;
  exports.PutBucketCorsCommand = PutBucketCorsCommand;
  exports.PutBucketEncryptionCommand = PutBucketEncryptionCommand;
  exports.PutBucketIntelligentTieringConfigurationCommand = PutBucketIntelligentTieringConfigurationCommand;
  exports.PutBucketInventoryConfigurationCommand = PutBucketInventoryConfigurationCommand;
  exports.PutBucketLifecycleConfigurationCommand = PutBucketLifecycleConfigurationCommand;
  exports.PutBucketLoggingCommand = PutBucketLoggingCommand;
  exports.PutBucketMetricsConfigurationCommand = PutBucketMetricsConfigurationCommand;
  exports.PutBucketNotificationConfigurationCommand = PutBucketNotificationConfigurationCommand;
  exports.PutBucketOwnershipControlsCommand = PutBucketOwnershipControlsCommand;
  exports.PutBucketPolicyCommand = PutBucketPolicyCommand;
  exports.PutBucketReplicationCommand = PutBucketReplicationCommand;
  exports.PutBucketRequestPaymentCommand = PutBucketRequestPaymentCommand;
  exports.PutBucketTaggingCommand = PutBucketTaggingCommand;
  exports.PutBucketVersioningCommand = PutBucketVersioningCommand;
  exports.PutBucketWebsiteCommand = PutBucketWebsiteCommand;
  exports.PutObjectAclCommand = PutObjectAclCommand;
  exports.PutObjectCommand = PutObjectCommand;
  exports.PutObjectLegalHoldCommand = PutObjectLegalHoldCommand;
  exports.PutObjectLockConfigurationCommand = PutObjectLockConfigurationCommand;
  exports.PutObjectRetentionCommand = PutObjectRetentionCommand;
  exports.PutObjectTaggingCommand = PutObjectTaggingCommand;
  exports.PutPublicAccessBlockCommand = PutPublicAccessBlockCommand;
  exports.QuoteFields = QuoteFields;
  exports.RenameObjectCommand = RenameObjectCommand;
  exports.ReplicaModificationsStatus = ReplicaModificationsStatus;
  exports.ReplicationRuleStatus = ReplicationRuleStatus;
  exports.ReplicationStatus = ReplicationStatus;
  exports.ReplicationTimeStatus = ReplicationTimeStatus;
  exports.RequestCharged = RequestCharged;
  exports.RequestPayer = RequestPayer;
  exports.RestoreObjectCommand = RestoreObjectCommand;
  exports.RestoreRequestType = RestoreRequestType;
  exports.S3 = S3;
  exports.S3Client = S3Client;
  exports.S3TablesBucketType = S3TablesBucketType;
  exports.SelectObjectContentCommand = SelectObjectContentCommand;
  exports.ServerSideEncryption = ServerSideEncryption;
  exports.SessionMode = SessionMode;
  exports.SseKmsEncryptedObjectsStatus = SseKmsEncryptedObjectsStatus;
  exports.StorageClass = StorageClass;
  exports.StorageClassAnalysisSchemaVersion = StorageClassAnalysisSchemaVersion;
  exports.TableSseAlgorithm = TableSseAlgorithm;
  exports.TaggingDirective = TaggingDirective;
  exports.Tier = Tier;
  exports.TransitionDefaultMinimumObjectSize = TransitionDefaultMinimumObjectSize;
  exports.TransitionStorageClass = TransitionStorageClass;
  exports.Type = Type;
  exports.UpdateBucketMetadataInventoryTableConfigurationCommand = UpdateBucketMetadataInventoryTableConfigurationCommand;
  exports.UpdateBucketMetadataJournalTableConfigurationCommand = UpdateBucketMetadataJournalTableConfigurationCommand;
  exports.UpdateObjectEncryptionCommand = UpdateObjectEncryptionCommand;
  exports.UploadPartCommand = UploadPartCommand;
  exports.UploadPartCopyCommand = UploadPartCopyCommand;
  exports.WriteGetObjectResponseCommand = WriteGetObjectResponseCommand;
  exports.paginateListBuckets = paginateListBuckets;
  exports.paginateListDirectoryBuckets = paginateListDirectoryBuckets;
  exports.paginateListObjectsV2 = paginateListObjectsV2;
  exports.paginateListParts = paginateListParts;
  exports.waitForBucketExists = waitForBucketExists;
  exports.waitForBucketNotExists = waitForBucketNotExists;
  exports.waitForObjectExists = waitForObjectExists;
  exports.waitForObjectNotExists = waitForObjectNotExists;
  exports.waitUntilBucketExists = waitUntilBucketExists;
  exports.waitUntilBucketNotExists = waitUntilBucketNotExists;
  exports.waitUntilObjectExists = waitUntilObjectExists;
  exports.waitUntilObjectNotExists = waitUntilObjectNotExists;
  Object.prototype.hasOwnProperty.call(schemas_0, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: schemas_0["__proto__"]
  });
  Object.keys(schemas_0).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = schemas_0[k];
  });
  Object.prototype.hasOwnProperty.call(errors, "__proto__") && !Object.prototype.hasOwnProperty.call(exports, "__proto__") && Object.defineProperty(exports, "__proto__", {
    enumerable: true,
    value: errors["__proto__"]
  });
  Object.keys(errors).forEach(function(k) {
    if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
      exports[k] = errors[k];
  });
});

// node_modules/@aws-sdk/util-format-url/dist-cjs/index.js
var require_dist_cjs75 = __commonJS((exports) => {
  var querystringBuilder = require_dist_cjs11();
  function formatUrl(request) {
    const { port, query } = request;
    let { protocol, path, hostname } = request;
    if (protocol && protocol.slice(-1) !== ":") {
      protocol += ":";
    }
    if (port) {
      hostname += `:${port}`;
    }
    if (path && path.charAt(0) !== "/") {
      path = `/${path}`;
    }
    let queryString = query ? querystringBuilder.buildQueryString(query) : "";
    if (queryString && queryString[0] !== "?") {
      queryString = `?${queryString}`;
    }
    let auth = "";
    if (request.username != null || request.password != null) {
      const username = request.username ?? "";
      const password = request.password ?? "";
      auth = `${username}:${password}@`;
    }
    let fragment = "";
    if (request.fragment) {
      fragment = `#${request.fragment}`;
    }
    return `${protocol}//${auth}${hostname}${path}${queryString}${fragment}`;
  }
  exports.formatUrl = formatUrl;
});

// node_modules/@aws-sdk/s3-request-presigner/dist-cjs/index.js
var require_dist_cjs76 = __commonJS((exports) => {
  var utilFormatUrl = require_dist_cjs75();
  var middlewareEndpoint = require_dist_cjs46();
  var protocolHttp = require_dist_cjs2();
  var signatureV4MultiRegion = require_dist_cjs50();
  var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
  var SHA256_HEADER = "X-Amz-Content-Sha256";

  class S3RequestPresigner {
    signer;
    constructor(options) {
      const resolvedOptions = {
        service: options.signingName || options.service || "s3",
        uriEscapePath: options.uriEscapePath || false,
        applyChecksum: options.applyChecksum || false,
        ...options
      };
      this.signer = new signatureV4MultiRegion.SignatureV4MultiRegion(resolvedOptions);
    }
    presign(requestToSign, { unsignableHeaders = new Set, hoistableHeaders = new Set, unhoistableHeaders = new Set, ...options } = {}) {
      this.prepareRequest(requestToSign, {
        unsignableHeaders,
        unhoistableHeaders,
        hoistableHeaders
      });
      return this.signer.presign(requestToSign, {
        expiresIn: 900,
        unsignableHeaders,
        unhoistableHeaders,
        ...options
      });
    }
    presignWithCredentials(requestToSign, credentials, { unsignableHeaders = new Set, hoistableHeaders = new Set, unhoistableHeaders = new Set, ...options } = {}) {
      this.prepareRequest(requestToSign, {
        unsignableHeaders,
        unhoistableHeaders,
        hoistableHeaders
      });
      return this.signer.presignWithCredentials(requestToSign, credentials, {
        expiresIn: 900,
        unsignableHeaders,
        unhoistableHeaders,
        ...options
      });
    }
    prepareRequest(requestToSign, { unsignableHeaders = new Set, unhoistableHeaders = new Set, hoistableHeaders = new Set } = {}) {
      unsignableHeaders.add("content-type");
      Object.keys(requestToSign.headers).map((header) => header.toLowerCase()).filter((header) => header.startsWith("x-amz-server-side-encryption")).forEach((header) => {
        if (!hoistableHeaders.has(header)) {
          unhoistableHeaders.add(header);
        }
      });
      requestToSign.headers[SHA256_HEADER] = UNSIGNED_PAYLOAD;
      const currentHostHeader = requestToSign.headers.host;
      const port = requestToSign.port;
      const expectedHostHeader = `${requestToSign.hostname}${requestToSign.port != null ? ":" + port : ""}`;
      if (!currentHostHeader || currentHostHeader === requestToSign.hostname && requestToSign.port != null) {
        requestToSign.headers.host = expectedHostHeader;
      }
    }
  }
  var getSignedUrl = async (client3, command, options = {}) => {
    let s3Presigner;
    let region;
    if (typeof client3.config.endpointProvider === "function") {
      const endpointV2 = await middlewareEndpoint.getEndpointFromInstructions(command.input, command.constructor, client3.config);
      const authScheme = endpointV2.properties?.authSchemes?.[0];
      if (authScheme?.name === "sigv4a") {
        region = authScheme?.signingRegionSet?.join(",");
      } else {
        region = authScheme?.signingRegion;
      }
      s3Presigner = new S3RequestPresigner({
        ...client3.config,
        signingName: authScheme?.signingName,
        region: async () => region
      });
    } else {
      s3Presigner = new S3RequestPresigner(client3.config);
    }
    const presignInterceptMiddleware = (next, context) => async (args) => {
      const { request } = args;
      if (!protocolHttp.HttpRequest.isInstance(request)) {
        throw new Error("Request to be presigned is not an valid HTTP request.");
      }
      delete request.headers["amz-sdk-invocation-id"];
      delete request.headers["amz-sdk-request"];
      delete request.headers["x-amz-user-agent"];
      let presigned2;
      const presignerOptions = {
        ...options,
        signingRegion: options.signingRegion ?? context["signing_region"] ?? region,
        signingService: options.signingService ?? context["signing_service"]
      };
      if (context.s3ExpressIdentity) {
        presigned2 = await s3Presigner.presignWithCredentials(request, context.s3ExpressIdentity, presignerOptions);
      } else {
        presigned2 = await s3Presigner.presign(request, presignerOptions);
      }
      return {
        response: {},
        output: {
          $metadata: { httpStatusCode: 200 },
          presigned: presigned2
        }
      };
    };
    const middlewareName = "presignInterceptMiddleware";
    const clientStack = client3.middlewareStack.clone();
    clientStack.addRelativeTo(presignInterceptMiddleware, {
      name: middlewareName,
      relation: "before",
      toMiddleware: "awsAuthMiddleware",
      override: true
    });
    const handler = command.resolveMiddleware(clientStack, client3.config, {});
    const { output } = await handler({ input: command.input });
    const { presigned } = output;
    return utilFormatUrl.formatUrl(presigned);
  };
  exports.S3RequestPresigner = S3RequestPresigner;
  exports.getSignedUrl = getSignedUrl;
});

// src/util/cache.ts
var DEFAULT_TTL_MS = 300000;

class TtlCache {
  cache = new Map;
  defaultTtlMs;
  constructor(config) {
    this.defaultTtlMs = config?.defaultTtlMs ?? DEFAULT_TTL_MS;
  }
  get(key, version) {
    const entry = this.cache.get(key);
    if (!entry)
      return null;
    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      return null;
    }
    if (version !== undefined && entry.version !== version) {
      this.cache.delete(key);
      return null;
    }
    return entry.value;
  }
  set(key, value, ttlMs, version) {
    this.cache.set(key, {
      value,
      expiresAt: Date.now() + (ttlMs ?? this.defaultTtlMs),
      version
    });
  }
  has(key) {
    return this.get(key) !== null;
  }
  delete(key) {
    this.cache.delete(key);
  }
  invalidate(pattern) {
    for (const key of this.cache.keys()) {
      if (key.includes(pattern)) {
        this.cache.delete(key);
      }
    }
  }
  invalidateByPrefix(prefix) {
    for (const key of this.cache.keys()) {
      if (key.startsWith(prefix)) {
        this.cache.delete(key);
      }
    }
  }
  clear() {
    this.cache.clear();
  }
  get size() {
    return this.cache.size;
  }
}

// src/util/log.ts
function log(level, module, message, data) {
  const entry = {
    level,
    module,
    message,
    ...data,
    timestamp: new Date().toISOString()
  };
  if (level === "error") {
    console.error(JSON.stringify(entry));
  } else if (level === "warn") {
    console.warn(JSON.stringify(entry));
  } else {
    console.info(JSON.stringify(entry));
  }
}

// src/util/circuitBreaker.ts
var DEFAULT_THRESHOLD = 5;
var DEFAULT_COOLDOWN_MS = 30000;

class CircuitBreaker {
  state = "closed";
  failures = 0;
  lastFailureTime = 0;
  threshold;
  cooldownMs;
  label;
  constructor(config) {
    this.threshold = config?.threshold ?? DEFAULT_THRESHOLD;
    this.cooldownMs = config?.cooldownMs ?? DEFAULT_COOLDOWN_MS;
    this.label = config?.label ?? "circuit-breaker";
  }
  async execute(fn) {
    if (this.state === "open") {
      if (Date.now() - this.lastFailureTime > this.cooldownMs) {
        this.state = "half-open";
        log("info", this.label, "circuit half-open, attempting recovery");
      } else {
        throw new Error(`${this.label}: service unavailable (circuit open)`);
      }
    }
    try {
      const result = await fn();
      this.reset();
      return result;
    } catch (error) {
      this.recordFailure();
      throw error;
    }
  }
  isOpen() {
    if (this.state !== "open")
      return false;
    if (Date.now() - this.lastFailureTime > this.cooldownMs) {
      this.state = "half-open";
      return false;
    }
    return true;
  }
  reset() {
    if (this.failures > 0 || this.state !== "closed") {
      log("info", this.label, "circuit closed");
    }
    this.failures = 0;
    this.state = "closed";
  }
  recordFailure() {
    this.failures++;
    this.lastFailureTime = Date.now();
    if (this.failures >= this.threshold) {
      this.state = "open";
      log("error", this.label, `circuit opened after ${this.failures} consecutive failures`);
    }
  }
}

// src/apiKey/gatekeeper.ts
var REQUEST_TIMEOUT_MS = 5000;
var DEFAULT_CACHE_TTL_MS = 120000;

class GatekeeperApiKeyProvider {
  config;
  circuitBreaker;
  keyCache;
  constructor(config) {
    this.config = {
      ...config,
      timeoutMs: config.timeoutMs ?? REQUEST_TIMEOUT_MS,
      cacheTtlMs: config.cacheTtlMs ?? DEFAULT_CACHE_TTL_MS
    };
    this.circuitBreaker = new CircuitBreaker({
      threshold: config.circuitBreakerThreshold,
      cooldownMs: config.circuitBreakerCooldownMs,
      label: "gatekeeper-api-key"
    });
    this.keyCache = new TtlCache({
      defaultTtlMs: this.config.cacheTtlMs
    });
  }
  async verifyApiKey(key) {
    const cached = this.keyCache.get(key);
    if (cached !== null) {
      return cached;
    }
    const startTime = Date.now();
    try {
      const info = await this.circuitBreaker.execute(async () => {
        const response = await fetch(`${this.config.authBaseUrl}/api-key/verify`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ key }),
          signal: AbortSignal.timeout(this.config.timeoutMs)
        });
        if (!response.ok) {
          throw new Error(`API key verification failed: ${response.status}`);
        }
        const raw = await response.json();
        if (!raw.valid || !raw.key) {
          return null;
        }
        let parsedMetadata;
        if (raw.key.metadata) {
          try {
            parsedMetadata = JSON.parse(raw.key.metadata);
          } catch {
            log("warn", "api-key", "failed to parse metadata JSON", {
              keyId: raw.key.id
            });
          }
        }
        const orgId = parsedMetadata?.organizationId;
        const result = {
          id: raw.key.id,
          name: raw.key.name ?? "",
          userId: raw.key.userId,
          organizationId: typeof orgId === "string" ? orgId : "",
          metadata: parsedMetadata
        };
        return result;
      });
      if (!info) {
        log("info", "api-key", "key invalid", {
          durationMs: Date.now() - startTime
        });
        return null;
      }
      this.keyCache.set(key, info);
      log("info", "api-key", "key verified", {
        keyId: info.id,
        userId: info.userId,
        durationMs: Date.now() - startTime
      });
      return info;
    } catch (err) {
      log("error", "api-key", "key verification failed", {
        durationMs: Date.now() - startTime,
        error: err instanceof Error ? err.message : String(err)
      });
      return null;
    }
  }
  async healthCheck() {
    try {
      const response = await fetch(`${this.config.authBaseUrl}/health`, {
        signal: AbortSignal.timeout(this.config.timeoutMs)
      });
      return {
        healthy: response.ok,
        message: response.ok ? "OK" : `Status ${response.status}`
      };
    } catch (error) {
      return {
        healthy: false,
        message: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
}

// src/apiKey/noop.ts
class NoopApiKeyProvider {
  mockResult;
  constructor(config) {
    this.mockResult = config?.mockResult ?? null;
  }
  async verifyApiKey(_key) {
    return this.mockResult;
  }
  async healthCheck() {
    return { healthy: true, message: "noop" };
  }
}

// src/apiKey/index.ts
var createApiKeyProvider = (config) => {
  if (!("provider" in config) || config.provider === "noop") {
    return new NoopApiKeyProvider("provider" in config ? config : undefined);
  }
  if (config.provider === "gatekeeper") {
    if (!config.authBaseUrl) {
      throw new Error("GatekeeperApiKeyProvider requires authBaseUrl in config");
    }
    return new GatekeeperApiKeyProvider({
      ...config,
      authBaseUrl: config.authBaseUrl
    });
  }
  const _exhaustive = config;
  throw new Error(`Unknown API key provider: ${_exhaustive}`);
};
// src/auth/types.ts
var OMNI_CLAIMS_NAMESPACE = "https://manifold.omni.dev/@omni/claims/organizations";

// src/auth/claims.ts
var extractOrgClaims = (claims) => {
  return claims[OMNI_CLAIMS_NAMESPACE] ?? [];
};
// node_modules/jose/dist/webapi/lib/buffer_utils.js
var encoder = new TextEncoder;
var decoder = new TextDecoder;
var MAX_INT32 = 2 ** 32;
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  for (const buffer of buffers) {
    buf.set(buffer, i);
    i += buffer.length;
  }
  return buf;
}
function encode(string) {
  const bytes = new Uint8Array(string.length);
  for (let i = 0;i < string.length; i++) {
    const code = string.charCodeAt(i);
    if (code > 127) {
      throw new TypeError("non-ASCII string encountered in encode()");
    }
    bytes[i] = code;
  }
  return bytes;
}

// node_modules/jose/dist/webapi/lib/base64.js
function decodeBase64(encoded) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(encoded);
  }
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0;i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}

// node_modules/jose/dist/webapi/util/base64url.js
function decode(input) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(typeof input === "string" ? input : decoder.decode(input), {
      alphabet: "base64url"
    });
  }
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/");
  try {
    return decodeBase64(encoded);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
}

// node_modules/jose/dist/webapi/util/errors.js
class JOSEError extends Error {
  static code = "ERR_JOSE_GENERIC";
  code = "ERR_JOSE_GENERIC";
  constructor(message, options) {
    super(message, options);
    this.name = this.constructor.name;
    Error.captureStackTrace?.(this, this.constructor);
  }
}

class JWTClaimValidationFailed extends JOSEError {
  static code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
  code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
  claim;
  reason;
  payload;
  constructor(message, payload, claim = "unspecified", reason = "unspecified") {
    super(message, { cause: { claim, reason, payload } });
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
}

class JWTExpired extends JOSEError {
  static code = "ERR_JWT_EXPIRED";
  code = "ERR_JWT_EXPIRED";
  claim;
  reason;
  payload;
  constructor(message, payload, claim = "unspecified", reason = "unspecified") {
    super(message, { cause: { claim, reason, payload } });
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
}

class JOSEAlgNotAllowed extends JOSEError {
  static code = "ERR_JOSE_ALG_NOT_ALLOWED";
  code = "ERR_JOSE_ALG_NOT_ALLOWED";
}

class JOSENotSupported extends JOSEError {
  static code = "ERR_JOSE_NOT_SUPPORTED";
  code = "ERR_JOSE_NOT_SUPPORTED";
}
class JWSInvalid extends JOSEError {
  static code = "ERR_JWS_INVALID";
  code = "ERR_JWS_INVALID";
}

class JWTInvalid extends JOSEError {
  static code = "ERR_JWT_INVALID";
  code = "ERR_JWT_INVALID";
}
class JWKSInvalid extends JOSEError {
  static code = "ERR_JWKS_INVALID";
  code = "ERR_JWKS_INVALID";
}

class JWKSNoMatchingKey extends JOSEError {
  static code = "ERR_JWKS_NO_MATCHING_KEY";
  code = "ERR_JWKS_NO_MATCHING_KEY";
  constructor(message = "no applicable key found in the JSON Web Key Set", options) {
    super(message, options);
  }
}

class JWKSMultipleMatchingKeys extends JOSEError {
  [Symbol.asyncIterator];
  static code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  constructor(message = "multiple matching keys found in the JSON Web Key Set", options) {
    super(message, options);
  }
}

class JWKSTimeout extends JOSEError {
  static code = "ERR_JWKS_TIMEOUT";
  code = "ERR_JWKS_TIMEOUT";
  constructor(message = "request timed out", options) {
    super(message, options);
  }
}

class JWSSignatureVerificationFailed extends JOSEError {
  static code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  constructor(message = "signature verification failed", options) {
    super(message, options);
  }
}

// node_modules/jose/dist/webapi/lib/crypto_key.js
var unusable = (name, prop = "algorithm.name") => new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
var isAlgorithm = (algorithm, name) => algorithm.name === name;
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usage) {
  if (usage && !key.usages.includes(usage)) {
    throw new TypeError(`CryptoKey does not support this operation, its usages must include ${usage}.`);
  }
}
function checkSigCryptoKey(key, alg, usage) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "Ed25519":
    case "EdDSA": {
      if (!isAlgorithm(key.algorithm, "Ed25519"))
        throw unusable("Ed25519");
      break;
    }
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87": {
      if (!isAlgorithm(key.algorithm, alg))
        throw unusable(alg);
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usage);
}

// node_modules/jose/dist/webapi/lib/invalid_key_input.js
function message(msg, actual, ...types) {
  types = types.filter(Boolean);
  if (types.length > 2) {
    const last = types.pop();
    msg += `one of type ${types.join(", ")}, or ${last}.`;
  } else if (types.length === 2) {
    msg += `one of type ${types[0]} or ${types[1]}.`;
  } else {
    msg += `of type ${types[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor?.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
var invalidKeyInput = (actual, ...types) => message("Key must be ", actual, ...types);
var withAlg = (alg, actual, ...types) => message(`Key for the ${alg} algorithm must be `, actual, ...types);

// node_modules/jose/dist/webapi/lib/is_key_like.js
var isCryptoKey = (key) => {
  if (key?.[Symbol.toStringTag] === "CryptoKey")
    return true;
  try {
    return key instanceof CryptoKey;
  } catch {
    return false;
  }
};
var isKeyObject = (key) => key?.[Symbol.toStringTag] === "KeyObject";
var isKeyLike = (key) => isCryptoKey(key) || isKeyObject(key);

// node_modules/jose/dist/webapi/lib/is_disjoint.js
function isDisjoint(...headers) {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
}

// node_modules/jose/dist/webapi/lib/is_object.js
var isObjectLike = (value) => typeof value === "object" && value !== null;
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/jose/dist/webapi/lib/check_key_length.js
function checkKeyLength(alg, key) {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
}

// node_modules/jose/dist/webapi/lib/jwk_to_key.js
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "AKP": {
      switch (jwk.alg) {
        case "ML-DSA-44":
        case "ML-DSA-65":
        case "ML-DSA-87":
          algorithm = { name: jwk.alg };
          keyUsages = jwk.priv ? ["sign"] : ["verify"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "Ed25519":
        case "EdDSA":
          algorithm = { name: "Ed25519" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
async function jwkToKey(jwk) {
  if (!jwk.alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  const { algorithm, keyUsages } = subtleMapping(jwk);
  const keyData = { ...jwk };
  if (keyData.kty !== "AKP") {
    delete keyData.alg;
  }
  delete keyData.use;
  return crypto.subtle.importKey("jwk", keyData, algorithm, jwk.ext ?? (jwk.d || jwk.priv ? false : true), jwk.key_ops ?? keyUsages);
}

// node_modules/jose/dist/webapi/key/import.js
async function importJWK(jwk, alg, options) {
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  let ext;
  alg ??= jwk.alg;
  ext ??= options?.extractable ?? jwk.ext;
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      return decode(jwk.k);
    case "RSA":
      if ("oth" in jwk && jwk.oth !== undefined) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
      return jwkToKey({ ...jwk, alg, ext });
    case "AKP": {
      if (typeof jwk.alg !== "string" || !jwk.alg) {
        throw new TypeError('missing "alg" (Algorithm) Parameter value');
      }
      if (alg !== undefined && alg !== jwk.alg) {
        throw new TypeError("JWK alg and alg option value mismatch");
      }
      return jwkToKey({ ...jwk, ext });
    }
    case "EC":
    case "OKP":
      return jwkToKey({ ...jwk, alg, ext });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}

// node_modules/jose/dist/webapi/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === undefined) {
    return new Set;
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== undefined) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}

// node_modules/jose/dist/webapi/lib/validate_algorithms.js
function validateAlgorithms(option, algorithms) {
  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return;
  }
  return new Set(algorithms);
}

// node_modules/jose/dist/webapi/lib/is_jwk.js
var isJWK = (key) => isObject(key) && typeof key.kty === "string";
var isPrivateJWK = (key) => key.kty !== "oct" && (key.kty === "AKP" && typeof key.priv === "string" || typeof key.d === "string");
var isPublicJWK = (key) => key.kty !== "oct" && key.d === undefined && key.priv === undefined;
var isSecretJWK = (key) => key.kty === "oct" && typeof key.k === "string";

// node_modules/jose/dist/webapi/lib/normalize_key.js
var cache;
var handleJWK = async (key, jwk, alg, freeze = false) => {
  cache ||= new WeakMap;
  let cached = cache.get(key);
  if (cached?.[alg]) {
    return cached[alg];
  }
  const cryptoKey = await jwkToKey({ ...jwk, alg });
  if (freeze)
    Object.freeze(key);
  if (!cached) {
    cache.set(key, { [alg]: cryptoKey });
  } else {
    cached[alg] = cryptoKey;
  }
  return cryptoKey;
};
var handleKeyObject = (keyObject, alg) => {
  cache ||= new WeakMap;
  let cached = cache.get(keyObject);
  if (cached?.[alg]) {
    return cached[alg];
  }
  const isPublic = keyObject.type === "public";
  const extractable = isPublic ? true : false;
  let cryptoKey;
  if (keyObject.asymmetricKeyType === "x25519") {
    switch (alg) {
      case "ECDH-ES":
      case "ECDH-ES+A128KW":
      case "ECDH-ES+A192KW":
      case "ECDH-ES+A256KW":
        break;
      default:
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, isPublic ? [] : ["deriveBits"]);
  }
  if (keyObject.asymmetricKeyType === "ed25519") {
    if (alg !== "EdDSA" && alg !== "Ed25519") {
      throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [
      isPublic ? "verify" : "sign"
    ]);
  }
  switch (keyObject.asymmetricKeyType) {
    case "ml-dsa-44":
    case "ml-dsa-65":
    case "ml-dsa-87": {
      if (alg !== keyObject.asymmetricKeyType.toUpperCase()) {
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
      }
      cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [
        isPublic ? "verify" : "sign"
      ]);
    }
  }
  if (keyObject.asymmetricKeyType === "rsa") {
    let hash;
    switch (alg) {
      case "RSA-OAEP":
        hash = "SHA-1";
        break;
      case "RS256":
      case "PS256":
      case "RSA-OAEP-256":
        hash = "SHA-256";
        break;
      case "RS384":
      case "PS384":
      case "RSA-OAEP-384":
        hash = "SHA-384";
        break;
      case "RS512":
      case "PS512":
      case "RSA-OAEP-512":
        hash = "SHA-512";
        break;
      default:
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    if (alg.startsWith("RSA-OAEP")) {
      return keyObject.toCryptoKey({
        name: "RSA-OAEP",
        hash
      }, extractable, isPublic ? ["encrypt"] : ["decrypt"]);
    }
    cryptoKey = keyObject.toCryptoKey({
      name: alg.startsWith("PS") ? "RSA-PSS" : "RSASSA-PKCS1-v1_5",
      hash
    }, extractable, [isPublic ? "verify" : "sign"]);
  }
  if (keyObject.asymmetricKeyType === "ec") {
    const nist = new Map([
      ["prime256v1", "P-256"],
      ["secp384r1", "P-384"],
      ["secp521r1", "P-521"]
    ]);
    const namedCurve = nist.get(keyObject.asymmetricKeyDetails?.namedCurve);
    if (!namedCurve) {
      throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    if (alg === "ES256" && namedCurve === "P-256") {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDSA",
        namedCurve
      }, extractable, [isPublic ? "verify" : "sign"]);
    }
    if (alg === "ES384" && namedCurve === "P-384") {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDSA",
        namedCurve
      }, extractable, [isPublic ? "verify" : "sign"]);
    }
    if (alg === "ES512" && namedCurve === "P-521") {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDSA",
        namedCurve
      }, extractable, [isPublic ? "verify" : "sign"]);
    }
    if (alg.startsWith("ECDH-ES")) {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDH",
        namedCurve
      }, extractable, isPublic ? [] : ["deriveBits"]);
    }
  }
  if (!cryptoKey) {
    throw new TypeError("given KeyObject instance cannot be used for this algorithm");
  }
  if (!cached) {
    cache.set(keyObject, { [alg]: cryptoKey });
  } else {
    cached[alg] = cryptoKey;
  }
  return cryptoKey;
};
async function normalizeKey(key, alg) {
  if (key instanceof Uint8Array) {
    return key;
  }
  if (isCryptoKey(key)) {
    return key;
  }
  if (isKeyObject(key)) {
    if (key.type === "secret") {
      return key.export();
    }
    if ("toCryptoKey" in key && typeof key.toCryptoKey === "function") {
      try {
        return handleKeyObject(key, alg);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
      }
    }
    let jwk = key.export({ format: "jwk" });
    return handleJWK(key, jwk, alg);
  }
  if (isJWK(key)) {
    if (key.k) {
      return decode(key.k);
    }
    return handleJWK(key, key, alg, true);
  }
  throw new Error("unreachable");
}

// node_modules/jose/dist/webapi/lib/check_key_type.js
var tag = (key) => key?.[Symbol.toStringTag];
var jwkMatchesOp = (alg, key, usage) => {
  if (key.use !== undefined) {
    let expected;
    switch (usage) {
      case "sign":
      case "verify":
        expected = "sig";
        break;
      case "encrypt":
      case "decrypt":
        expected = "enc";
        break;
    }
    if (key.use !== expected) {
      throw new TypeError(`Invalid key for this operation, its "use" must be "${expected}" when present`);
    }
  }
  if (key.alg !== undefined && key.alg !== alg) {
    throw new TypeError(`Invalid key for this operation, its "alg" must be "${alg}" when present`);
  }
  if (Array.isArray(key.key_ops)) {
    let expectedKeyOp;
    switch (true) {
      case (usage === "sign" || usage === "verify"):
      case alg === "dir":
      case alg.includes("CBC-HS"):
        expectedKeyOp = usage;
        break;
      case alg.startsWith("PBES2"):
        expectedKeyOp = "deriveBits";
        break;
      case /^A\d{3}(?:GCM)?(?:KW)?$/.test(alg):
        if (!alg.includes("GCM") && alg.endsWith("KW")) {
          expectedKeyOp = usage === "encrypt" ? "wrapKey" : "unwrapKey";
        } else {
          expectedKeyOp = usage;
        }
        break;
      case (usage === "encrypt" && alg.startsWith("RSA")):
        expectedKeyOp = "wrapKey";
        break;
      case usage === "decrypt":
        expectedKeyOp = alg.startsWith("RSA") ? "unwrapKey" : "deriveBits";
        break;
    }
    if (expectedKeyOp && key.key_ops?.includes?.(expectedKeyOp) === false) {
      throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${expectedKeyOp}" when present`);
    }
  }
  return true;
};
var symmetricTypeCheck = (alg, key, usage) => {
  if (key instanceof Uint8Array)
    return;
  if (isJWK(key)) {
    if (isSecretJWK(key) && jwkMatchesOp(alg, key, usage))
      return;
    throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present`);
  }
  if (!isKeyLike(key)) {
    throw new TypeError(withAlg(alg, key, "CryptoKey", "KeyObject", "JSON Web Key", "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage) => {
  if (isJWK(key)) {
    switch (usage) {
      case "decrypt":
      case "sign":
        if (isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation must be a private JWK`);
      case "encrypt":
      case "verify":
        if (isPublicJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation must be a public JWK`);
    }
  }
  if (!isKeyLike(key)) {
    throw new TypeError(withAlg(alg, key, "CryptoKey", "KeyObject", "JSON Web Key"));
  }
  if (key.type === "secret") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (key.type === "public") {
    switch (usage) {
      case "sign":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);
      case "decrypt":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type "private"`);
    }
  }
  if (key.type === "private") {
    switch (usage) {
      case "verify":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);
      case "encrypt":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`);
    }
  }
};
function checkKeyType(alg, key, usage) {
  switch (alg.substring(0, 2)) {
    case "A1":
    case "A2":
    case "di":
    case "HS":
    case "PB":
      symmetricTypeCheck(alg, key, usage);
      break;
    default:
      asymmetricTypeCheck(alg, key, usage);
  }
}

// node_modules/jose/dist/webapi/lib/subtle_dsa.js
function subtleAlgorithm(alg, algorithm) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: parseInt(alg.slice(-3), 10) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "Ed25519":
    case "EdDSA":
      return { name: "Ed25519" };
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87":
      return { name: alg };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/jose/dist/webapi/lib/get_sign_verify_key.js
async function getSigKey(alg, key, usage) {
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalidKeyInput(key, "CryptoKey", "KeyObject", "JSON Web Key"));
    }
    return crypto.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  checkSigCryptoKey(key, alg, usage);
  return key;
}

// node_modules/jose/dist/webapi/lib/verify.js
async function verify(alg, key, signature, data) {
  const cryptoKey = await getSigKey(alg, key, "verify");
  checkKeyLength(alg, cryptoKey);
  const algorithm = subtleAlgorithm(alg, cryptoKey.algorithm);
  try {
    return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch {
    return false;
  }
}

// node_modules/jose/dist/webapi/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === undefined && jws.header === undefined) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== undefined && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === undefined) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== undefined && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!isDisjoint(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validateCrit(JWSInvalid, new Map([["b64", true]]), options?.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validateAlgorithms("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  checkKeyType(alg, key, "verify");
  const data = concat(jws.protected !== undefined ? encode(jws.protected) : new Uint8Array, encode("."), typeof jws.payload === "string" ? b64 ? encode(jws.payload) : encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const k = await normalizeKey(key, alg);
  const verified = await verify(alg, k, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed;
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== undefined) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== undefined) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key: k };
  }
  return result;
}

// node_modules/jose/dist/webapi/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}

// node_modules/jose/dist/webapi/lib/jwt_claims_set.js
var epoch = (date) => Math.floor(date.getTime() / 1000);
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
function secs(str) {
  const matched = REGEX.exec(str);
  if (!matched || matched[4] && matched[1]) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[2]);
  const unit = matched[3].toLowerCase();
  let numericDate;
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      numericDate = Math.round(value);
      break;
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      numericDate = Math.round(value * minute);
      break;
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      numericDate = Math.round(value * hour);
      break;
    case "day":
    case "days":
    case "d":
      numericDate = Math.round(value * day);
      break;
    case "week":
    case "weeks":
    case "w":
      numericDate = Math.round(value * week);
      break;
    default:
      numericDate = Math.round(value * year);
      break;
  }
  if (matched[1] === "-" || matched[4] === "ago") {
    return -numericDate;
  }
  return numericDate;
}
function validateInput(label, input) {
  if (!Number.isFinite(input)) {
    throw new TypeError(`Invalid ${label} input`);
  }
  return input;
}
var normalizeTyp = (value) => {
  if (value.includes("/")) {
    return value.toLowerCase();
  }
  return `application/${value.toLowerCase()}`;
};
var checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
function validateClaimsSet(protectedHeader, encodedPayload, options = {}) {
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch {}
  if (!isObject(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', payload, "typ", "check_failed");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  const presenceCheck = [...requiredClaims];
  if (maxTokenAge !== undefined)
    presenceCheck.push("iat");
  if (audience !== undefined)
    presenceCheck.push("aud");
  if (subject !== undefined)
    presenceCheck.push("sub");
  if (issuer !== undefined)
    presenceCheck.push("iss");
  for (const claim of new Set(presenceCheck.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, payload, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', payload, "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', payload, "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', payload, "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch(currentDate || new Date);
  if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', payload, "iat", "invalid");
  }
  if (payload.nbf !== undefined) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', payload, "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', payload, "nbf", "check_failed");
    }
  }
  if (payload.exp !== undefined) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', payload, "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', payload, "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', payload, "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', payload, "iat", "check_failed");
    }
  }
  return payload;
}

class JWTClaimsBuilder {
  #payload;
  constructor(payload) {
    if (!isObject(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this.#payload = structuredClone(payload);
  }
  data() {
    return encoder.encode(JSON.stringify(this.#payload));
  }
  get iss() {
    return this.#payload.iss;
  }
  set iss(value) {
    this.#payload.iss = value;
  }
  get sub() {
    return this.#payload.sub;
  }
  set sub(value) {
    this.#payload.sub = value;
  }
  get aud() {
    return this.#payload.aud;
  }
  set aud(value) {
    this.#payload.aud = value;
  }
  set jti(value) {
    this.#payload.jti = value;
  }
  set nbf(value) {
    if (typeof value === "number") {
      this.#payload.nbf = validateInput("setNotBefore", value);
    } else if (value instanceof Date) {
      this.#payload.nbf = validateInput("setNotBefore", epoch(value));
    } else {
      this.#payload.nbf = epoch(new Date) + secs(value);
    }
  }
  set exp(value) {
    if (typeof value === "number") {
      this.#payload.exp = validateInput("setExpirationTime", value);
    } else if (value instanceof Date) {
      this.#payload.exp = validateInput("setExpirationTime", epoch(value));
    } else {
      this.#payload.exp = epoch(new Date) + secs(value);
    }
  }
  set iat(value) {
    if (value === undefined) {
      this.#payload.iat = epoch(new Date);
    } else if (value instanceof Date) {
      this.#payload.iat = validateInput("setIssuedAt", epoch(value));
    } else if (typeof value === "string") {
      this.#payload.iat = validateInput("setIssuedAt", epoch(new Date) + secs(value));
    } else {
      this.#payload.iat = validateInput("setIssuedAt", value);
    }
  }
}

// node_modules/jose/dist/webapi/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  const verified = await compactVerify(jwt, key, options);
  if (verified.protectedHeader.crit?.includes("b64") && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = validateClaimsSet(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
// node_modules/jose/dist/webapi/jwks/local.js
function getKtyFromAlg(alg) {
  switch (typeof alg === "string" && alg.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    case "ML":
      return "AKP";
    default:
      throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  }
}
function isJWKSLike(jwks) {
  return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
  return isObject(key);
}

class LocalJWKSet {
  #jwks;
  #cached = new WeakMap;
  constructor(jwks) {
    if (!isJWKSLike(jwks)) {
      throw new JWKSInvalid("JSON Web Key Set malformed");
    }
    this.#jwks = structuredClone(jwks);
  }
  jwks() {
    return this.#jwks;
  }
  async getKey(protectedHeader, token) {
    const { alg, kid } = { ...protectedHeader, ...token?.header };
    const kty = getKtyFromAlg(alg);
    const candidates = this.#jwks.keys.filter((jwk2) => {
      let candidate = kty === jwk2.kty;
      if (candidate && typeof kid === "string") {
        candidate = kid === jwk2.kid;
      }
      if (candidate && (typeof jwk2.alg === "string" || kty === "AKP")) {
        candidate = alg === jwk2.alg;
      }
      if (candidate && typeof jwk2.use === "string") {
        candidate = jwk2.use === "sig";
      }
      if (candidate && Array.isArray(jwk2.key_ops)) {
        candidate = jwk2.key_ops.includes("verify");
      }
      if (candidate) {
        switch (alg) {
          case "ES256":
            candidate = jwk2.crv === "P-256";
            break;
          case "ES384":
            candidate = jwk2.crv === "P-384";
            break;
          case "ES512":
            candidate = jwk2.crv === "P-521";
            break;
          case "Ed25519":
          case "EdDSA":
            candidate = jwk2.crv === "Ed25519";
            break;
        }
      }
      return candidate;
    });
    const { 0: jwk, length } = candidates;
    if (length === 0) {
      throw new JWKSNoMatchingKey;
    }
    if (length !== 1) {
      const error = new JWKSMultipleMatchingKeys;
      const _cached = this.#cached;
      error[Symbol.asyncIterator] = async function* () {
        for (const jwk2 of candidates) {
          try {
            yield await importWithAlgCache(_cached, jwk2, alg);
          } catch {}
        }
      };
      throw error;
    }
    return importWithAlgCache(this.#cached, jwk, alg);
  }
}
async function importWithAlgCache(cache2, jwk, alg) {
  const cached = cache2.get(jwk) || cache2.set(jwk, {}).get(jwk);
  if (cached[alg] === undefined) {
    const key = await importJWK({ ...jwk, ext: true }, alg);
    if (key instanceof Uint8Array || key.type !== "public") {
      throw new JWKSInvalid("JSON Web Key Set members must be public keys");
    }
    cached[alg] = key;
  }
  return cached[alg];
}
function createLocalJWKSet(jwks) {
  const set = new LocalJWKSet(jwks);
  const localJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);
  Object.defineProperties(localJWKSet, {
    jwks: {
      value: () => structuredClone(set.jwks()),
      enumerable: false,
      configurable: false,
      writable: false
    }
  });
  return localJWKSet;
}

// node_modules/jose/dist/webapi/jwks/remote.js
function isCloudflareWorkers() {
  return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers" || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
}
var USER_AGENT;
if (typeof navigator === "undefined" || !navigator.userAgent?.startsWith?.("Mozilla/5.0 ")) {
  const NAME = "jose";
  const VERSION = "v6.1.3";
  USER_AGENT = `${NAME}/${VERSION}`;
}
var customFetch = Symbol();
async function fetchJwks(url, headers, signal, fetchImpl = fetch) {
  const response = await fetchImpl(url, {
    method: "GET",
    signal,
    redirect: "manual",
    headers
  }).catch((err) => {
    if (err.name === "TimeoutError") {
      throw new JWKSTimeout;
    }
    throw err;
  });
  if (response.status !== 200) {
    throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
  }
  try {
    return await response.json();
  } catch {
    throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
  }
}
var jwksCache = Symbol();
function isFreshJwksCache(input, cacheMaxAge) {
  if (typeof input !== "object" || input === null) {
    return false;
  }
  if (!("uat" in input) || typeof input.uat !== "number" || Date.now() - input.uat >= cacheMaxAge) {
    return false;
  }
  if (!("jwks" in input) || !isObject(input.jwks) || !Array.isArray(input.jwks.keys) || !Array.prototype.every.call(input.jwks.keys, isObject)) {
    return false;
  }
  return true;
}

class RemoteJWKSet {
  #url;
  #timeoutDuration;
  #cooldownDuration;
  #cacheMaxAge;
  #jwksTimestamp;
  #pendingFetch;
  #headers;
  #customFetch;
  #local;
  #cache;
  constructor(url, options) {
    if (!(url instanceof URL)) {
      throw new TypeError("url must be an instance of URL");
    }
    this.#url = new URL(url.href);
    this.#timeoutDuration = typeof options?.timeoutDuration === "number" ? options?.timeoutDuration : 5000;
    this.#cooldownDuration = typeof options?.cooldownDuration === "number" ? options?.cooldownDuration : 30000;
    this.#cacheMaxAge = typeof options?.cacheMaxAge === "number" ? options?.cacheMaxAge : 600000;
    this.#headers = new Headers(options?.headers);
    if (USER_AGENT && !this.#headers.has("User-Agent")) {
      this.#headers.set("User-Agent", USER_AGENT);
    }
    if (!this.#headers.has("accept")) {
      this.#headers.set("accept", "application/json");
      this.#headers.append("accept", "application/jwk-set+json");
    }
    this.#customFetch = options?.[customFetch];
    if (options?.[jwksCache] !== undefined) {
      this.#cache = options?.[jwksCache];
      if (isFreshJwksCache(options?.[jwksCache], this.#cacheMaxAge)) {
        this.#jwksTimestamp = this.#cache.uat;
        this.#local = createLocalJWKSet(this.#cache.jwks);
      }
    }
  }
  pendingFetch() {
    return !!this.#pendingFetch;
  }
  coolingDown() {
    return typeof this.#jwksTimestamp === "number" ? Date.now() < this.#jwksTimestamp + this.#cooldownDuration : false;
  }
  fresh() {
    return typeof this.#jwksTimestamp === "number" ? Date.now() < this.#jwksTimestamp + this.#cacheMaxAge : false;
  }
  jwks() {
    return this.#local?.jwks();
  }
  async getKey(protectedHeader, token) {
    if (!this.#local || !this.fresh()) {
      await this.reload();
    }
    try {
      return await this.#local(protectedHeader, token);
    } catch (err) {
      if (err instanceof JWKSNoMatchingKey) {
        if (this.coolingDown() === false) {
          await this.reload();
          return this.#local(protectedHeader, token);
        }
      }
      throw err;
    }
  }
  async reload() {
    if (this.#pendingFetch && isCloudflareWorkers()) {
      this.#pendingFetch = undefined;
    }
    this.#pendingFetch ||= fetchJwks(this.#url.href, this.#headers, AbortSignal.timeout(this.#timeoutDuration), this.#customFetch).then((json) => {
      this.#local = createLocalJWKSet(json);
      if (this.#cache) {
        this.#cache.uat = Date.now();
        this.#cache.jwks = json;
      }
      this.#jwksTimestamp = Date.now();
      this.#pendingFetch = undefined;
    }).catch((err) => {
      this.#pendingFetch = undefined;
      throw err;
    });
    await this.#pendingFetch;
  }
}
function createRemoteJWKSet(url, options) {
  const set = new RemoteJWKSet(url, options);
  const remoteJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);
  Object.defineProperties(remoteJWKSet, {
    coolingDown: {
      get: () => set.coolingDown(),
      enumerable: true,
      configurable: false
    },
    fresh: {
      get: () => set.fresh(),
      enumerable: true,
      configurable: false
    },
    reload: {
      value: () => set.reload(),
      enumerable: true,
      configurable: false,
      writable: false
    },
    reloading: {
      get: () => set.pendingFetch(),
      enumerable: true,
      configurable: false
    },
    jwks: {
      value: () => set.jwks(),
      enumerable: true,
      configurable: false,
      writable: false
    }
  });
  return remoteJWKSet;
}
// src/auth/jwt.ts
var jwksCache2 = new Map;
function getJWKS(authBaseUrl) {
  let jwks = jwksCache2.get(authBaseUrl);
  if (!jwks) {
    jwks = createRemoteJWKSet(new URL(`${authBaseUrl}/.well-known/jwks.json`));
    jwksCache2.set(authBaseUrl, jwks);
  }
  return jwks;
}
async function verifyAccessToken(token, config) {
  const jwks = getJWKS(config.authBaseUrl);
  const { payload } = await jwtVerify(token, jwks, {
    issuer: config.issuer ?? config.authBaseUrl
  });
  if (!payload.sub) {
    throw new Error("Missing required 'sub' claim");
  }
  return payload;
}
// src/authz/warden.ts
var REQUEST_TIMEOUT_MS2 = 5000;
var DEFAULT_CACHE_TTL_MS2 = 120000;

class WardenAuthzProvider {
  config;
  circuitBreaker;
  permissionCache;
  constructor(config) {
    this.config = {
      ...config,
      cacheTtlMs: config.cacheTtlMs ?? DEFAULT_CACHE_TTL_MS2
    };
    this.circuitBreaker = new CircuitBreaker({
      threshold: config.circuitBreakerThreshold,
      cooldownMs: config.circuitBreakerCooldownMs,
      label: "warden-authz"
    });
    this.permissionCache = new TtlCache({
      defaultTtlMs: this.config.cacheTtlMs
    });
  }
  async checkPermission(userId, resourceType, resourceId, permission, requestCache) {
    const cacheKey = buildCacheKey(userId, resourceType, resourceId, permission);
    if (requestCache?.has(cacheKey)) {
      return requestCache.get(cacheKey);
    }
    const cached = this.permissionCache.get(cacheKey);
    if (cached !== null) {
      requestCache?.set(cacheKey, cached);
      return cached;
    }
    const startTime = Date.now();
    try {
      const allowed = await this.circuitBreaker.execute(async () => {
        const response = await fetch(`${this.config.apiUrl}/check`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...this.authHeaders()
          },
          body: JSON.stringify({
            user: `user:${userId}`,
            relation: permission,
            object: `${resourceType}:${resourceId}`
          }),
          signal: AbortSignal.timeout(REQUEST_TIMEOUT_MS2)
        });
        if (!response.ok) {
          throw new Error(`AuthZ check failed: ${response.status}`);
        }
        const result = await response.json();
        return result.allowed;
      });
      requestCache?.set(cacheKey, allowed);
      this.permissionCache.set(cacheKey, allowed);
      log("info", "authz", "permission check", {
        userId,
        resourceType,
        resourceId,
        permission,
        allowed,
        durationMs: Date.now() - startTime
      });
      return allowed;
    } catch (err) {
      log("error", "authz", "permission check failed", {
        userId,
        resourceType,
        resourceId,
        permission,
        durationMs: Date.now() - startTime,
        error: err instanceof Error ? err.message : String(err)
      });
      throw err;
    }
  }
  async checkPermissionsBatch(checks, requestCache) {
    const results = [];
    const uncachedChecks = [];
    for (let i = 0;i < checks.length; i++) {
      const check = checks[i];
      const cacheKey = buildCacheKey(check.userId, check.resourceType, check.resourceId, check.permission);
      if (requestCache?.has(cacheKey)) {
        results[i] = { ...check, allowed: requestCache.get(cacheKey) };
        continue;
      }
      const cached = this.permissionCache.get(cacheKey);
      if (cached !== null) {
        requestCache?.set(cacheKey, cached);
        results[i] = { ...check, allowed: cached };
        continue;
      }
      uncachedChecks.push({ index: i, check });
    }
    if (uncachedChecks.length === 0)
      return results;
    const startTime = Date.now();
    try {
      const batchResults = await this.circuitBreaker.execute(async () => {
        const response = await fetch(`${this.config.apiUrl}/check/batch`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...this.authHeaders()
          },
          body: JSON.stringify({
            checks: uncachedChecks.map(({ check }) => ({
              user: `user:${check.userId}`,
              relation: check.permission,
              object: `${check.resourceType}:${check.resourceId}`
            }))
          }),
          signal: AbortSignal.timeout(REQUEST_TIMEOUT_MS2)
        });
        if (!response.ok) {
          throw new Error(`AuthZ batch check failed: ${response.status}`);
        }
        const result = await response.json();
        return result.results;
      });
      for (let i = 0;i < uncachedChecks.length; i++) {
        const { index, check } = uncachedChecks[i];
        const allowed = batchResults[i].allowed;
        const cacheKey = buildCacheKey(check.userId, check.resourceType, check.resourceId, check.permission);
        requestCache?.set(cacheKey, allowed);
        this.permissionCache.set(cacheKey, allowed);
        results[index] = { ...check, allowed };
      }
      log("info", "authz", "batch permission check", {
        total: checks.length,
        fetched: uncachedChecks.length,
        durationMs: Date.now() - startTime
      });
      return results;
    } catch (err) {
      log("error", "authz", "batch permission check failed", {
        durationMs: Date.now() - startTime,
        error: err instanceof Error ? err.message : String(err)
      });
      throw err;
    }
  }
  async writeTuples(tuples, accessToken) {
    if (tuples.length === 0)
      return { success: true };
    if (this.config.vortexUrl && this.config.vortexWebhookSecret) {
      const result = await this.syncViaVortex("write", tuples);
      if (result.success)
        return result;
    }
    return this.syncDirect("POST", tuples, accessToken);
  }
  async deleteTuples(tuples, accessToken) {
    if (tuples.length === 0)
      return { success: true };
    if (this.config.vortexUrl && this.config.vortexWebhookSecret) {
      const result = await this.syncViaVortex("delete", tuples);
      if (result.success)
        return result;
    }
    return this.syncDirect("DELETE", tuples, accessToken);
  }
  invalidateCache(pattern) {
    this.permissionCache.invalidate(pattern);
  }
  clearCache() {
    this.permissionCache.clear();
  }
  async healthCheck() {
    try {
      const response = await fetch(`${this.config.apiUrl}/health`, {
        signal: AbortSignal.timeout(5000)
      });
      return {
        healthy: response.ok,
        message: response.ok ? "OK" : `Status ${response.status}`
      };
    } catch (error) {
      return {
        healthy: false,
        message: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  authHeaders() {
    if (this.config.serviceKey) {
      return { "X-Service-Key": this.config.serviceKey };
    }
    return {};
  }
  async syncViaVortex(operation, tuples) {
    try {
      const response = await fetch(`${this.config.vortexUrl}/webhooks/authz/${this.config.vortexWebhookSecret}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Event-Type": `authz.tuples.${operation}`
        },
        body: JSON.stringify({
          tuples,
          timestamp: new Date().toISOString(),
          source: this.config.source ?? "unknown"
        }),
        signal: AbortSignal.timeout(REQUEST_TIMEOUT_MS2)
      });
      if (response.ok) {
        log("info", "authz", `tuple ${operation} via Vortex`, {
          tupleCount: tuples.length
        });
        return { success: true };
      }
      log("warn", "authz", `Vortex ${operation} failed, falling back`, {
        status: response.status,
        tupleCount: tuples.length
      });
      return {
        success: false,
        error: `Vortex returned ${response.status}`
      };
    } catch (error) {
      log("warn", "authz", `Vortex ${operation} error, falling back`, {
        error: error instanceof Error ? error.message : String(error),
        tupleCount: tuples.length
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  async syncDirect(method, tuples, accessToken) {
    const operation = method === "POST" ? "write" : "delete";
    if (!this.config.serviceKey && !accessToken) {
      const errorMsg = "No service key or access token for Warden API authentication";
      log("error", "authz", `tuple ${operation} failed`, {
        error: errorMsg,
        tupleCount: tuples.length
      });
      return { success: false, error: errorMsg };
    }
    try {
      const headers = {
        "Content-Type": "application/json"
      };
      if (this.config.serviceKey) {
        headers["X-Service-Key"] = this.config.serviceKey;
      } else if (accessToken) {
        headers.Authorization = `Bearer ${accessToken}`;
      }
      const response = await fetch(`${this.config.apiUrl}/tuples`, {
        method,
        headers,
        body: JSON.stringify({ tuples }),
        signal: AbortSignal.timeout(REQUEST_TIMEOUT_MS2)
      });
      if (response.ok) {
        log("info", "authz", `tuple ${operation}`, {
          tupleCount: tuples.length
        });
        return { success: true };
      }
      const errorMsg = `Warden API returned ${response.status}`;
      log("error", "authz", `tuple ${operation} failed`, {
        error: errorMsg,
        tupleCount: tuples.length
      });
      return { success: false, error: errorMsg };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log("error", "authz", `tuple ${operation} failed`, {
        error: errorMsg,
        tupleCount: tuples.length
      });
      return { success: false, error: errorMsg };
    }
  }
}
function buildCacheKey(userId, resourceType, resourceId, permission) {
  return `${userId}:${resourceType}:${resourceId}:${permission}`;
}

// src/authz/index.ts
var createAuthzProvider = (config) => {
  if (!config?.apiUrl) {
    throw new Error("WardenAuthzProvider requires apiUrl in config");
  }
  return new WardenAuthzProvider({ ...config, apiUrl: config.apiUrl });
};
// src/billing/aether.ts
var REQUEST_TIMEOUT_MS3 = 5000;
var DEFAULT_CACHE_TTL_MS3 = 300000;

class AetherBillingProvider {
  config;
  circuitBreaker;
  cache;
  constructor(config) {
    this.config = {
      ...config,
      cacheTtlMs: config.cacheTtlMs ?? DEFAULT_CACHE_TTL_MS3
    };
    this.circuitBreaker = new CircuitBreaker({
      threshold: config.circuitBreakerThreshold,
      cooldownMs: config.circuitBreakerCooldownMs,
      label: "aether-billing"
    });
    this.cache = new TtlCache({
      defaultTtlMs: this.config.cacheTtlMs
    });
  }
  async getEntitlements(entityType, entityId, productId, accessToken) {
    const cacheKey = `${entityType}:${entityId}:${productId ?? "all"}`;
    const cached = this.cache.get(cacheKey);
    if (cached)
      return cached;
    if (this.circuitBreaker.isOpen()) {
      log("warn", "billing", "circuit breaker open, returning null");
      return null;
    }
    try {
      const appId = productId ?? this.config.appId;
      const url = new URL(`${this.config.baseUrl}/entitlements/${appId}/${entityType}/${entityId}`);
      const headers = {};
      if (this.config.serviceApiKey) {
        headers["x-service-api-key"] = this.config.serviceApiKey;
      }
      if (accessToken) {
        headers.Authorization = `Bearer ${accessToken}`;
      }
      const response = await fetch(url.toString(), {
        headers,
        signal: AbortSignal.timeout(REQUEST_TIMEOUT_MS3)
      });
      if (response.status === 404) {
        return null;
      }
      if (!response.ok) {
        log("error", "billing", "failed to fetch entitlements", {
          status: response.status
        });
        return null;
      }
      const result = await response.json();
      this.cache.set(cacheKey, result);
      return result;
    } catch (error) {
      log("error", "billing", "error fetching entitlements", {
        error: error instanceof Error ? error.message : String(error)
      });
      return null;
    }
  }
  async checkEntitlement(entityType, entityId, productId, featureKey, accessToken) {
    const entitlements = await this.getEntitlements(entityType, entityId, productId, accessToken);
    if (!entitlements)
      return null;
    const entitlement = entitlements.entitlements.find((e) => e.featureKey === featureKey);
    return entitlement?.value ?? null;
  }
  async getPrices(appName) {
    const response = await fetch(`${this.config.baseUrl}/prices/${appName}`, {
      headers: this.serviceHeaders(),
      signal: AbortSignal.timeout(REQUEST_TIMEOUT_MS3)
    });
    if (!response.ok)
      return [];
    const { prices } = await response.json();
    return prices;
  }
  async createCheckoutSession(params) {
    const response = await fetch(`${this.config.baseUrl}/checkout/session`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...this.serviceHeaders()
      },
      body: JSON.stringify(params)
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error || "Failed to create checkout session");
    }
    const { url } = await response.json();
    return url;
  }
  async createCheckoutWithWorkspace(params) {
    const response = await fetch(`${this.config.baseUrl}/checkout`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${params.accessToken}`
      },
      body: JSON.stringify({
        appId: params.appId,
        priceId: params.priceId,
        successUrl: params.successUrl,
        cancelUrl: params.cancelUrl,
        ...params.workspaceId && { workspaceId: params.workspaceId },
        ...params.createWorkspace && {
          createWorkspace: params.createWorkspace
        }
      })
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error || "Failed to create checkout session");
    }
    return response.json();
  }
  async getSubscription(entityType, entityId, accessToken) {
    try {
      const response = await fetch(`${this.config.baseUrl}/billing-portal/subscription/${entityType}/${entityId}`, {
        headers: { Authorization: `Bearer ${accessToken}` },
        signal: AbortSignal.timeout(REQUEST_TIMEOUT_MS3)
      });
      if (!response.ok)
        return null;
      const { subscription } = await response.json();
      return subscription;
    } catch {
      return null;
    }
  }
  async getBillingPortalUrl(entityType, entityId, productId, returnUrl, accessToken) {
    const response = await fetch(`${this.config.baseUrl}/billing-portal/${entityType}/${entityId}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${accessToken}`
      },
      body: JSON.stringify({ productId, returnUrl })
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error || "Failed to get billing portal URL");
    }
    const { url } = await response.json();
    return url;
  }
  async cancelSubscription(entityType, entityId, accessToken) {
    const response = await fetch(`${this.config.baseUrl}/billing-portal/subscription/${entityType}/${entityId}/cancel`, {
      method: "POST",
      headers: { Authorization: `Bearer ${accessToken}` }
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error || "Failed to cancel subscription");
    }
    const { id } = await response.json();
    return id;
  }
  async renewSubscription(entityType, entityId, accessToken) {
    const response = await fetch(`${this.config.baseUrl}/billing-portal/subscription/${entityType}/${entityId}/renew`, {
      method: "POST",
      headers: { Authorization: `Bearer ${accessToken}` }
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error || "Failed to renew subscription");
    }
  }
  invalidateCache(entityType, entityId) {
    this.cache.invalidateByPrefix(`${entityType}:${entityId}:`);
  }
  clearCache() {
    this.cache.clear();
  }
  async healthCheck() {
    try {
      const response = await fetch(`${this.config.baseUrl}/health`, {
        signal: AbortSignal.timeout(5000)
      });
      return {
        healthy: response.ok,
        message: response.ok ? "OK" : `Status ${response.status}`
      };
    } catch (error) {
      return {
        healthy: false,
        message: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  serviceHeaders() {
    if (this.config.serviceApiKey) {
      return { "x-service-api-key": this.config.serviceApiKey };
    }
    return {};
  }
}
// src/billing/helpers.ts
var isWithinLimit = (entitlements, featureKey, currentCount, defaultLimits) => {
  if (!entitlements) {
    const freeLimit = defaultLimits?.[featureKey]?.free;
    if (freeLimit === undefined || freeLimit === -1)
      return true;
    return currentCount < freeLimit;
  }
  const entitlement = entitlements.entitlements.find((e) => e.featureKey === featureKey);
  if (entitlement?.value) {
    const limit = Number(entitlement.value);
    if (limit === -1 || Number.isNaN(limit))
      return true;
    return currentCount < limit;
  }
  if (defaultLimits) {
    const tierEntitlement = entitlements.entitlements.find((e) => e.featureKey === "tier");
    const tier = tierEntitlement?.value ?? "free";
    const limit = defaultLimits[featureKey]?.[tier];
    if (limit === undefined || limit === -1)
      return true;
    return currentCount < limit;
  }
  return true;
};

// src/billing/index.ts
var createBillingProvider = (config) => {
  if (!config?.baseUrl) {
    throw new Error("AetherBillingProvider requires baseUrl in config");
  }
  if (!config?.appId) {
    throw new Error("AetherBillingProvider requires appId in config");
  }
  return new AetherBillingProvider({
    ...config,
    baseUrl: config.baseUrl,
    appId: config.appId
  });
};
// src/events/http.ts
var REQUEST_TIMEOUT_MS4 = 5000;
var DEFAULT_MAX_RETRIES = 3;
var BASE_DELAY_MS = 200;

class HttpEventsProvider {
  config;
  circuitBreaker;
  maxRetries;
  timeoutMs;
  constructor(config) {
    this.config = config;
    this.maxRetries = config.maxRetries ?? DEFAULT_MAX_RETRIES;
    this.timeoutMs = config.timeoutMs ?? REQUEST_TIMEOUT_MS4;
    this.circuitBreaker = new CircuitBreaker({
      threshold: config.circuitBreakerThreshold,
      cooldownMs: config.circuitBreakerCooldownMs,
      label: "vortex-events"
    });
  }
  async emit(event) {
    const startTime = Date.now();
    const body = {
      type: event.type,
      data: event.data,
      source: event.source ?? this.config.source,
      subject: event.subject,
      correlationId: event.correlationId,
      schemaId: event.schemaId,
      specversion: event.specversion,
      datacontenttype: event.datacontenttype,
      dataschema: event.dataschema,
      omniworkspaceid: event.omniworkspaceid,
      omnischemaversion: event.omnischemaversion
    };
    try {
      const result = await this.circuitBreaker.execute(() => retryWithBackoff(async () => {
        const response = await fetch(`${this.config.baseUrl}/api/v1/events`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...this.authHeaders()
          },
          body: JSON.stringify(body),
          signal: AbortSignal.timeout(this.timeoutMs)
        });
        if (!response.ok) {
          throw new Error(`Event emit failed: ${response.status}`);
        }
        return await response.json();
      }, this.maxRetries));
      log("info", "events", "event emitted", {
        eventId: result.eventId,
        type: event.type,
        durationMs: Date.now() - startTime
      });
      return result;
    } catch (err) {
      log("error", "events", "event emit failed", {
        type: event.type,
        durationMs: Date.now() - startTime,
        error: err instanceof Error ? err.message : String(err)
      });
      throw err;
    }
  }
  async emitBatch(events) {
    const results = [];
    for (const event of events) {
      results.push(await this.emit(event));
    }
    return results;
  }
  async healthCheck() {
    try {
      const response = await fetch(`${this.config.baseUrl}/health`, {
        signal: AbortSignal.timeout(this.timeoutMs)
      });
      return {
        healthy: response.ok,
        message: response.ok ? "OK" : `Status ${response.status}`
      };
    } catch (error) {
      return {
        healthy: false,
        message: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async close() {}
  authHeaders() {
    return { Authorization: this.config.apiKey };
  }
}
async function retryWithBackoff(fn, maxRetries) {
  let lastError;
  for (let attempt = 0;attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (err) {
      lastError = err;
      if (attempt < maxRetries - 1) {
        const delay = BASE_DELAY_MS * 2 ** attempt * (0.5 + Math.random() * 0.5);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  }
  throw lastError;
}

// src/events/iggy.ts
var DEFAULT_PORT = 8090;
var DEFAULT_STREAM_NAME = "omni-events";
var STREAM_ID = 1;
var DEFAULT_PARTITION_COUNT = 3;
var RETENTION_SECONDS = 90 * 24 * 60 * 60;

class IggyEventsProvider {
  config;
  port;
  streamName;
  partitionCount;
  client = null;
  knownTopics = new Set;
  constructor(config) {
    this.config = config;
    this.port = config.port ?? DEFAULT_PORT;
    this.streamName = config.streamName ?? DEFAULT_STREAM_NAME;
    this.partitionCount = config.partitionCount ?? DEFAULT_PARTITION_COUNT;
  }
  async emit(event) {
    const client3 = await this.#requireClient();
    const topicName = event.organizationId ?? this.config.organizationId ?? "system";
    await this.#ensureTopic(topicName);
    const eventId = crypto.randomUUID();
    const timestamp = new Date().toISOString();
    const envelope = {
      id: eventId,
      type: event.type,
      data: event.data,
      source: event.source ?? this.config.source,
      subject: event.subject,
      organizationId: topicName,
      correlationId: event.correlationId,
      schemaId: event.schemaId,
      timestamp
    };
    const { Partitioning: Partitioning2 } = await Promise.resolve().then(() => (init_dist(), exports_dist));
    const partition2 = event.subject ? Partitioning2.MessageKey(event.subject) : Partitioning2.Balanced;
    await client3.message.send({
      streamId: STREAM_ID,
      topicId: topicName,
      messages: [{ payload: Buffer.from(JSON.stringify(envelope)) }],
      partition: partition2
    });
    log("info", "events", "event published to Iggy", {
      eventId,
      type: event.type,
      topic: topicName
    });
    return { eventId, timestamp };
  }
  async emitBatch(events) {
    const results = [];
    for (const event of events) {
      results.push(await this.emit(event));
    }
    return results;
  }
  async healthCheck() {
    try {
      await this.#requireClient();
      return { healthy: true, message: "OK" };
    } catch (error) {
      return {
        healthy: false,
        message: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async close() {
    this.client?.destroy();
    this.client = null;
    this.knownTopics.clear();
    log("info", "events", "Iggy client closed");
  }
  async#requireClient() {
    if (this.client)
      return this.client;
    const { Client: Client2 } = await Promise.resolve().then(() => (init_dist(), exports_dist));
    this.client = new Client2({
      transport: "TCP",
      options: { host: this.config.host, port: this.port },
      credentials: {
        username: this.config.username,
        password: this.config.password
      }
    });
    await this.#ensureStream();
    log("info", "events", "Iggy client connected", {
      host: this.config.host,
      port: this.port
    });
    return this.client;
  }
  async#ensureStream() {
    const client3 = this.client;
    try {
      await client3.stream.get({ streamId: STREAM_ID });
    } catch {
      await client3.stream.create({
        streamId: STREAM_ID,
        name: this.streamName
      });
      log("info", "events", "created Iggy stream", {
        streamId: STREAM_ID,
        name: this.streamName
      });
    }
  }
  async#ensureTopic(name) {
    if (this.knownTopics.has(name))
      return;
    const client3 = await this.#requireClient();
    const { CompressionAlgorithmKind: CompressionAlgorithmKind2 } = await Promise.resolve().then(() => (init_topic_utils(), exports_topic_utils));
    try {
      await client3.topic.get({ streamId: STREAM_ID, topicId: name });
    } catch {
      await client3.topic.create({
        streamId: STREAM_ID,
        topicId: 0,
        name,
        partitionCount: this.partitionCount,
        compressionAlgorithm: CompressionAlgorithmKind2.None,
        messageExpiry: BigInt(RETENTION_SECONDS)
      });
      log("info", "events", "created Iggy topic", {
        streamId: STREAM_ID,
        topic: name
      });
    }
    this.knownTopics.add(name);
  }
}

// src/events/noop.ts
class NoopEventsProvider {
  async emit(_event) {
    return {
      eventId: crypto.randomUUID(),
      timestamp: new Date().toISOString()
    };
  }
  async emitBatch(events) {
    return events.map(() => ({
      eventId: crypto.randomUUID(),
      timestamp: new Date().toISOString()
    }));
  }
  async healthCheck() {
    return { healthy: true, message: "noop" };
  }
  async close() {}
}

// src/events/helpers.ts
var REQUEST_TIMEOUT_MS5 = 5000;
var registerSchemas = async (baseUrl, apiKey, schemas) => {
  const results = [];
  for (const schema of schemas) {
    try {
      const response = await fetch(`${baseUrl}/api/v1/schemas`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: apiKey
        },
        body: JSON.stringify({
          name: schema.name,
          source: schema.source,
          version: schema.version ?? 1,
          description: schema.description,
          payloadSchema: schema.payloadSchema,
          enforcement: schema.enforcement,
          compatibilityMode: schema.compatibilityMode,
          migrationTransform: schema.migrationTransform
        }),
        signal: AbortSignal.timeout(REQUEST_TIMEOUT_MS5)
      });
      if (!response.ok) {
        log("error", "events", "schema registration failed", {
          name: schema.name,
          status: response.status
        });
        continue;
      }
      const { schema: registered } = await response.json();
      results.push(registered);
      log("info", "events", "schema registered", {
        name: registered.name,
        version: registered.version,
        id: registered.id
      });
    } catch (err) {
      log("error", "events", "schema registration error", {
        name: schema.name,
        error: err instanceof Error ? err.message : String(err)
      });
    }
  }
  return results;
};

// src/events/index.ts
var createEventsProvider = (config) => {
  if (!("provider" in config) || config.provider === "noop") {
    return new NoopEventsProvider;
  }
  if (config.provider === "http") {
    if (!config.baseUrl) {
      throw new Error("HttpEventsProvider requires baseUrl in config");
    }
    if (!config.apiKey) {
      throw new Error("HttpEventsProvider requires apiKey in config");
    }
    return new HttpEventsProvider({
      ...config,
      baseUrl: config.baseUrl,
      apiKey: config.apiKey
    });
  }
  if (config.provider === "iggy") {
    if (!config.host) {
      throw new Error("IggyEventsProvider requires host in config");
    }
    if (!config.username) {
      throw new Error("IggyEventsProvider requires username in config");
    }
    if (!config.password) {
      throw new Error("IggyEventsProvider requires password in config");
    }
    return new IggyEventsProvider({
      ...config,
      host: config.host,
      username: config.username,
      password: config.password
    });
  }
  const _exhaustive = config;
  throw new Error(`Unknown events provider: ${_exhaustive}`);
};
// src/flags/noop.ts
class NoopFlagProvider {
  defaults;
  constructor(config = {}) {
    this.defaults = config.defaults ?? {};
  }
  async isEnabled(flagKey, _context) {
    return this.defaults[flagKey] ?? false;
  }
  async healthCheck() {
    return { healthy: true, message: "noop" };
  }
  async close() {}
}

// src/flags/unleash.ts
var INIT_TIMEOUT_MS = 5000;

class UnleashFlagProvider {
  config;
  defaults;
  devMode;
  client = null;
  initialized = false;
  constructor(config) {
    this.config = config;
    this.defaults = config.defaults ?? {};
    this.devMode = config.devMode ?? false;
  }
  async isEnabled(flagKey, context) {
    if (this.devMode) {
      return this.defaults[flagKey] ?? false;
    }
    const client3 = await this.#requireClient();
    if (!client3) {
      return this.defaults[flagKey] ?? false;
    }
    const unleashContext = {};
    if (context?.userId) {
      unleashContext.userId = context.userId;
    }
    if (context?.environment) {
      unleashContext.environment = context.environment;
    }
    const properties = {};
    if (context?.organizationId) {
      properties.organizationId = context.organizationId;
    }
    if (context?.properties) {
      Object.assign(properties, context.properties);
    }
    if (Object.keys(properties).length > 0) {
      unleashContext.properties = properties;
    }
    return client3.isEnabled(flagKey, unleashContext);
  }
  async healthCheck() {
    if (this.devMode) {
      return { healthy: true, message: "dev mode" };
    }
    await this.#requireClient();
    if (this.client) {
      return { healthy: true, message: "OK" };
    }
    return { healthy: true, message: "fallback defaults" };
  }
  async close() {
    if (this.client) {
      this.client.destroy();
      this.client = null;
      this.initialized = false;
      log("info", "flags", "Unleash client closed");
    }
  }
  async#requireClient() {
    if (this.client)
      return this.client;
    if (this.initialized)
      return null;
    try {
      const { startUnleash } = await Promise.resolve().then(() => __toESM(require_lib13(), 1));
      const unleashConfig = {
        url: this.config.url,
        appName: this.config.appName,
        customHeaders: { Authorization: this.config.apiKey }
      };
      if (this.config.refreshInterval) {
        unleashConfig.refreshInterval = this.config.refreshInterval;
      }
      this.client = await Promise.race([
        startUnleash(unleashConfig),
        new Promise((_resolve, reject) => setTimeout(() => reject(new Error("Unleash init timed out")), INIT_TIMEOUT_MS))
      ]);
      this.initialized = true;
      log("info", "flags", "Unleash client connected", {
        url: this.config.url,
        appName: this.config.appName
      });
      return this.client;
    } catch (error) {
      this.initialized = true;
      log("warn", "flags", "Unleash init failed, falling back to defaults", {
        error: error instanceof Error ? error.message : "Unknown error"
      });
      return null;
    }
  }
}

// src/flags/index.ts
var createFlagProvider = (config) => {
  if (!("provider" in config) || config.provider === "noop") {
    return new NoopFlagProvider(config);
  }
  if (config.provider === "unleash") {
    if (!config.url) {
      throw new Error("UnleashFlagProvider requires url in config");
    }
    if (!config.apiKey) {
      throw new Error("UnleashFlagProvider requires apiKey in config");
    }
    if (!config.appName) {
      throw new Error("UnleashFlagProvider requires appName in config");
    }
    return new UnleashFlagProvider({
      ...config,
      url: config.url,
      apiKey: config.apiKey,
      appName: config.appName
    });
  }
  const _exhaustive = config;
  throw new Error(`Unknown flag provider: ${_exhaustive}`);
};
// src/notifications/noop.ts
class NoopNotificationProvider {
  async sendEmail(_params) {
    return { success: true, messageId: crypto.randomUUID() };
  }
  async sendEmailBatch(params) {
    return params.map(() => ({
      success: true,
      messageId: crypto.randomUUID()
    }));
  }
  async healthCheck() {
    return { healthy: true, message: "noop" };
  }
}

// src/notifications/resend.ts
class ResendNotificationProvider {
  config;
  client = null;
  constructor(config) {
    this.config = config;
  }
  async sendEmail(params) {
    try {
      const client3 = await this.#requireClient();
      const to = Array.isArray(params.to) ? params.to : [params.to];
      const payload = {
        from: params.from ?? this.config.defaultFrom,
        to,
        subject: params.subject,
        ...params.html ? { html: params.body } : { text: params.body },
        ...params.replyTo && { replyTo: params.replyTo },
        ...params.cc && { cc: params.cc },
        ...params.bcc && { bcc: params.bcc }
      };
      const result = await client3.emails.send(payload);
      log("info", "notifications", "email sent", {
        messageId: result.data?.id,
        to
      });
      return {
        success: true,
        messageId: result.data?.id
      };
    } catch (error) {
      const message3 = error instanceof Error ? error.message : "Unknown error";
      log("error", "notifications", "email send failed", {
        error: message3
      });
      return { success: false, error: message3 };
    }
  }
  async sendEmailBatch(params) {
    try {
      const client3 = await this.#requireClient();
      const payloads = params.map((p) => {
        const to = Array.isArray(p.to) ? p.to : [p.to];
        return {
          from: p.from ?? this.config.defaultFrom,
          to,
          subject: p.subject,
          ...p.html ? { html: p.body } : { text: p.body },
          ...p.replyTo && { replyTo: p.replyTo },
          ...p.cc && { cc: p.cc },
          ...p.bcc && { bcc: p.bcc }
        };
      });
      const result = await client3.batch.send(payloads);
      log("info", "notifications", "email batch sent", {
        count: params.length
      });
      return (result.data ?? []).map((item) => ({
        success: true,
        messageId: item.id
      }));
    } catch (error) {
      const message3 = error instanceof Error ? error.message : "Unknown error";
      log("error", "notifications", "email batch send failed", {
        error: message3
      });
      return params.map(() => ({ success: false, error: message3 }));
    }
  }
  async healthCheck() {
    try {
      await this.#requireClient();
      return { healthy: true, message: "OK" };
    } catch (error) {
      return {
        healthy: false,
        message: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async#requireClient() {
    if (this.client)
      return this.client;
    const { Resend: Resend2 } = await Promise.resolve().then(() => (init_dist2(), exports_dist2));
    this.client = new Resend2(this.config.apiKey);
    log("info", "notifications", "Resend client initialized");
    return this.client;
  }
}

// src/notifications/index.ts
var createNotificationProvider = (config) => {
  if (!("provider" in config) || config.provider === "noop") {
    return new NoopNotificationProvider;
  }
  if (config.provider === "resend") {
    if (!config.apiKey) {
      throw new Error("ResendNotificationProvider requires apiKey in config");
    }
    if (!config.defaultFrom) {
      throw new Error("ResendNotificationProvider requires defaultFrom in config");
    }
    return new ResendNotificationProvider({
      ...config,
      apiKey: config.apiKey,
      defaultFrom: config.defaultFrom
    });
  }
  const _exhaustive = config;
  throw new Error(`Unknown notification provider: ${_exhaustive}`);
};
// src/storage/noop.ts
var NOOP_BASE_URL = "https://noop.example.com";

class NoopStorageProvider {
  async upload(params) {
    return { key: params.key, url: `${NOOP_BASE_URL}/${params.key}` };
  }
  async delete(_key) {}
  async getPresignedUploadUrl(params) {
    return {
      url: `${NOOP_BASE_URL}/upload/${params.key}`,
      key: params.key,
      expiresIn: params.expiresIn ?? 3600
    };
  }
  getPublicUrl(key) {
    return `${NOOP_BASE_URL}/${key}`;
  }
  async healthCheck() {
    return { healthy: true, message: "noop" };
  }
  async close() {}
}

// src/storage/s3.ts
var DEFAULT_PRESIGNED_EXPIRY = 3600;

class S3StorageProvider {
  config;
  client = null;
  constructor(config) {
    this.config = config;
  }
  async upload(params) {
    const client3 = await this.#requireClient();
    const { PutObjectCommand } = await Promise.resolve().then(() => __toESM(require_dist_cjs74(), 1));
    const command = new PutObjectCommand({
      Bucket: this.config.bucket,
      Key: params.key,
      Body: params.body,
      ContentType: params.contentType,
      CacheControl: params.cacheControl,
      Metadata: params.metadata
    });
    await client3.send(command);
    const url = this.getPublicUrl(params.key);
    log("info", "storage", "object uploaded", {
      bucket: this.config.bucket,
      key: params.key
    });
    return { key: params.key, url };
  }
  async delete(key) {
    const client3 = await this.#requireClient();
    const { DeleteObjectCommand } = await Promise.resolve().then(() => __toESM(require_dist_cjs74(), 1));
    const command = new DeleteObjectCommand({
      Bucket: this.config.bucket,
      Key: key
    });
    await client3.send(command);
    log("info", "storage", "object deleted", {
      bucket: this.config.bucket,
      key
    });
  }
  async getPresignedUploadUrl(params) {
    const client3 = await this.#requireClient();
    const { PutObjectCommand } = await Promise.resolve().then(() => __toESM(require_dist_cjs74(), 1));
    const { getSignedUrl } = await Promise.resolve().then(() => __toESM(require_dist_cjs76(), 1));
    const expiresIn = params.expiresIn ?? DEFAULT_PRESIGNED_EXPIRY;
    const command = new PutObjectCommand({
      Bucket: this.config.bucket,
      Key: params.key,
      ContentType: params.contentType
    });
    const url = await getSignedUrl(client3, command, { expiresIn });
    log("info", "storage", "presigned URL generated", {
      bucket: this.config.bucket,
      key: params.key,
      expiresIn
    });
    return { url, key: params.key, expiresIn };
  }
  getPublicUrl(key) {
    if (this.config.publicBaseUrl) {
      const base = this.config.publicBaseUrl.replace(/\/+$/, "");
      return `${base}/${key}`;
    }
    if (this.config.endpoint) {
      const base = this.config.endpoint.replace(/\/+$/, "");
      return `${base}/${this.config.bucket}/${key}`;
    }
    const region = this.config.region ?? "us-east-1";
    return `https://${this.config.bucket}.s3.${region}.amazonaws.com/${key}`;
  }
  async healthCheck() {
    try {
      const client3 = await this.#requireClient();
      const { HeadBucketCommand } = await Promise.resolve().then(() => __toESM(require_dist_cjs74(), 1));
      await client3.send(new HeadBucketCommand({ Bucket: this.config.bucket }));
      return { healthy: true, message: "OK" };
    } catch (error) {
      return {
        healthy: false,
        message: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async close() {
    this.client?.destroy();
    this.client = null;
  }
  async#requireClient() {
    if (this.client)
      return this.client;
    const { S3Client } = await Promise.resolve().then(() => __toESM(require_dist_cjs74(), 1));
    const forcePathStyle = this.config.forcePathStyle ?? (this.config.endpoint ? /localhost|127\.0\.0\.1/.test(this.config.endpoint) : false);
    this.client = new S3Client({
      endpoint: this.config.endpoint,
      region: this.config.region ?? "us-east-1",
      credentials: this.config.credentials,
      forcePathStyle
    });
    log("info", "storage", "S3 client initialized", {
      bucket: this.config.bucket,
      endpoint: this.config.endpoint,
      region: this.config.region,
      forcePathStyle
    });
    return this.client;
  }
}

// src/storage/index.ts
var createStorageProvider = (config) => {
  if (!("provider" in config) || config.provider === "noop") {
    return new NoopStorageProvider;
  }
  if (config.provider === "s3") {
    if (!config.bucket) {
      throw new Error("S3StorageProvider requires bucket in config");
    }
    return new S3StorageProvider({ ...config, bucket: config.bucket });
  }
  const _exhaustive = config;
  throw new Error(`Unknown storage provider: ${_exhaustive}`);
};
export {
  verifyAccessToken,
  registerSchemas,
  isWithinLimit,
  extractOrgClaims,
  createStorageProvider,
  createNotificationProvider,
  createFlagProvider,
  createEventsProvider,
  createBillingProvider,
  createAuthzProvider,
  createApiKeyProvider,
  WardenAuthzProvider,
  UnleashFlagProvider,
  TtlCache,
  S3StorageProvider,
  ResendNotificationProvider,
  OMNI_CLAIMS_NAMESPACE,
  NoopStorageProvider,
  NoopNotificationProvider,
  NoopFlagProvider,
  NoopEventsProvider,
  NoopApiKeyProvider,
  IggyEventsProvider,
  HttpEventsProvider,
  GatekeeperApiKeyProvider,
  CircuitBreaker,
  AetherBillingProvider
};
